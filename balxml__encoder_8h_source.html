<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// balxml_encoder.h                                                   -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BALXML_ENCODER
#define INCLUDED_BALXML_ENCODER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an XML encoder utility.
//
//@CLASSES:
//  balxml::Encoder: XML encoder utility class
//
//@SEE_ALSO: balxml_decoder, balber_berencoder
//
//@DESCRIPTION: This component provides a class for encoding value-semantic
// objects in XML format.  In particular, the &#39;balxml::Encoder&#39; &#39;class&#39;
// contains a parameterized &#39;encode&#39; function that encodes a specified
// value-semantic object into a specified stream.  There are three overloaded
// versions of this function:
//..
//    o writes to an &#39;bsl::streambuf&#39;
//    o writes to an &#39;bsl::ostream&#39;
//    o writes to an &#39;balxml::Formatter&#39;
//..
// The &#39;encode&#39; function encodes objects in XML format, which is a very useful
// format for debugging.  For more efficient performance, a binary encoding
// (such as BER) should be used.
//
// This component can be used with types supported by the &#39;bdlat&#39; framework.
// In particular, types generated by the &#39;bas_codegen.pl&#39; tool can be used.
//
///Usage
///-----
// The following snippets of code illustrate the usage of this component.
// Suppose we have an XML schema inside a file named &#39;employee.xsd&#39;:
//..
//  &lt;?xml version=&#39;1.0&#39; encoding=&#39;UTF-8&#39;?&gt;
//  &lt;xs:schema xmlns:xs=&#39;http://www.w3.org/2001/XMLSchema&#39;
//             xmlns:test=&#39;http://bloomberg.com/schemas/test&#39;
//             targetNamespace=&#39;http://bloomberg.com/schemas/test&#39;
//             elementFormDefault=&#39;unqualified&#39;&gt;
//
//      &lt;xs:complexType name=&#39;Address&#39;&gt;
//          &lt;xs:sequence&gt;
//              &lt;xs:element name=&#39;street&#39; type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;city&#39;   type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;state&#39;  type=&#39;xs:string&#39;/&gt;
//          &lt;/xs:sequence&gt;
//      &lt;/xs:complexType&gt;
//
//      &lt;xs:complexType name=&#39;Employee&#39;&gt;
//          &lt;xs:sequence&gt;
//              &lt;xs:element name=&#39;name&#39;        type=&#39;xs:string&#39;/&gt;
//              &lt;xs:element name=&#39;homeAddress&#39; type=&#39;test:Address&#39;/&gt;
//              &lt;xs:element name=&#39;age&#39;         type=&#39;xs:int&#39;/&gt;
//          &lt;/xs:sequence&gt;
//      &lt;/xs:complexType&gt;
//  &lt;/xs:schema&gt;
//..
// Using the &#39;bas_codegen.pl&#39; tool, we generate C++ classes for this schema as
// follows:
//..
//  $ bas_codegen.pl -m msg -p test employee.xsd
//..
// This tool will generate the header and implementation files for the
// &#39;test_messages&#39; components in the current directory.
//
// Now suppose we wanted to encode information about a particular employee
// using XML encoding to the standard output, and using the &#39;PRETTY&#39; option for
// formatting the output.  The following function will do this:
//..
//  #include &lt;test_messages.h&gt;
//
//  #include &lt;balxml_encoder.h&gt;
//  #include &lt;balxml_encodingstyle.h&gt;
//
//  #include &lt;bsl_iostream.h&gt;
//  #include &lt;bsl_sstream.h&gt;
//
//  using namespace BloombergLP;
//
//  void usageExample()
//  {
//      test::Employee bob;
//
//      bob.name()                 = &quot;Bob&quot;;
//      bob.homeAddress().street() = &quot;Some Street&quot;;
//      bob.homeAddress().city()   = &quot;Some City&quot;;
//      bob.homeAddress().state()  = &quot;Some State&quot;;
//      bob.age()                  = 21;
//
//      balxml::EncoderOptions options;
//      options.setEncodingStyle(balxml::EncodingStyle::BAEXML_PRETTY);
//
//      balxml::Encoder encoder(&amp;options, &amp;bsl::cerr, &amp;bsl::cerr);
//
//      const bsl::string EXPECTED_OUTPUT =
//       &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; ?&gt;\n&quot;
//       &quot;&lt;Employee xmlns:xsi=\&quot;http://www.w3.org/2001/XMLSchema-instance\&quot;&gt;\n&quot;
//       &quot;    &lt;name&gt;Bob&lt;/name&gt;\n&quot;
//       &quot;    &lt;homeAddress&gt;\n&quot;
//       &quot;        &lt;street&gt;Some Street&lt;/street&gt;\n&quot;
//       &quot;        &lt;city&gt;Some City&lt;/city&gt;\n&quot;
//       &quot;        &lt;state&gt;Some State&lt;/state&gt;\n&quot;
//       &quot;    &lt;/homeAddress&gt;\n&quot;
//       &quot;    &lt;age&gt;21&lt;/age&gt;\n&quot;
//       &quot;&lt;/Employee&gt;\n&quot;;
//
//      bsl::ostringstream os;
//      const int rc = encoder.encodeToStream(os, bob);
//
//      assert(0 == rc);
//      assert(EXPECTED_OUTPUT == os.str());
//  }
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALXML_ENCODEROPTIONS
#include &lt;balxml_encoderoptions.h&gt;
#endif

#ifndef INCLUDED_BALXML_ENCODINGSTYLE
#include &lt;balxml_encodingstyle.h&gt;
#endif

#ifndef INCLUDED_BALXML_ERRORINFO
#include &lt;balxml_errorinfo.h&gt;      // for Severity
#endif

#ifndef INCLUDED_BALXML_FORMATTER
#include &lt;balxml_formatter.h&gt;
#endif

#ifndef INCLUDED_BALXML_TYPESPRINTUTIL
#include &lt;balxml_typesprintutil.h&gt;
#endif

#ifndef INCLUDED_BDLAT_ARRAYFUNCTIONS
#include &lt;bdlat_arrayfunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_CHOICEFUNCTIONS
#include &lt;bdlat_choicefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_NULLABLEVALUEFUNCTIONS
#include &lt;bdlat_nullablevaluefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_SEQUENCEFUNCTIONS
#include &lt;bdlat_sequencefunctions.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPECATEGORY
#include &lt;bdlat_typecategory.h&gt;
#endif

#ifndef INCLUDED_BDLAT_TYPENAME
#include &lt;bdlat_typename.h&gt;
#endif

#ifndef INCLUDED_BDLSB_MEMOUTSTREAMBUF
#include &lt;bdlsb_memoutstreambuf.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_BSL_OSTREAM
#include &lt;bsl_ostream.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {


namespace balxml {class Encoder_Context;

                               // =============
                               // class Encoder
                               // =============

class Encoder {
    // This &#39;class&#39; contains the parameterized &#39;encode&#39; functions that encode
    // &#39;bdlat&#39; types in XML format.

    // FRIENDS
    friend class Encoder_Context;

  private:
    // PRIVATE TYPES
    class MemOutStream : public bsl::ostream
    {
        // This class provides stream for logging using
        // &#39;bdlsb::MemOutStreamBuf&#39; as a streambuf.  The logging stream is
        // created on demand, i.e., during the first attempt to log message.
        bdlsb::MemOutStreamBuf d_sb;

        // Not implemented:
        MemOutStream(const MemOutStream&amp;);
        MemOutStream&amp; operator=(const MemOutStream&amp;);

      public:
        // CREATORS
        MemOutStream(bslma::Allocator *basicAllocator = 0);
            // Create a new stream using the optionally specified
            // &#39;basicAllocator&#39;.

        virtual ~MemOutStream();
            // Destroy this stream and release memory back to the allocator.
            //
            // Although the compiler should generate this destructor
            // implicitly, xlC 8 breaks when the destructor is called by name
            // unless it is explicitly declared.

        // MANIPULATORS
        void reset();
            // Reset the internal streambuf to empty.

        // ACCESSORS
        const char *data() const;
            // Return a pointer to the memory containing the formatted values
            // formatted to this stream.  The data is not null-terminated
            // unless a null character was appended onto this stream.

        int length() const;
            // Return the length of of the formatted data, including null
            // characters appended to the stream, if any.
    };

  private:
    // DATA
    const EncoderOptions            *d_options;        // held, not owned
    bslma::Allocator                *d_allocator;      // held, not owned

    bsls::ObjectBuffer&lt;MemOutStream&gt; d_logArea;
        // placeholder for MemOutStream

    MemOutStream                    *d_logStream;
        // if not zero, log stream was created at the moment of first logging
        // and must be destroyed

    ErrorInfo::Severity              d_severity;       // error severity

    bsl::ostream                    *d_errorStream;    // held, not owned
    bsl::ostream                    *d_warningStream;  // held, not owned

    // PRIVATE MANIPULATORS
    ErrorInfo::Severity logError(const char               *text,
                                 const bslstl::StringRef&amp;  tag,
                                 int                       formattingMode,
                                 int                       index = -1);

    bsl::ostream&amp; logStream();
        // Return the stream for logging.  Note the if stream has not been
        // created yet, it will be created during this call.

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Encoder, bslma::UsesBslmaAllocator);

    // CREATORS
    Encoder(const EncoderOptions *options, bslma::Allocator *basicAllocator);

    Encoder(const EncoderOptions *options,
            bsl::ostream         *errorStream   = 0,
            bsl::ostream         *warningStream = 0,
            bslma::Allocator     *basicAllocator = 0);
        // Construct a encoder object using the specified &#39;options&#39;.  Errors
        // and warnings will be rendered to the optionally specified
        // &#39;errorStream&#39; and &#39;warningStream&#39; respectively.

    ~Encoder();
        // Destroy this object.  This destruction has no effect on objects
        // pointed-to by the pointers provided at construction.

    template &lt;class TYPE&gt;
    int encode(bsl::streambuf *buffer, const TYPE&amp; object);
        // Encode the specified non-modifiable &#39;object&#39; to the specified
        // &#39;buffer&#39;.  Return 0 on success, and a non-zero value otherwise.
        // Note that the encoder will use encoder options, error and warning
        // streams specified at the construction time.

    template &lt;class TYPE&gt;
    int encodeToStream(bsl::ostream&amp; stream, const TYPE&amp; object);
        // Encode the specified non-modifiable &#39;object&#39; to the specified
        // &#39;stream&#39;.  Return 0 on success, and a non-zero value otherwise.
        // Note that the encoder will use encoder options, error and warning
        // streams specified at the construction time.

    template &lt;class TYPE&gt;
    bsl::ostream&amp; encode(bsl::ostream&amp; stream, const TYPE&amp; object);
        // Encode the specified non-modifiable &#39;object&#39; to the specified
        // &#39;stream&#39;.  Return a reference to &#39;stream&#39;.  If an encoding error is
        // detected, &#39;stream.fail()&#39; will be true on return.  Note that the
        // encoder will use encoder options, error and warning streams
        // specified at the construction time.  IMPORTANT: The use of
        // &#39;stream.fail()&#39; to communicate errors to the caller has two
        // consequences: 1) if &#39;stream&#39; is the same as the &#39;errorStream&#39;
        // passed to the constructor, then the error message may be suppressed
        // (because of the output/error stream becoming invalidated) and 2) it
        // is important to call &#39;stream.clear()&#39; after testing the stream
        // state.  To avoid these issues, we recommend that you use use
        // &#39;encodeToStream&#39;, above, instead of this version of &#39;encode&#39;.

    template &lt;class TYPE&gt;
    int encode(Formatter&amp; formatter, const TYPE&amp; object);
        // Encode the specified non-modifiable &#39;object&#39; to the specified
        // &#39;formatter&#39;.  Return 0 on success, and a non-zero value otherwise.
        // Note that encoder will use encoder options, error and warning
        // streams specified at the construction time.

    //ACCESSORS
    const EncoderOptions *options() const;
        // Return the encoder options.

    bool isCompact() const;
        // Return &#39;true&#39; if the encoding style in the encoder options is
        // defined as &#39;EncodingStyle::BAEXML_COMPACT&#39;, and &#39;false&#39; otherwise.

    bsl::ostream *errorStream() const;
        // Return pointer to the error stream.

    bsl::ostream *warningStream() const;
        // Return pointer to the warning stream.

    ErrorInfo::Severity  errorSeverity() const;
        // Return the severity of the most severe warning or error encountered
        // during the last call to the &#39;encode&#39; method.  The severity is reset
        // each time &#39;encode&#39; is called.

    bslstl::StringRef loggedMessages() const;
        // Return a string containing any error, warning, or trace messages
        // that were logged during the last call to the &#39;encode&#39; method.  The
        // log is reset each time &#39;encode&#39; is called.
};

// ---- Anything below this line is implementation specific.  Do not use.  ----

                           // ======================
                           // struct Encoder_Context
                           // ======================

class Encoder_Context {
    // This &#39;struct&#39; contains state that is maintained during encoding.  It
    // also contains methods for switching between pretty formatting and
    // compact formatting, based on the encoding options.

    Formatter  *d_formatter;
    Encoder    *d_encoder;

    // NOT IMPLEMENTED
    Encoder_Context(const Encoder_Context&amp; other);
    Encoder_Context&amp; operator=(const Encoder_Context&amp; other);

  public:
    // CREATORS
    Encoder_Context(Formatter *formatter, Encoder *encoder);

    // ACCESSORS
    int status() const
    {
        return d_formatter-&gt;status();
    }

    const EncoderOptions&amp; encoderOptions() const
    {
        return *d_encoder-&gt;options();
    }

    // MANIPULATORS
    bsl::ostream&amp; rawOutputStream()
    {
        return d_formatter-&gt;rawOutputStream();
    }

    void invalidate()
    {
        rawOutputStream().setstate(bsl::ios_base::failbit);
    }

    ErrorInfo::Severity logError(const char               *text,
                                 const bslstl::StringRef&amp;  tag,
                                 int                       formattingMode,
                                 int                       index = -1)
    {
        return d_encoder-&gt;logError(text, tag, formattingMode, index);
    }

    template &lt;class TYPE&gt;
    static void encode(const TYPE&amp; object);

    // HELPER FUNCTIONS
    template&lt;class NAME_TYPE, class VALUE_TYPE&gt;
    void addAttribute(const NAME_TYPE&amp;  name,
                      const VALUE_TYPE&amp; value,
                      int               formattingMode)
    {
        d_formatter-&gt;addAttribute(name, value, formattingMode);
    }

    template &lt;class NAME_TYPE, class VALUE_TYPE&gt;
    void addAttribute(const NAME_TYPE&amp; name, const VALUE_TYPE&amp; value)
    {
        d_formatter-&gt;addAttribute(name,
                                  value,
                                  bdlat_FormattingMode::e_DEFAULT);
    }

    template &lt;class NAME_TYPE&gt;
    void openElement(const NAME_TYPE&amp; name)
    {
        d_formatter-&gt;openElement(name);
    }

    template &lt;class NAME_TYPE&gt;
    void closeElement(const NAME_TYPE&amp; name)
    {
        d_formatter-&gt;closeElement(name);
    }

};

                         // ==========================
                         // class Encoder_EncodeObject
                         // ==========================

class Encoder_EncodeObject {
    // Component-private class.  Do not use.
    //
    // This struct encodes an object *with* enclosing tags.  Compared to the
    // &#39;EncoderUtil_EncodeValue&#39; class below, this class prefixes the value
    // with an opening tag, and suffixes the value with a closing tag.  In
    // pseudocode, this is equivalent to:
    //..
    //  openTag()
    //  Encoder_EncodeValue()
    //  closeTag()
    //..
    // There is an overloaded version of &#39;bsl::vector&lt;char&gt;&#39; because, based on
    // the formatting mode, this class needs to switch between encoding the
    // value in a single tag (i.e., when using BASE64, TEXT, IS_LIST or HEX)
    // and encoding the value in multiple tags (i.e., when repetition is used).

    // PRIVATE TYPES
    struct CanBeListOrRepetition { };
    struct CanBeRepetitionOnly   { };

    // PRIVATE DATA MEMBERS
    Encoder_Context *d_context_p;

  public:
    // IMPLEMENTATION MANIPULATORS
    template &lt;class TYPE&gt;
    int executeImp(const TYPE&amp;               object,
                   const bslstl::StringRef&amp;  tag,
                   int                       formattingMode,
                   bdlat_TypeCategory::Array);

    template &lt;class TYPE&gt;
    int executeImp(const TYPE&amp;                       object,
                   const bslstl::StringRef&amp;          tag,
                   int                               formattingMode,
                   bdlat_TypeCategory::NullableValue);

    template &lt;class TYPE&gt;
    int executeImp(const TYPE&amp;                     object,
                   const bslstl::StringRef&amp;        tag,
                   int                             formattingMode,
                   bdlat_TypeCategory::DynamicType);

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int executeImp(const TYPE&amp;              object,
                   const bslstl::StringRef&amp; tag,
                   int                      formattingMode,
                   ANY_CATEGORY);

    int executeImp(const bsl::vector&lt;char&gt;&amp;  object,
                   const bslstl::StringRef&amp;  tag,
                   int                       formattingMode,
                   bdlat_TypeCategory::Array);

    template &lt;class TYPE&gt;
    int executeArrayListImp(const TYPE&amp; object, const bslstl::StringRef&amp; tag);

    template &lt;class TYPE&gt;
    int executeArrayRepetitionImp(const TYPE&amp;              object,
                                  const bslstl::StringRef&amp; tag,
                                  int                      formattingMode);

  private:
    // NOT IMPLEMENTED
    Encoder_EncodeObject(const Encoder_EncodeObject&amp;);
    Encoder_EncodeObject&amp; operator=(const Encoder_EncodeObject&amp;);

  public:
    // CREATORS
    explicit Encoder_EncodeObject(Encoder_Context *context);

    // Using compiler generated destructor:
    //  ~Encoder_EncodeObject();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(const TYPE&amp; object, const INFO_TYPE&amp; info);

    template &lt;class TYPE&gt;
    int execute(const TYPE&amp;              object,
                const bslstl::StringRef&amp; tag,
                int                      formattingMode);
};

                         // =========================
                         // class Encoder_EncodeValue
                         // =========================

class Encoder_EncodeValue {
    // Component-private class.  Do not use.
    //
    // This class just encodes a value *without* any enclosing tags.

    // PRIVATE DATA MEMBERS
    Encoder_Context *d_context_p;

  public:
    // IMPLEMENTATION MANIPULATORS
    template &lt;class TYPE&gt;
    int executeImp(const TYPE&amp;                  object,
                   int                          formattingMode,
                   bdlat_TypeCategory::Sequence);

    template &lt;class TYPE&gt;
    int executeImp(const TYPE&amp;                object,
                   int                        formattingMode,
                   bdlat_TypeCategory::Choice);

    template &lt;class TYPE&gt;
    int executeImp(const TYPE&amp;                     object,
                   int                             formattingMode,
                   bdlat_TypeCategory::DynamicType);

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int executeImp(const TYPE&amp; object, int formattingMode, ANY_CATEGORY);

  private:
    // NOT IMPLEMENTED
    Encoder_EncodeValue(const Encoder_EncodeValue&amp;);
    Encoder_EncodeValue&amp; operator=(const Encoder_EncodeValue&amp;);

  public:
    // CREATORS
    explicit Encoder_EncodeValue(Encoder_Context *context);

    // Using compiler generated destructor:
    //  ~Encoder_EncodeValue();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(const TYPE&amp; object, const INFO_TYPE&amp; info);

    template &lt;class TYPE&gt;
    int execute(const TYPE&amp; object, int formattingMode);
};

                      // ===============================
                      // class Encoder_SequenceFirstPass
                      // ===============================

class Encoder_SequenceFirstPass {
    // Component private class.  Do not use.
    //
    // This class is used as the first pass when encoding elements of a
    // sequence.  It basically does two things:
    //     o encode elements with the
    //       &#39;bdlat_FormattingMode::e_IS_ATTRIBUTE&#39; flag using the
    //       &#39;Formatter::addAttribute&#39; method.
    //     o looks for an element with the
    //       &#39;bdlat_FormattingMode::e_IS_SIMPLE_CONTENT&#39; flag and, if
    //       found, provides accessors to obtain the &#39;id&#39; of the element.
    //       Note that the behavior is undefined unless there is only one
    //       element with &#39;IS_SIMPLE_CONTENT&#39; flag and, if this element exist,
    //       all other elements must have &#39;IS_ATTRIBUTE&#39; flag.

    // PRIVATE DATA MEMBERS
    Encoder_Context   *d_context_p;        // held, not owned
    bool                      d_hasSubElements;   // true if an element with
                                                  // neither &#39;IS_ATTRIBUTE&#39; nor
                                                  // &#39;IS_SIMPLE_CONTENT&#39; is
                                                  // found
    bdlb::NullableValue&lt;int&gt;  d_simpleContentId;  // the &#39;id&#39; of the element
                                                  // with &#39;IS_SIMPLE_CONTENT&#39;
                                                  // flag, if found

  public:
    // IMPLEMENTATION MANIPULATORS
    template &lt;class TYPE&gt;
    int addAttributeImp(const TYPE&amp;                       object,
                        const bslstl::StringRef&amp;          name,
                        int                               formattingMode,
                        bdlat_TypeCategory::NullableValue);
    template &lt;class TYPE&gt;
    int addAttributeImp(const TYPE&amp;                     object,
                        const bslstl::StringRef&amp;        name,
                        int                             formattingMode,
                        bdlat_TypeCategory::DynamicType);
    template &lt;class TYPE, class ANY_CATEGORY&gt;
    int addAttributeImp(const TYPE&amp;              object,
                        const bslstl::StringRef&amp; name,
                        int                      formattingMode,
                        ANY_CATEGORY);
        // Add an attribute with the specified &#39;name&#39;, the value of the
        // specified &#39;object&#39;, using the specified &#39;formattingMode&#39;.  Note that
        // the last argument is used for overloading purposes only.

    template &lt;class TYPE&gt;
    int addAttribute(const TYPE&amp;              object,
                     const bslstl::StringRef&amp; name,
                     int                      formattingMode);
        // Add an attribute with the specified &#39;name&#39;, the value of the
        // specified &#39;object&#39;, using the specified &#39;formattingMode&#39;.

  private:
    // NOT IMPLEMENTED
    Encoder_SequenceFirstPass(const Encoder_SequenceFirstPass&amp;);
    Encoder_SequenceFirstPass&amp; operator=(const Encoder_SequenceFirstPass&amp;);

  public:
    // CREATORS
    explicit Encoder_SequenceFirstPass(Encoder_Context *context);
        // Create a visitor for first pass for sequences.

    // Generated by compiler:
    //  ~Encoder_SequenceFirstPass();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(const TYPE&amp; object, const INFO_TYPE&amp; info);
        // Called back when an element is visited.

    // ACCESSORS
    const bool&amp; hasSubElements() const;
        // Return true if a sub-element is found, and false otherwise.

    const bdlb::NullableValue&lt;int&gt;&amp; simpleContentId() const;
        // Return a null value if there is no element with &#39;IS_SIMPLE_CONTENT&#39;
        // flag, or a non-null value with the integer &#39;id&#39; of the element
        // otherwise.
};

                      // ================================
                      // class Encoder_SequenceSecondPass
                      // ================================

class Encoder_SequenceSecondPass {
    // Component-private class.  Do not use.
    //
    // This class is used as the second pass when encoding elements of a
    // sequence.  It basically calls &#39;EncoderUtil_EncodeObject&#39; for elements
    // that do not have &#39;IS_ATTRIBUTE&#39; flag.  Note that the behavior is
    // undefined if there is an element with the &#39;IS_SIMPLE_CONTENT&#39; flag.

    // DATA
    Encoder_EncodeObject d_encodeObjectFunctor;
        // functor used to encode sub-elements

    // NOT IMPLEMENTED
    Encoder_SequenceSecondPass(const Encoder_SequenceSecondPass&amp;);
    Encoder_SequenceSecondPass&amp; operator=(const Encoder_SequenceSecondPass&amp;);

  public:
    // CREATORS
    explicit
    Encoder_SequenceSecondPass(Encoder_Context *context);
        // Create a visitor for the second pass for sequences.

    // Generated by compiler:
    //  ~Encoder_SequenceSecondPass();

    // MANIPULATORS
    template &lt;class TYPE, class INFO_TYPE&gt;
    int operator()(const TYPE&amp; object, const INFO_TYPE&amp; info);
        // Called back when an element is visited.
};

// ============================================================================
//                               PROXY CLASSES
// ============================================================================

                  // ========================================
                  // struct Encoder_EncodeObject_executeProxy
                  // ========================================

struct Encoder_EncodeObject_executeProxy {
    // Component-private struct.  Do not use.

    // DATA MEMBERS
    Encoder_EncodeObject *d_instance_p;
    const bslstl::StringRef       *d_tag_p;
    int                          d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(const TYPE&amp; object)
    {
        return d_instance_p-&gt;execute(object, *d_tag_p, d_formattingMode);
    }
};

                // ===========================================
                // struct Encoder_EncodeObject_executeImpProxy
                // ===========================================

struct Encoder_EncodeObject_executeImpProxy {
    // Component-private struct.  Do not use.

    // DATA
    Encoder_EncodeObject *d_instance_p;
    const bslstl::StringRef       *d_tag_p;
    int                          d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(const TYPE&amp;, bslmf::Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    inline
    int operator()(const TYPE&amp; object, ANY_CATEGORY category)
    {
        return d_instance_p-&gt;executeImp(object,
                                        *d_tag_p,
                                        d_formattingMode,
                                        category);
    }
};

                 // ==========================================
                 // struct Encoder_EncodeValue_executeImpProxy
                 // ==========================================

struct Encoder_EncodeValue_executeImpProxy {
    // Component-private struct.  Do not use.

    // DATA MEMBERS
    Encoder_EncodeValue *d_instance_p;
    int                         d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(const TYPE&amp;, bslmf::Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    inline
    int operator()(const TYPE&amp; object, ANY_CATEGORY category)
    {
        return d_instance_p-&gt;executeImp(object, d_formattingMode, category);
    }
};

             // ==================================================
             // struct Encoder_SequenceFirstPass_addAttributeProxy
             // ==================================================

struct Encoder_SequenceFirstPass_addAttributeProxy {
    // Component-private struct.  Do not use.

    // DATA MEMBERS
    Encoder_SequenceFirstPass *d_instance_p;
    const bslstl::StringRef            *d_name_p;
    int                               d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(const TYPE&amp; object)
    {
        return d_instance_p-&gt;addAttribute(object, *d_name_p, d_formattingMode);
    }
};

           // =====================================================
           // struct Encoder_SequenceFirstPass_addAttributeImpProxy
           // =====================================================

struct Encoder_SequenceFirstPass_addAttributeImpProxy {
    // Component-private struct.  Do not use.

    // DATA MEMBERS
    Encoder_SequenceFirstPass *d_instance_p;
    const bslstl::StringRef            *d_name_p;
    int                               d_formattingMode;

    // CREATORS

    // Creators have been omitted to allow simple static initialization of this
    // struct.

    // FUNCTIONS
    template &lt;class TYPE&gt;
    inline
    int operator()(const TYPE&amp;, bslmf::Nil)
    {
        BSLS_ASSERT_SAFE(0);
        return -1;
    }

    template &lt;class TYPE, class ANY_CATEGORY&gt;
    inline
    int operator()(const TYPE&amp; object, ANY_CATEGORY category)
    {
        return d_instance_p-&gt;addAttributeImp(object,
                                             *d_name_p,
                                             d_formattingMode,
                                             category);
    }
};
}  // close package namespace

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                   // --------------------------------------
                   // class baexml::BerEncoder::MemOutStream
                   // --------------------------------------

inline
balxml::Encoder::MemOutStream::MemOutStream(bslma::Allocator *basicAllocator)
: bsl::ostream(0)
, d_sb(bslma::Default::allocator(basicAllocator))
{
    rdbuf(&amp;d_sb);
}

// MANIPULATORS
inline
void balxml::Encoder::MemOutStream::reset()
{
    d_sb.reset();
}

// ACCESSORS
inline
const char *balxml::Encoder::MemOutStream::data() const
{
    return d_sb.data();
}

inline
int balxml::Encoder::MemOutStream::length() const
{
    return (int)d_sb.length();
}

namespace balxml {
                               // -------------
                               // class Encoder
                               // -------------

inline
bool Encoder::isCompact() const
{
    return EncodingStyle::e_COMPACT == d_options-&gt;encodingStyle();
}

inline
const EncoderOptions *Encoder::options() const
{
    return d_options;
}

inline
bsl::ostream *Encoder::errorStream() const
{
    return d_errorStream;
}

inline
bsl::ostream *Encoder::warningStream() const
{
    return d_warningStream;
}

inline
ErrorInfo::Severity Encoder::errorSeverity() const
{
    return d_severity;
}

inline
bslstl::StringRef Encoder::loggedMessages() const
{
    if (d_logStream) {
        return bslstl::StringRef(d_logStream-&gt;data(), d_logStream-&gt;length());
                                                                      // RETURN
    }
    return bslstl::StringRef();
}

inline
bsl::ostream&amp; Encoder::logStream()
{
    if (0 == d_logStream) {
        d_logStream = new(d_logArea.buffer()) MemOutStream(d_allocator);
    }
    return *d_logStream;
}

template &lt;class TYPE&gt;
inline
int Encoder::encode(bsl::streambuf *buffer, const TYPE&amp; object)
{
    bool bCompact = isCompact();

    Formatter formatter(buffer,
         bCompact ?  0 : d_options-&gt;initialIndentLevel(),
         bCompact ?  0 : d_options-&gt;spacesPerLevel(),
         bCompact ? -1 : d_options-&gt;wrapColumn());

    const int rc = encode(formatter, object);

    buffer-&gt;pubsync();

    return rc;
}

template &lt;class TYPE&gt;
inline
int Encoder::encodeToStream(bsl::ostream&amp; stream, const TYPE&amp; object)
{
    return encode(stream.rdbuf(), object);
}

template &lt;class TYPE&gt;
inline
bsl::ostream&amp; Encoder::encode(bsl::ostream&amp; stream, const TYPE&amp; object)
{
    bool bCompact = isCompact();

    Formatter formatter(stream,
         bCompact ?  0 : d_options-&gt;initialIndentLevel(),
         bCompact ?  0 : d_options-&gt;spacesPerLevel(),
         bCompact ? -1 : d_options-&gt;wrapColumn());

    encode(formatter, object);

    stream.flush();

    return stream;
}

template &lt;class TYPE&gt;
int Encoder::encode(Formatter&amp; formatter, const TYPE&amp; object)
{
    d_severity = ErrorInfo::e_NO_ERROR;
    if (d_logStream != 0) {
        d_logStream-&gt;reset();
    }

    Encoder_Context context(&amp;formatter,this);

    if (d_options-&gt;outputXMLHeader()) {
        formatter.addHeader();
    }

    const char *tag = d_options-&gt;tag().empty()
                    ? bdlat_TypeName::xsdName(object,
                                              d_options-&gt;formattingMode())
                    : d_options-&gt;tag().c_str();

    context.openElement(tag);

    if (!d_options-&gt;objectNamespace().empty()) {

        context.addAttribute(&quot;xmlns&quot;, d_options-&gt;objectNamespace());

        if (d_options-&gt;outputXSIAlias()) {
            // Only declare the &quot;xsi&quot; namespace and schema location if an
            // object namespace was provided because only then can validation
            // happen.
            context.addAttribute(&quot;xmlns:xsi&quot;,
                                 &quot;http://www.w3.org/2001/XMLSchema-instance&quot;);

            if (!d_options-&gt;schemaLocation().empty()) {
                context.addAttribute(&quot;xsi:schemaLocation&quot;,
                                     d_options-&gt;objectNamespace()
                                     + &quot; &quot;
                                     + d_options-&gt;schemaLocation());
            }
        }
    }
    else if (d_options-&gt;outputXSIAlias()) {
        context.addAttribute(&quot;xmlns:xsi&quot;,
                             &quot;http://www.w3.org/2001/XMLSchema-instance&quot;);
    }

    Encoder_EncodeValue encodeValue(&amp;context);

    int rc = 0;
    if (0 != encodeValue.execute(object,d_options-&gt;formattingMode())) {

        logError(&quot;Failed to encode&quot;, tag, d_options-&gt;formattingMode());

        context.invalidate();
        rc = -1;
    }
    else {
        context.closeElement(tag);
    }

    switch (d_severity) {
      case ErrorInfo::e_NO_ERROR: {
      } break;
      case ErrorInfo::e_WARNING: {
        if (d_warningStream) {
            *d_warningStream &lt;&lt; loggedMessages();
        }
      } break;
      default: {
        if (d_errorStream) {
            *d_errorStream &lt;&lt; loggedMessages();
        }
      } break;
    }
    return rc;
}

                         // --------------------------
                         // class Encoder_EncodeObject
                         // --------------------------

// IMPLEMENTATION MANIPULATORS
template &lt;class TYPE&gt;
inline
int Encoder_EncodeObject::executeImp(const TYPE&amp;               object,
                                     const bslstl::StringRef&amp;  tag,
                                     int                       formattingMode,
                                     bdlat_TypeCategory::Array)
{
    if (formattingMode &amp; bdlat_FormattingMode::e_LIST) {
        return executeArrayListImp(object, tag);                      // RETURN
    }
    // else { return ... } removed, to prevent warning with gcc-4.1.1 (reach
    // end of non-void function), instead, have unconditional:

    return executeArrayRepetitionImp(object, tag, formattingMode);
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeObject::executeImp(
                              const TYPE&amp;                       object,
                              const bslstl::StringRef&amp;          tag,
                              int                               formattingMode,
                              bdlat_TypeCategory::NullableValue)
{
    enum { k_SUCCESS = 0 };

    if (bdlat_NullableValueFunctions::isNull(object)) {
        if (formattingMode &amp; bdlat_FormattingMode::e_NILLABLE) {
            d_context_p-&gt;openElement(tag);
            if (!d_context_p-&gt;encoderOptions().objectNamespace().empty()
             &amp;&amp; d_context_p-&gt;encoderOptions().outputXSIAlias()) {
                // Only add the &quot;xsi:nil&quot; attribute if an object namespace was
                // provided because only then can validation happen.
                d_context_p-&gt;addAttribute(&quot;xsi:nil&quot;, &quot;true&quot;);
            }
            d_context_p-&gt;closeElement(tag);
        }

        return d_context_p-&gt;status();                                 // RETURN
    }

    Encoder_EncodeObject_executeProxy proxy = {
        this,
        &amp;tag,
        formattingMode
    };

    return bdlat_NullableValueFunctions::accessValue(object, proxy);
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeObject::executeImp(
                                const TYPE&amp;                     object,
                                const bslstl::StringRef&amp;        tag,
                                int                             formattingMode,
                                bdlat_TypeCategory::DynamicType)
{
    Encoder_EncodeObject_executeImpProxy proxy = {
        this,
        &amp;tag,
        formattingMode
    };

    return bdlat_TypeCategoryUtil::accessByCategory(object, proxy);
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
int Encoder_EncodeObject::executeImp(const TYPE&amp;              object,
                                     const bslstl::StringRef&amp; tag,
                                     int                      formattingMode,
                                     ANY_CATEGORY)
{
    enum { k_FAILURE = -1 };

    bool isUntagged = formattingMode &amp; bdlat_FormattingMode::e_UNTAGGED;

    if (!isUntagged) {
        d_context_p-&gt;openElement(tag);
    }

    Encoder_EncodeValue encodeValue(d_context_p);

    if (0 != encodeValue.execute(object, formattingMode)) {
        d_context_p-&gt;logError(&quot;Unable to encode value&quot;, tag, formattingMode);
        return k_FAILURE;                                             // RETURN
    }

    if (!isUntagged) {
        d_context_p-&gt;closeElement(tag);
    }

    int ret = d_context_p-&gt;status();

    if (ret) {
        d_context_p-&gt;logError(&quot;Formatter was invalidated for&quot;,
                              tag,
                              formattingMode);
    }

    return ret;
}

template &lt;class TYPE&gt;
int Encoder_EncodeObject::executeArrayListImp(const TYPE&amp;              object,
                                              const bslstl::StringRef&amp; tag)
{
    d_context_p-&gt;openElement(tag);

    TypesPrintUtil::printList(d_context_p-&gt;rawOutputStream(),
                              object,
                              &amp;d_context_p-&gt;encoderOptions());

    d_context_p-&gt;closeElement(tag);

    int ret = d_context_p-&gt;status();

    if (ret) {

        d_context_p-&gt;logError(
            &quot;Error while encoding list for&quot;,
            tag,
            EncoderOptions::DEFAULT_INITIALIZER_FORMATTING_MODE);
    }

    return ret;
}

template &lt;class TYPE&gt;
int Encoder_EncodeObject::executeArrayRepetitionImp(
                                       const TYPE&amp;              object,
                                       const bslstl::StringRef&amp; tag,
                                       int                      formattingMode)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    const int size = (int)bdlat_ArrayFunctions::size(object);

    Encoder_EncodeObject_executeProxy proxy = { this, &amp;tag, formattingMode };

    for (int i = 0; i &lt; size; ++i) {
        if (0 != bdlat_ArrayFunctions::accessElement(object, proxy, i)) {

            d_context_p-&gt;logError(
                &quot;Error while encoding array element&quot;,
                tag,
                formattingMode,
                i);

            return k_FAILURE;                                         // RETURN
        }
    }

    return k_SUCCESS;
}

// CREATORS
inline
Encoder_EncodeObject::Encoder_EncodeObject(Encoder_Context *context)
: d_context_p(context)
{
    BSLS_ASSERT_SAFE(d_context_p);
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
inline
int Encoder_EncodeObject::operator()(const TYPE&amp; object, const INFO_TYPE&amp; info)
{
    bslstl::StringRef name(info.name(), info.nameLength());

    return execute(object, name, info.formattingMode());
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeObject::execute(const TYPE&amp;              object,
                                  const bslstl::StringRef&amp; tag,
                                  int                      formattingMode)
{
    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    return executeImp(object, tag, formattingMode, TypeCategory());
}

                         // -------------------------
                         // class Encoder_EncodeValue
                         // -------------------------

// IMPLEMENTATION MANIPULATORS
template &lt;class TYPE&gt;
inline
int Encoder_EncodeValue::executeImp(
                                   const TYPE&amp;                  object,
                                   int                          formattingMode,
                                   bdlat_TypeCategory::Sequence)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

#if defined(BDE_BUILD_TARGET_SAFE)
    int type = formattingMode &amp; bdlat_FormattingMode::e_TYPE_MASK;

    BSLS_ASSERT_SAFE(bdlat_FormattingMode::e_DEFAULT == type);
#else
    (void) formattingMode;
#endif

    Encoder_SequenceFirstPass firstPass(d_context_p);

    if (0 != bdlat_SequenceFunctions::accessAttributes(object, firstPass)) {
        return k_FAILURE;                                             // RETURN
    }

    if (!firstPass.simpleContentId().isNull()) {
    }

    if (!firstPass.simpleContentId().isNull()) {
        Encoder_EncodeValue encodeValue(d_context_p);

        return bdlat_SequenceFunctions::accessAttribute(
                                          object,
                                          encodeValue,
                                          firstPass.simpleContentId().value());
                                                                      // RETURN
    }

    if (firstPass.hasSubElements()) {
        Encoder_SequenceSecondPass secondPass(d_context_p);

        return bdlat_SequenceFunctions::accessAttributes(object, secondPass);
                                                                      // RETURN
    }

    return k_SUCCESS;
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeValue::executeImp(const TYPE&amp;                object,
                                    int                        formattingMode,
                                    bdlat_TypeCategory::Choice)
{
    enum { k_FAILURE = -1 };

#if defined(BDE_BUILD_TARGET_SAFE)
    int type = formattingMode &amp; bdlat_FormattingMode::e_TYPE_MASK;

    BSLS_ASSERT_SAFE(bdlat_FormattingMode::e_DEFAULT == type);
#endif

    if (bdlat_ChoiceFunctions::k_UNDEFINED_SELECTION_ID
                               == bdlat_ChoiceFunctions::selectionId(object)) {

        d_context_p-&gt;logError(&quot;Undefined selection is not allowed &quot;,
                              &quot;???&quot;,
                              formattingMode);
        return k_FAILURE;                                             // RETURN
    }

    Encoder_EncodeObject encodeObject(d_context_p);

    return bdlat_ChoiceFunctions::accessSelection(object, encodeObject);
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeValue::executeImp(
                                const TYPE&amp;                     object,
                                int                             formattingMode,
                                bdlat_TypeCategory::DynamicType)
{
    Encoder_EncodeValue_executeImpProxy proxy = { this, formattingMode };

    return bdlat_TypeCategoryUtil::accessByCategory(object, proxy);
}

template &lt;class TYPE, class ANY_CATEGORY&gt;
inline
int Encoder_EncodeValue::executeImp(const TYPE&amp;  object,
                                    int          formattingMode,
                                    ANY_CATEGORY)
{
    TypesPrintUtil::print(d_context_p-&gt;rawOutputStream(),
                          object,
                          formattingMode,
                          &amp;d_context_p-&gt;encoderOptions());

    return d_context_p-&gt;status();
}

// CREATORS
inline
Encoder_EncodeValue::Encoder_EncodeValue(Encoder_Context *context)
: d_context_p(context)
{
    BSLS_ASSERT_SAFE(d_context_p);
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
inline
int Encoder_EncodeValue::operator()(const TYPE&amp; object, const INFO_TYPE&amp; info)
{
    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    return executeImp(object, info.formattingMode(), TypeCategory());
}

template &lt;class TYPE&gt;
inline
int Encoder_EncodeValue::execute(const TYPE&amp; object, int formattingMode)
{
    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    return executeImp(object, formattingMode, TypeCategory());
}

                      // -------------------------------
                      // class Encoder_SequenceFirstPass
                      // -------------------------------

// IMPLEMENTATION MANIPULATORS
template &lt;class TYPE&gt;
inline
int Encoder_SequenceFirstPass::addAttributeImp(
                              const TYPE&amp;                       object,
                              const bslstl::StringRef&amp;          name,
                              int                               formattingMode,
                              bdlat_TypeCategory::NullableValue)
{
    enum { k_SUCCESS = 0 };

    if (bdlat_NullableValueFunctions::isNull(object)) {
        return k_SUCCESS;                                             // RETURN
    }

    Encoder_SequenceFirstPass_addAttributeProxy proxy = {
        this,
        &amp;name,
        formattingMode
    };

    return bdlat_NullableValueFunctions::accessValue(object, proxy);
}

template &lt;class TYPE&gt;
inline
int Encoder_SequenceFirstPass::addAttributeImp(
                                const TYPE&amp;                     object,
                                const bslstl::StringRef&amp;        name,
                                int                             formattingMode,
                                bdlat_TypeCategory::DynamicType)
{
    Encoder_SequenceFirstPass_addAttributeImpProxy proxy = {
        this,
        &amp;name,
        formattingMode
    };

    return bdlat_TypeCategoryUtil::accessByCategory(object, proxy);

}

template &lt;class TYPE, class ANY_CATEGORY&gt;
inline
int Encoder_SequenceFirstPass::addAttributeImp(
                                       const TYPE&amp;              object,
                                       const bslstl::StringRef&amp; name,
                                       int                      formattingMode,
                                       ANY_CATEGORY)
{
    d_context_p-&gt;addAttribute(name, object, formattingMode);

    int ret = d_context_p-&gt;status();

    if (ret) {
        d_context_p-&gt;logError(&quot;Failed to encode attribute&quot;,
                              name,
                              formattingMode);
    }

    return ret;
}

template &lt;class TYPE&gt;
inline
int Encoder_SequenceFirstPass::addAttribute(
                                       const TYPE&amp;              object,
                                       const bslstl::StringRef&amp; name,
                                       int                      formattingMode)
{
    typedef typename bdlat_TypeCategory::Select&lt;TYPE&gt;::Type TypeCategory;

    return addAttributeImp(object, name, formattingMode, TypeCategory());
}

// CREATORS
inline
Encoder_SequenceFirstPass::Encoder_SequenceFirstPass(Encoder_Context *context)
: d_context_p(context)
, d_hasSubElements(false)
{
    BSLS_ASSERT_SAFE(d_context_p);
    BSLS_ASSERT_SAFE(d_simpleContentId.isNull());
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
int Encoder_SequenceFirstPass::operator()(const TYPE&amp;      object,
                                          const INFO_TYPE&amp; info)
{
    enum { k_SUCCESS = 0 };

    int  formattingMode  = info.formattingMode();
    bool isSimpleContent = formattingMode
                         &amp; bdlat_FormattingMode::e_SIMPLE_CONTENT;
    bool isAttribute     = formattingMode &amp; bdlat_FormattingMode::e_ATTRIBUTE;

    if (isSimpleContent) {
        BSLS_ASSERT_SAFE(!isAttribute);
        BSLS_ASSERT_SAFE(!d_hasSubElements);
        BSLS_ASSERT_SAFE(d_simpleContentId.isNull());

        d_simpleContentId.makeValue(info.id());
    }
    else if (isAttribute) {
        bslstl::StringRef name(info.name(), info.nameLength());

        return addAttribute(object, name, formattingMode);            // RETURN
    }
    else {
        BSLS_ASSERT_SAFE(d_simpleContentId.isNull());

        d_hasSubElements = true;
    }

    return k_SUCCESS;
}

// ACCESSORS
inline
const bool&amp; Encoder_SequenceFirstPass::hasSubElements() const
{
    return d_hasSubElements;
}

inline
const bdlb::NullableValue&lt;int&gt;&amp;
Encoder_SequenceFirstPass::simpleContentId() const
{
    return d_simpleContentId;
}

                      // --------------------------------
                      // class Encoder_SequenceSecondPass
                      // --------------------------------

// CREATORS
inline
Encoder_SequenceSecondPass::Encoder_SequenceSecondPass(
                                                      Encoder_Context* context)
: d_encodeObjectFunctor(context)
{
}

// MANIPULATORS
template &lt;class TYPE, class INFO_TYPE&gt;
int Encoder_SequenceSecondPass::operator()(const TYPE&amp;      object,
                                           const INFO_TYPE&amp; info)
{
    enum { k_SUCCESS = 0 };

    int formattingMode = info.formattingMode();

    BSLS_ASSERT_SAFE(
               !(formattingMode &amp; bdlat_FormattingMode::e_SIMPLE_CONTENT));

    if (!(formattingMode &amp; bdlat_FormattingMode::e_ATTRIBUTE)) {
        return d_encodeObjectFunctor(object, info);                   // RETURN
    }

    return k_SUCCESS;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
