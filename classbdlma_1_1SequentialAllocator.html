<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlma::SequentialAllocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlma.html">bdlma</a>      </li>
      <li><a class="el" href="classbdlma_1_1SequentialAllocator.html">bdlma::SequentialAllocator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlma::SequentialAllocator Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlma::SequentialAllocator" --><!-- doxytag: inherits="bdlma::ManagedAllocator" -->
<p><code>#include &lt;<a class="el" href="bdlma__sequentialallocator_8h_source.html">bdlma_sequentialallocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bdlma::SequentialAllocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbdlma_1_1SequentialAllocator.png" usemap="#bdlma::SequentialAllocator_map" alt=""/>
  <map id="bdlma::SequentialAllocator_map" name="bdlma::SequentialAllocator_map">
<area href="classbdlma_1_1ManagedAllocator.html" alt="bdlma::ManagedAllocator" shape="rect" coords="0,56,160,80"/>
<area href="classbslma_1_1Allocator.html" alt="bslma::Allocator" shape="rect" coords="0,0,160,24"/>
</map>
</div>

<p><a href="classbdlma_1_1SequentialAllocator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#adf60ace478b9c95506dbe04a6491156b">SequentialAllocator</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a47d2cebf1e82307cc930ad51fd75baca">SequentialAllocator</a> (<a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#ab72ece5c2f1b7a8a4a2863d9e1d86fa0">SequentialAllocator</a> (<a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a4f63f61df4b5a86e509bf51ef147efcd">SequentialAllocator</a> (<a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a17ef24b1320ad65998aca5758e3314ae">SequentialAllocator</a> (int initialSize, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#ab849de0fa6033b7125ec85a43b700211">SequentialAllocator</a> (int initialSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#adab38577e49c6486d438137d6802079a">SequentialAllocator</a> (int initialSize, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a48bd8f9504178bc5eb24bfe6ce162409">SequentialAllocator</a> (int initialSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#aaef14105e5e2722f697640d1dc8a1650">SequentialAllocator</a> (int initialSize, int maxBufferSize, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a4645ab4e9db0849fd10464c8ed3460ce">SequentialAllocator</a> (int initialSize, int maxBufferSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#ad95e759edf2a04f5e1af63558c8573c5">SequentialAllocator</a> (int initialSize, int maxBufferSize, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a69a0ebe7a5b92178ba6c7dcf562a86f3">SequentialAllocator</a> (int initialSize, int maxBufferSize, <a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a> growthStrategy, <a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a> alignmentStrategy, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a7a079fe0847768ff6d052f57da6ab9e5">~SequentialAllocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a3696da7587a1c842d9430a960520af71">allocate</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#aebd95db81f54c96a8ca9a1f4f2cd1492">allocateAndExpand</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> *size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a107050851e46527f4664869ec8a76f44">deallocate</a> (void *address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a88b2b20d0384373ea5a99e5b632fc210">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#adfebba8f75439699174f6af02191afce">reserveCapacity</a> (int numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlma_1_1SequentialAllocator.html#a7406226eadc9b9313502b699d462afae">truncate</a> (void *address, int originalSize, int newSize)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a0e51fc2d107684523cc66bf65293dc37">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a> (const TYPE *object)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">ManagedAllocator</a></code> protocol to provide a fast allocator that dispenses heterogeneous blocks of memory (of varying, user-specified sizes) from a sequence of dynamically-allocated buffers. Memory for the internal buffers is supplied by an (optional) allocator supplied at construction; if no allocator is supplied, the currently installed default allocator is used. If an allocation exceeds the remaining free memory space in the current buffer, the allocator replenishes its internal buffer with new memory to satisfy the request. This class is <em>exception</em> <em>neutral</em>: If memory cannot be allocated, the behavior is defined by the (optional) allocator specified at construction. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a07cd3ddf3fba145a0469a4e867047287"></a><!-- doxytag: member="bdlma::SequentialAllocator::size_type" ref="a07cd3ddf3fba145a0469a4e867047287" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="adf60ace478b9c95506dbe04a6491156b"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="adf60ace478b9c95506dbe04a6491156b" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a47d2cebf1e82307cc930ad51fd75baca"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="a47d2cebf1e82307cc930ad51fd75baca" args="(bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab72ece5c2f1b7a8a4a2863d9e1d86fa0"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="ab72ece5c2f1b7a8a4a2863d9e1d86fa0" args="(bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f63f61df4b5a86e509bf51ef147efcd"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="a4f63f61df4b5a86e509bf51ef147efcd" args="(bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a sequential allocator for allocating memory blocks from a sequence of dynamically-allocated buffers. Optionally specify a <code>basicAllocator</code> used to supply memory for the dynamically-allocated buffers. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Optionally specify a <code>growthStrategy</code> used to control buffer growth. If no <code>growthStrategy</code> is specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to control alignment of allocated memory blocks. If no <code>alignmentStrategy</code> is specified, natural alignment is used. Note that no limit is imposed on the size of the internal buffers when geometric growth is used. </p>

</div>
</div>
<a class="anchor" id="a17ef24b1320ad65998aca5758e3314ae"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="a17ef24b1320ad65998aca5758e3314ae" args="(int initialSize, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab849de0fa6033b7125ec85a43b700211"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="ab849de0fa6033b7125ec85a43b700211" args="(int initialSize, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adab38577e49c6486d438137d6802079a"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="adab38577e49c6486d438137d6802079a" args="(int initialSize, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a48bd8f9504178bc5eb24bfe6ce162409"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="a48bd8f9504178bc5eb24bfe6ce162409" args="(int initialSize, bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a sequential allocator for allocating memory blocks from a sequence of dynamically-allocated buffers, of which the initial buffer has the specified <code>initialSize</code> (in bytes). Optionally specify a <code>basicAllocator</code> used to supply memory for the dynamically-allocated buffers. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Optionally specify a <code>growthStrategy</code> used to control buffer growth. If no <code>growthStrategy</code> is specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to control alignment of allocated memory blocks. If no <code>alignmentStrategy</code> is specified, natural alignment is used. An implementation-defined value is used as the initial size of the internal buffer. The behavior is undefined unless <code>0 &lt; initialSize</code>. Note that no limit is imposed on the size of the internal buffers when geometric growth is used. Also note that when constant growth is used, the size of the internal buffers will always be the same as the implementation-defined value. </p>

</div>
</div>
<a class="anchor" id="aaef14105e5e2722f697640d1dc8a1650"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="aaef14105e5e2722f697640d1dc8a1650" args="(int initialSize, int maxBufferSize, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4645ab4e9db0849fd10464c8ed3460ce"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="a4645ab4e9db0849fd10464c8ed3460ce" args="(int initialSize, int maxBufferSize, bsls::BlockGrowth::Strategy growthStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad95e759edf2a04f5e1af63558c8573c5"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="ad95e759edf2a04f5e1af63558c8573c5" args="(int initialSize, int maxBufferSize, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69a0ebe7a5b92178ba6c7dcf562a86f3"></a><!-- doxytag: member="bdlma::SequentialAllocator::SequentialAllocator" ref="a69a0ebe7a5b92178ba6c7dcf562a86f3" args="(int initialSize, int maxBufferSize, bsls::BlockGrowth::Strategy growthStrategy, bsls::Alignment::Strategy alignmentStrategy, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlma::SequentialAllocator::SequentialAllocator </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxBufferSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1BlockGrowth.html#aa1ba2343ba322b66a455d222ba630c31">bsls::BlockGrowth::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>growthStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Alignment.html#af3fa512292007f79df13f954a7d4ed1e">bsls::Alignment::Strategy</a>&nbsp;</td>
          <td class="paramname"> <em>alignmentStrategy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a sequential allocator for allocating memory blocks from a sequence of dynamically-allocated buffers, of which the initial buffer has the specified <code>initialSize</code> (in bytes), and the buffer growth is limited to the specified <code>maxBufferSize</code>. Optionally specify a <code>basicAllocator</code> used to supply memory for the dynamically-allocated buffers. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. Optionally specify a <code>growthStrategy</code> used to control buffer growth. If no <code>growthStrategy</code> is specified, geometric growth is used. Optionally specify an <code>alignmentStrategy</code> used to control alignment of allocated memory blocks. If no <code>alignmentStrategy</code> is specified, natural alignment is used. The behavior is undefined unless <code>0 &lt; initialSize</code> and <code>initialSize &lt;= maxBufferSize</code>. Note that when constant growth is used, the size of the internal buffers will always be the same as <code>initialSize</code>. </p>

</div>
</div>
<a class="anchor" id="a7a079fe0847768ff6d052f57da6ab9e5"></a><!-- doxytag: member="bdlma::SequentialAllocator::~SequentialAllocator" ref="a7a079fe0847768ff6d052f57da6ab9e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bdlma::SequentialAllocator::~SequentialAllocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this sequential allocator. All memory allocated from this allocator is released. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a3696da7587a1c842d9430a960520af71"></a><!-- doxytag: member="bdlma::SequentialAllocator::allocate" ref="a3696da7587a1c842d9430a960520af71" args="(size_type size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* bdlma::SequentialAllocator::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of memory of the specified <code>size</code> (in bytes) according to the alignment strategy specified at construction. If <code>size</code> is 0, no memory is allocated and 0 is returned. If the allocation request exceeds the remaining free memory space in the current internal buffer, use the allocator supplied at construction to allocate a new internal buffer, then allocate memory from the new buffer. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="aebd95db81f54c96a8ca9a1f4f2cd1492"></a><!-- doxytag: member="bdlma::SequentialAllocator::allocateAndExpand" ref="aebd95db81f54c96a8ca9a1f4f2cd1492" args="(size_type *size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* bdlma::SequentialAllocator::allocateAndExpand </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> *&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of a contiguous block of memory of at least the specified <code>*size</code> (in bytes), and load the actual amount of memory allocated into <code>*size</code>. If <code>*size</code> is 0, return 0 with no effect. If the allocation request exceeds the remaining free memory space in the current internal buffer, use the allocator supplied at construction to allocate a new internal buffer, then allocate memory from the new buffer. </p>

</div>
</div>
<a class="anchor" id="a107050851e46527f4664869ec8a76f44"></a><!-- doxytag: member="bdlma::SequentialAllocator::deallocate" ref="a107050851e46527f4664869ec8a76f44" args="(void *address)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bdlma::SequentialAllocator::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method has no effect on the memory block at the specified <code>address</code> as all memory allocated by this allocator is managed. The behavior is undefined unless <code>address</code> is 0, or was allocated by this allocator and has not already been deallocated. </p>

<p>Implements <a class="el" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">bslma::Allocator</a>.</p>

</div>
</div>
<a class="anchor" id="a88b2b20d0384373ea5a99e5b632fc210"></a><!-- doxytag: member="bdlma::SequentialAllocator::release" ref="a88b2b20d0384373ea5a99e5b632fc210" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bdlma::SequentialAllocator::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release all memory allocated through this allocator. The allocator is reset to its default constructed state, retaining the alignment and growth strategy supplied at construction (if any) after this call. </p>

<p>Implements <a class="el" href="classbdlma_1_1ManagedAllocator.html#ad86110a47aaf5e53356c86b5fd240bfb">bdlma::ManagedAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="adfebba8f75439699174f6af02191afce"></a><!-- doxytag: member="bdlma::SequentialAllocator::reserveCapacity" ref="adfebba8f75439699174f6af02191afce" args="(int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlma::SequentialAllocator::reserveCapacity </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve sufficient memory to satisfy allocation requests for at least the specified <code>numBytes</code> without replenishment (i.e., without dynamic allocation). If <code>numBytes</code> is 0, no memory is reserved. This method ignores <code>maxBufferSize</code> even if it is supplied at construction. The behavior is undefined unless <code>0 &lt;= numBytes</code>. Note that, due to alignment effects, it is possible that not all <code>numBytes</code> of memory will be used for allocation before triggering dynamic allocation. </p>

</div>
</div>
<a class="anchor" id="a7406226eadc9b9313502b699d462afae"></a><!-- doxytag: member="bdlma::SequentialAllocator::truncate" ref="a7406226eadc9b9313502b699d462afae" args="(void *address, int originalSize, int newSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlma::SequentialAllocator::truncate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>originalSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>newSize</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reduce the amount of memory allocated at the specified <code>address</code> of the specified <code>originalSize</code> (in bytes) to the specified <code>newSize</code>. Return <code>newSize</code> after truncating, or <code>originalSize</code> if the memory at <code>address</code> cannot be truncated. This method can only <code>truncate</code> the memory block returned by the most recent <code>allocate</code> request from this allocator, and otherwise has no effect. The behavior is undefined unless the memory at <code>address</code> was originally allocated by this allocator, the size of the memory block at <code>address</code> is <code>originalSize</code>, <code>newSize &lt;= originalSize</code>, <code>0 &lt;= newSize</code>, and <code>release</code> was not called after allocating the memory block at <code>address</code>. </p>

</div>
</div>
<a class="anchor" id="a0e51fc2d107684523cc66bf65293dc37"></a><!-- doxytag: member="bdlma::SequentialAllocator::deleteObject" ref="a0e51fc2d107684523cc66bf65293dc37" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this allocator and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="abeccfe6cfd8205faf528a8e12f97aebe"></a><!-- doxytag: member="bdlma::SequentialAllocator::deleteObjectRaw" ref="abeccfe6cfd8205faf528a8e12f97aebe" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code> was allocated using this allocator, is <b>not</b> a secondary base class pointer -- i.e., the address is (numerically) the same as when it was originally dispensed by this allocator, and has not already been deallocated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlma__sequentialallocator_8h_source.html">bdlma_sequentialallocator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
