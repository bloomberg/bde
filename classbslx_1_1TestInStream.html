<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bslx::TestInStream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslx.html">bslx</a>      </li>
      <li><a class="el" href="classbslx_1_1TestInStream.html">bslx::TestInStream</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bslx::TestInStream Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslx::TestInStream" -->
<p><code>#include &lt;<a class="el" href="bslx__testinstream_8h_source.html">bslx_testinstream.h</a>&gt;</code></p>

<p><a href="classbslx_1_1TestInStream-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#acce77d0485b63f9f7dab0619414081ab">TestInStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a720b8e018d740d3332c11975e38fb104">TestInStream</a> (const char *buffer, bsl::size_t numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a02792a9fcd184184c8efe9e87fec03a0">TestInStream</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a911835733568a5b51fe7ba4cf4ef81de">~TestInStream</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#aa0179fe7efb0289925b07cce6eadf0c8">getLength</a> (int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a7b63cc0c642729a51c6f52f0bdd3eb01">getVersion</a> (int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a6abd2ade531583b6cd60c95134793982">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a15d9f118faa0f50a41e1ae5d901d1318">reset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#acb9666d532a16f1a427e42b65231eaf6">reset</a> (const char *buffer, bsl::size_t numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a5558d85d074716136a8dcb3dd3de2b7d">reset</a> (const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;srcData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#ad3e64b049578e5547fa7caa06e089cee">seek</a> (bsl::size_t offset)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#ad4e9133aba295aeb86e7411d78d1be8b">setInputLimit</a> (int limit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#afa13e4d8ac53a85f6d40149aa4b3c0f0">setQuiet</a> (bool flagValue)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#adf8d11869a7276e1f81a3ec17512b4d0">getInt64</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a19aead66ea55a35b3dfb6561ff1401be">getUint64</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a0eddae73aa61677af7b91a5badde5e82">getInt56</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a80eb3621d01cba2c294948e034536de9">getUint56</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#ae61760f29fe754ee1f0594a575e0589f">getInt48</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a7c1b15ec7958554dadfbe09485f60795">getUint48</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#afae7933bdcc2030296d58de16856048a">getInt40</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a3504edef047e10f7ed87385bb2e9c4f4">getUint40</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a5d446409945e550aedc68c23e04e6f95">getInt32</a> (int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a98c1b0bfeafd2e44df0b29ca0f829cd4">getUint32</a> (unsigned int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#af452f651f3bd43ce42e1e685d2372631">getInt24</a> (int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#afed3f41cf2397a70980d3e9fbf5643e1">getUint24</a> (unsigned int &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#aeab581ede8b61bc696557ccfdfb7373a">getInt16</a> (short &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a51293b38a68769655d874c4421563adf">getUint16</a> (unsigned short &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a151624625c68c6b5f5824f1abfa4afe1">getInt8</a> (char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#adaf5bd1282247e02f367c406707d3c01">getInt8</a> (signed char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a96ea73541be60fed5940b52da4310431">getUint8</a> (char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#afadd4acfc6242cc3105f833029c2059b">getUint8</a> (unsigned char &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a333760498aaf6b464a18441eab706114">getFloat64</a> (double &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a6cd2550f6990a931c90b5a6b9201686e">getFloat32</a> (float &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a38b01ede285238268197d23ecb13741c">getString</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;variable)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#ada4a217beab328a79cd062fa18e3f7e6">getArrayInt64</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#aab1cc2470db83c21d1984311397c5241">getArrayUint64</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#aa562a71892bffdcd9d100bdc6cc7ced3">getArrayInt56</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#ac1dba9ee6ac0d33fa8fd0f17f7ca97db">getArrayUint56</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a78f9a49a43034b8cd378750b027bfb79">getArrayInt48</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#af480c2245ac4c8c39eeb999c06d0c52f">getArrayUint48</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#af49c0f32c0caae72e7fab9438fee533a">getArrayInt40</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a889a6b30a2c0543b92526e56f3367ebb">getArrayUint40</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a634d1c199ec9fa78515debe019e51d2b">getArrayInt32</a> (int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a111a9714ee9ee502fbb92f74b6797ce5">getArrayUint32</a> (unsigned int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#af0c6c3e435ee7a1d01ae6e7524200889">getArrayInt24</a> (int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#ac1f28c79ba593a1ad8f459096198ca06">getArrayUint24</a> (unsigned int *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#aebcda85cc648fa91c6f55831711ff357">getArrayInt16</a> (short *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#af0318c3f3635d456c1107901b03bc91a">getArrayUint16</a> (unsigned short *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a2262be98066e68107dfe19de6c6fd76d">getArrayInt8</a> (char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a375e4221b10edeb2cddfcf723ab4373a">getArrayInt8</a> (signed char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#aae700781d68810d75e39e85678f30002">getArrayUint8</a> (char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#af10f2c1013b222a41090b004b5cde339">getArrayUint8</a> (unsigned char *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a668413ce6cd3d2640641cbf76fa41783">getArrayFloat64</a> (double *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a046e60c3ee83e887fd554fe9af6306cb">getArrayFloat32</a> (float *variables, int numVariables)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#ae2b932bbac03ab75ce0aab3b2dbb6d9c">operator const void *</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a124ace6f584b858e1aaa7dfc229fd9cb">cursor</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a4690c360643bd03239214e9a67e491e8">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#ac3d3965f6d428191409b43df58c4e825">inputLimit</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a1459f5cb18e4829ceb1f4a312ef72d76">isEmpty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a3d45aface8244b0d22ea3f4b879120a4">isQuiet</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a87d3b2a5d22c0c20745d160094f3c55b">isValid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a21dc3694a9461b076658ca107df2cb91">length</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslx_1_1TestInStream.html#a0e83ff50708b4c8b21cc90798b1785c4">operator&lt;&lt;</a> (bsl::ostream &amp;, const <a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides input methods to unexternalize values, and C-style arrays of values, of fundamental types from their byte representations. Each input method also verifies the input value type. By default, if invalid data is detected, error messages are displayed on <code>stdout</code>; this error reporting may be disabled via the <code>setQuiet</code> method. Note that attempting to read beyond the end of a stream will automatically invalidate the stream. See the <code>bslx</code> package-level documentation for the definition of the BDEX <code>InStream</code> protocol. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acce77d0485b63f9f7dab0619414081ab"></a><!-- doxytag: member="bslx::TestInStream::TestInStream" ref="acce77d0485b63f9f7dab0619414081ab" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestInStream::TestInStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty test input stream. Note that the constructed object is useless until a buffer is set with the <code>reset</code> method. </p>

</div>
</div>
<a class="anchor" id="a720b8e018d740d3332c11975e38fb104"></a><!-- doxytag: member="bslx::TestInStream::TestInStream" ref="a720b8e018d740d3332c11975e38fb104" args="(const char *buffer, bsl::size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestInStream::TestInStream </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a test input stream containing the specified initial <code>numBytes</code> from the specified <code>buffer</code>. The behavior is undefined unless <code>0 == numBytes</code> if <code>0 == buffer</code>. </p>

</div>
</div>
<a class="anchor" id="a02792a9fcd184184c8efe9e87fec03a0"></a><!-- doxytag: member="bslx::TestInStream::TestInStream" ref="a02792a9fcd184184c8efe9e87fec03a0" args="(const bslstl::StringRef &amp;srcData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestInStream::TestInStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcData</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a test input stream containing the specified <code>srcData</code>. </p>

</div>
</div>
<a class="anchor" id="a911835733568a5b51fe7ba4cf4ef81de"></a><!-- doxytag: member="bslx::TestInStream::~TestInStream" ref="a911835733568a5b51fe7ba4cf4ef81de" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestInStream::~TestInStream </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this test input stream. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa0179fe7efb0289925b07cce6eadf0c8"></a><!-- doxytag: member="bslx::TestInStream::getLength" ref="aa0179fe7efb0289925b07cce6eadf0c8" args="(int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getLength </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 8-bit unsigned integer or 32-bit signed integer value representing a length (see the <code>bslx</code> package-level documentation) into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. Consume an 8-bit unsigned integer if the most significant bit of this byte is 0, otherwise consume a 32-bit signed integer and set the most significant bit to zero in the resultant <code>variable</code>. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a7b63cc0c642729a51c6f52f0bdd3eb01"></a><!-- doxytag: member="bslx::TestInStream::getVersion" ref="a7b63cc0c642729a51c6f52f0bdd3eb01" args="(int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getVersion </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 8-bit unsigned integer value representing a version (see the <code>bslx</code> package-level documentation) into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a6abd2ade531583b6cd60c95134793982"></a><!-- doxytag: member="bslx::TestInStream::invalidate" ref="a6abd2ade531583b6cd60c95134793982" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestInStream::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put this input stream in an invalid state. This function has no effect if this stream is already invalid. Note that this function should be called whenever a value extracted from this stream is determined to be invalid, inconsistent, or otherwise incorrect. </p>

</div>
</div>
<a class="anchor" id="a15d9f118faa0f50a41e1ae5d901d1318"></a><!-- doxytag: member="bslx::TestInStream::reset" ref="a15d9f118faa0f50a41e1ae5d901d1318" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestInStream::reset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the index of the next byte to be extracted from this stream to 0 (i.e., the beginning of the stream) and validate this stream if it is currently invalid. </p>

</div>
</div>
<a class="anchor" id="acb9666d532a16f1a427e42b65231eaf6"></a><!-- doxytag: member="bslx::TestInStream::reset" ref="acb9666d532a16f1a427e42b65231eaf6" args="(const char *buffer, bsl::size_t numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestInStream::reset </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this stream to extract from the specified <code>buffer</code> containing the specified <code>numBytes</code>, set the index of the next byte to be extracted to 0 (i.e., the beginning of the stream), and validate this stream if it is currently invalid. The behavior is undefined unless <code>0 == numBytes</code> if <code>0 == buffer</code>. </p>

</div>
</div>
<a class="anchor" id="a5558d85d074716136a8dcb3dd3de2b7d"></a><!-- doxytag: member="bslx::TestInStream::reset" ref="a5558d85d074716136a8dcb3dd3de2b7d" args="(const bslstl::StringRef &amp;srcData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestInStream::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>srcData</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset this stream to extract from the specified <code>srcData</code>, set the index of the next byte to be extracted to 0 (i.e., the beginning of the stream), and validate this stream if it is currently invalid. </p>

</div>
</div>
<a class="anchor" id="ad3e64b049578e5547fa7caa06e089cee"></a><!-- doxytag: member="bslx::TestInStream::seek" ref="ad3e64b049578e5547fa7caa06e089cee" args="(bsl::size_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestInStream::seek </td>
          <td>(</td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>offset</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the index of the next byte to be extracted from this stream to the specified <code>offset</code> from the beginning of the stream, and validate this stream if it is currently invalid. The behavior is undefined unless <code>offset &lt;= <a class="el" href="classbslx_1_1TestInStream.html#a21dc3694a9461b076658ca107df2cb91">length()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ad4e9133aba295aeb86e7411d78d1be8b"></a><!-- doxytag: member="bslx::TestInStream::setInputLimit" ref="ad4e9133aba295aeb86e7411d78d1be8b" args="(int limit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestInStream::setInputLimit </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>limit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the number of input operations allowed on this stream to the specified <code>limit</code> before an exception is thrown. If <code>limit</code> is less than 0, no exception is to be thrown. By default, no exception is scheduled. </p>

</div>
</div>
<a class="anchor" id="afa13e4d8ac53a85f6d40149aa4b3c0f0"></a><!-- doxytag: member="bslx::TestInStream::setQuiet" ref="afa13e4d8ac53a85f6d40149aa4b3c0f0" args="(bool flagValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bslx::TestInStream::setQuiet </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>flagValue</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the quiet mode for this test stream to the specified (boolean) <code>flagValue</code>. If <code>flagValue</code> is <code>true</code>, then quiet mode is turned ON and no error messages will be written to standard output. If <code>flagValue</code> is <code>false</code>, then quiet mode is turned OFF. Note that quiet mode is turned OFF by default. </p>

</div>
</div>
<a class="anchor" id="adf8d11869a7276e1f81a3ec17512b4d0"></a><!-- doxytag: member="bslx::TestInStream::getInt64" ref="adf8d11869a7276e1f81a3ec17512b4d0" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 64-bit signed integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a19aead66ea55a35b3dfb6561ff1401be"></a><!-- doxytag: member="bslx::TestInStream::getUint64" ref="a19aead66ea55a35b3dfb6561ff1401be" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 64-bit unsigned integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a0eddae73aa61677af7b91a5badde5e82"></a><!-- doxytag: member="bslx::TestInStream::getInt56" ref="a0eddae73aa61677af7b91a5badde5e82" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 56-bit signed integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a80eb3621d01cba2c294948e034536de9"></a><!-- doxytag: member="bslx::TestInStream::getUint56" ref="a80eb3621d01cba2c294948e034536de9" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 56-bit unsigned integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="ae61760f29fe754ee1f0594a575e0589f"></a><!-- doxytag: member="bslx::TestInStream::getInt48" ref="ae61760f29fe754ee1f0594a575e0589f" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 48-bit signed integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a7c1b15ec7958554dadfbe09485f60795"></a><!-- doxytag: member="bslx::TestInStream::getUint48" ref="a7c1b15ec7958554dadfbe09485f60795" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 48-bit unsigned integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="afae7933bdcc2030296d58de16856048a"></a><!-- doxytag: member="bslx::TestInStream::getInt40" ref="afae7933bdcc2030296d58de16856048a" args="(bsls::Types::Int64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 40-bit signed integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a3504edef047e10f7ed87385bb2e9c4f4"></a><!-- doxytag: member="bslx::TestInStream::getUint40" ref="a3504edef047e10f7ed87385bb2e9c4f4" args="(bsls::Types::Uint64 &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 40-bit unsigned integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a5d446409945e550aedc68c23e04e6f95"></a><!-- doxytag: member="bslx::TestInStream::getInt32" ref="a5d446409945e550aedc68c23e04e6f95" args="(int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt32 </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 32-bit signed integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a98c1b0bfeafd2e44df0b29ca0f829cd4"></a><!-- doxytag: member="bslx::TestInStream::getUint32" ref="a98c1b0bfeafd2e44df0b29ca0f829cd4" args="(unsigned int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 32-bit unsigned integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="af452f651f3bd43ce42e1e685d2372631"></a><!-- doxytag: member="bslx::TestInStream::getInt24" ref="af452f651f3bd43ce42e1e685d2372631" args="(int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt24 </td>
          <td>(</td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 24-bit signed integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="afed3f41cf2397a70980d3e9fbf5643e1"></a><!-- doxytag: member="bslx::TestInStream::getUint24" ref="afed3f41cf2397a70980d3e9fbf5643e1" args="(unsigned int &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 24-bit unsigned integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="aeab581ede8b61bc696557ccfdfb7373a"></a><!-- doxytag: member="bslx::TestInStream::getInt16" ref="aeab581ede8b61bc696557ccfdfb7373a" args="(short &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt16 </td>
          <td>(</td>
          <td class="paramtype">short &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 16-bit signed integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a51293b38a68769655d874c4421563adf"></a><!-- doxytag: member="bslx::TestInStream::getUint16" ref="a51293b38a68769655d874c4421563adf" args="(unsigned short &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 16-bit unsigned integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a151624625c68c6b5f5824f1abfa4afe1"></a><!-- doxytag: member="bslx::TestInStream::getInt8" ref="a151624625c68c6b5f5824f1abfa4afe1" args="(char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt8 </td>
          <td>(</td>
          <td class="paramtype">char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adaf5bd1282247e02f367c406707d3c01"></a><!-- doxytag: member="bslx::TestInStream::getInt8" ref="adaf5bd1282247e02f367c406707d3c01" args="(signed char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getInt8 </td>
          <td>(</td>
          <td class="paramtype">signed char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 8-bit signed integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a96ea73541be60fed5940b52da4310431"></a><!-- doxytag: member="bslx::TestInStream::getUint8" ref="a96ea73541be60fed5940b52da4310431" args="(char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint8 </td>
          <td>(</td>
          <td class="paramtype">char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afadd4acfc6242cc3105f833029c2059b"></a><!-- doxytag: member="bslx::TestInStream::getUint8" ref="afadd4acfc6242cc3105f833029c2059b" args="(unsigned char &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getUint8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 8-bit unsigned integer value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="a333760498aaf6b464a18441eab706114"></a><!-- doxytag: member="bslx::TestInStream::getFloat64" ref="a333760498aaf6b464a18441eab706114" args="(double &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getFloat64 </td>
          <td>(</td>
          <td class="paramtype">double &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that IEEE double-precision (8-byte) floating-point value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="a6cd2550f6990a931c90b5a6b9201686e"></a><!-- doxytag: member="bslx::TestInStream::getFloat32" ref="a6cd2550f6990a931c90b5a6b9201686e" args="(float &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getFloat32 </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that IEEE single-precision (4-byte) floating-point value into the specified <code>variable</code> if its type is appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variable</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="a38b01ede285238268197d23ecb13741c"></a><!-- doxytag: member="bslx::TestInStream::getString" ref="a38b01ede285238268197d23ecb13741c" args="(bsl::string &amp;variable)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume a string from this input stream, assign that value to the specified <code>variable</code>, update the cursor location, and return a reference to this stream. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variable</code> is undefined. The string must be prefaced by a non-negative integer indicating the number of characters composing the string. The behavior is undefined unless the length indicator is non-negative. </p>

</div>
</div>
<a class="anchor" id="ada4a217beab328a79cd062fa18e3f7e6"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt64" ref="ada4a217beab328a79cd062fa18e3f7e6" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 64-bit signed integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="aab1cc2470db83c21d1984311397c5241"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint64" ref="aab1cc2470db83c21d1984311397c5241" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 64-bit unsigned integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="aa562a71892bffdcd9d100bdc6cc7ced3"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt56" ref="aa562a71892bffdcd9d100bdc6cc7ced3" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 56-bit signed integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="ac1dba9ee6ac0d33fa8fd0f17f7ca97db"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint56" ref="ac1dba9ee6ac0d33fa8fd0f17f7ca97db" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint56 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 56-bit unsigned integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="a78f9a49a43034b8cd378750b027bfb79"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt48" ref="a78f9a49a43034b8cd378750b027bfb79" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 48-bit signed integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="af480c2245ac4c8c39eeb999c06d0c52f"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint48" ref="af480c2245ac4c8c39eeb999c06d0c52f" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint48 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 48-bit unsigned integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="af49c0f32c0caae72e7fab9438fee533a"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt40" ref="af49c0f32c0caae72e7fab9438fee533a" args="(bsls::Types::Int64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 40-bit signed integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="a889a6b30a2c0543b92526e56f3367ebb"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint40" ref="a889a6b30a2c0543b92526e56f3367ebb" args="(bsls::Types::Uint64 *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint40 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 40-bit unsigned integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="a634d1c199ec9fa78515debe019e51d2b"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt32" ref="a634d1c199ec9fa78515debe019e51d2b" args="(int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt32 </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 32-bit signed integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="a111a9714ee9ee502fbb92f74b6797ce5"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint32" ref="a111a9714ee9ee502fbb92f74b6797ce5" args="(unsigned int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint32 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 32-bit unsigned integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="af0c6c3e435ee7a1d01ae6e7524200889"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt24" ref="af0c6c3e435ee7a1d01ae6e7524200889" args="(int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt24 </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 24-bit signed integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="ac1f28c79ba593a1ad8f459096198ca06"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint24" ref="ac1f28c79ba593a1ad8f459096198ca06" args="(unsigned int *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint24 </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 24-bit unsigned integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="aebcda85cc648fa91c6f55831711ff357"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt16" ref="aebcda85cc648fa91c6f55831711ff357" args="(short *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt16 </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 16-bit signed integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="af0318c3f3635d456c1107901b03bc91a"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint16" ref="af0318c3f3635d456c1107901b03bc91a" args="(unsigned short *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint16 </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 16-bit unsigned integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="a2262be98066e68107dfe19de6c6fd76d"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt8" ref="a2262be98066e68107dfe19de6c6fd76d" args="(char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a375e4221b10edeb2cddfcf723ab4373a"></a><!-- doxytag: member="bslx::TestInStream::getArrayInt8" ref="a375e4221b10edeb2cddfcf723ab4373a" args="(signed char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayInt8 </td>
          <td>(</td>
          <td class="paramtype">signed char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 8-bit signed integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="aae700781d68810d75e39e85678f30002"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint8" ref="aae700781d68810d75e39e85678f30002" args="(char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af10f2c1013b222a41090b004b5cde339"></a><!-- doxytag: member="bslx::TestInStream::getArrayUint8" ref="af10f2c1013b222a41090b004b5cde339" args="(unsigned char *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayUint8 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that 8-bit unsigned integer array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. </p>

</div>
</div>
<a class="anchor" id="a668413ce6cd3d2640641cbf76fa41783"></a><!-- doxytag: member="bslx::TestInStream::getArrayFloat64" ref="a668413ce6cd3d2640641cbf76fa41783" args="(double *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayFloat64 </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that IEEE double-precision (8-byte) floating-point array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="a046e60c3ee83e887fd554fe9af6306cb"></a><!-- doxytag: member="bslx::TestInStream::getArrayFloat32" ref="a046e60c3ee83e887fd554fe9af6306cb" args="(float *variables, int numVariables)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a>&amp; bslx::TestInStream::getArrayFloat32 </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>variables</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVariables</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>If required, throw a <code><a class="el" href="classbslx_1_1TestInStreamException.html">TestInStreamException</a></code> (see <code>throwExceptionIfInputLimitExhausted</code>); otherwise, consume the 8-bit unsigned integer type code, verify the type of the next value in this stream, consume that IEEE single-precision (4-byte) floating-point array value into the specified <code>variables</code> of the specified <code>numVariables</code> if its type and length are appropriate, update the cursor location, and return a reference to this stream. If the type is incorrect, then this stream is marked invalid and the value of <code>variables</code> is unchanged. If this stream is initially invalid, this operation has no effect. If this function otherwise fails to extract a valid value, this stream is marked invalid and the value of <code>variables</code> is undefined. The behavior is undefined unless <code>0 &lt;= numVariables</code> and <code>variables</code> has sufficient capacity. Note that for non-conforming platforms, this operation may be lossy. </p>

</div>
</div>
<a class="anchor" id="ae2b932bbac03ab75ce0aab3b2dbb6d9c"></a><!-- doxytag: member="bslx::TestInStream::operator const void *" ref="ae2b932bbac03ab75ce0aab3b2dbb6d9c" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bslx::TestInStream::operator const void * </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-zero value if this stream is valid, and 0 otherwise. An invalid stream is a stream for which an input operation was detected to have failed. </p>

</div>
</div>
<a class="anchor" id="a124ace6f584b858e1aaa7dfc229fd9cb"></a><!-- doxytag: member="bslx::TestInStream::cursor" ref="a124ace6f584b858e1aaa7dfc229fd9cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::size_t bslx::TestInStream::cursor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the next byte to be extracted from this stream. </p>

</div>
</div>
<a class="anchor" id="a4690c360643bd03239214e9a67e491e8"></a><!-- doxytag: member="bslx::TestInStream::data" ref="a4690c360643bd03239214e9a67e491e8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* bslx::TestInStream::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the contiguous, non-modifiable external memory buffer of this stream. The behavior of accessing elements outside the range <code>[ <a class="el" href="classbslx_1_1TestInStream.html#a4690c360643bd03239214e9a67e491e8">data()</a> .. <a class="el" href="classbslx_1_1TestInStream.html#a4690c360643bd03239214e9a67e491e8">data()</a> + (<a class="el" href="classbslx_1_1TestInStream.html#a21dc3694a9461b076658ca107df2cb91">length()</a> - 1) ]</code> is undefined. </p>

</div>
</div>
<a class="anchor" id="ac3d3965f6d428191409b43df58c4e825"></a><!-- doxytag: member="bslx::TestInStream::inputLimit" ref="ac3d3965f6d428191409b43df58c4e825" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bslx::TestInStream::inputLimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the current number of input requests left before an exception is thrown. A negative value indicates that no exception is scheduled. </p>

</div>
</div>
<a class="anchor" id="a1459f5cb18e4829ceb1f4a312ef72d76"></a><!-- doxytag: member="bslx::TestInStream::isEmpty" ref="a1459f5cb18e4829ceb1f4a312ef72d76" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslx::TestInStream::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stream is empty, and <code>false</code> otherwise. Note that this function enables higher-level types to verify that, after successfully reading all expected data, no data remains. </p>

</div>
</div>
<a class="anchor" id="a3d45aface8244b0d22ea3f4b879120a4"></a><!-- doxytag: member="bslx::TestInStream::isQuiet" ref="a3d45aface8244b0d22ea3f4b879120a4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslx::TestInStream::isQuiet </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stream's quiet mode is ON, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a87d3b2a5d22c0c20745d160094f3c55b"></a><!-- doxytag: member="bslx::TestInStream::isValid" ref="a87d3b2a5d22c0c20745d160094f3c55b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bslx::TestInStream::isValid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stream is valid, and <code>false</code> otherwise. An invalid stream is a stream in which insufficient or invalid data was detected during an extraction operation. Note that an empty stream will be valid unless an extraction attempt or explicit invalidation causes it to be otherwise. </p>

</div>
</div>
<a class="anchor" id="a21dc3694a9461b076658ca107df2cb91"></a><!-- doxytag: member="bslx::TestInStream::length" ref="a21dc3694a9461b076658ca107df2cb91" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::size_t bslx::TestInStream::length </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of bytes stored in the external memory buffer. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a0e83ff50708b4c8b21cc90798b1785c4"></a><!-- doxytag: member="bslx::TestInStream::operator&lt;&lt;" ref="a0e83ff50708b4c8b21cc90798b1785c4" args="(bsl::ostream &amp;, const TestInStream &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslx_1_1TestInStream.html">TestInStream</a> &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>object</code> to the specified output <code>stream</code> in some reasonable (multi-line) format, and return a reference to <code>stream</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslx__testinstream_8h_source.html">bslx_testinstream.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:12 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
