<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslstl_bitset.h                                                    -*-C++-*-
#ifndef INCLUDED_BSLSTL_BITSET
#define INCLUDED_BSLSTL_BITSET

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an STL-compliant bitset class.
//
//@CLASSES:
//  bsl::bitset: STL-compatible bitset template
//
//@SEE_ALSO: bsl+stdhdrs
//
//@DESCRIPTION: This component is for internal use only.  Please include
// &#39;&lt;bsl_bitset.h&gt;&#39; instead and use &#39;bsl::bitset&#39; directly.  This component
// implements a static bitset class that is suitable for use as an
// implementation of the &#39;std::bitset&#39; class template.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Determining if a Number is Prime (Sieve of Eratosthenes)
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to write a function to determine whether or not a given
// number is prime.  One way to implement this function is by using what&#39;s
// called the Sieve of Eratosthenes.  The basic idea of this algorithm is to
// repeatedly walk the sequence of integer values and mark any numbers up to
// and including the particular value of interest that are integer multiples of
// first 2, then 3, then 5, etc. (skipping 4 because it was previously marked
// when we walked the sequence by 2&#39;s).  Once we have walked the sequence
// with all primes up to and including the square root of the number of
// interest, we check to see if that number has been marked: If it has, it&#39;s
// composite; otherwise it&#39;s prime.
//
// When implementing this classic algorithm, we need an efficient way of
// representing a flag for each potential prime number.  The following
// illustrates how we can use &#39;bsl::bitset&#39; to accomplish this result, provided
// we know an upper bound on supplied candidate values at compile time.
//
// First, we begin to define a function template that will determine whether or
// not a given candidate value is prime:
//..
//  template &lt;unsigned int MAX_VALUE&gt;
//  bool isPrime(int candidate)
//      // Return &#39;true&#39; if the specified &#39;candidate&#39; value is a prime number,
//      // and &#39;false&#39; otherwise.  The behavior is undefined unless
//      // &#39;2 &lt;= candidate &lt;= MAX_VALUE&#39;
//  {
//      BSLMF_ASSERT(2 &lt;= MAX_VALUE);
//      BSLS_ASSERT(2 &lt;= candidate); BSLS_ASSERT(candidate &lt;= MAX_VALUE);
//..
// Then, we declare a &#39;bsl::bitset&#39;, &#39;compositeFlags&#39;, that will contain flags
// indicating whether a value corresponding to a given index is known to be
// composite (&#39;true&#39;) or is still potentially prime (&#39;false&#39;) up to and
// including the compile-time constant template parameter, &#39;MAX_VALUE&#39;.
//..
//      // Candidate primes in the &#39;[2 .. MAX_VALUE]&#39; range.
//
//      bsl::bitset&lt;MAX_VALUE + 1&gt; compositeFlags;
//..
// Next, we observe that a default-constructed &#39;bsl::bitset&#39; has no flags set,
// We can check this by asserting that the &#39;none&#39; method returns true, by
// asserting that the &#39;any&#39; method returns false, or by asserting that the
// &#39;count&#39; of set bits is 0:
//..
//      assert(true  == compositeFlags.none());
//      assert(false == compositeFlags.any());
//      assert(0     == compositeFlags.count());
//..
// Then, we note that a &#39;bsl::bitset&#39; has a fixed &#39;size&#39; (the set can&#39;t be
// grown or shrunk) and verify that &#39;size&#39; is the same as the template
// argument used to create the &#39;bsl::bitset&#39;:
//..
//      assert(MAX_VALUE + 1 == compositeFlags.size());
//..
// Next, we compute &#39;sqrt(candidate)&#39;, which is as far as we need to look:
//..
//      // We need to cast the &#39;sqrt&#39; argument to avoid an overload ambiguity.
//      const int sqrtOfCandidate = std::sqrt(static_cast&lt;double&gt;(candidate))
//                                + 0.01;  // fudge factor
//..
// Now, we loop from 2 to &#39;sqrtOfCandidate&#39;, and use the sieve algorithm to
// eliminate non-primes:
//..
//      // Note that we treat &#39;false&#39; values as potential primes,
//      // since that is how &#39;bsl::bitset&#39; is default-initialized.
//
//      for (std::size_t i = 2; i &lt;= sqrtOfCandidate; ++i) {
//          if (compositeFlags[i]) {
//              continue; // Skip this value: it&#39;s flagged as composite, so all
//                        // of its multiples are already flagged as composite
//                        // as well.
//          }
//
//          for (std::size_t flagValue = i;
//               flagValue &lt;= candidate;
//               flagValue += i) {
//              compositeFlags[flagValue] = true;
//          }
//
//          if (true == compositeFlags[candidate]) {
//              return false;                                         // RETURN
//          }
//      }
//
//      BSLS_ASSERT(false == compositeFlags[candidate]);
//
//      return true;
//  }
//..
// Notice that if we don&#39;t return &#39;false&#39; from the loop, none of the lower
// numbers evenly divided the candidate value; hence, it is a prime number.
//
// Finally, we can exercise our &#39;isPrime&#39; function with an upper bound of
// 10,000:
//..
//  enum { UPPER_BOUND = 10000 };
//
//  assert(1 == isPrime&lt;UPPER_BOUND&gt;(2));
//  assert(1 == isPrime&lt;UPPER_BOUND&gt;(3));
//  assert(0 == isPrime&lt;UPPER_BOUND&gt;(4));
//  assert(1 == isPrime&lt;UPPER_BOUND&gt;(5));
//  assert(0 == isPrime&lt;UPPER_BOUND&gt;(6));
//  assert(1 == isPrime&lt;UPPER_BOUND&gt;(7));
//  assert(0 == isPrime&lt;UPPER_BOUND&gt;(8));
//  assert(0 == isPrime&lt;UPPER_BOUND&gt;(9));
//  assert(0 == isPrime&lt;UPPER_BOUND&gt;(10));
//  // ...
//  assert(1 == isPrime&lt;UPPER_BOUND&gt;(9973));
//  assert(0 == isPrime&lt;UPPER_BOUND&gt;(9975));
//  assert(0 == isPrime&lt;UPPER_BOUND&gt;(10000));
//..


// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;include &lt;bsl_bitset.h&gt; instead of &lt;bslstl_bitset.h&gt; in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATOR
#include &lt;bslstl_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STDEXCEPTUTIL
#include &lt;bslstl_stdexceptutil.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_STRING
#include &lt;bslstl_string.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_BSLS_PERFORMANCEHINT
#include &lt;bsls_performancehint.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_ALGORITHM
#include &lt;algorithm&gt;    // &#39;min&#39;
#define INCLUDED_ALGORITHM
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;
#define INCLUDED_CSTDDEF
#endif

#ifndef INCLUDED_IOSFWD
#include &lt;iosfwd&gt;
#define INCLUDED_IOSFWD
#endif

#ifndef BDE_DONT_ALLOW_TRANSITIVE_INCLUDES

#ifndef INCLUDED_STDEXCEPT
#include &lt;stdexcept&gt;
#define INCLUDED_STDEXCEPT
#endif

#ifndef INCLUDED_STRING
#include &lt;string&gt;
#define INCLUDED_STRING
#endif

#endif

namespace bsl {

template &lt;std::size_t N&gt;
class bitset;

                        // =================
                        // class bsl::bitset
                        // =================

template &lt;std::size_t N&gt;
class bitset {
    // This class template provides an STL-compliant &#39;bitset&#39;.  For the
    // requirements of a &#39;bitset&#39; class, consult the second revision of the
    // ISO/IEC 14882 Programming Language c++ (2003).
    //
    // In addition to the methods defined in the standard, this class also
    // provides an extra constructor that takes a &#39;bsl::basic_string&#39;.  This
    // extra constructor provides the capability to construct a &#39;bitset&#39; from a
    // &#39;bsl::basic_string&#39;, in addition to a &#39;std::basic_string&#39;.

    // PRIVATE TYPES
    enum {
        BYTESPERINT = sizeof(int),
        BITSPERINT  = 8 * sizeof(int),
        BITSETSIZE  = N ? (N - 1) / BITSPERINT + 1 : 1
    };

    // DATA
    unsigned int d_data[BITSETSIZE];  // storage for bitset, d_data[0] holds
                                      // the least significant bit.

    // FRIENDS
    friend class reference;

  public:
    // PUBLIC TYPES
    class reference {
        // This class represents a reference to a modifiable bit inside a
        // &#39;bsl::bitset&#39;.

        // FRIENDS
        friend class bitset;

        // DATA
        unsigned int *d_int_p;   // pointer to the int inside the bitset.
        unsigned int  d_offset;  // bit offset to &#39;d_int&#39;.

        // PRIVATE CREATORS
        reference(unsigned int *i, unsigned int offset);

      public:
        // MANIPULATORS
        reference&amp; operator=(bool x);

        reference&amp; operator=(const reference&amp; x);

        reference&amp; flip();

        // ACCESSORS
        operator bool() const;

        bool operator~() const;
    };

  private:
    // PRIVATE MANIPULATORS
    template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
    void copyString(const native_std::basic_string&lt;CHAR_TYPE,
                                                   TRAITS,
                                                   ALLOCATOR&gt;&amp;           str,
                    typename native_std::basic_string&lt;CHAR_TYPE,
                                                   TRAITS,
                                                   ALLOCATOR&gt;::size_type pos,
                    typename native_std::basic_string&lt;CHAR_TYPE,
                                                   TRAITS,
                                                   ALLOCATOR&gt;::size_type n);

    template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
    void copyString(const     bsl::basic_string&lt;CHAR_TYPE,
                                                   TRAITS,
                                                   ALLOCATOR&gt;&amp;           str,
                    typename  bsl::basic_string&lt;CHAR_TYPE,
                                                   TRAITS,
                                                   ALLOCATOR&gt;::size_type pos,
                    typename  bsl::basic_string&lt;CHAR_TYPE,
                                                   TRAITS,
                                                   ALLOCATOR&gt;::size_type n);

    void clearUnusedBits();
        // Clear the bits unused by the bitset in &#39;d_data&#39;, namely, bits
        // &#39;BITSETSIZE * BITSPERINT - 1&#39; to &#39;N&#39; (where the bit count starts at
        // 0).

    void clearUnusedBits(bsl::false_type);
    void clearUnusedBits(bsl::true_type);
        // Implementations of &#39;clearUnusedBits&#39;, overloaded by whether there
        // are any unused bits.

    // PRIVATE ACCESSORS
    std::size_t numOneSet(unsigned int src) const;
        // Return the number of 1 bits in the specified &#39;src&#39;.

  public:
    // CREATORS
    bitset();
        // Create a bitset with all bits initialized to 0.

    bitset(unsigned long val);
        // Create a bitset with its first &#39;M&#39; bit positions correspond to bit
        // values in the specified &#39;val&#39;.  &#39;M&#39; is the smaller of the
        // parameterized &#39;N&#39; and &#39;8 * sizeof(unsigned long)&#39;.  If &#39;M &lt; N&#39;, the
        // remaining bit positions are initialized to 0.

    template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
    explicit
    bitset(const native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;&amp; str,
           typename native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                      size_type pos = 0);
    template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
    bitset(const native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;&amp; str,
           typename native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                      size_type pos,
           typename native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                      size_type n);
        // Create a bitset with its first &#39;M&#39; bit positions correspond to the
        // characters in the specified &#39;pos&#39; of the specified &#39;str&#39;.  &#39;M&#39; is
        // the smaller of the parameterized &#39;N&#39; and &#39;str.length()&#39;.  If
        // &#39;M &lt; N&#39;, the remaining bit positions are initialized to 0.  The
        // behavior is undefined if the characters in the specified &#39;str&#39; is
        // not &#39;0&#39; and not &#39;1&#39;.

    template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
    explicit
    bitset(const bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;&amp; str,
           typename bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                      size_type pos = 0);
    template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
    bitset(const bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;&amp; str,
           typename bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                      size_type pos,
           typename bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                      size_type n);
        // Create a bitset with its first &#39;M&#39; bit positions correspond to the
        // characters in the specified &#39;pos&#39; of the specified &#39;str&#39;.  &#39;M&#39; is
        // the smaller of the parameterized &#39;N&#39; and &#39;str.length()&#39;.  If
        // &#39;M &lt; N&#39;, the remaining bit positions are initialized to 0.  The
        // behavior is undefined if the characters in the specified &#39;str&#39; is
        // not 0 and not 1.

    // MANIPULATORS
    bitset&amp; operator&amp;=(const bitset&amp; rhs);
        // Clear each bit of this bitset for each corresponding bit that is 0
        // in the specified &#39;rhs&#39;, and leaves all other bits unchanged.  Return
        // a reference to this modifiable bitset.  Note that this is equivalent
        // to a bitwise OR.

    bitset&amp; operator|=(const bitset&amp; rhs);
        // Set each bit of this bitset for each corresponding bit that is 1 in
        // the specified &#39;rhs&#39;, and leaves all other bits unchanged.  Return a
        // reference to this modifiable bitset.  Note that this is equivalent
        // to a bitwise AND.

    bitset&amp; operator^=(const bitset&amp; rhs);
        // Toggle each bit of this bitset for each corresponding bit that is 1
        // in the specified &#39;rhs&#39;, and leaves all other bits unchanged.  Return
        // a reference to this modifiable bitset.  Note that this is equivalent
        // to a bitwise XOR.

    bitset&amp; operator&lt;&lt;=(std::size_t pos);
        // Shift the bits of this bitset left (towards the most significant
        // bit) by the specified &#39;pos&#39; and return a reference to this
        // modifiable bitset.  For all bits with position I where &#39;I &lt;= pos&#39;,
        // the new value is 0.  The behavior is undefined unless &#39;pos &lt;= N&#39;.

    bitset&amp; operator&gt;&gt;=(std::size_t pos);
        // Shift the bits of this bitset right (towards the least significant
        // bit) by the specified &#39;pos&#39; and return a reference to this
        // modifiable bitset.  For all bits with position I where
        // &#39;I &gt; N - pos&#39;, the new value is 0.  The behavior is undefined unless
        // &#39;pos &lt;= N&#39;.

    bitset&amp; flip();
        // Toggle all bits of this bitset and return a reference to this
        // modifiable bitset.

    bitset&amp; flip(std::size_t pos);
        // Toggle the bit at the specified &#39;pos&#39; of this bitset and return a
        // reference to this modifiable bitset.

    bitset&amp; reset();
        // Set all bits of this bitset to 0 and return a reference to this
        // modifiable bitset.

    bitset&amp; reset(std::size_t pos);
        // Set the bit at the specified &#39;pos&#39; of this bitset to 0 and return a
        // reference to this modifiable bitset.

    bitset&amp; set();
        // Set all bits of this bitset to 1 and return a reference to this
        // modifiable bitset.

    bitset&amp; set(std::size_t pos, int val = true);
        // Set the bit at the specified &#39;pos&#39; of this bitset to 1 and return a
        // reference to this modifiable bitset.  Optionally specify &#39;val&#39; as
        // the value to set the bit.  If &#39;val&#39; is non-zero, the bit is set to
        // 1, otherwise the bit is set to 0.

    reference operator[](std::size_t pos);
        // Return a &#39;reference&#39; to the modifiable bit position at the specified
        // &#39;pos&#39;.

    // ACCESSORS
    bitset operator&lt;&lt;(std::size_t pos) const;
        // Return a bitset constructed from shifting this bitset left by the
        // specified &#39;pos&#39;.

    bitset operator&gt;&gt;(std::size_t pos) const;
        // Return a bitset constructed from shifting this bitset right by the
        // specified &#39;pos&#39;.

    bitset operator~() const;
        // Toggle all bits of this bitset and return a reference to this
        // modifiable bitset.

    template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
    basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt; to_string() const;
        // Return a &#39;basic_string&#39; representation of this bitset, where bit
        // value 1 is represented with &#39;1&#39; and bit value 0 is represented with
        // &#39;0&#39;.  The most-significant bit is placed at the beginning of the
        // string, and the least-significant bit is placed at the end of the
        // string.

    bool operator[](std::size_t pos) const;
        // Return the value of the bit position at the specified &#39;pos&#39;.

    bool operator==(const bitset&amp; rhs) const;
        // Return &#39;true&#39; if the specified &#39;rhs&#39; has the same value as this
        // bitset and &#39;false&#39; otherwise.  Two bitsets have the same value when
        // the sequence and value of bits they hold are the same.

    bool operator!=(const bitset&amp; rhs) const;
        // Return &#39;true&#39; if the specified &#39;rhs&#39; do not have the same value as
        // this bitset and &#39;false&#39; otherwise.  Two bitset do not have the same
        // value when either the sequence or the value of bits they hold are
        // not the same.

    bool any() const;
        // Return &#39;true&#39; if any of the bits in this bitset has the value of 1
        // and &#39;false&#39; otherwise.

    bool none() const;
        // Return &#39;true&#39; if all the bits in this bitset has the value of 0 and
        // &#39;false&#39; otherwise.

    std::size_t size() const;
        // Return the number of bits this bitset holds.

    std::size_t count() const;
        // Return the number of bits in this bitset that have the value of 1.

    bool test(size_t pos) const;
        // Return &#39;true&#39; if the bit at the specified &#39;pos&#39; has the value of 1
        // and &#39;false&#39; otherwise.

    unsigned long to_ulong() const;
        // Return an &#39;unsigned&#39; &#39;long&#39; value that has the same bit value as the
        // bitset.  Note that the behavior is undefined if the bitset cannot be
        // represented as an &#39;unsigned&#39; &#39;long&#39;.
};

// FREE OPERATORS
template &lt;std::size_t N&gt;
bitset&lt;N&gt; operator&amp;(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs);
    // Return a &#39;bitset&#39; that results from a bitwise AND of the specified &#39;lhs&#39;
    // and &#39;rhs&#39;.

template &lt;std::size_t N&gt;
bitset&lt;N&gt; operator|(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs);
    // Return a &#39;bitset&#39; that results from a bitwise OR of the specified &#39;lhs&#39;
    // and &#39;rhs&#39;.

template &lt;std::size_t N&gt;
bitset&lt;N&gt; operator^(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs);
    // Return a &#39;bitset&#39; that results from a bitwise XOR of the specified &#39;lhs&#39;
    // and &#39;rhs&#39;.

template &lt;class CHAR_TYPE, class TRAITS, std::size_t N&gt;
std::basic_istream&lt;CHAR_TYPE, TRAITS&gt;&amp;
operator&gt;&gt;(std::basic_istream&lt;CHAR_TYPE, TRAITS&gt;&amp; is, bitset&lt;N&gt;&amp; x);

template &lt;class CHAR_TYPE, class TRAITS, std::size_t N&gt;
std::basic_ostream&lt;CHAR_TYPE, TRAITS&gt;&amp;
operator&lt;&lt;(std::basic_ostream&lt;CHAR_TYPE, TRAITS&gt;&amp; os, const bitset&lt;N&gt;&amp; x);

// ============================================================================
//                   INLINE AND TEMPLATE FUNCTION DEFINITIONS
// ============================================================================

                        // -----------------------
                        // class bitset::reference
                        // -----------------------

// PRIVATE CREATORS
template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt;::reference::reference(unsigned int *i, unsigned int offset)
: d_int_p(i)
, d_offset(offset)
{
    BSLS_ASSERT_SAFE(d_int_p);
}

// MANIPULATORS
template &lt;std::size_t N&gt;
inline
typename bitset&lt;N&gt;::reference&amp;
bitset&lt;N&gt;::reference::operator=(bool x)
{
    if (x) {
        *d_int_p |= (1 &lt;&lt; d_offset);
    }
    else {
        *d_int_p &amp;= ~(1 &lt;&lt; d_offset);
    }
    return *this;
}

template &lt;std::size_t N&gt;
inline
typename bitset&lt;N&gt;::reference&amp;
bitset&lt;N&gt;::reference::operator=(const reference&amp; x)
{
    if (x) {
        *d_int_p |= (1 &lt;&lt; d_offset);
    }
    else {
        *d_int_p &amp;= ~(1 &lt;&lt; d_offset);
    }
    return *this;
}

template &lt;std::size_t N&gt;
inline
typename bitset&lt;N&gt;::reference&amp;
bitset&lt;N&gt;::reference::flip()
{
    *d_int_p ^= (1 &lt;&lt; d_offset);
    return *this;
}

// ACCESSORS
template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt;::reference::operator bool() const
{
    return ((*d_int_p &amp; (1 &lt;&lt; d_offset)) != 0);
}

template &lt;std::size_t N&gt;
inline
bool bitset&lt;N&gt;::reference::operator~() const
{
    return ((*d_int_p &amp; (1 &lt;&lt; d_offset)) == 0);
}

                        // ------------
                        // class bitset
                        // ------------

// PRIVATE MANIPULATORS
template &lt;std::size_t N&gt;
template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
void bitset&lt;N&gt;::copyString(const native_std::basic_string&lt;CHAR_TYPE,
                                               TRAITS,
                                               ALLOCATOR&gt;&amp;           str,
                typename native_std::basic_string&lt;CHAR_TYPE,
                                               TRAITS,
                                               ALLOCATOR&gt;::size_type pos,
                typename native_std::basic_string&lt;CHAR_TYPE,
                                               TRAITS,
                                               ALLOCATOR&gt;::size_type n)
{
    typedef typename native_std::basic_string&lt;CHAR_TYPE,
                                               TRAITS,
                                               ALLOCATOR&gt;::size_type size_type;
    n = std::min(N, std::min(n, str.size() - pos));
    for (size_type i = 0; i &lt; n; ++i) {
        typename TRAITS::int_type bit = TRAITS::to_int_type(
                                                        str[pos + n  - i - 1]);

        if (bit == &#39;1&#39;) {
            set(i);
        }
        else if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(bit != &#39;0&#39;)) {
            BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
            BloombergLP::bslstl::StdExceptUtil::throwInvalidArgument(
                                             &quot;string for bitset constructor &quot;
                                             &quot;must be &#39;0&#39; or &#39;1&#39;&quot;);
        }
    }
}

template &lt;std::size_t N&gt;
template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
void bitset&lt;N&gt;::copyString(const bsl::basic_string&lt;CHAR_TYPE,
                                               TRAITS,
                                               ALLOCATOR&gt;&amp;           str,
                typename bsl::basic_string&lt;CHAR_TYPE,
                                              TRAITS,
                                              ALLOCATOR&gt;::size_type pos,
                typename bsl::basic_string&lt;CHAR_TYPE,
                                              TRAITS,
                                              ALLOCATOR&gt;::size_type n)
{
    typedef typename bsl::basic_string&lt;CHAR_TYPE,
                                          TRAITS,
                                          ALLOCATOR&gt;::size_type size_type;
    n = std::min(N, std::min(n, str.size() - pos));
    for (size_type i = 0; i &lt; n; ++i) {
        typename TRAITS::int_type bit = TRAITS::to_int_type(
                                                        str[pos + n  - i - 1]);

        if (bit == &#39;1&#39;) {
            set(i);
        }
        else if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(bit != &#39;0&#39;)) {
            BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
            BloombergLP::bslstl::StdExceptUtil::throwInvalidArgument(
                                             &quot;string for bitset constructor &quot;
                                             &quot;must be &#39;0&#39; or &#39;1&#39;&quot;);
        }
    }
}

template &lt;std::size_t N&gt;
inline
void bitset&lt;N&gt;::clearUnusedBits()
{
    enum { VALUE = N % BITSPERINT ? 1 : 0 };

    clearUnusedBits(bsl::integral_constant&lt;bool, VALUE&gt;());
}

template &lt;std::size_t N&gt;
inline
void bitset&lt;N&gt;::clearUnusedBits(bsl::false_type)
{
}

template &lt;std::size_t N&gt;
inline
void bitset&lt;N&gt;::clearUnusedBits(bsl::true_type)
{
    const unsigned int offset = N % BITSPERINT;  // never 0

    d_data[BITSETSIZE - 1] &amp;= ~(~((unsigned int)0) &lt;&lt; offset);
}

template &lt;std::size_t N&gt;
std::size_t bitset&lt;N&gt;::numOneSet(unsigned int src) const
{
    // The following code was taken from &#39;bdes_bitutil&#39;.
    unsigned input = src;

    // First we use a tricky way of getting every 2-bit half-nibble to
    // represent the number of bits that were set in those two bits.

    input -= (input &gt;&gt; 1) &amp; 0x55555555;

    // Henceforth, we just accumulate the sum down into lower and lower bits.

    {
        const int mask = 0x33333333;
        input = ((input &gt;&gt; 2) &amp; mask) + (input &amp; mask);
    }

    // Any 4-bit nibble is now guaranteed to be less than or equal to 8, so we
    // do not have to mask both sides of the addition.  We must mask after the
    // addition, so 8-bit bytes are the sum of bits in those 8 bits.

    input = ((input &gt;&gt; 4) + input) &amp; 0x0f0f0f0f;

    // It is no longer necessary to mask the additions, because it is
    // impossible for any bit groups to add up to more than 256 and carry, thus
    // interfering with adjacent groups.  Each 8-bit byte is independent from
    // now on.

    input = (input &gt;&gt;  8) + input;
    input = (input &gt;&gt; 16) + input;

    return input &amp; 0x000000ff;
}

// CREATORS
template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt;::bitset()
{
    std::memset(d_data, 0, BITSETSIZE * BYTESPERINT);
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt;::bitset(unsigned long val)
{
    enum {
        BSLSTL_INTS_IN_LONG = sizeof(unsigned long) / sizeof(int)
    };

    std::memset(d_data, 0, BITSETSIZE * BYTESPERINT);

    if (1 == BSLSTL_INTS_IN_LONG) {
        d_data[0] = static_cast&lt;unsigned int&gt;(val);
    }
    else {
        const unsigned int numInts = (unsigned int) BSLSTL_INTS_IN_LONG
                                                    &lt; (unsigned int) BITSETSIZE
                                     ? (unsigned int) BSLSTL_INTS_IN_LONG
                                     : (unsigned int) BITSETSIZE;

        for (unsigned int i = 0; i &lt; numInts; ++i) {
            d_data[i] = static_cast&lt;unsigned int&gt;(val &gt;&gt; (BITSPERINT * i));
        }
    }
}

template &lt;std::size_t N&gt;
template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
inline
bitset&lt;N&gt;::
bitset(const    native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;&amp; str,
       typename native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                                                              size_type pos)
{
    typedef native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt; StringType;

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(pos &gt; str.size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                                               &quot;&#39;pos &gt; str.size()&#39; for bitset &quot;
                                               &quot;constructor&quot;);
    }
    std::memset(d_data, 0, BITSETSIZE * BYTESPERINT);
    copyString(str, pos, StringType::npos);
}

template &lt;std::size_t N&gt;
template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
inline
bitset&lt;N&gt;::
bitset(const    native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;&amp; str,
       typename native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                                                              size_type pos,
       typename native_std::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                                                                size_type n)
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(pos &gt; str.size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                                               &quot;&#39;pos &gt; str.size()&#39; for bitset &quot;
                                               &quot;constructor&quot;);
    }
    std::memset(d_data, 0, BITSETSIZE * BYTESPERINT);
    copyString(str, pos, n);
}

template &lt;std::size_t N&gt;
template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
inline
bitset&lt;N&gt;::
bitset(const    bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;&amp; str,
       typename bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                                                                 size_type pos)
{
    typedef bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt; StringType;

    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(pos &gt; str.size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                                               &quot;&#39;pos &gt; str.size()&#39; for bitset &quot;
                                               &quot;constructor&quot;);
    }
    std::memset(d_data, 0, BITSETSIZE * BYTESPERINT);
    copyString(str, pos, StringType::npos);
}

template &lt;std::size_t N&gt;
template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
inline
bitset&lt;N&gt;::
bitset(const    bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;&amp; str,
       typename bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                                                                 size_type pos,
       typename bsl::basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt;::
                                                                   size_type n)

{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(pos &gt; str.size())) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                                               &quot;&#39;pos &gt; str.size()&#39; for bitset &quot;
                                               &quot;constructor&quot;);
    }
    std::memset(d_data, 0, BITSETSIZE * BYTESPERINT);
    copyString(str, pos, n);
}

// MANIPULATORS
template &lt;std::size_t N&gt;
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::operator&amp;=(const bitset&lt;N&gt;&amp; rhs)
{
    for (std::size_t i = 0; i &lt; BITSETSIZE; ++i) {
        d_data[i] &amp;= rhs.d_data[i];
    }
    return *this;
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::operator|=(const bitset&lt;N&gt;&amp; rhs)
{
    for (std::size_t i = 0; i &lt; BITSETSIZE; ++i) {
        d_data[i] |= rhs.d_data[i];
    }
    return *this;
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::operator^=(const bitset&lt;N&gt;&amp; rhs)
{
    for (std::size_t i = 0; i &lt; BITSETSIZE; ++i) {
        d_data[i] ^= rhs.d_data[i];
    }
    return *this;
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::operator&lt;&lt;=(std::size_t pos)
{
    BSLS_ASSERT_SAFE(pos &lt;= N);

    if (pos) {
        const std::size_t shift  = pos / BITSPERINT;
        const std::size_t offset = pos % BITSPERINT;

        if (shift) {
            std::memmove(d_data + shift,
                         d_data,
                         (BITSETSIZE - shift) * BYTESPERINT);
            std::memset(d_data, 0, shift * BYTESPERINT);
        }

        if (offset) {
            for (std::size_t i = BITSETSIZE - 1; i &gt; shift; --i) {
                d_data[i] = (d_data[i] &lt;&lt; offset) |
                                        (d_data[i-1] &gt;&gt; (BITSPERINT - offset));
            }
            d_data[shift] &lt;&lt;= offset;
        }

        clearUnusedBits();
    }
    return *this;
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::operator&gt;&gt;=(std::size_t pos)
{
    BSLS_ASSERT_SAFE(pos &lt;= N);

    if (pos) {
        const std::size_t shift  = pos / BITSPERINT;
        const std::size_t offset = pos % BITSPERINT;

        if (shift) {
            std::memmove(d_data,
                         d_data + shift,
                         (BITSETSIZE - shift) * BYTESPERINT);
            std::memset(d_data + BITSETSIZE - shift, 0, shift * BYTESPERINT);
        }

        if (offset) {
            for (std::size_t i = 0; i &lt; BITSETSIZE - shift - 1; ++i) {
                d_data[i] = (d_data[i] &gt;&gt; offset) |
                                        (d_data[i+1] &lt;&lt; (BITSPERINT - offset));
            }
            d_data[BITSETSIZE - shift - 1] &gt;&gt;= offset;
        }

        clearUnusedBits();
    }
    return *this;
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::flip()
{
    for (std::size_t i = 0; i &lt; BITSETSIZE; ++i) {
        d_data[i] = ~d_data[i];
    }
    clearUnusedBits();
    return *this;
}

template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::flip(std::size_t pos)
{
    BSLS_ASSERT_SAFE(pos &lt; N);

    const std::size_t shift  = pos / BITSPERINT;
    const std::size_t offset = pos % BITSPERINT;
    d_data[shift] ^= (1 &lt;&lt; offset);
    return *this;
}

template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::reset()
{
    std::memset(d_data, 0, BITSETSIZE * BYTESPERINT);
    return *this;
}

template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::reset(std::size_t pos)
{
    BSLS_ASSERT_SAFE(pos &lt; N);

    const std::size_t shift  = pos / BITSPERINT;
    const std::size_t offset = pos % BITSPERINT;
    d_data[shift] &amp;= ~(1 &lt;&lt; offset);
    return *this;
}

template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::set()
{
    std::memset(d_data, 0xFF, BITSETSIZE * BYTESPERINT);
    clearUnusedBits();
    return *this;
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt;&amp; bitset&lt;N&gt;::set(std::size_t pos, int val)
{
    BSLS_ASSERT_SAFE(pos &lt; N);

    const std::size_t shift  = pos / BITSPERINT;
    const std::size_t offset = pos % BITSPERINT;
    if (val) {
        d_data[shift] |= (1 &lt;&lt; offset);
    }
    else {
        d_data[shift] &amp;= ~(1 &lt;&lt; offset);
    }
    return *this;
}

template &lt;std::size_t N&gt;
inline
typename bitset&lt;N&gt;::reference bitset&lt;N&gt;::operator[](std::size_t pos)
{
    BSLS_ASSERT_SAFE(pos &lt; N);

    const std::size_t shift  = pos / BITSPERINT;
    const std::size_t offset = pos % BITSPERINT;
    return typename bitset&lt;N&gt;::reference(&amp;d_data[shift],
                                         static_cast&lt;unsigned int&gt;(offset));
}

// ACCESSORS
template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt; bitset&lt;N&gt;::operator&lt;&lt;(std::size_t pos) const
{
    BSLS_ASSERT_SAFE(pos &lt;= N);

    bitset&lt;N&gt; tmp(*this);
    return tmp &lt;&lt;= pos;
}

template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt; bitset&lt;N&gt;::operator&gt;&gt;(std::size_t pos) const
{
    BSLS_ASSERT_SAFE(pos &lt;= N);

    bitset&lt;N&gt; tmp(*this);
    return tmp &gt;&gt;= pos;
}

template &lt;std::size_t N&gt;
inline
bitset&lt;N&gt; bitset&lt;N&gt;::operator~() const
{
    bitset&lt;N&gt; tmp(*this);
    return tmp.flip();
}

template &lt;std::size_t N&gt;
inline
bool bitset&lt;N&gt;::operator[](std::size_t pos) const
{
    BSLS_ASSERT_SAFE(pos &lt; N);

    const std::size_t shift  = pos / BITSPERINT;
    const std::size_t offset = pos % BITSPERINT;
    return ((d_data[shift] &amp; (1 &lt;&lt; offset)) != 0);
}

template &lt;std::size_t N&gt;
inline
bool bitset&lt;N&gt;::operator==(const bitset&amp; rhs) const
{
    return std::memcmp(d_data, rhs.d_data, BITSETSIZE * BYTESPERINT) == 0;
}

template &lt;std::size_t N&gt;
inline
bool bitset&lt;N&gt;::operator!=(const bitset&amp; rhs) const
{
    return !operator==(rhs);
}

template &lt;std::size_t N&gt;
bool bitset&lt;N&gt;::any() const
{
    for (std::size_t i = 0; i &lt; BITSETSIZE; ++i) {
        if (d_data[i] != 0) {
            return true;                                              // RETURN
        }
    }
    return false;
}

template &lt;std::size_t N&gt;
inline
bool bitset&lt;N&gt;::none() const
{
    return !any();
}

template &lt;std::size_t N&gt;
inline
std::size_t bitset&lt;N&gt;::size() const
{
    return N;
}

template &lt;std::size_t N&gt;
std::size_t bitset&lt;N&gt;::count() const
{
    std::size_t sum = 0;
    for (std::size_t i = 0; i &lt; BITSETSIZE; ++i) {
        sum += numOneSet(d_data[i]);
    }
    return sum;
}

template &lt;std::size_t N&gt;
template &lt;class CHAR_TYPE, class TRAITS, class ALLOCATOR&gt;
basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt; bitset&lt;N&gt;::to_string() const
{
    basic_string&lt;CHAR_TYPE, TRAITS, ALLOCATOR&gt; str(N,
                                                   TRAITS::to_char_type(&#39;0&#39;));
    for (std::size_t i = 0; i &lt; N; ++i) {
        if (this-&gt;operator[](i)) {
            str[N - i - 1] = TRAITS::to_char_type(&#39;1&#39;);
        }
    }
    return str;
}

template &lt;std::size_t N&gt;
inline
bool bitset&lt;N&gt;::test(size_t pos) const
{
    if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(pos &gt;= N)) {
        BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
        BloombergLP::bslstl::StdExceptUtil::throwOutOfRange(
                                        &quot;out_of_range in bsl::bitset&lt;&gt;::test&quot;);
    }
    return operator[](pos);
}

template &lt;std::size_t N&gt;
unsigned long bitset&lt;N&gt;::to_ulong() const
{
    enum {
        BSLSTL_INTS_IN_LONG = sizeof(unsigned long) / sizeof(int)
    };

    for (std::size_t i = BSLSTL_INTS_IN_LONG; i &lt; BITSETSIZE; ++i) {
        if (BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(d_data[i])) {
            BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
            BloombergLP::bslstl::StdExceptUtil::throwOverflowError(
                                        &quot;overflow in bsl::bitset&lt;&gt;::to_ulong&quot;);
        }
    }

    unsigned long      value   = 0;
    const unsigned int numInts = (unsigned int) BSLSTL_INTS_IN_LONG
                                                    &lt; (unsigned int) BITSETSIZE
                               ? (unsigned int) BSLSTL_INTS_IN_LONG
                               : (unsigned int) BITSETSIZE;

    for (unsigned int i = 0; i &lt; numInts; ++i) {
        value |= (unsigned long) d_data[i] &lt;&lt; (BITSPERINT * i);
    }
    return value;
}

// FREE OPERATORS
template &lt;std::size_t N&gt;
bitset&lt;N&gt; operator&amp;(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs)
{
    bitset&lt;N&gt; tmp(lhs);
    return tmp &amp;= rhs;
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt; operator|(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs)
{
    bitset&lt;N&gt; tmp(lhs);
    return tmp |= rhs;
}

template &lt;std::size_t N&gt;
bitset&lt;N&gt; operator^(const bitset&lt;N&gt;&amp; lhs, const bitset&lt;N&gt;&amp; rhs)
{
    bitset&lt;N&gt; tmp(lhs);
    return tmp ^= rhs;
}

template &lt;class CHAR_TYPE, class TRAITS, std::size_t N&gt;
std::basic_istream&lt;CHAR_TYPE, TRAITS&gt;&amp;
operator&gt;&gt;(std::basic_istream&lt;CHAR_TYPE, TRAITS&gt;&amp; is, bitset&lt;N&gt;&amp; x)
{
    typedef typename TRAITS::int_type int_type;

    basic_string&lt;CHAR_TYPE, TRAITS, allocator&lt;CHAR_TYPE&gt; &gt; tmp;
    tmp.reserve(N);

    typename std::basic_istream&lt;CHAR_TYPE, TRAITS&gt;::sentry sen(is);
    if (sen) {
        std::basic_streambuf&lt;CHAR_TYPE, TRAITS&gt; *buffer = is.rdbuf();
        for (std::size_t i = 0; i &lt; N; ++i) {
            static int_type eof = TRAITS::eof();
            int_type cint = buffer-&gt;sbumpc();
            if (TRAITS::eq_int_type(cint, eof)) {
                is.setstate(std::ios_base::eofbit);
                break;
            }
            else {
                CHAR_TYPE cchar = TRAITS::to_char_type(cint);
                char      c     = is.narrow(cchar, &#39;*&#39;);

                if (c == &#39;0&#39; || c == &#39;1&#39;) {
                    tmp.push_back(c);
                }
                else if (TRAITS::eq_int_type(buffer-&gt;sputbackc(cchar), eof)) {
                    is.setstate(std::ios_base::failbit);
                    break;
                }
            }
        }

        if (tmp.empty()) {
            is.setstate(std::ios_base::failbit);
        }
        else {
            x = bitset&lt;N&gt;(tmp);
        }
    }
    return is;
}

template &lt;class CHAR_TYPE, class TRAITS, std::size_t N&gt;
inline
std::basic_ostream&lt;CHAR_TYPE, TRAITS&gt;&amp;
operator&lt;&lt;(std::basic_ostream&lt;CHAR_TYPE, TRAITS&gt;&amp; os, const bitset&lt;N&gt;&amp; x)
{
    basic_string&lt;CHAR_TYPE, TRAITS, allocator&lt;CHAR_TYPE&gt; &gt; tmp (
             x.template to_string&lt;CHAR_TYPE, TRAITS, allocator&lt;CHAR_TYPE&gt; &gt;());
    return os &lt;&lt; tmp;
}

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
