<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslh_hash Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslh_hash<br/>
<small>
[<a class="el" href="group__bslh.html">Package bslh</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a struct to run <code>bslh</code> hash algorithms on supported types.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslh.html">bslh</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Modularity</a> </li>
<li>
<a href="#3.2"><code>hashAppend</code></a> </li>
<li>
<a href="#3.3">Hashing Algorithms</a> </li>
<li>
<a href="#3.4">Requirements for Regular <code>bslh</code> Hashing Algorithms</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Keying a hash table with a user defined type</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a struct to run <code>bslh</code> hash algorithms on supported types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a> </td><td>functor that runs <code>bslh</code> hash algorithms on supported types  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a templated <code>struct</code>, <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code>, that defines a hash-functor that can be used with standard containers (a drop in replacement for <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code>), and which applies the supplied (template parameter) <code>HASH_ALGORITHM</code> to the attributes of the (template parameter) <code>TYPE</code> which have been identified as salient to hashing. The <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code> template parameter <code>HASH_ALGORITHM</code> must be a hashing algorithm that conforms the the requirements outlined below (see <a href="group__bslh__hash.html#requirements_for_regular_bslh_hashing_algorithms" class="el">Requirements for Regular <code>bslh</code> Hashing Algorithms</a>). Note that there are several hashing algorithms defined within the <code>bslh</code> package and some, such as those that require seeds, will not meet these requirements, meaning they cannot be used with <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code>. A call to <code>bslh::Hash::operator()</code> for a (template parameter) <code>TYPE</code> will call the <code>hashAppend</code> free function for <code>TYPE</code> and provide <code>hashAppend</code> an instance of the <code>HASH_ALGORITHM</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component also contains <code>hashAppend</code> definitions for fundamental types, which are required by algorithms defined in <code>bslh</code>. Clients are expected to define a free-function <code>hashAppend</code> for each of the types they wish to be hashable (see <a href="group__hashAppend.html" class="el"><code>hashAppend</code></a> below). More information can be found in the package level documentation for <code>bslh</code> (internal users can also find information here {TEAM BDE:USING MODULAR HASHING&lt;GO&gt;}) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="modularity"></a> <a class="anchor" id="description.modularity"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Modularity: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code> provides a modular system for hashing. This modularity refers to the decoupling of the various tasks associated with hashing. Using this system, type implementers can identify attributes of their type that are salient to hashing, without having to write a hashing algorithm. Conversely, hashing algorithms can be written independent of types. Attributes that are salient to hashing are called out on a type using <code>hashAppend</code>. Hashing algorithms are written to operate on the attributes called out by <code>hashAppend</code>. Some default algorithms have been provided in the <code>bslh</code> package. This modularity allows type creators to avoid writing hashing algorithms, which can save work and avoid bad hashing algorithm implementations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hashappend"></a> <a class="anchor" id="description.hashappend"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>hashAppend: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>hashAppend</code> is the function that is used to pass attributes that are salient to hashing into a hashing algorithm. A type must define a <code>hashAppend</code> overload that can be discovered through ADL in order to be hashed using this facility. A simple implementation of an overload for <code>hashAppend</code> might call <code>hashAppend</code> on each of the type's attributes that are salient to hashing. Note that when writing a <code>hashAppend</code> function, <code>using <a class="el" href="namespacebslh.html#a31a7b904ae7d10296832e8bb46b22aee">bslh::hashAppend</a>;</code> must be included as the first line of code in the function. The using statement ensures that ADL will always be able to find the fundamental type <code>hashAppend</code> functions, even when the (template parameter) type <code>HASH_ALGORITHM</code> is not implemented in <code>bslh</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Some types may require more subtle implementations for <code>hashAppend</code>, such as types containing C-strings which are salient to hashing. These C-strings must be passed directly into the (template parameter) type <code>HASH_ALGORITHM</code>, rather than calling <code>hashAppend</code> with the pointer as an argument. This special case exists because calling <code>hashAppend</code> with a pointer will hash the pointer rather than the data that is pointed to. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Within this component, <code>hashAppend</code> has been implemented for all of the fundamental types. When 'hashAppend is reached on a fundamental type, the hashing algorithm is no longer propagated, and instead a pointer to the beginning of the type in memory is passed to the algorithm, along with the length of the type. There are special cases with floating point numbers and boolean values where the data is tweaked before hashing to ensure that values that compare equal will be hashed with the same bit-wise representation. The algorithm will then incorporate the type into its internal state and return a finalized hash when requested. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hashing_algorithms"></a> <a class="anchor" id="description.hashing_algorithms"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Hashing Algorithms: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are algorithms implemented in the <code>bslh</code> package that can be passed in and used as template parameters for <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code> or other <code>struct</code>s like it. Some of these algorithms, such as <code><a class="el" href="classbslh_1_1SpookyHashAlgorithm.html">bslh::SpookyHashAlgorithm</a></code>, are named for the algorithm they implement. These named algorithms are intended for use by those who want a specific algorithm. There are other algorithms, such as <code><a class="el" href="classbslh_1_1DefaultHashAlgorithm.html">bslh::DefaultHashAlgorithm</a></code>, which wrap an unspecified algorithm and describe the properties of the wrapped algorithm. The descriptive algorithms are intended for use by those who need specific properties and want to be updated to a new algorithm when one is published with improvements to the desired properties. <code><a class="el" href="classbslh_1_1DefaultHashAlgorithm.html">bslh::DefaultHashAlgorithm</a></code> has the property of being a good default algorithm, specifically for use in a hash table. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_for_regular_bslh_hashing_algorithms"></a> <a class="anchor" id="description.requirements_for_regular_bslh_hashing_algorithms"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Requirements for Regular bslh Hashing Algorithms: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Users of this modular hashing system are free to write their own hashing algorithms. In order to plug into <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a></code>, the user-implemented algorithms must implement the interface shown here: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>SomeHashAlgorithm
 {
   <span class="keyword">public</span>:
     <span class="comment">// TYPES</span>
     <span class="keyword">typedef</span> Uint64 result_type;

     <span class="comment">// CREATORS</span>
     SomeHashAlgorithm();

     <span class="comment">// MANIPULATORS</span>
     <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keywordtype">void</span> *data, <span class="keywordtype">size_t</span> numBytes);

     result_type computeHash();
 };
</pre></div><br/>
<br/>
 The <code>result_type</code> <code>typedef</code> must define the return type of this particular algorithm. A default constructor (either implicit or explicit) must be supplied that creates an algorithm functor that is in a usable state. An <code>operator()</code> must be supplied that takes a <code>const void *</code> to the data to be hashed and a <code>size_t</code> length of bytes to be hashed. This operator must operate on all data uniformly, meaning that regardless of whether data is passed in all at once, or one byte at a time, the result returned by <code>computeHash()</code> will be the same. <code>computeHash()</code> will return the final result of the hashing algorithm, as type <code>result_type</code>. <code>computeHash()</code> is allowed to modify the internal state of the algorithm, meaning calling <code>computeHash()</code> more than once may not return the correct value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_keying_a_hash_table_with_a_user_defined_type"></a> <a class="anchor" id="usage.example_1~3A_keying_a_hash_table_with_a_user_defined_type"></a> <a class="anchor" id="description.usage.example_1~3A_keying_a_hash_table_with_a_user_defined_type"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Keying a hash table with a user defined type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have a value semantic type, <code>Box</code>, that contains attributes that are salient to hashing as well as attributes that are not salient to hashing. Some of these attributes are themselves user defined types. We want to store objects of type <code>Box</code> in a hash table, so we need to be able to produce hash values that represent instances of <code>Box</code>. We don't want to write our own hashing or hash combine algorithm, because we know it is very difficult and labor-intensive to write a proper hashing algorithm. In order to hash this <code>Box</code>, we will use the modular hashing system supplied in <code>bslh</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define <code>Point</code>, a class that allows us to identify a location on a two dimensional Cartesian plane. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Point {
      <span class="comment">// This class is a value semantic type that represents a two</span>
      <span class="comment">// dimensional location on a Cartesian plane.</span>

    <span class="keyword">private</span>:
      <span class="keywordtype">int</span>    d_x;
      <span class="keywordtype">int</span>    d_y;
      <span class="keywordtype">double</span> d_distToOrigin; <span class="comment">// This value will be accessed frequently, so we</span>
                             <span class="comment">// cache it rather than recalculate it every</span>
                             <span class="comment">// time.</span>

    <span class="keyword">public</span>:
      Point (<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
          <span class="comment">// Create a &#39;Point&#39; having the specified &#39;x&#39; and &#39;y&#39; coordinates.</span>

      <span class="keywordtype">double</span> distanceToOrigin() <span class="keyword">const</span>;
          <span class="comment">// Return the distance from the origin (0, 0) to this point.</span>

      <span class="keywordtype">int</span> getX() <span class="keyword">const</span>;
          <span class="comment">// Return the x coordinate of this point.</span>

      <span class="keywordtype">int</span> getY() <span class="keyword">const</span>;
          <span class="comment">// Return the y coordinate of this point.</span>
  };

  <span class="keyword">inline</span>
  Point::Point(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
  : d_x(x)
  , d_y(y)
  {
      d_distToOrigin = sqrt(static_cast&lt;double&gt;(d_x * d_x) +
                            static_cast&lt;double&gt;(d_y * d_y));
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">double</span> Point::distanceToOrigin()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_distToOrigin;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> Point::getX()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_x;
  }

  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> Point::getY()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_y;
  }
</pre></div><br/>
<br/>
 Then, we define <code>operator==</code>. Notice how it checks only attributes that we would want to incorporate into the hashed value. Note that attributes that are salient to hashing tend to be the same as or a subset of the attributes that are checked in <code>operator==</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> Point &amp;lhs, <span class="keyword">const</span> Point &amp;rhs)
      <span class="comment">// Return true if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value.</span>
      <span class="comment">// Two &#39;Point&#39; objects have the same value if they have the same x and</span>
      <span class="comment">// y coordinates.</span>
  {
      <span class="keywordflow">return</span> (lhs.getX() == rhs.getX()) &amp;&amp; (lhs.getY() == rhs.getY());
  }
</pre></div><br/>
<br/>
 Next, we define <code>hashAppend</code>. This function will allow any hashing algorithm that meets the <code>bslh</code> hashing algorithm requirements to be applied to <code>Point</code>. This is the full extent of the work that needs to be done by type creators. They do not need to implement any algorithms, they just need to call out the attributes that are salient to hashing by calling <code>hashAppend</code> on them. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
  <span class="keywordtype">void</span> <a class="code" href="namespacebslh.html#a31a7b904ae7d10296832e8bb46b22aee">hashAppend</a>(HASH_ALGORITHM &amp;hashAlg, <span class="keyword">const</span> Point &amp;point)
      <span class="comment">// Apply the specified &#39;hashAlg&#39; to the specified &#39;point&#39;</span>
  {
      <span class="keyword">using</span> bslh::hashAppend;
      <a class="code" href="namespacebslh.html#a31a7b904ae7d10296832e8bb46b22aee">hashAppend</a>(hashAlg, point.getX());
      <a class="code" href="namespacebslh.html#a31a7b904ae7d10296832e8bb46b22aee">hashAppend</a>(hashAlg, point.getY());
  }
</pre></div><br/>
<br/>
 Then, we declare another value semantic type, <code>Box</code> that will have a <code>Point</code> as one of its attributes that are salient to hashing. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Box {
      <span class="comment">// This class is a value semantic type that represents a box drawn on</span>
      <span class="comment">// to a Cartesian plane.</span>

    <span class="keyword">private</span>:
      Point d_position;
      <span class="keywordtype">int</span> d_length;
      <span class="keywordtype">int</span> d_width;

    <span class="keyword">public</span>:
      Box(Point position, <span class="keywordtype">int</span> length, <span class="keywordtype">int</span> width);
          <span class="comment">// Create a box having the specified &#39;length&#39; and &#39;width&#39;, with its</span>
          <span class="comment">// upper left corner at the specified &#39;position&#39;</span>

      <span class="keywordtype">int</span> getLength() <span class="keyword">const</span>;
          <span class="comment">// Return the length of this box.</span>

      Point getPosition() <span class="keyword">const</span>;
          <span class="comment">// Return a &#39;Point&#39; representing the upper left corner of this box</span>
          <span class="comment">// on a Cartesian plane</span>

      <span class="keywordtype">int</span> getWidth() <span class="keyword">const</span>;
          <span class="comment">// Return the width of this box.</span>
  };

  <span class="keyword">inline</span>
  Box::Box(Point position, <span class="keywordtype">int</span> length, <span class="keywordtype">int</span> width)
  : d_position(position)
  , d_length(length)
  , d_width(width) { }

  <span class="keywordtype">int</span> Box::getLength()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_length;
  }

  Point Box::getPosition()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_position;
  }

  <span class="keywordtype">int</span> Box::getWidth()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_width;
  }
</pre></div><br/>
<br/>
 Then, we define <code>operator==</code>. This time all of the data members are salient to equality. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> Box &amp;lhs, <span class="keyword">const</span> Box &amp;rhs)
      <span class="comment">// Return true if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value.</span>
      <span class="comment">// Two &#39;Box&#39; objects have the same value if they have the same length,</span>
      <span class="comment">// width, and position.</span>
  {
      <span class="keywordflow">return</span> (lhs.getPosition() == rhs.getPosition()) &amp;&amp;
             (lhs.getLength()   == rhs.getLength()) &amp;&amp;
             (lhs.getWidth()    == rhs.getWidth());
  }
</pre></div><br/>
<br/>
 Next, we define <code>hashAppend</code> for <code>Box</code>. Notice how as well as calling <code>hashAppend</code> on fundamental types, we can also call it with our user defined type <code>Point</code>. Calling <code>hashAppend</code> with <code>Point</code> will propogate a reference to the hashing algorithm functor <code>hashAlg</code> down to the fundamental types that make up <code>Point</code>, and those types will then be passed into the referenced algorithm functor. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> HASH_ALGORITHM&gt;
  <span class="keywordtype">void</span> <a class="code" href="namespacebslh.html#a31a7b904ae7d10296832e8bb46b22aee">hashAppend</a>(HASH_ALGORITHM &amp;hashAlg, <span class="keyword">const</span> Box &amp;box)
      <span class="comment">// Apply the specified &#39;hashAlg&#39; to the specified &#39;box&#39;</span>
  {
      <span class="keyword">using</span> bslh::hashAppend;
      <a class="code" href="namespacebslh.html#a31a7b904ae7d10296832e8bb46b22aee">hashAppend</a>(hashAlg, box.getPosition());
      <a class="code" href="namespacebslh.html#a31a7b904ae7d10296832e8bb46b22aee">hashAppend</a>(hashAlg, box.getLength());
      <a class="code" href="namespacebslh.html#a31a7b904ae7d10296832e8bb46b22aee">hashAppend</a>(hashAlg, box.getWidth());
  }
</pre></div><br/>
<br/>
 Then, we declare our hash table (implementation elided). We simplify the problem by requiring the caller to supply an array. Our hash table takes two type parameters: <code>TYPE</code> (the type being referenced) and <code>HASHER</code> (a functor that produces the hash). <code>HASHER</code> will default to <code><a class="el" href="structbslh_1_1Hash.html">bslh::Hash</a>&lt;&gt;</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> HASHER = bslh::Hash&lt;&gt; &gt;
  <span class="keyword">class </span>HashTable {
      <span class="comment">// This class template implements a hash table providing fast lookup of</span>
      <span class="comment">// an external, non-owned, array of values of (template parameter)</span>
      <span class="comment">// &#39;TYPE&#39;.</span>
      <span class="comment">//</span>
      <span class="comment">// The (template parameter) &#39;TYPE&#39; shall have a transitive, symmetric</span>
      <span class="comment">// &#39;operator==&#39; function and it will be hashable using &#39;bslh::Hash&#39;.</span>
      <span class="comment">// Note that there is no requirement that it have any kind of creator</span>
      <span class="comment">// defined.</span>
      <span class="comment">//</span>
      <span class="comment">// The &#39;HASHER&#39; template parameter type must be a functor with a method</span>
      <span class="comment">// having the following signature:</span>
      <span class="comment">//..</span>
      <span class="comment">//  size_t operator()(TYPE)  const;</span>
      <span class="comment">//                   -OR-</span>
      <span class="comment">//  size_t operator()(const TYPE&amp;) const;</span>
      <span class="comment">//..</span>
      <span class="comment">// and &#39;HASHER&#39; shall have a publicly accessible default constructor</span>
      <span class="comment">// and destructor.  Here we use &#39;bslh::Hash&#39; as our default template</span>
      <span class="comment">// argument.  This allows us to hash any type for which &#39;hashAppend&#39;</span>
      <span class="comment">// has been implemented.</span>
      <span class="comment">//</span>
      <span class="comment">// Note that this hash table has numerous simplifications because we</span>
      <span class="comment">// know the size of the array and never have to resize the table.</span>

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> TYPE       *d_values;             <span class="comment">// Array of values table is to</span>
                                              <span class="comment">// hold</span>
      <span class="keywordtype">size_t</span>            d_numValues;          <span class="comment">// Length of &#39;d_values&#39;.</span>
      <span class="keyword">const</span> TYPE      **d_bucketArray;        <span class="comment">// Contains ptrs into</span>
                                              <span class="comment">// &#39;d_values&#39;</span>
      <span class="keywordtype">unsigned</span>          d_bucketArrayMask;    <span class="comment">// Will always be &#39;2^N - 1&#39;.</span>
      HASHER            d_hasher;

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keywordtype">bool</span> lookup(<span class="keywordtype">size_t</span>      *idx,
                  <span class="keyword">const</span> TYPE&amp;  value,
                  <span class="keywordtype">size_t</span>       hashValue) <span class="keyword">const</span>;
          <span class="comment">// Look up the specified &#39;value&#39;, having the specified &#39;hashValue&#39;,</span>
          <span class="comment">// and load its index in &#39;d_bucketArray&#39; into the specified &#39;idx&#39;.</span>
          <span class="comment">// If not found, return the vacant entry in &#39;d_bucketArray&#39; where</span>
          <span class="comment">// it should be inserted.  Return &#39;true&#39; if &#39;value&#39; is found and</span>
          <span class="comment">// &#39;false&#39; otherwise.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      HashTable(<span class="keyword">const</span> TYPE *valuesArray,
                <span class="keywordtype">size_t</span>      numValues);
          <span class="comment">// Create a hash table referring to the specified &#39;valuesArray&#39;</span>
          <span class="comment">// having length of the specified &#39;numValues&#39;.  No value in</span>
          <span class="comment">// &#39;valuesArray&#39; shall have the same value as any of the other</span>
          <span class="comment">// values in &#39;valuesArray&#39;</span>

      ~HashTable();
          <span class="comment">// Free up memory used by this hash table.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">bool</span> contains(<span class="keyword">const</span> TYPE&amp; value) <span class="keyword">const</span>;
          <span class="comment">// Return true if the specified &#39;value&#39; is found in the table and</span>
          <span class="comment">// false otherwise.</span>
  };
</pre></div><br/>
<br/>
 Next, we will create an array of boxes that we want to store in our hash table. <br/>
<br/>
<div class="fragment"><pre class="fragment">        Box boxes[] = { Box(Point(1, 1), 3, 2),
                        Box(Point(3, 1), 4, 2),
                        Box(Point(1, 2), 3, 3),
                        Box(Point(1, 1), 2, 2),
                        Box(Point(1, 4), 4, 3),
                        Box(Point(2, 1), 4, 2),
                        Box(Point(1, 0), 3, 1)};
        <span class="keyword">enum</span> { NUM_BOXES = <span class="keyword">sizeof</span> boxes / <span class="keyword">sizeof</span> *boxes };
</pre></div><br/>
<br/>
 Then, we create our hash table <code>hashTable</code>. We pass we use the default functor which will pick up the <code>hashAppend</code> function we created: <br/>
<br/>
<div class="fragment"><pre class="fragment">        HashTable&lt;Box&gt; hashTable(boxes, NUM_BOXES);
</pre></div><br/>
<br/>
 Now, we verify that each element in our array registers with count: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i) { ASSERT(hashTable.contains(boxes[i])); }
</pre></div><br/>
<br/>
 Finally, we verify that futures not in our original array are correctly identified as not being in the set: <br/>
<br/>
<div class="fragment"><pre class="fragment"> ASSERT(!hashTable.contains(Box(Point(1, 1), 1, 1)));
 ASSERT(!hashTable.contains(Box(Point(0, 0), 0, 0)));
 ASSERT(!hashTable.contains(Box(Point(3, 3), 3, 3)));
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
