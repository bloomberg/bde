<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslstl_vector Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_vector<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant vector class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__Util.html">bsl::Vector_Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;::Guard</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector.html">bsl::vector&lt; VALUE_TYPE, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector_3_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.html">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1vector_3_01const_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.html">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__DeduceIteratorCategory.html">bsl::Vector_DeduceIteratorCategory&lt; BSLSTL_ITERATOR, BSLSTL_NOTSPECIALIZED &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__DeduceIteratorCategory_3_01BSLSTL__ITERATOR_00_01true_01_4.html">bsl::Vector_DeduceIteratorCategory&lt; BSLSTL_ITERATOR, true &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__IsRandomAccessIterator.html">bsl::Vector_IsRandomAccessIterator&lt; BSLSTL_ITERATOR &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbsl_1_1Vector__RangeCheck.html">bsl::Vector_RangeCheck</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac6e8391c59e60b5a4dfd48e956f3b1c9">bsl::Vector_ImpBase::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadb78a996fed8af2d5899cca9dd1a9bc9">bsl::Vector_ImpBase::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga24d7c145ce94bf2f3ae8068569c143b8">bsl::Vector_ImpBase::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga18f44f5ce10b93d15ea3def898eab913">bsl::Vector_ImpBase::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">bsl::Vector_ImpBase::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga354535932a26dcc4a3021a0db40529ff">bsl::Vector_ImpBase::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa738a4a015b0459014a402a11f434fa4">bsl::Vector_ImpBase::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga37a11cdffcc2935872a29b90a5b90f4b">bsl::Vector_ImpBase::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga973722bc781447a95bbe3bad22bee7cd">bsl::Vector_ImpBase::const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaca634e1eaec2e15e41489ddd3997f916">bsl::Vector_Imp::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4d36ba02f1f56b7d3625473a13f1bbb9">bsl::Vector_Imp::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">bsl::Vector_Imp::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">bsl::Vector_Imp::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4c92c0cd3a23f5ba0ec05e91675e58c1">bsl::Vector_Imp::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1f80e17756d526b21865fe253de14ec0">bsl::Vector_Imp::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadf855a9b9d8659fef24bbff380847a09">bsl::Vector_Imp::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa4ba7599bad447463c136ddde706fe89">bsl::Vector_Imp::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad76280cde3c26148167685e86d916257">bsl::Vector_Imp::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafa599b89b411e2432aa34da953455b14">bsl::Vector_Imp::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9e2e1498f06434da2754aa4b893145a0">bsl::Vector_Imp::const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Base::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga950b9c5bf2fd674f5f84a930a9e75135">bsl::vector::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabd67713b2dc4fb388a6c9e9664505153">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga999efeb5f3915fb3501aad640cad4849">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabde26ba05b21196782157a1f8a76dabe">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1376a22b6e9b3c12f1e67dc5f3b1c2f8">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7c87e3765a9fe91486ad51a3193bdf1e">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga02cc4f8f85a558c7e6fa47050aa5df4e">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE_TYPE **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE_TYPE *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5308963c5edb86c346bc1f14576a71ad">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3385240d8b8b8b1241daea914944818b">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga55b2f2ba3be58a312c86e829bea00079">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa982216c00abe2084c2c863dc0254511">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga724824e0e6971c79b509b5a8151a9b36">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; const_iterator &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8264920698cfb33deb64977f93dd6bff">bsl::Vector_Util::swap</a> (void *a, void *b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf269e14b5972863897b472606b524ea0">bsl::Vector_ImpBase::Vector_ImpBase</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">bsl::Vector_ImpBase::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">bsl::Vector_ImpBase::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6080200616b755699e352155c7572d98">bsl::Vector_ImpBase::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafe52ce718a880c32d4bd69ed3bc65d3b">bsl::Vector_ImpBase::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaed1d2854dd5aaf5c0734202f5f43d42d">bsl::Vector_ImpBase::operator[]</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gacd7de02bfa273ac7643909b55502e462">bsl::Vector_ImpBase::at</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga547e809dc68789a250cd367760601d78">bsl::Vector_ImpBase::front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad737a7196152ddb07b059506a070d149">bsl::Vector_ImpBase::back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad98d192f5ea0af3ec3c6b5dabca1faa3">bsl::Vector_ImpBase::data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0eb1a2336108dd9a87ba8682fe199837">bsl::Vector_ImpBase::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0a53fc2c03dcc45dcba8fe6bf7298259">bsl::Vector_ImpBase::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4f6ee393ad3b6d9a72f13b15a95ea32a">bsl::Vector_ImpBase::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4a98f38e4458d7323fb526adf8c87da5">bsl::Vector_ImpBase::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0dd4792a346dae5157c7f4a4f7ee25f9">bsl::Vector_ImpBase::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga259f561373a610c2accfdf2961596c7d">bsl::Vector_ImpBase::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1f35ca07ac717fbc40e7cf3d755cc61f">bsl::Vector_ImpBase::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf7cd9b62a54f46268ef4d55c8358abbb">bsl::Vector_ImpBase::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">bsl::Vector_ImpBase::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga22982ebdac58b9b9a89e339feeeb8eb6">bsl::Vector_ImpBase::capacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad77dd3f93b278367659e8d1489df4a86">bsl::Vector_ImpBase::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf92663fe0dfe8dd17097054a4c115626">bsl::Vector_ImpBase::operator[]</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf7db0521ebb67c49b5625972ebb0d944">bsl::Vector_ImpBase::at</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab884eb9fa93b6f6fb1e748978b6b7136">bsl::Vector_ImpBase::front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga813678ea2bee5b416ffaae85b1005dd2">bsl::Vector_ImpBase::back</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae6c1ea9e07542194c9bd652087e49974">bsl::Vector_ImpBase::data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4bcd4f97cf1731cfa3a07320b29e9163">bsl::Vector_Imp::Guard::Guard</a> (VALUE_TYPE *data, std::size_t capacity, VectorContainerBase *container)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga627ffc01b497e5517ccb83b60fddebfb">bsl::Vector_Imp::Guard::~Guard</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4385b427bfd450fb3189a1e735d18029">bsl::Vector_Imp::Guard::release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga284fe64b913f45e344f50ff54983ca86">bsl::Vector_Imp::Vector_Imp</a> (const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga97c6d794f60bcc049dfb246840af3ae5">bsl::Vector_Imp::Vector_Imp</a> (size_type initialSize, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga51468b963e6f9cc53e3ef8501e5822f4">bsl::Vector_Imp::Vector_Imp</a> (size_type initialSize, const VALUE_TYPE &amp;value, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga29978342ad70c393ce602b58f8a359a5">bsl::Vector_Imp::Vector_Imp</a> (INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9fb9c29f67db4c74fca0804e28605b98">bsl::Vector_Imp::Vector_Imp</a> (const Vector_Imp &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae31bfd1e98019fc6fadefcbb504b80cf">bsl::Vector_Imp::Vector_Imp</a> (const Vector_Imp &amp;original, const ALLOCATOR &amp;basicAllocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga688d9df2c46cac0599b2aa4346131965">bsl::Vector_Imp::~Vector_Imp</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Vector_Imp &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6a8b9a37bd5bbd1eb310cd5fe2a10665">bsl::Vector_Imp::operator=</a> (const Vector_Imp &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga81fed82a60da7d7c72724f95bfa7ac7f">bsl::Vector_Imp::assign</a> (INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga142315e14e55d68bb9edf0c9c227feb0">bsl::Vector_Imp::assign</a> (size_type numElements, const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac5203d4410a4c7c3d1d2014d5542e0d9">bsl::Vector_Imp::resize</a> (size_type newSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4fedf6842b169a88be67a5758b3aa229">bsl::Vector_Imp::resize</a> (size_type newSize, const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac931be06971aedc190c1191a00ee251a">bsl::Vector_Imp::reserve</a> (size_type newCapacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf5dd77d0be1e77193b7289fc08e828ec">bsl::Vector_Imp::shrink_to_fit</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga332db0292e3c1107be19e02fd9f22299">bsl::Vector_Imp::emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">bsl::Vector_Imp::push_back</a> (const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8fbe1d9aac697597bce2b527b8208003">bsl::Vector_Imp::pop_back</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">VALUE_TYPE *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadeebf7a713dc053843dee059e23e9375">bsl::Vector_Imp::emplace</a> (const_iterator position, Args &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa856a23873fe4d5354e0d8b63f0b0659">bsl::Vector_Imp::insert</a> (const_iterator position, const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf28f2fa76a6acfe212d1dee103c2dafe">bsl::Vector_Imp::insert</a> (const_iterator position, size_type numElements, const VALUE_TYPE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadc116debf5b1eb8a37aa4d0bd85213b2">bsl::Vector_Imp::insert</a> (const_iterator position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8398ddeb0509741ce8734bc4eb5d5654">bsl::Vector_Imp::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga840ceb3ecb6c53492e8a5b73fbe7501d">bsl::Vector_Imp::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac169aabe4c02a46527a12822254293ea">bsl::Vector_Imp::swap</a> (Vector_Imp &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae9fa4fec3242df3b8c6a70118726304d">bsl::Vector_Imp::clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8d52d78392a987e2864466198f37fb62">bsl::Vector_Imp::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga66cf2ced34b3c15613d0ba2acc86f5c1">bsl::Vector_Imp::max_size</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae1cf7ebaf57b20ad849f3cec698e88b9">bsl::operator==</a> (const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3b21b4b523ef349a450e774e69fba3a2">bsl::operator!=</a> (const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafae8e5536e4d0104153320a37e8c1e3a">bsl::operator&lt;</a> (const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga625351fd0ddd03d582652b3aae6ebbc9">bsl::operator&gt;</a> (const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9300705f377d58094c8b40530816ffb7">bsl::operator&lt;=</a> (const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4310a39a792a2712adaa5104a67a0bf8">bsl::operator&gt;=</a> (const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga73c7729c8388a194029dab1d69d08360">bsl::swap</a> (Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;a, Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8328b2e4c53f551aff7d2214c64a8fc6">bsl::vector::vector</a> (const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5041cf05bb3c096dc9ac7d9ab7622b42">bsl::vector::vector</a> (size_type n, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa3e74030769c96731f89650b88b266ca">bsl::vector::vector</a> (size_type n, const VALUE_TYPE &amp;value, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga85ed9bce9c0a6cd632370f8ad1bbfe2a">bsl::vector::vector</a> (INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad6aee9294aa848f350279f61830ca372">bsl::vector::vector</a> (const vector &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad5ed08a31f91d6b2c79d9e7c0752814d">bsl::vector::vector</a> (const vector &amp;original, const ALLOCATOR &amp;alloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga14c35993dffc40a4366db40b6461003e">bsl::vector::~vector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa65ad70520f2bb5fcd615c7163f64e01">bsl::vector::operator=</a> (const vector &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1829ad82eb519b1fb7c79a803af91153">bsl::operator==</a> (const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae2296fbb2872dbb82c90f7c41ab6ca41">bsl::operator!=</a> (const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaaa78d320fb70553c12c5ac664ef03e4e">bsl::operator&lt;</a> (const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9fefac8bbb8472a45f2f021b3045b886">bsl::operator&gt;</a> (const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad43a151e8130ffa1975e64bceae4cfef">bsl::operator&lt;=</a> (const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga926b2d565333233f7bca60072014322a">bsl::operator&gt;=</a> (const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabaf47fbdf5a80691a93069d8e5041e90">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0c1cc0f422360c7d58dfcb64f79529c5">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (size_type n, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga9ce6f8d6734545c00615962da7f39611">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (size_type n, VALUE_TYPE *value, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga60d71628e72898d8584e3378ed1dfe32">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga152981423ce926f8024acbd0a976de11">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (const vector &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga818a2d9d0fb6027b41f79612b6f979a1">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (const vector &amp;original, const ALLOCATOR &amp;alloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6dcf3a85a5d8b27bda092b4a504cc6fa">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::~vector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad28e356adf09adaf80b1f800bcddd5a5">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator=</a> (const vector &amp;other)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5de26b249081554ec1cb21b3f7b43df5">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::assign</a> (INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadefaed4ca7f4d26ff6ee384e0476b124">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::assign</a> (size_type numElements, VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga318ef936958ee98c2f298f1a31b922f7">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga55d52f185850254ecb4b6ec28b9f8d6d">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1b4b7957e130864312eca3df390fb785">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4288784db009e96af1eff77d09b90fc1">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae909e329344974ad7fb4e7b424878d36">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator[]</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8fdb6db1c20406556e29c11021c472bb">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::at</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga81f700b55078ee5468b96fa6ebea55ad">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5338994a167c6bafe6bbccac8c514795">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE_TYPE **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae08c76cfbf01f80e7380a994157df568">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga61a91e79364592b47b626313c961a6e5">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::resize</a> (size_type newLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga23e40cd74587357f81715af062e2eaa9">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::resize</a> (size_type newLength, VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga728a77555f5235b5197ba697837c2cff">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::push_back</a> (VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae9352c4608b40e6c4230d245f68ae146">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert</a> (const_iterator position, VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5a0e0e9d0944dc1ab7bb339c73463b06">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert</a> (const_iterator position, size_type numElements, VALUE_TYPE *value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga463c9e3a03f1a0aded9c067f41c0d06c">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert</a> (const_iterator position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2f4211727f28143130412cdd04df0fb9">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga56f6de18a557d17ee3d26bdd91ac3474">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga87fc99fbeadf2f8b9e165eb363d1cc81">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga066fbb8af43cfc8b0c1b86a2a69aad0b">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga60dd96d572ec3b5a62d87a19d4d48860">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga56af29169db429fdadcf393a67b05045">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3a92029c5fa75db8d4025f90e61bab0e">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac159e88612a81f0f7be8f213eb2fee03">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7acd8f6ac7e55437aa76379e6bdf1361">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga338ccdaed2d290b97203b32aaf928eec">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga03dbba1d8ff19a8c45b3d617aad600ca">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga308cd1b4084480a1241a8d47c23b9956">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator[]</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafb049517872ca58d40d1f436ba261203">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::at</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gacd47d558bbb42957c05d6388f63cd8a8">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5aca08cd5fd53de3f530fbd9564ab001">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::back</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE_TYPE *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2f2d08ae008a632d57896127fc34b4b6">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::data</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab76628a7a0c98d331cb819c2a350eb66">bsl::operator==</a> (const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa050f07faffd38620497590ae4a99b4d">bsl::operator!=</a> (const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad44b0030adeab48da89a630cd9dbda69">bsl::operator&lt;</a> (const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga06eed7e12572f6abb9838f1737348bd6">bsl::operator&gt;</a> (const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga43dfb63a5e8e2518d34771637f3b3815">bsl::operator&lt;=</a> (const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae74b32df8b2eebf0034d006226553379">bsl::operator&gt;=</a> (const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab53faa313dc32ebffbfb834e8f6bc923">bsl::swap</a> (vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;a, vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga885f0a024872596f0edc7598433c9316">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga75b47261356e66440a3f22326fca0c3c">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (size_type n, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga518a0bb8a9d0f20b087368c0ea100810">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (size_type n, const VALUE_TYPE *value, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadcc082b76fa6e1053a2f24b95cbbdb09">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5cc6a14692647bbb83dd82a866e33556">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (const vector &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf9cd6c1e661a3297a387f9dfc145e467">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector</a> (const vector &amp;original, const ALLOCATOR &amp;alloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadd98de3e2f67da150e94b98fc065a179">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::~vector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">vector &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae93ec72d9ac8c3353f89b037de80eebf">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator=</a> (const vector &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga80beed773775ff491a560d9827470983">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::assign</a> (INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga63ea4226486bf51bd44bc1c84ed81b60">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::assign</a> (size_type numElements, const VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1e9dc42f3178d710fe2c66a192508db1">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3e6518351f9405fee2207027515573ab">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1d2c5620294830f3bd6f8481074424f3">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2a3153ef2b2ca91c59a6fd0a90035e56">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6f481f36ad2cc5f154ce79371f926511">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator[]</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf4a44098a0f50e69fad7cc01c408ba5e">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::at</a> (size_type position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaae5378ea8aa29d554ed2dbc57854762b">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga255da60d771bc40adc9602c63107d50e">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE_TYPE **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae14419f8bfc1c405679399b295275811">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga22024042f45a5f1566f956156d9cecb3">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::resize</a> (size_type newLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2507559e3c1ed336d4bc988aa880afe4">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::resize</a> (size_type newLength, const VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad4b087bd66d82c406c68ec31a054ee4c">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::push_back</a> (const VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf0e738c92639f1b6a84145727982eacf">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert</a> (const_iterator position, const VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8142025bc027624b76dc97505310175c">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert</a> (const_iterator position, size_type numElements, const VALUE_TYPE *value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae1ce3952d041389078ec3ee8450e8a54">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert</a> (const_iterator position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga92ced92b9688f17e37023f8e95bfe130">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::erase</a> (const_iterator position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga23ce96df781efd19791d63f1a07d78f6">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">allocator_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8f61cc68c2ce841df5d6a084d750dae3">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5ee3d15eea6c4801e247f53e7b5c4e4c">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1e62a537951df42db9a85e01b1c509d6">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab7d6db73f2b12880a2a9987bb1095350">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7a9a945d04de22e3cd264290a6d6e647">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac0b64df8420c75db7c2927a7f6afc670">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac8fe319720a2ef4788a2feea029c56f4">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5dd4cfaacb1291b7cbb7eb05f82340d5">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae1d17dce2e3f11f2a410513266227dc7">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa491c401d912f10e4161f06aaa116482">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator[]</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga015e3fd3a1291374dbb98b1fc59ee96d">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::at</a> (size_type position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4deef186a0f457ca404b26cc3b7cebb3">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0630475bf0de545f5053bc23661a1b89">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::back</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE_TYPE *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac6feec182b2932d2c3d242eb16655bb7">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::data</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6bc33a80f40864c84d527e1dba8ea0f7">bsl::operator==</a> (const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga70e39ecc5bb6b312e77055ab69db74e9">bsl::operator!=</a> (const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1d962f9bb93e44002b825909c6f5481c">bsl::operator&lt;</a> (const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga55051a5f21e7701e046a08080015b9d9">bsl::operator&gt;</a> (const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga229794ea813dde0fe7160991fccb5253">bsl::operator&lt;=</a> (const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac48a0847b58ba26910284d521f2dfb4f">bsl::operator&gt;=</a> (const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga11c0d5aedac133a4c9fd2a2404471c2c">bsl::swap</a> (vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;a, vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;b)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class BSLSTL_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a><br class="typebreak"/>
&lt; Vector_IsRandomAccessIterator<br class="typebreak"/>
&lt; BSLSTL_ITERATOR &gt;::VALUE, <br class="typebreak"/>
bool &gt;::type&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3e1a64e0c76bee38e5c27e2be33f23e0">bsl::Vector_RangeCheck::isInvalidRange</a> (BSLSTL_ITERATOR first, BSLSTL_ITERATOR last)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4270c95067ff340ec7469d1411e252ac">bsl::Vector_ImpBase::d_dataEnd</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabb717a1693d469a315711bddc394a404">bsl::Vector_ImpBase::d_capacity</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Specialization for <code>bool</code></a> </li>
<li>
<a href="#3.2">Requirements on <code>VALUE_TYPE</code></a> </li>
<li>
<a href="#3.3">Memory Allocation</a> <ul>
<li>
<a href="#3.3.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.4">Operations</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Creating a Matrix Type</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant vector class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsl_1_1vector.html">bsl::vector</a> </td><td>STL-compatible vector template  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__deque.html" title="Provide an STL-compliant deque class.">Component bslstl_deque</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template <code>vector</code>, implementing the standard sequential container, <code>std::vector</code>, holding a dynamic array of values of a template parameter type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An instantiation of <code>vector</code> is an allocator-aware, value-semantic type whose salient attributes are its size (number of values) and the sequence of values the vector contains. If <code>vector</code> is instantiated with an value type that is not value-semantic, then the vector will not retain all of its value-semantic qualities. In particular, if an value type cannot be tested for equality, then a <code>vector</code> containing that type cannot be tested for equality. It is even possible to instantiate <code>vector</code> with an value type that does not have a copy-constructor, in which case the <code>vector</code> will not be copyable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A vector meets the requirements of a sequential container with random access iterators in section 23.3.6 [vector] of the C++ standard. The <code>vector</code> implemented here adheres to the C++11 standard, except it does not have the <code>shrink_to_fit</code> method, interfaces that take rvalue references, <code>initializer_lists</code>, <code>emplace</code>, and operations taking a variadic number of template parameters. Note that, except for <code>shrink_to_fit</code>, excluded C++11 features are those that require (or are greatly simplified by) C++11 compiler support. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="specialization_for_bool"></a> <a class="anchor" id="description.specialization_for_bool"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Specialization for bool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>vector</code> is specialized when its value type is <code>bool</code> to optimize space allocation, so each value occupies only one bit. The references returned by a <code>vector&lt;bool&gt;</code> object are not references to <code>bool</code>, but a class that simulates the behavior of references to a bit in <code>vector&lt;bool&gt;</code>. Specifically, the class provides a conversion operator that returns <code>true</code> when the bit is set and <code>false</code> otherwise, and the class also provides an assignment operator that set the bit when the argument is <code>true</code> and clears it otherwise. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_on_value_type"></a> <a class="anchor" id="description.requirements_on_value_type"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Requirements on VALUE_TYPE: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code>vector</code> is a fully <a href="group__bsldoc__glossary.html#value-semantic_type" class="glossary">Value-Semantic Type</a> (see <a href="group__bsldoc__glossary.html" class="el"><code>bsldoc_glossary</code></a>) only if the supplied <code>VALUE_TYPE</code> template parameter is fully value-semantic. It is possible to instantiate a <code>vector</code> with <code>VALUE_TYPE</code> parameters that do not have a full set of value-semantic operations, but then some methods of the container may not be instantiable. The following terminology, adopted from the C++11 standard, is used in the function documentation of <code>vector</code> to describe a function's requirements for the <code>VALUE_TYPE</code> template parameter. These terms are also defined in section [17.6.3.1] of the C++11 standard. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="default-constructible"></a> <a class="anchor" id="requirements_on_value_type.default-constructible"></a> <a class="anchor" id="description.requirements_on_value_type.default-constructible"></a> <em>default-constructible</em>: The type provides a default constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="copy-constructible"></a> <a class="anchor" id="requirements_on_value_type.copy-constructible"></a> <a class="anchor" id="description.requirements_on_value_type.copy-constructible"></a> <em>copy-constructible</em>: The type provides a copy constructor.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="equality-comparable"></a> <a class="anchor" id="requirements_on_value_type.equality-comparable"></a> <a class="anchor" id="description.requirements_on_value_type.equality-comparable"></a> <em>equality-comparable</em>: The type provides an equality-comparison operator that defines an equivalence relationship and is both reflexive and transitive.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> <a class="anchor" id="less-than-comparable"></a> <a class="anchor" id="requirements_on_value_type.less-than-comparable"></a> <a class="anchor" id="description.requirements_on_value_type.less-than-comparable"></a> <em>less-than-comparable</em>: The type provides a less-than operator, which defines a strict weak ordering relation on values of the type.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a vector's <code>ALLOCATOR</code> template parameter determines how that vector will allocate memory. The <code>vector</code> template supports allocators meeting the requirements of the C++03 standard, in addition it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code> style allocators should use the template's default <code>ALLOCATOR</code> type: The default type for the <code>ALLOCATOR</code> template parameter, <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the (template parameter) type <code>ALLOCATOR</code> of an <code>vector</code> instantiation' is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that vector type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a vector accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it will be used to supply memory for the vector throughout its lifetime; otherwise, the vector will use the default allocator installed at the time of the vector's construction (see <code>bslma_default</code>). In addition to directly allocating memory from the indicated <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, a vector supplies that allocator's address to the constructors of contained objects of the (template parameter) type <code>VALUE_TYPE</code>, if it defines the <code><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a></code> trait. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code>vector</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;V&#39;</span>              - the <span class="stringliteral">&#39;VALUE_TYPE&#39;</span> <span class="keyword">template</span> parameter type of the vector
  <span class="charliteral">&#39;a&#39;</span>, <span class="charliteral">&#39;b&#39;</span>         - two distinct objects of type <span class="stringliteral">&#39;vector&lt;V&gt;&#39;</span>
  <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;m&#39;</span>         - number of values in <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span> respectively
  <span class="charliteral">&#39;k&#39;</span>              - an integral number
  <span class="stringliteral">&#39;al&#39;</span>             - an STL-style memory allocator
  <span class="stringliteral">&#39;i1&#39;</span>, <span class="stringliteral">&#39;i2&#39;</span>       - two iterators defining a sequence of <span class="stringliteral">&#39;VALUE_TYPE&#39;</span>
                     objects
  <span class="charliteral">&#39;v&#39;</span>              - an <span class="keywordtype">object</span> of type <span class="charliteral">&#39;V&#39;</span>
  <span class="stringliteral">&#39;p1&#39;</span>, <span class="stringliteral">&#39;p2&#39;</span>       - two iterators belonging to <span class="charliteral">&#39;a&#39;</span>
  distance(i1,i2)  - the number of values in the range [i1, i2)

  |-----------------------------------------+-------------------------------|
  | Operation                               | Complexity                    |
  |=========================================+===============================|
  | vector&lt;V&gt; a      (<span class="keywordflow">default</span> construction) | O[1]                          |
  | vector&lt;V&gt; a(al)                         |                               |
  |-----------------------------------------+-------------------------------|
  | vector&lt;V&gt; a(b)   (copy construction)    | O[n]                          |
  | vector&lt;V&gt; a(b, al)                      |                               |
  |-----------------------------------------+-------------------------------|
  | vector&lt;V&gt; a(k)                          | O[k]                          |
  | vector&lt;V&gt; a(k, al)                      |                               |
  |-----------------------------------------+-------------------------------|
  | vector&lt;V&gt; a(i1, i2)                     | O[distance(i1, i2)]           |
  | vector&lt;V&gt; a(i1, i2, al)                 |                               |
  |-----------------------------------------+-------------------------------|
  | a.~vector&lt;V&gt;()  (destruction)           | O[n]                          |
  |-----------------------------------------+-------------------------------|
  | a.assign(k, v)                          | O[k]                          |
  |-----------------------------------------+-------------------------------|
  | a.assign(i1, i2)                        | O[distance(i1, i2)            |
  |-----------------------------------------+-------------------------------|
  | get_allocator()                         | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.begin(), a.end(),                     | O[1]                          |
  | a.cbegin(), a.cend(),                   |                               |
  | a.rbegin(), a.rend(),                   |                               |
  | a.crbegin(), a.crend()                  |                               |
  |-----------------------------------------+-------------------------------|
  | a.size()                                | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.max_size()                            | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.resize(k)                             | O[k]                          |
  | a.resize(k, v)                          |                               |
  |-----------------------------------------+-------------------------------|
  | a.empty()                               | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.reserve(k)                            | O[k]                          |
  |-----------------------------------------+-------------------------------|
  | a[k]                                    | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.at(k)                                 | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.front()                               | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.back()                                | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.push_back()                           | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.pop_back()                            | O[1]                          |
  |-----------------------------------------+-------------------------------|
  | a.insert(p1, v)                         | O[1 + distance(p1, a.end())] |
  |-----------------------------------------+-------------------------------|
  | a.insert(p1, k, v)                      | O[k + distance(p1, a.end())] |
  |-----------------------------------------+-------------------------------|
  | a.insert(p1, i1, i2)                    | O[distance(i1, i2)            |
  |                                         |      + distance(p1, a.end())] |
  |-----------------------------------------+-------------------------------|
  | a.erase(p1)                             | O[1 + distance(p1, a.end())]  |
  |-----------------------------------------+-------------------------------|
  | a.erase(p1, p2)                         | O[distance(p1, p2)            |
  |                                         |      + distance(p1, a.end())] |
  |-----------------------------------------+-------------------------------|
  | a.swap(b), <a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(a,b),                   | O[1] <span class="keywordflow">if</span> <span class="charliteral">&#39;a&#39;</span> and <span class="charliteral">&#39;b&#39;</span> use the   |
  |                                         | same allocator, O[n + m]      |
  |                                         | otherwise                     |
  |-----------------------------------------+-------------------------------|
  | a.clear()                               | O[n]                          |
  |-----------------------------------------+-------------------------------|
  | a = b;           (assignment)           | O[n]                          |
  |-----------------------------------------+-------------------------------|
  | a == b, a != b                          | O[n]                          |
  |-----------------------------------------+-------------------------------|
  | a &lt; b, a &lt;= b, a &gt; b, a &gt;= b            | O[n]                          |
  |-----------------------------------------+-------------------------------|
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_matrix_type"></a> <a class="anchor" id="usage.example_1~3A_creating_a_matrix_type"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_matrix_type"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Matrix Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to define a value semantic type representing a dynamically resizable two-dimensional matrix. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the public interface for the <code>MyMatrix</code> class template: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>MyMatrix {
      <span class="comment">// This value-semantic type characterizes a two-dimensional matrix of</span>
      <span class="comment">// objects of the (template parameter) &#39;TYPE&#39;.  The numbers of columns</span>
      <span class="comment">// and rows of the matrix can be specified at construction and, at any</span>
      <span class="comment">// time, via the &#39;reset&#39;, &#39;insertRow&#39;, and &#39;insertColumn&#39; methods.  The</span>
      <span class="comment">// value of each element in the matrix can be set and accessed using</span>
      <span class="comment">// the &#39;theValue&#39;, and &#39;theModifiableValue&#39; methods respectively.</span>

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
</pre></div><br/>
<br/>
 Here, we create a type alias, <code>RowType</code>, for an instantiation of <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code> to represent a row of <code>TYPE</code> objects in the matrix. We create another type alias, <code>MatrixType</code>, for an instantiation of <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code> to represent the entire matrix of <code>TYPE</code> objects as a list of rows: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;TYPE&gt;</a>    RowType;
          <span class="comment">// This is an alias representing a row of values of the (template</span>
          <span class="comment">// parameter) &#39;TYPE&#39;.</span>

      <span class="keyword">typedef</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;RowType&gt;</a> MatrixType;
          <span class="comment">// This is an alias representing a two-dimensional matrix of values</span>
          <span class="comment">// of the (template parameter) &#39;TYPE&#39;.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      MatrixType d_matrix;      <span class="comment">// matrix of values</span>
      <span class="keywordtype">int</span>        d_numColumns;  <span class="comment">// number of columns</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> MyMatrix&lt;T&gt;&amp;, <span class="keyword">const</span> MyMatrix&lt;T&gt;&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// PUBLIC TYPES</span>
      <span class="keyword">typedef</span> <span class="keyword">typename</span> MatrixType::const_iterator ConstRowIterator;

      <span class="comment">// CREATORS</span>
      MyMatrix(<span class="keywordtype">int</span>               numRows,
               <span class="keywordtype">int</span>               numColumns,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;MyMatrix&#39; object having the specified &#39;numRows&#39; and</span>
          <span class="comment">// the specified &#39;numColumns&#39;.  All elements of the (template</span>
          <span class="comment">// parameter) &#39;TYPE&#39; in the matrix will have the</span>
          <span class="comment">// default-constructed value.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.  The</span>
          <span class="comment">// behavior is undefined unless &#39;0 &lt;= numRows&#39; and</span>
          <span class="comment">// &#39;0 &lt;= numColumns&#39;</span>

      MyMatrix(<span class="keyword">const</span> MyMatrix&amp;   original,
               <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;MyMatrix&#39; object having the same value as the</span>
          <span class="comment">// specified &#39;original&#39; object.  Optionally specify a</span>
          <span class="comment">// &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is</span>
          <span class="comment">// 0, the currently installed default allocator is used.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      MyMatrix&amp; operator=(<span class="keyword">const</span> MyMatrix&amp; rhs);
          <span class="comment">// Assign to this object the value of the specified &#39;rhs&#39; object,</span>
          <span class="comment">// and return a reference providing modifiable access to this</span>
          <span class="comment">// object.</span>

      <span class="keywordtype">void</span> clear();
          <span class="comment">// Remove all rows and columns from this object.</span>

      <span class="keywordtype">void</span> insertRow(<span class="keywordtype">int</span> rowIndex);
          <span class="comment">// Insert, into this matrix, a row at the specified &#39;rowIndex&#39;.</span>
          <span class="comment">// All elements of the (template parameter) &#39;TYPE&#39; in the row will</span>
          <span class="comment">// have the default-constructed value.  The behavior is undefined</span>
          <span class="comment">// unless &#39;0 &lt;= rowIndex &lt;= numRows()&#39;.</span>

      <span class="keywordtype">void</span> insertColumn(<span class="keywordtype">int</span> columnIndex);
          <span class="comment">// Insert, into this matrix, an column at the specified</span>
          <span class="comment">// &#39;columnIndex&#39;.  All elements of the (template parameter) &#39;TYPE&#39;</span>
          <span class="comment">// in the column will have the default-constructed value.  The</span>
          <span class="comment">// behavior is undefined unless &#39;0 &lt;= columnIndex &lt;= numColumns()&#39;.</span>

      TYPE&amp; theModifiableValue(<span class="keywordtype">int</span> rowIndex, <span class="keywordtype">int</span> columnIndex);
          <span class="comment">// Return a reference providing modifiable access to the element at</span>
          <span class="comment">// the specified &#39;rowIndex&#39; and the specified &#39;columnIndex&#39; in this</span>
          <span class="comment">// matrix.  The behavior is undefined unless</span>
          <span class="comment">// &#39;0 &lt;= rowIndex &lt; numRows()&#39; and</span>
          <span class="comment">// &#39;0 &lt;= columnIndex &lt; numColumns()&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">int</span> numRows() <span class="keyword">const</span>;
          <span class="comment">// Return the number of rows in this matrix.</span>

      <span class="keywordtype">int</span> numColumns() <span class="keyword">const</span>;
          <span class="comment">// Return the number of columns in this matrix.</span>

      ConstRowIterator beginRow() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// &#39;RowType&#39; objects representing the first row in this matrix.</span>

      ConstRowIterator endRow() <span class="keyword">const</span>;
          <span class="comment">// Return an iterator providing non-modifiable access to the</span>
          <span class="comment">// &#39;RowType&#39; objects representing the past-the-end row in this</span>
          <span class="comment">// matrix.</span>

      <span class="keyword">const</span> TYPE&amp; theValue(<span class="keywordtype">int</span> rowIndex, <span class="keywordtype">int</span> columnIndex) <span class="keyword">const</span>;
          <span class="comment">// Return a reference providing non-modifiable access to the</span>
          <span class="comment">// element at the specified &#39;rowIndex&#39; and the specified</span>
          <span class="comment">// &#39;columnIndex&#39; in this matrix.  The behavior is undefined unless</span>
          <span class="comment">// &#39;0 &lt;= rowIndex &lt; numRows()&#39; and</span>
          <span class="comment">// &#39;0 &lt;= columnIndex &lt; numColumns()&#39;.</span>
  };
</pre></div><br/>
<br/>
 Then we declare the free operator for <code>MyMatrix</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyMatrix&lt;TYPE&gt; <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; lhs,
                            <span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same</span>
      <span class="comment">// value, and &#39;false&#39; otherwise.  Two &#39;MyMatrix&#39; objects have the same</span>
      <span class="comment">// value if they have the same number of rows and columns and every</span>
      <span class="comment">// element in both matrices compare equal.</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyMatrix&lt;TYPE&gt; <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; lhs,
                            <span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; rhs);
      <span class="comment">// Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have</span>
      <span class="comment">// the same value, and &#39;false&#39; otherwise.  Two &#39;MyMatrix&#39; objects do</span>
      <span class="comment">// not have the same value if they do not have the same number of rows</span>
      <span class="comment">// and columns or every element in both matrices do not compare equal.</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyMatrix&lt;TYPE&gt; <a class="code" href="namespacebdldfp.html#a8158394e9cee4367a9de15cf73e3646a">operator*</a>(<span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; lhs,
                           <span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; rhs);
      <span class="comment">// Return a &#39;MyMatrix&#39; objects that is the product of the specified</span>
      <span class="comment">// &#39;lhs&#39; and &#39;rhs&#39;.  The behavior is undefined unless</span>
      <span class="comment">// &#39;lhs.numColumns() == rhs.numRows()&#39;.</span>
</pre></div><br/>
<br/>
 Now, we define the methods of <code>MyMatrix</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyMatrix&lt;TYPE&gt;::MyMatrix(<span class="keywordtype">int</span> numRows,
                           <span class="keywordtype">int</span> numColumns,
                           <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_matrix(numRows, basicAllocator)
  , d_numColumns(numColumns)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= numRows);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= numColumns);

      <span class="keywordflow">for</span> (<span class="keyword">typename</span> MatrixType::iterator itr = d_matrix.begin();
           itr != d_matrix.end();
           ++itr) {
          itr-&gt;resize(d_numColumns);
      }
  }
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyMatrix&lt;TYPE&gt;::MyMatrix(<span class="keyword">const</span> MyMatrix&amp; original,
                           <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_matrix(original.d_matrix, basicAllocator)
  , d_numColumns(original.d_numColumns)
  {
  }
</pre></div><br/>
<br/>
 Notice that we pass the contained <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code> (<code>d_matrix</code>) the allocator specified at construction to supply memory. If the (template parameter) <code>TYPE</code> of the elements has the <code>bslalg_TypeTraitUsesBslmaAllocator</code> trait, this allocator will be passed by the vector to the elements as well. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyMatrix&lt;TYPE&gt;&amp; MyMatrix&lt;TYPE&gt;::operator=(<span class="keyword">const</span> MyMatrix&amp; rhs)
  {
      d_matrix = rhs.d_matrix;
      d_numColumns = rhs.d_numColumns;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> MyMatrix&lt;TYPE&gt;::clear()
  {
      d_matrix.clear();
      d_numColumns = 0;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> MyMatrix&lt;TYPE&gt;::insertRow(<span class="keywordtype">int</span> rowIndex)
  {
      <span class="keyword">typename</span> MatrixType::iterator itr =
          d_matrix.insert(d_matrix.begin() + rowIndex, RowType());
      itr-&gt;resize(d_numColumns);
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> MyMatrix&lt;TYPE&gt;::insertColumn(<span class="keywordtype">int</span> colIndex) {
      <span class="keywordflow">for</span> (<span class="keyword">typename</span> MatrixType::iterator itr = d_matrix.begin();
           itr != d_matrix.end();
           ++itr) {
          itr-&gt;insert(itr-&gt;begin() + colIndex, TYPE());
      }
      ++d_numColumns;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  TYPE&amp; MyMatrix&lt;TYPE&gt;::theModifiableValue(<span class="keywordtype">int</span> rowIndex, <span class="keywordtype">int</span> columnIndex)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= rowIndex);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(rowIndex &lt; d_matrix.size());
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= columnIndex);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(columnIndex &lt; d_numColumns);

      <span class="keywordflow">return</span> d_matrix[rowIndex][columnIndex];
  }

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">int</span> MyMatrix&lt;TYPE&gt;::numRows()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_matrix.size();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">int</span> MyMatrix&lt;TYPE&gt;::numColumns()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_numColumns;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">typename</span> MyMatrix&lt;TYPE&gt;::ConstRowIterator MyMatrix&lt;TYPE&gt;::beginRow()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_matrix.begin();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">typename</span> MyMatrix&lt;TYPE&gt;::ConstRowIterator MyMatrix&lt;TYPE&gt;::endRow()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_matrix.end();
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">const</span> TYPE&amp; MyMatrix&lt;TYPE&gt;::theValue(<span class="keywordtype">int</span> rowIndex, <span class="keywordtype">int</span> columnIndex)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= rowIndex);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(rowIndex &lt; d_matrix.size());
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= columnIndex);
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(columnIndex &lt; d_numColumns);

      <span class="keywordflow">return</span> d_matrix[rowIndex][columnIndex];
  }
</pre></div><br/>
<br/>
 Finally, we defines the free operators for <code>MyMatrix</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// FREE OPERATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyMatrix&lt;TYPE&gt; <a class="code" href="group__bslstl__allocator.html#gad6d3f796409781b394c2140195a5b7d2">operator==</a>(<span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; lhs,
                            <span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; rhs)
  {
      <span class="keywordflow">return</span> lhs.d_numColumns == rhs.d_numColumns &amp;&amp;
                                                lhs.d_matrix == rhs.d_matrix;
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  MyMatrix&lt;TYPE&gt; <a class="code" href="group__bslstl__allocator.html#gaf374c3c1f79238d64b145df26aa1845c">operator!=</a>(<span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; lhs,
                            <span class="keyword">const</span> MyMatrix&lt;TYPE&gt;&amp; rhs)
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="gac6e8391c59e60b5a4dfd48e956f3b1c9"></a><!-- doxytag: member="bsl::Vector_ImpBase::reference" ref="gac6e8391c59e60b5a4dfd48e956f3b1c9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE&amp; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="classbsl_1_1Vector__Imp.html#a9d3de812a42c88150d0e0a349ab82c60">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gadb78a996fed8af2d5899cca9dd1a9bc9"></a><!-- doxytag: member="bsl::Vector_ImpBase::const_reference" ref="gadb78a996fed8af2d5899cca9dd1a9bc9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE const&amp; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#gaca634e1eaec2e15e41489ddd3997f916">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga24d7c145ce94bf2f3ae8068569c143b8"></a><!-- doxytag: member="bsl::Vector_ImpBase::iterator" ref="ga24d7c145ce94bf2f3ae8068569c143b8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE* <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga4d36ba02f1f56b7d3625473a13f1bbb9">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga18f44f5ce10b93d15ea3def898eab913"></a><!-- doxytag: member="bsl::Vector_ImpBase::const_iterator" ref="ga18f44f5ce10b93d15ea3def898eab913" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE const* <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gae247ca9f6b273a302bd925b3f0449c0d"></a><!-- doxytag: member="bsl::Vector_ImpBase::size_type" ref="gae247ca9f6b273a302bd925b3f0449c0d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga950b9c5bf2fd674f5f84a930a9e75135">bsl::vector&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga354535932a26dcc4a3021a0db40529ff"></a><!-- doxytag: member="bsl::Vector_ImpBase::difference_type" ref="ga354535932a26dcc4a3021a0db40529ff" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga4c92c0cd3a23f5ba0ec05e91675e58c1">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gaa738a4a015b0459014a402a11f434fa4"></a><!-- doxytag: member="bsl::Vector_ImpBase::value_type" ref="gaa738a4a015b0459014a402a11f434fa4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga1f80e17756d526b21865fe253de14ec0">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga37a11cdffcc2935872a29b90a5b90f4b"></a><!-- doxytag: member="bsl::Vector_ImpBase::reverse_iterator" ref="ga37a11cdffcc2935872a29b90a5b90f4b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#gafa599b89b411e2432aa34da953455b14">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga973722bc781447a95bbe3bad22bee7cd"></a><!-- doxytag: member="bsl::Vector_ImpBase::const_reverse_iterator" ref="ga973722bc781447a95bbe3bad22bee7cd" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga9e2e1498f06434da2754aa4b893145a0">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gaca634e1eaec2e15e41489ddd3997f916"></a><!-- doxytag: member="bsl::Vector_Imp::const_reference" ref="gaca634e1eaec2e15e41489ddd3997f916" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_reference <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gadb78a996fed8af2d5899cca9dd1a9bc9">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga9ab3c6019d7c47aa4100b404513cc1e9">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d36ba02f1f56b7d3625473a13f1bbb9"></a><!-- doxytag: member="bsl::Vector_Imp::iterator" ref="ga4d36ba02f1f56b7d3625473a13f1bbb9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE* <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga24d7c145ce94bf2f3ae8068569c143b8">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga5a97b5d28ad35744384447175b368b3c">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga0cd0846f3e77c27d31e494f6983c6d2a"></a><!-- doxytag: member="bsl::Vector_Imp::const_iterator" ref="ga0cd0846f3e77c27d31e494f6983c6d2a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE const* <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga18f44f5ce10b93d15ea3def898eab913">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga2954bfae57cec2922d80838c055258cc"></a><!-- doxytag: member="bsl::Vector_Imp::size_type" ref="ga2954bfae57cec2922d80838c055258cc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga950b9c5bf2fd674f5f84a930a9e75135">bsl::vector&lt; VALUE_TYPE, ALLOCATOR &gt;</a>, <a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, <a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga950b9c5bf2fd674f5f84a930a9e75135">bsl::vector&lt; char &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga4c92c0cd3a23f5ba0ec05e91675e58c1"></a><!-- doxytag: member="bsl::Vector_Imp::difference_type" ref="ga4c92c0cd3a23f5ba0ec05e91675e58c1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga354535932a26dcc4a3021a0db40529ff">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga999efeb5f3915fb3501aad640cad4849">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga5308963c5edb86c346bc1f14576a71ad">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f80e17756d526b21865fe253de14ec0"></a><!-- doxytag: member="bsl::Vector_Imp::value_type" ref="ga1f80e17756d526b21865fe253de14ec0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gaa738a4a015b0459014a402a11f434fa4">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#gabde26ba05b21196782157a1f8a76dabe">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga3385240d8b8b8b1241daea914944818b">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gadf855a9b9d8659fef24bbff380847a09"></a><!-- doxytag: member="bsl::Vector_Imp::allocator_type" ref="gadf855a9b9d8659fef24bbff380847a09" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga1376a22b6e9b3c12f1e67dc5f3b1c2f8">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga55b2f2ba3be58a312c86e829bea00079">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gaa4ba7599bad447463c136ddde706fe89"></a><!-- doxytag: member="bsl::Vector_Imp::pointer" ref="gaa4ba7599bad447463c136ddde706fe89" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::pointer <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga7c87e3765a9fe91486ad51a3193bdf1e">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#gaa982216c00abe2084c2c863dc0254511">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gad76280cde3c26148167685e86d916257"></a><!-- doxytag: member="bsl::Vector_Imp::const_pointer" ref="gad76280cde3c26148167685e86d916257" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_pointer <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga02cc4f8f85a558c7e6fa47050aa5df4e">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga724824e0e6971c79b509b5a8151a9b36">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gafa599b89b411e2432aa34da953455b14"></a><!-- doxytag: member="bsl::Vector_Imp::reverse_iterator" ref="gafa599b89b411e2432aa34da953455b14" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga37a11cdffcc2935872a29b90a5b90f4b">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga4b85fe9e069f48f8c39db04ac4593b68">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e2e1498f06434da2754aa4b893145a0"></a><!-- doxytag: member="bsl::Vector_Imp::const_reverse_iterator" ref="ga9e2e1498f06434da2754aa4b893145a0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga973722bc781447a95bbe3bad22bee7cd">bsl::Vector_ImpBase&lt; VALUE_TYPE &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga49d2191a36776ea8b8b09270dabcf6bc">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga950b9c5bf2fd674f5f84a930a9e75135"></a><!-- doxytag: member="bsl::vector::size_type" ref="ga950b9c5bf2fd674f5f84a930a9e75135" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Base::size_type <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">bsl::Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gabd67713b2dc4fb388a6c9e9664505153"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::reference" ref="gabd67713b2dc4fb388a6c9e9664505153" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classbsl_1_1Vector__Imp.html#a9d3de812a42c88150d0e0a349ab82c60">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga9ab3c6019d7c47aa4100b404513cc1e9"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_reference" ref="ga9ab3c6019d7c47aa4100b404513cc1e9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gaca634e1eaec2e15e41489ddd3997f916">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga5a97b5d28ad35744384447175b368b3c"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::iterator" ref="ga5a97b5d28ad35744384447175b368b3c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE** <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga4d36ba02f1f56b7d3625473a13f1bbb9">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gaf63525577a811da914699b2083873ecc"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_iterator" ref="gaf63525577a811da914699b2083873ecc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE* const* <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga072e1d3b72efeb60bde40edfb4934d11"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::size_type" ref="ga072e1d3b72efeb60bde40edfb4934d11" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga999efeb5f3915fb3501aad640cad4849"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::difference_type" ref="ga999efeb5f3915fb3501aad640cad4849" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga4c92c0cd3a23f5ba0ec05e91675e58c1">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gabde26ba05b21196782157a1f8a76dabe"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::value_type" ref="gabde26ba05b21196782157a1f8a76dabe" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE_TYPE* <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga1f80e17756d526b21865fe253de14ec0">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga1376a22b6e9b3c12f1e67dc5f3b1c2f8"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::allocator_type" ref="ga1376a22b6e9b3c12f1e67dc5f3b1c2f8" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gadf855a9b9d8659fef24bbff380847a09">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c87e3765a9fe91486ad51a3193bdf1e"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::pointer" ref="ga7c87e3765a9fe91486ad51a3193bdf1e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::pointer <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gaa4ba7599bad447463c136ddde706fe89">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga02cc4f8f85a558c7e6fa47050aa5df4e"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_pointer" ref="ga02cc4f8f85a558c7e6fa47050aa5df4e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_pointer <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gad76280cde3c26148167685e86d916257">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b85fe9e069f48f8c39db04ac4593b68"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::reverse_iterator" ref="ga4b85fe9e069f48f8c39db04ac4593b68" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gafa599b89b411e2432aa34da953455b14">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga49d2191a36776ea8b8b09270dabcf6bc"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_reverse_iterator" ref="ga49d2191a36776ea8b8b09270dabcf6bc" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga9e2e1498f06434da2754aa4b893145a0">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga49f23f56e64250ad863d15193ada7d3e"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reference" ref="ga49f23f56e64250ad863d15193ada7d3e" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="classbsl_1_1Vector__Imp.html#a9d3de812a42c88150d0e0a349ab82c60">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga74c04a33092057079255ade18163ded6"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_reference" ref="ga74c04a33092057079255ade18163ded6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gaca634e1eaec2e15e41489ddd3997f916">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga4291d2e6fef9b494c54cc6083d659ca0"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::iterator" ref="ga4291d2e6fef9b494c54cc6083d659ca0" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const VALUE_TYPE** <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga4d36ba02f1f56b7d3625473a13f1bbb9">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga67e0e0b7f2336c267c4884e8c340c156"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_iterator" ref="ga67e0e0b7f2336c267c4884e8c340c156" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const VALUE_TYPE* const* <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gae4813c4ee19eb083b1a358ea9238fe54"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::size_type" ref="gae4813c4ee19eb083b1a358ea9238fe54" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga5308963c5edb86c346bc1f14576a71ad"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::difference_type" ref="ga5308963c5edb86c346bc1f14576a71ad" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::difference_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga4c92c0cd3a23f5ba0ec05e91675e58c1">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga3385240d8b8b8b1241daea914944818b"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::value_type" ref="ga3385240d8b8b8b1241daea914944818b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef const VALUE_TYPE* <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::value_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga1f80e17756d526b21865fe253de14ec0">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga55b2f2ba3be58a312c86e829bea00079"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::allocator_type" ref="ga55b2f2ba3be58a312c86e829bea00079" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gadf855a9b9d8659fef24bbff380847a09">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gaa982216c00abe2084c2c863dc0254511"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::pointer" ref="gaa982216c00abe2084c2c863dc0254511" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::pointer <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gaa4ba7599bad447463c136ddde706fe89">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga724824e0e6971c79b509b5a8151a9b36"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_pointer" ref="ga724824e0e6971c79b509b5a8151a9b36" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR::const_pointer <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_pointer<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gad76280cde3c26148167685e86d916257">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d96c143e028e4314212bdba9ef9ef8a"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reverse_iterator" ref="ga2d96c143e028e4314212bdba9ef9ef8a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;iterator&gt; <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#gafa599b89b411e2432aa34da953455b14">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gaa1210066404446c90e43dc1b7ca1a94d"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_reverse_iterator" ref="gaa1210066404446c90e43dc1b7ca1a94d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;const_iterator&gt; <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_reverse_iterator<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga9e2e1498f06434da2754aa4b893145a0">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga8264920698cfb33deb64977f93dd6bff"></a><!-- doxytag: member="bsl::Vector_Util::swap" ref="ga8264920698cfb33deb64977f93dd6bff" args="(void *a, void *b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bsl::Vector_Util::swap </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of the specified <code>a</code> vector with that of the specified <code>b</code> vector. </p>

</div>
</div>
<a class="anchor" id="gaf269e14b5972863897b472606b524ea0"></a><!-- doxytag: member="bsl::Vector_ImpBase::Vector_ImpBase" ref="gaf269e14b5972863897b472606b524ea0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::Vector_ImpBase </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize this object to empty with 0 capacity. </p>

</div>
</div>
<a class="anchor" id="ga5b7f9c7b9b0be302ee1b7533b9764ef1"></a><!-- doxytag: member="bsl::Vector_ImpBase::begin" ref="ga5b7f9c7b9b0be302ee1b7533b9764ef1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga7eb9edf13eb71d39489477702fa09671"></a><!-- doxytag: member="bsl::Vector_ImpBase::end" ref="ga7eb9edf13eb71d39489477702fa09671" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga6080200616b755699e352155c7572d98"></a><!-- doxytag: member="bsl::Vector_ImpBase::rbegin" ref="ga6080200616b755699e352155c7572d98" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="gafe52ce718a880c32d4bd69ed3bc65d3b"></a><!-- doxytag: member="bsl::Vector_ImpBase::rend" ref="gafe52ce718a880c32d4bd69ed3bc65d3b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this modifiable vector. </p>

</div>
</div>
<a class="anchor" id="gaed1d2854dd5aaf5c0734202f5f43d42d"></a><!-- doxytag: member="bsl::Vector_ImpBase::operator[]" ref="gaed1d2854dd5aaf5c0734202f5f43d42d" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>position</code> in this vector. The behavior is undefined unless <code>0 &lt;= position &lt; size()</code>. </p>

</div>
</div>
<a class="anchor" id="gacd7de02bfa273ac7643909b55502e462"></a><!-- doxytag: member="bsl::Vector_ImpBase::at" ref="gacd7de02bfa273ac7643909b55502e462" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>position</code> in this vector. Throws <code>std::out_of_range</code> if <code>position &gt;= size()</code>. </p>

</div>
</div>
<a class="anchor" id="ga547e809dc68789a250cd367760601d78"></a><!-- doxytag: member="bsl::Vector_ImpBase::front" ref="ga547e809dc68789a250cd367760601d78" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the first position in this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gad737a7196152ddb07b059506a070d149"></a><!-- doxytag: member="bsl::Vector_ImpBase::back" ref="gad737a7196152ddb07b059506a070d149" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the last position in this vector. The behavior is undefined if this vector is empty. Note that the last position is <code>size() - 1</code>. </p>

</div>
</div>
<a class="anchor" id="gad98d192f5ea0af3ec3c6b5dabca1faa3"></a><!-- doxytag: member="bsl::Vector_ImpBase::data" ref="gad98d192f5ea0af3ec3c6b5dabca1faa3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE_TYPE* <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable first element in this vector, or a valid, but non-dereferenceable pointer value if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="ga0eb1a2336108dd9a87ba8682fe199837"></a><!-- doxytag: member="bsl::Vector_ImpBase::begin" ref="ga0eb1a2336108dd9a87ba8682fe199837" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this non-modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga0a53fc2c03dcc45dcba8fe6bf7298259"></a><!-- doxytag: member="bsl::Vector_ImpBase::cbegin" ref="ga0a53fc2c03dcc45dcba8fe6bf7298259" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this non-modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga4f6ee393ad3b6d9a72f13b15a95ea32a"></a><!-- doxytag: member="bsl::Vector_ImpBase::end" ref="ga4f6ee393ad3b6d9a72f13b15a95ea32a" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga4a98f38e4458d7323fb526adf8c87da5"></a><!-- doxytag: member="bsl::Vector_ImpBase::cend" ref="ga4a98f38e4458d7323fb526adf8c87da5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga0dd4792a346dae5157c7f4a4f7ee25f9"></a><!-- doxytag: member="bsl::Vector_ImpBase::rbegin" ref="ga0dd4792a346dae5157c7f4a4f7ee25f9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this non-modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga259f561373a610c2accfdf2961596c7d"></a><!-- doxytag: member="bsl::Vector_ImpBase::crbegin" ref="ga259f561373a610c2accfdf2961596c7d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this non-modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga1f35ca07ac717fbc40e7cf3d755cc61f"></a><!-- doxytag: member="bsl::Vector_ImpBase::rend" ref="ga1f35ca07ac717fbc40e7cf3d755cc61f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="gaf7cd9b62a54f46268ef4d55c8358abbb"></a><!-- doxytag: member="bsl::Vector_ImpBase::crend" ref="gaf7cd9b62a54f46268ef4d55c8358abbb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga6b5f3f3e0564b62536fd52679d99bdbd"></a><!-- doxytag: member="bsl::Vector_ImpBase::size" ref="ga6b5f3f3e0564b62536fd52679d99bdbd" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this vector. </p>

</div>
</div>
<a class="anchor" id="ga22982ebdac58b9b9a89e339feeeb8eb6"></a><!-- doxytag: member="bsl::Vector_ImpBase::capacity" ref="ga22982ebdac58b9b9a89e339feeeb8eb6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the capacity of this vector, i.e., the maximum number of elements for which resizing is guaranteed not to trigger a reallocation. </p>

</div>
</div>
<a class="anchor" id="gad77dd3f93b278367659e8d1489df4a86"></a><!-- doxytag: member="bsl::Vector_ImpBase::empty" ref="gad77dd3f93b278367659e8d1489df4a86" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this vector has size 0, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gaf92663fe0dfe8dd17097054a4c115626"></a><!-- doxytag: member="bsl::Vector_ImpBase::operator[]" ref="gaf92663fe0dfe8dd17097054a4c115626" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>position</code> in this vector. The behavior is undefined unless <code>0 &lt;= position &lt; size()</code>. </p>

</div>
</div>
<a class="anchor" id="gaf7db0521ebb67c49b5625972ebb0d944"></a><!-- doxytag: member="bsl::Vector_ImpBase::at" ref="gaf7db0521ebb67c49b5625972ebb0d944" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>position</code>. Throws <code>std::out_of_range</code> if <code>position &gt;= size()</code>. </p>

</div>
</div>
<a class="anchor" id="gab884eb9fa93b6f6fb1e748978b6b7136"></a><!-- doxytag: member="bsl::Vector_ImpBase::front" ref="gab884eb9fa93b6f6fb1e748978b6b7136" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the first position in this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="ga813678ea2bee5b416ffaae85b1005dd2"></a><!-- doxytag: member="bsl::Vector_ImpBase::back" ref="ga813678ea2bee5b416ffaae85b1005dd2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the last position in this vector. The behavior is undefined if this vector is empty. Note that the last position is <code>size() - 1</code>. </p>

</div>
</div>
<a class="anchor" id="gae6c1ea9e07542194c9bd652087e49974"></a><!-- doxytag: member="bsl::Vector_ImpBase::data" ref="gae6c1ea9e07542194c9bd652087e49974" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE_TYPE* <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the non-modifiable first element in this vector, or a valid, but non-dereferenceable pointer value if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="ga4bcd4f97cf1731cfa3a07320b29e9163"></a><!-- doxytag: member="bsl::Vector_Imp::Guard::Guard" ref="ga4bcd4f97cf1731cfa3a07320b29e9163" args="(VALUE_TYPE *data, std::size_t capacity, VectorContainerBase *container)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Guard::Guard </td>
          <td>(</td>
          <td class="paramtype">VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&nbsp;</td>
          <td class="paramname"> <em>capacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VectorContainerBase *&nbsp;</td>
          <td class="paramname"> <em>container</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a proctor for the specified <code>data</code> array of the specified <code>capacity</code>, using the <code>deallocateN</code> method of the specified <code>container</code> to return <code>data</code> to its allocator upon destruction, unless this proctor's <code>release</code> is called prior. </p>

</div>
</div>
<a class="anchor" id="ga627ffc01b497e5517ccb83b60fddebfb"></a><!-- doxytag: member="bsl::Vector_Imp::Guard::~Guard" ref="ga627ffc01b497e5517ccb83b60fddebfb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Guard::~Guard </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this proctor, deallocating any data under management. </p>

</div>
</div>
<a class="anchor" id="ga4385b427bfd450fb3189a1e735d18029"></a><!-- doxytag: member="bsl::Vector_Imp::Guard::release" ref="ga4385b427bfd450fb3189a1e735d18029" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Guard::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Release the data from management by this proctor. </p>

</div>
</div>
<a class="anchor" id="ga284fe64b913f45e344f50ff54983ca86"></a><!-- doxytag: member="bsl::Vector_Imp::Vector_Imp" ref="ga284fe64b913f45e344f50ff54983ca86" args="(const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Vector_Imp </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty vector. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, a default-constructed allocator is used. </p>

</div>
</div>
<a class="anchor" id="ga97c6d794f60bcc049dfb246840af3ae5"></a><!-- doxytag: member="bsl::Vector_Imp::Vector_Imp" ref="ga97c6d794f60bcc049dfb246840af3ae5" args="(size_type initialSize, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Vector_Imp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector of the specified <code>initialSize</code> whose every element is default-constructed. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, a default-constructed allocator is used. Throw <code>std::length_error</code> if <code>initialSize &gt; max_size()</code>. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.default-constructible" class="glossary">default-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga51468b963e6f9cc53e3ef8501e5822f4"></a><!-- doxytag: member="bsl::Vector_Imp::Vector_Imp" ref="ga51468b963e6f9cc53e3ef8501e5822f4" args="(size_type initialSize, const VALUE_TYPE &amp;value, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Vector_Imp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>initialSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector of the specified <code>initialSize</code> whose every element equals the specified <code>value</code>. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, a default-constructed allocator is used. Throw <code>std::length_error</code> if <code>initialSize &gt; max_size()</code>. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga29978342ad70c393ce602b58f8a359a5"></a><!-- doxytag: member="bsl::Vector_Imp::Vector_Imp" ref="ga29978342ad70c393ce602b58f8a359a5" args="(INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;basicAllocator=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Vector_Imp </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector initially containing copies of the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, a default-constructed allocator is used. Throw <code>std::length_error</code> if the number of elements in <code>[ first, last )</code> exceeds the value returned by the method <code>max_size</code>. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga9fb9c29f67db4c74fca0804e28605b98"></a><!-- doxytag: member="bsl::Vector_Imp::Vector_Imp" ref="ga9fb9c29f67db4c74fca0804e28605b98" args="(const Vector_Imp &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Vector_Imp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae31bfd1e98019fc6fadefcbb504b80cf"></a><!-- doxytag: member="bsl::Vector_Imp::Vector_Imp" ref="gae31bfd1e98019fc6fadefcbb504b80cf" args="(const Vector_Imp &amp;original, const ALLOCATOR &amp;basicAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::Vector_Imp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector that has the same value as the specified <code>original</code> vector. Optionally specify the <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is not specified, then if <code>ALLOCATOR</code> is convertible from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>, the currently installed default allocator is used, otherwise the <code>original</code> allocator is used (as mandated per the ISO standard). This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga688d9df2c46cac0599b2aa4346131965"></a><!-- doxytag: member="bsl::Vector_Imp::~Vector_Imp" ref="ga688d9df2c46cac0599b2aa4346131965" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::~Vector_Imp </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this vector. </p>

</div>
</div>
<a class="anchor" id="ga6a8b9a37bd5bbd1eb310cd5fe2a10665"></a><!-- doxytag: member="bsl::Vector_Imp::operator=" ref="ga6a8b9a37bd5bbd1eb310cd5fe2a10665" args="(const Vector_Imp &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Vector_Imp&amp; <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this vector the value of the specified <code>other</code> vector and return a reference to this modifiable vector. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga81fed82a60da7d7c72724f95bfa7ac7f"></a><!-- doxytag: member="bsl::Vector_Imp::assign" ref="ga81fed82a60da7d7c72724f95bfa7ac7f" args="(INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this vector the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. Note that this vector will be left in an empty state in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga5de26b249081554ec1cb21b3f7b43df5">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga80beed773775ff491a560d9827470983">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga142315e14e55d68bb9edf0c9c227feb0"></a><!-- doxytag: member="bsl::Vector_Imp::assign" ref="ga142315e14e55d68bb9edf0c9c227feb0" args="(size_type numElements, const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this vector the value of the vector of the specified <code>numElements</code> size whose every elements equal the specified <code>value</code>. Note that this vector will be left in an empty state in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac5203d4410a4c7c3d1d2014d5542e0d9"></a><!-- doxytag: member="bsl::Vector_Imp::resize" ref="gac5203d4410a4c7c3d1d2014d5542e0d9" args="(size_type newSize)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4fedf6842b169a88be67a5758b3aa229"></a><!-- doxytag: member="bsl::Vector_Imp::resize" ref="ga4fedf6842b169a88be67a5758b3aa229" args="(size_type newSize, const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the size of this vector to the specified <code>newSize</code>, erasing elements at the end if <code>newSize &lt; size()</code> or appending the appropriate number of copies of the optionally specified <code>value</code> at the end if <code>size() &lt; newSize</code>. If <code>value</code> is not specified, a default-constructed value is used. Throw <code>std::length_error</code> if <code>newSize &gt; max_size()</code>. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be "copy-constructible" if <code>value</code> is specified and "default-constructible" otherwise (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac931be06971aedc190c1191a00ee251a"></a><!-- doxytag: member="bsl::Vector_Imp::reserve" ref="gac931be06971aedc190c1191a00ee251a" args="(size_type newCapacity)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newCapacity</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the capacity of this vector to the specified <code>newCapacity</code>. Note that the capacity of a vector is the maximum number of elements it can accommodate without reallocation. The actual storage allocated may be higher. </p>

</div>
</div>
<a class="anchor" id="gaf5dd77d0be1e77193b7289fc08e828ec"></a><!-- doxytag: member="bsl::Vector_Imp::shrink_to_fit" ref="gaf5dd77d0be1e77193b7289fc08e828ec" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reduce the capacity of this vector to its size. The method has no effect if the capacity is equivalent to the size. </p>

</div>
</div>
<a class="anchor" id="ga332db0292e3c1107be19e02fd9f22299"></a><!-- doxytag: member="bsl::Vector_Imp::emplace_back" ref="ga332db0292e3c1107be19e02fd9f22299" args="(Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a new element to the end of this vector, constructed directly in place from the specified <code>args</code>. The <code>args</code> are passed to the constructor using "perfect forwarding", meaning move semantics will be utilized for rvalued elements that implement them. The combination of constructing in place and "perfect forwarding" means that when move semantics are availible, elements in <code>args</code> will not be copied at all. When move semantics are not availible, elements in <code>args</code> will be copied only once. This method provides the strong exception safety guarentee, so the state of this object will not be changed if an exception is thrown (such as when allocating memory, or from operations of <code>VALUE_TYPE</code>). </p>

</div>
</div>
<a class="anchor" id="gaa1d6a35af66d87307ee9a48be96644a5"></a><!-- doxytag: member="bsl::Vector_Imp::push_back" ref="gaa1d6a35af66d87307ee9a48be96644a5" args="(const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a copy of the specified <code>value</code> at the end of this vector. This method provides the strong exception safety guarantee, so the state of this object will not be changed if an exception is thrown (such as when allocating memory, or from operations of <code>VALUE_TYPE</code>). This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8fbe1d9aac697597bce2b527b8208003"></a><!-- doxytag: member="bsl::Vector_Imp::pop_back" ref="ga8fbe1d9aac697597bce2b527b8208003" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase the last element from this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gadeebf7a713dc053843dee059e23e9375"></a><!-- doxytag: member="bsl::Vector_Imp::emplace" ref="gadeebf7a713dc053843dee059e23e9375" args="(const_iterator position, Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE_TYPE* <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa856a23873fe4d5354e0d8b63f0b0659"></a><!-- doxytag: member="bsl::Vector_Imp::insert" ref="gaa856a23873fe4d5354e0d8b63f0b0659" args="(const_iterator position, const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector a copy of the specified <code>value</code>, and return an iterator pointing to the newly inserted element. If <code>value</code> has move semantics, then its value is valid but unspecified upon returning from this function. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code> (both endpoints included). Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaf28f2fa76a6acfe212d1dee103c2dafe"></a><!-- doxytag: member="bsl::Vector_Imp::insert" ref="gaf28f2fa76a6acfe212d1dee103c2dafe" args="(const_iterator position, size_type numElements, const VALUE_TYPE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector a number equal to the specified <code>numElements</code> of copies of the specified <code>value</code>. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code> (both endpoints included). Note that this method offers full guarantee of rollback in case an exception is throw is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gadc116debf5b1eb8a37aa4d0bd85213b2"></a><!-- doxytag: member="bsl::Vector_Imp::insert" ref="gadc116debf5b1eb8a37aa4d0bd85213b2" args="(const_iterator position, INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() ]</code> (both endpoints included). Note that this method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8398ddeb0509741ce8734bc4eb5d5654"></a><!-- doxytag: member="bsl::Vector_Imp::erase" ref="ga8398ddeb0509741ce8734bc4eb5d5654" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this vector the element at the specified <code>position</code>, and return an iterator pointing to the element immediately following the removed element, or to the position returned by the <code>end</code> method if the removed element was the last in the sequence. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[ begin(), end() )</code>. </p>

</div>
</div>
<a class="anchor" id="ga840ceb3ecb6c53492e8a5b73fbe7501d"></a><!-- doxytag: member="bsl::Vector_Imp::erase" ref="ga840ceb3ecb6c53492e8a5b73fbe7501d" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this vector the elements starting at the specified <code>first</code> position that are before the specified <code>last</code> position, and return an iterator pointing to the element immediately following the last removed element, or the position returned by the method <code>end</code> if the removed elements were last in the sequence. The behavior is undefined unless <code>first</code> is an iterator in the range <code>[ begin(), end() ]</code> and <code>last</code> is an iterator in the range <code>[ first, end() ]</code> (both endpoints included). </p>

</div>
</div>
<a class="anchor" id="gac169aabe4c02a46527a12822254293ea"></a><!-- doxytag: member="bsl::Vector_Imp::swap" ref="gac169aabe4c02a46527a12822254293ea" args="(Vector_Imp &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this vector with that of the specified <code>other</code> vector, such that each vector has, upon return, the value of the other vector prior to this call. This method does not throw or invalidate iterators if <code>get_allocator</code>, invoked on this vector and <code>other</code>, returns the same value. </p>

</div>
</div>
<a class="anchor" id="gae9fa4fec3242df3b8c6a70118726304d"></a><!-- doxytag: member="bsl::Vector_Imp::clear" ref="gae9fa4fec3242df3b8c6a70118726304d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the elements from this vector. Note that this vector is empty after this call, but conserves the same capacity. </p>

</div>
</div>
<a class="anchor" id="ga8d52d78392a987e2864466198f37fb62"></a><!-- doxytag: member="bsl::Vector_Imp::get_allocator" ref="ga8d52d78392a987e2864466198f37fb62" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the allocator used by this vector to supply memory. </p>

<p>Reimplemented in <a class="el" href="group__bslstl__vector.html#ga87fc99fbeadf2f8b9e165eb363d1cc81">bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__vector.html#ga8f61cc68c2ce841df5d6a084d750dae3">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga66cf2ced34b3c15613d0ba2acc86f5c1"></a><!-- doxytag: member="bsl::Vector_Imp::max_size" ref="ga66cf2ced34b3c15613d0ba2acc86f5c1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum possible size for this vector. Note that requests to create a vector longer than this number of elements are guaranteed to raise a <code>std::length_error</code> exception. </p>

</div>
</div>
<a class="anchor" id="gae1cf7ebaf57b20ad849f3cec698e88b9"></a><!-- doxytag: member="bsl::operator==" ref="gae1cf7ebaf57b20ad849f3cec698e88b9" args="(const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> vector has the same value as the specified <code>rhs</code> vector. Two vectors have the same value if they have the same number of elements and the same element value at each index position in the range 0 to <code>size() - 1</code>. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga3b21b4b523ef349a450e774e69fba3a2"></a><!-- doxytag: member="bsl::operator!=" ref="ga3b21b4b523ef349a450e774e69fba3a2" args="(const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> vector does not have the same value as the specified <code>rhs</code> vector. Two vectors do not have the same value if they have different numbers of elements or different element values in at least one index position in the range 0 to <code>size() - 1</code>. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.equality-comparable" class="glossary">equality-comparable</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gafae8e5536e4d0104153320a37e8c1e3a"></a><!-- doxytag: member="bsl::operator&lt;" ref="gafae8e5536e4d0104153320a37e8c1e3a" args="(const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> vector is lexicographically smaller than the specified <code>rhs</code> vector, and <code>false</code> otherwise. A vector <code>lhs</code> is lexicographically smaller than another vector <code>rhs</code> if there exists an index <code>i</code> between 0 and the minimum of <code>lhs.size()</code> and <code>rhs.size()</code> such that <code>lhs[i] == rhs[j]</code> for every <code>0 &lt;= j &lt; i</code>, <code>i &lt; rhs.size()</code>, and either <code>i == lhs.size()</code> or <code>lhs[i] &lt; rhs[i]</code>. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga625351fd0ddd03d582652b3aae6ebbc9"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga625351fd0ddd03d582652b3aae6ebbc9" args="(const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> vector is lexicographically larger than the specified <code>rhs</code> vector, and <code>false</code> otherwise. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga9300705f377d58094c8b40530816ffb7"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga9300705f377d58094c8b40530816ffb7" args="(const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> vector is lexicographically smaller than or equal to the specified <code>rhs</code> vector, and <code>false</code> otherwise. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga4310a39a792a2712adaa5104a67a0bf8"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga4310a39a792a2712adaa5104a67a0bf8" args="(const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> vector is lexicographically larger than the specified <code>rhs</code> vector, and <code>false</code> otherwise. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.less-than-comparable" class="glossary">less-than-comparable</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga73c7729c8388a194029dab1d69d08360"></a><!-- doxytag: member="bsl::swap" ref="ga73c7729c8388a194029dab1d69d08360" args="(Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;a, Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Vector_Imp&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of the specified <code>a</code> vector with that of the specified <code>b</code> vector, such that each vector has upon return the value of the other vector prior to this call. Note that this function does not throw if <code>lhs.get_allocator()</code> and <code>rhs.get_allocator()</code> are equal. </p>

</div>
</div>
<a class="anchor" id="ga8328b2e4c53f551aff7d2214c64a8fc6"></a><!-- doxytag: member="bsl::vector::vector" ref="ga8328b2e4c53f551aff7d2214c64a8fc6" args="(const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty vector. Optionally specify an allocator <code>alloc</code> used to supply memory. If <code>alloc</code> is not specified, a default-constructed allocator is used. </p>

</div>
</div>
<a class="anchor" id="ga5041cf05bb3c096dc9ac7d9ab7622b42"></a><!-- doxytag: member="bsl::vector::vector" ref="ga5041cf05bb3c096dc9ac7d9ab7622b42" args="(size_type n, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga950b9c5bf2fd674f5f84a930a9e75135">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector of the specified size <code>n</code> whose every element is default-constructed. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not specified, a default-constructed allocator is used. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.default-constructible" class="glossary">default-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaa3e74030769c96731f89650b88b266ca"></a><!-- doxytag: member="bsl::vector::vector" ref="gaa3e74030769c96731f89650b88b266ca" args="(size_type n, const VALUE_TYPE &amp;value, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga950b9c5bf2fd674f5f84a930a9e75135">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector of the specified size <code>n</code> whose every element equals the specified <code>value</code>. Optionally specify an allocator <code>alloc</code> used to supply memory. If <code>alloc</code> is not specified, a default-constructed allocator is used. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga85ed9bce9c0a6cd632370f8ad1bbfe2a"></a><!-- doxytag: member="bsl::vector::vector" ref="ga85ed9bce9c0a6cd632370f8ad1bbfe2a" args="(INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector initially containing copies of the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. Optionally specify an allocator <code>alloc</code> used to supply memory. If <code>alloc</code> is not specified, a default-constructed allocator is used. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gad6aee9294aa848f350279f61830ca372"></a><!-- doxytag: member="bsl::vector::vector" ref="gad6aee9294aa848f350279f61830ca372" args="(const vector &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad5ed08a31f91d6b2c79d9e7c0752814d"></a><!-- doxytag: member="bsl::vector::vector" ref="gad5ed08a31f91d6b2c79d9e7c0752814d" args="(const vector &amp;original, const ALLOCATOR &amp;alloc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a vector that has the same value as the specified <code>original</code> vector. Optionally specify an allocator <code>alloc</code> used to supply memory. If <code>alloc</code> is not specified, then if <code>ALLOCATOR</code> is convertible from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>, the currently installed default allocator is used, otherwise the <code>original</code> allocator is used (as mandated per the ISO standard). This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga14c35993dffc40a4366db40b6461003e"></a><!-- doxytag: member="bsl::vector::~vector" ref="ga14c35993dffc40a4366db40b6461003e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::~vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this vector. </p>

</div>
</div>
<a class="anchor" id="gaa65ad70520f2bb5fcd615c7163f64e01"></a><!-- doxytag: member="bsl::vector::operator=" ref="gaa65ad70520f2bb5fcd615c7163f64e01" args="(const vector &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE, class ALLOCATOR = bsl::allocator&lt;VALUE_TYPE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&amp; <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this vector the value of the specified <code>other</code> vector and return a reference to this modifiable vector. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga1829ad82eb519b1fb7c79a803af91153"></a><!-- doxytag: member="bsl::operator==" ref="ga1829ad82eb519b1fb7c79a803af91153" args="(const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae2296fbb2872dbb82c90f7c41ab6ca41"></a><!-- doxytag: member="bsl::operator!=" ref="gae2296fbb2872dbb82c90f7c41ab6ca41" args="(const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaaa78d320fb70553c12c5ac664ef03e4e"></a><!-- doxytag: member="bsl::operator&lt;" ref="gaaa78d320fb70553c12c5ac664ef03e4e" args="(const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9fefac8bbb8472a45f2f021b3045b886"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga9fefac8bbb8472a45f2f021b3045b886" args="(const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad43a151e8130ffa1975e64bceae4cfef"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gad43a151e8130ffa1975e64bceae4cfef" args="(const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga926b2d565333233f7bca60072014322a"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga926b2d565333233f7bca60072014322a" args="(const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gabaf47fbdf5a80691a93069d8e5041e90"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="gabaf47fbdf5a80691a93069d8e5041e90" args="(const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0c1cc0f422360c7d58dfcb64f79529c5"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga0c1cc0f422360c7d58dfcb64f79529c5" args="(size_type n, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9ce6f8d6734545c00615962da7f39611"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga9ce6f8d6734545c00615962da7f39611" args="(size_type n, VALUE_TYPE *value, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga60d71628e72898d8584e3378ed1dfe32"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga60d71628e72898d8584e3378ed1dfe32" args="(INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga152981423ce926f8024acbd0a976de11"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga152981423ce926f8024acbd0a976de11" args="(const vector &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga818a2d9d0fb6027b41f79612b6f979a1"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga818a2d9d0fb6027b41f79612b6f979a1" args="(const vector &amp;original, const ALLOCATOR &amp;alloc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6dcf3a85a5d8b27bda092b4a504cc6fa"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::~vector" ref="ga6dcf3a85a5d8b27bda092b4a504cc6fa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::~vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad28e356adf09adaf80b1f800bcddd5a5"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator=" ref="gad28e356adf09adaf80b1f800bcddd5a5" args="(const vector &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&amp; <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5de26b249081554ec1cb21b3f7b43df5"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::assign" ref="ga5de26b249081554ec1cb21b3f7b43df5" args="(INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this vector the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. Note that this vector will be left in an empty state in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga81fed82a60da7d7c72724f95bfa7ac7f">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="gadefaed4ca7f4d26ff6ee384e0476b124"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::assign" ref="gadefaed4ca7f4d26ff6ee384e0476b124" args="(size_type numElements, VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga318ef936958ee98c2f298f1a31b922f7"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::begin" ref="ga318ef936958ee98c2f298f1a31b922f7" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga55d52f185850254ecb4b6ec28b9f8d6d"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::end" ref="ga55d52f185850254ecb4b6ec28b9f8d6d" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1b4b7957e130864312eca3df390fb785"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rbegin" ref="ga1b4b7957e130864312eca3df390fb785" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4288784db009e96af1eff77d09b90fc1"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rend" ref="ga4288784db009e96af1eff77d09b90fc1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae909e329344974ad7fb4e7b424878d36"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator[]" ref="gae909e329344974ad7fb4e7b424878d36" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8fdb6db1c20406556e29c11021c472bb"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::at" ref="ga8fdb6db1c20406556e29c11021c472bb" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga81f700b55078ee5468b96fa6ebea55ad"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::front" ref="ga81f700b55078ee5468b96fa6ebea55ad" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5338994a167c6bafe6bbccac8c514795"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::back" ref="ga5338994a167c6bafe6bbccac8c514795" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae08c76cfbf01f80e7380a994157df568"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::data" ref="gae08c76cfbf01f80e7380a994157df568" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE_TYPE** <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga61a91e79364592b47b626313c961a6e5"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::resize" ref="ga61a91e79364592b47b626313c961a6e5" args="(size_type newLength)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga23e40cd74587357f81715af062e2eaa9"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::resize" ref="ga23e40cd74587357f81715af062e2eaa9" args="(size_type newLength, VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga728a77555f5235b5197ba697837c2cff"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::push_back" ref="ga728a77555f5235b5197ba697837c2cff" args="(VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae9352c4608b40e6c4230d245f68ae146"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gae9352c4608b40e6c4230d245f68ae146" args="(const_iterator position, VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5a0e0e9d0944dc1ab7bb339c73463b06"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="ga5a0e0e9d0944dc1ab7bb339c73463b06" args="(const_iterator position, size_type numElements, VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga463c9e3a03f1a0aded9c067f41c0d06c"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="ga463c9e3a03f1a0aded9c067f41c0d06c" args="(const_iterator position, INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2f4211727f28143130412cdd04df0fb9"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::erase" ref="ga2f4211727f28143130412cdd04df0fb9" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga56f6de18a557d17ee3d26bdd91ac3474"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::erase" ref="ga56f6de18a557d17ee3d26bdd91ac3474" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gaf63525577a811da914699b2083873ecc">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga87fc99fbeadf2f8b9e165eb363d1cc81"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::get_allocator" ref="ga87fc99fbeadf2f8b9e165eb363d1cc81" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the allocator used by this vector to supply memory. </p>

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga8d52d78392a987e2864466198f37fb62">bsl::Vector_Imp&lt; void *, ALLOCATOR::template rebind&lt; void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga066fbb8af43cfc8b0c1b86a2a69aad0b"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::begin" ref="ga066fbb8af43cfc8b0c1b86a2a69aad0b" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga60dd96d572ec3b5a62d87a19d4d48860"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::cbegin" ref="ga60dd96d572ec3b5a62d87a19d4d48860" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga56af29169db429fdadcf393a67b05045"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::end" ref="ga56af29169db429fdadcf393a67b05045" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3a92029c5fa75db8d4025f90e61bab0e"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::cend" ref="ga3a92029c5fa75db8d4025f90e61bab0e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac159e88612a81f0f7be8f213eb2fee03"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rbegin" ref="gac159e88612a81f0f7be8f213eb2fee03" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7acd8f6ac7e55437aa76379e6bdf1361"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::crbegin" ref="ga7acd8f6ac7e55437aa76379e6bdf1361" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga338ccdaed2d290b97203b32aaf928eec"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::rend" ref="ga338ccdaed2d290b97203b32aaf928eec" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga03dbba1d8ff19a8c45b3d617aad600ca"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::crend" ref="ga03dbba1d8ff19a8c45b3d617aad600ca" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga308cd1b4084480a1241a8d47c23b9956"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator[]" ref="ga308cd1b4084480a1241a8d47c23b9956" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gafb049517872ca58d40d1f436ba261203"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::at" ref="gafb049517872ca58d40d1f436ba261203" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga072e1d3b72efeb60bde40edfb4934d11">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gacd47d558bbb42957c05d6388f63cd8a8"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::front" ref="gacd47d558bbb42957c05d6388f63cd8a8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5aca08cd5fd53de3f530fbd9564ab001"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::back" ref="ga5aca08cd5fd53de3f530fbd9564ab001" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2f2d08ae008a632d57896127fc34b4b6"></a><!-- doxytag: member="bsl::vector&lt; VALUE_TYPE *, ALLOCATOR &gt;::data" ref="ga2f2d08ae008a632d57896127fc34b4b6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE_TYPE* const* <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; VALUE_TYPE *, ALLOCATOR &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab76628a7a0c98d331cb819c2a350eb66"></a><!-- doxytag: member="bsl::operator==" ref="gab76628a7a0c98d331cb819c2a350eb66" args="(const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa050f07faffd38620497590ae4a99b4d"></a><!-- doxytag: member="bsl::operator!=" ref="gaa050f07faffd38620497590ae4a99b4d" args="(const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad44b0030adeab48da89a630cd9dbda69"></a><!-- doxytag: member="bsl::operator&lt;" ref="gad44b0030adeab48da89a630cd9dbda69" args="(const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga06eed7e12572f6abb9838f1737348bd6"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga06eed7e12572f6abb9838f1737348bd6" args="(const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga43dfb63a5e8e2518d34771637f3b3815"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga43dfb63a5e8e2518d34771637f3b3815" args="(const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae74b32df8b2eebf0034d006226553379"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gae74b32df8b2eebf0034d006226553379" args="(const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab53faa313dc32ebffbfb834e8f6bc923"></a><!-- doxytag: member="bsl::swap" ref="gab53faa313dc32ebffbfb834e8f6bc923" args="(vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;a, vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga885f0a024872596f0edc7598433c9316"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga885f0a024872596f0edc7598433c9316" args="(const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga75b47261356e66440a3f22326fca0c3c"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga75b47261356e66440a3f22326fca0c3c" args="(size_type n, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga518a0bb8a9d0f20b087368c0ea100810"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga518a0bb8a9d0f20b087368c0ea100810" args="(size_type n, const VALUE_TYPE *value, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadcc082b76fa6e1053a2f24b95cbbdb09"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="gadcc082b76fa6e1053a2f24b95cbbdb09" args="(INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;alloc=ALLOCATOR())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em> = <code>ALLOCATOR()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5cc6a14692647bbb83dd82a866e33556"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="ga5cc6a14692647bbb83dd82a866e33556" args="(const vector &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf9cd6c1e661a3297a387f9dfc145e467"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector" ref="gaf9cd6c1e661a3297a387f9dfc145e467" args="(const vector &amp;original, const ALLOCATOR &amp;alloc)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>alloc</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadd98de3e2f67da150e94b98fc065a179"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::~vector" ref="gadd98de3e2f67da150e94b98fc065a179" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::~vector </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae93ec72d9ac8c3353f89b037de80eebf"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator=" ref="gae93ec72d9ac8c3353f89b037de80eebf" args="(const vector &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&amp; <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1vector.html">vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga80beed773775ff491a560d9827470983"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::assign" ref="ga80beed773775ff491a560d9827470983" args="(INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this vector the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. Note that this vector will be left in an empty state in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. This method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga81fed82a60da7d7c72724f95bfa7ac7f">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga63ea4226486bf51bd44bc1c84ed81b60"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::assign" ref="ga63ea4226486bf51bd44bc1c84ed81b60" args="(size_type numElements, const VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1e9dc42f3178d710fe2c66a192508db1"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::begin" ref="ga1e9dc42f3178d710fe2c66a192508db1" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3e6518351f9405fee2207027515573ab"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::end" ref="ga3e6518351f9405fee2207027515573ab" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1d2c5620294830f3bd6f8481074424f3"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rbegin" ref="ga1d2c5620294830f3bd6f8481074424f3" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2a3153ef2b2ca91c59a6fd0a90035e56"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rend" ref="ga2a3153ef2b2ca91c59a6fd0a90035e56" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6f481f36ad2cc5f154ce79371f926511"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator[]" ref="ga6f481f36ad2cc5f154ce79371f926511" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf4a44098a0f50e69fad7cc01c408ba5e"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::at" ref="gaf4a44098a0f50e69fad7cc01c408ba5e" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaae5378ea8aa29d554ed2dbc57854762b"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::front" ref="gaae5378ea8aa29d554ed2dbc57854762b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga255da60d771bc40adc9602c63107d50e"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::back" ref="ga255da60d771bc40adc9602c63107d50e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae14419f8bfc1c405679399b295275811"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::data" ref="gae14419f8bfc1c405679399b295275811" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE_TYPE** <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga22024042f45a5f1566f956156d9cecb3"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::resize" ref="ga22024042f45a5f1566f956156d9cecb3" args="(size_type newLength)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newLength</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2507559e3c1ed336d4bc988aa880afe4"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::resize" ref="ga2507559e3c1ed336d4bc988aa880afe4" args="(size_type newLength, const VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad4b087bd66d82c406c68ec31a054ee4c"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::push_back" ref="gad4b087bd66d82c406c68ec31a054ee4c" args="(const VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf0e738c92639f1b6a84145727982eacf"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gaf0e738c92639f1b6a84145727982eacf" args="(const_iterator position, const VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8142025bc027624b76dc97505310175c"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="ga8142025bc027624b76dc97505310175c" args="(const_iterator position, size_type numElements, const VALUE_TYPE *value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae1ce3952d041389078ec3ee8450e8a54"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gae1ce3952d041389078ec3ee8450e8a54" args="(const_iterator position, INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;class INPUT_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga92ced92b9688f17e37023f8e95bfe130"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::erase" ref="ga92ced92b9688f17e37023f8e95bfe130" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga23ce96df781efd19791d63f1a07d78f6"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::erase" ref="ga23ce96df781efd19791d63f1a07d78f6" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga8f61cc68c2ce841df5d6a084d750dae3"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::get_allocator" ref="ga8f61cc68c2ce841df5d6a084d750dae3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">allocator_type <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the allocator used by this vector to supply memory. </p>

<p>Reimplemented from <a class="el" href="group__bslstl__vector.html#ga8d52d78392a987e2864466198f37fb62">bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ga5ee3d15eea6c4801e247f53e7b5c4e4c"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::begin" ref="ga5ee3d15eea6c4801e247f53e7b5c4e4c" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1e62a537951df42db9a85e01b1c509d6"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::cbegin" ref="ga1e62a537951df42db9a85e01b1c509d6" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab7d6db73f2b12880a2a9987bb1095350"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::end" ref="gab7d6db73f2b12880a2a9987bb1095350" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga7a9a945d04de22e3cd264290a6d6e647"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::cend" ref="ga7a9a945d04de22e3cd264290a6d6e647" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac0b64df8420c75db7c2927a7f6afc670"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rbegin" ref="gac0b64df8420c75db7c2927a7f6afc670" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac8fe319720a2ef4788a2feea029c56f4"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::crbegin" ref="gac8fe319720a2ef4788a2feea029c56f4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga5dd4cfaacb1291b7cbb7eb05f82340d5"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rend" ref="ga5dd4cfaacb1291b7cbb7eb05f82340d5" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae1d17dce2e3f11f2a410513266227dc7"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::crend" ref="gae1d17dce2e3f11f2a410513266227dc7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa491c401d912f10e4161f06aaa116482"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator[]" ref="gaa491c401d912f10e4161f06aaa116482" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga015e3fd3a1291374dbb98b1fc59ee96d"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::at" ref="ga015e3fd3a1291374dbb98b1fc59ee96d" args="(size_type position) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4deef186a0f457ca404b26cc3b7cebb3"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::front" ref="ga4deef186a0f457ca404b26cc3b7cebb3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga0630475bf0de545f5053bc23661a1b89"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::back" ref="ga0630475bf0de545f5053bc23661a1b89" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac6feec182b2932d2c3d242eb16655bb7"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::data" ref="gac6feec182b2932d2c3d242eb16655bb7" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE_TYPE* const* <a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; const VALUE_TYPE *, ALLOCATOR &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga6bc33a80f40864c84d527e1dba8ea0f7"></a><!-- doxytag: member="bsl::operator==" ref="ga6bc33a80f40864c84d527e1dba8ea0f7" args="(const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga70e39ecc5bb6b312e77055ab69db74e9"></a><!-- doxytag: member="bsl::operator!=" ref="ga70e39ecc5bb6b312e77055ab69db74e9" args="(const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1d962f9bb93e44002b825909c6f5481c"></a><!-- doxytag: member="bsl::operator&lt;" ref="ga1d962f9bb93e44002b825909c6f5481c" args="(const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga55051a5f21e7701e046a08080015b9d9"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga55051a5f21e7701e046a08080015b9d9" args="(const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga229794ea813dde0fe7160991fccb5253"></a><!-- doxytag: member="bsl::operator&lt;=" ref="ga229794ea813dde0fe7160991fccb5253" args="(const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gac48a0847b58ba26910284d521f2dfb4f"></a><!-- doxytag: member="bsl::operator&gt;=" ref="gac48a0847b58ba26910284d521f2dfb4f" args="(const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;lhs, const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga11c0d5aedac133a4c9fd2a2404471c2c"></a><!-- doxytag: member="bsl::swap" ref="ga11c0d5aedac133a4c9fd2a2404471c2c" args="(vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;a, vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;b)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga3e1a64e0c76bee38e5c27e2be33f23e0"></a><!-- doxytag: member="bsl::Vector_RangeCheck::isInvalidRange" ref="ga3e1a64e0c76bee38e5c27e2be33f23e0" args="(BSLSTL_ITERATOR first, BSLSTL_ITERATOR last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class BSLSTL_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structbsl_1_1enable__if.html">bsl::enable_if</a>&lt; Vector_IsRandomAccessIterator&lt;BSLSTL_ITERATOR&gt;::VALUE, bool&gt;::type bsl::Vector_RangeCheck::isInvalidRange </td>
          <td>(</td>
          <td class="paramtype">BSLSTL_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BSLSTL_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, static, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>last</em>&nbsp;</td><td>Return <code>true</code> if <code>first &lt;= last</code>, and <code>false</code> otherwise. Behavior is undefined unless both <code>first</code> and <code>last</code> are valid iterators that refer to the same range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="ga4270c95067ff340ec7469d1411e252ac"></a><!-- doxytag: member="bsl::Vector_ImpBase::d_dataEnd" ref="ga4270c95067ff340ec7469d1411e252ac" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE_TYPE* <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::d_dataEnd<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>end of data storage (owned) </p>

</div>
</div>
<a class="anchor" id="gabb717a1693d469a315711bddc394a404"></a><!-- doxytag: member="bsl::Vector_ImpBase::d_capacity" ref="gabb717a1693d469a315711bddc394a404" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; VALUE_TYPE &gt;::d_capacity<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>length of storage </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:24 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
