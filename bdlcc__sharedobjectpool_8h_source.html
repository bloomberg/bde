<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlcc_sharedobjectpool.h                                           -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLCC_SHAREDOBJECTPOOL
#define INCLUDED_BDLCC_SHAREDOBJECTPOOL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a thread-safe pool of shared objects.
//
//@CLASSES:
//  bdlcc::SharedObjectPool: thread-enabled container of shared objects
//
//@SEE_ALSO: bcema_sharedptr
//
//@DESCRIPTION: This component provides a generic thread-safe pool of shared
// objects, &#39;bdlcc::SharedObjectPool&#39;, using the acquire-release idiom.  The
// functionality provided is identical to &#39;bdlcc::ObjectPool&#39;, except that
// &#39;getObject&#39; returns efficiently-constructed &#39;bsl::shared_ptr&#39; objects
// instead of raw pointers.  For client code that needs to provide shared
// access to objects in the pool, this functionality saves an additional
// allocation for the shared pointer itself.  Since the shared pointer and the
// object are contiguous in memory, this component also tends to improve
// performance by reducing &quot;cache misses.&quot;
//
///Object Construction and Destruction
///-----------------------------------
// The object pool owns the memory required to store the pooled objects and the
// shared-pointer representations, and manages the construction, resetting, and
// destruction of objects.  The user may supply functors to create objects and
// to reset them to a valid state for their return to the pool; alternatively,
// this component supplies reasonable defaults.  Upon destruction the object
// pool deallocates all memory associated with the objects in the pool.  The
// behavior is undefined if there are any outstanding shared pointer references
// to the objects in the pool when it is destroyed.
//
///Creator and Resetter Template Contract
///--------------------------------------
// &#39;bdlcc::SharedObjectPool&#39; is templated on two types &#39;CREATOR&#39; and &#39;RESETTER&#39;
// in addition to the underlying object &#39;TYPE&#39;.  Objects of these types may be
// provided at construction (or defaults may be used).  The creator will be
// invoked as: &#39;void(*)(void*, bslma::Allocator*)&#39;.  The resetter will be
// invoked as: &#39;void(*)(TYPE*)&#39;.  The creator functor will be called to
// construct a new object of the parameterized &#39;TYPE&#39; when the pool must be
// expanded (and thus it will typically invoke placement new and pass its
// allocator argument to the constructor of &#39;TYPE&#39;).  The resetter functor will
// be called before each object is returned to the pool, and is required to put
// the object into a state such that it is ready to be reused.  The defaults
// for these types are as follows:
//..
//    CREATOR = bdlcc::ObjectPoolFunctors::DefaultCreator
//    RESETTER = bdlcc::ObjectPoolFunctors::Nil&lt;TYPE&gt;
//..
// &#39;bdlcc::ObjectPoolFunctors::Nil&#39; is a no-op; it is only suitable if the
// objects stored in the pool are *always* in a valid state to be reused.
// Otherwise - that is, if anything must be done to render the objects ready
// for reuse - another kind of &#39;RESETTER&#39; should be provided (so long as that
// type supplies &#39;void(*)(TYPE*)&#39;).  In &#39;bdlcc::ObjectPoolFunctors&#39;, the
// classes &#39;Clear&#39;, &#39;RemoveAll&#39;, and &#39;Reset&#39; are all acceptable types for
// &#39;RESETTER&#39;.  Since these &quot;functor&quot; types are fully inline, it is generally
// most efficient to define &#39;reset()&#39; (or &#39;clear()&#39; or &#39;removeAll()&#39;) in the
// underlying &#39;TYPE&#39; and allow the functor to call that method.  The &#39;CREATOR&#39;
// functor defaults to an object that invokes the default constructor with
// placement new, passing the allocator argument if the type traits of the
// object indicate it uses an allocator (see &#39;bslma_usesbslmaallocator&#39;).  If a
// custom creator functor or a custom &#39;CREATOR&#39; type is specified, it is the
// user&#39;s responsibility to ensure that it correctly passes its allocator
// argument through to the constructor of &#39;TYPE&#39; if &#39;TYPE&#39; uses allocator.
//
///Exception Safety
///----------------
// There are two potential sources of exceptions in this component: memory
// allocation and object construction.  The object pool is exception-neutral
// with full guarantee of rollback for the following methods: if an exception
// is thrown in &#39;getObject&#39;, &#39;reserveCapacity&#39;, or &#39;increaseCapacity&#39;, then the
// pool is in a valid unmodified state (i.e., identical to prior the call to
// &#39;getObject&#39;).  No other method of &#39;bdlcc::SharedObjectPool&#39; can throw.
//
///Pool Replenishment Policy
///-------------------------
// The &#39;growBy&#39; parameter can be specified in the pool&#39;s constructor to
// instruct the pool how it is to increase its capacity each time the pool is
// depleted.  If &#39;growBy&#39; is positive, the pool always replenishes itself with
// enough objects so that it can satisfy at least &#39;growBy&#39; object requests
// before the next replenishment.  If &#39;growBy&#39; is negative, the pool will
// increase its capacity geometrically until it exceeds the internal maximum
// (which itself is implementation-defined), and after that it will be
// replenished with constant number of objects.  If &#39;growBy&#39; is not specified,
// an implementation-defined default will be chosen.  The behavior is undefined
// if growBy is 0.
//
///Usage
///-----
// This component is intended to improve the efficiency of code which provides
// shared pointers to pooled objects.  As an example, consider a class which
// maintains a pool of &#39;vector&lt;char&gt;&#39; objects and provides shared pointers to
// them.  Using &#39;bdlcc::ObjectPool&#39;, the class might be implemented like this:
//..
//  typedef vector&lt;char&gt; CharArray;
//
//  class SlowCharArrayPool {
//      bdlma::ConcurrentPoolAllocator d_spAllocator;  // alloc. shared pointer
//      bdlcc::ObjectPool&lt;CharArray&gt;   d_charArrayPool;  // supply charArrays
//
//      static void createCharArray(void *address, bslma::Allocator *allocator)
//      {
//          new (address) CharArray(allocator);
//      }
//
//      static void resetAndReturnCharArray(
//                                     CharArray                    *charArray,
//                                     bdlcc::ObjectPool&lt;CharArray&gt; *pool)
//      {
//          charArray-&gt;clear();
//          pool-&gt;releaseObject(charArray);
//      }
//
//    private:
//      // Not implemented:
//      SlowCharArrayPool(const SlowCharArrayPool&amp;);
//
//    public:
//      SlowCharArrayPool(bslma::Allocator *basicAllocator = 0)
//      : d_spAllocator(basicAllocator)
//      , d_charArrayPool(bdlf::BindUtil::bind(
//                                         &amp;SlowCharArrayPool::createCharArray,
//                                         bdlf::PlaceHolders::_1,
//                                         basicAllocator),
//                        -1,
//                        basicAllocator)
//      {
//      }
//
//      void getCharArray(bsl::shared_ptr&lt;CharArray&gt; *charArray_sp)
//      {
//          charArray_sp-&gt;reset(d_charArrayPool.getObject(),
//                              bdlf::BindUtil::bind(
//                                 &amp;SlowCharArrayPool::resetAndReturnCharArray,
//                                 bdlf::PlaceHolders::_1,
//                                 &amp;d_charArrayPool),
//                              &amp;d_spAllocator);
//      }
//  };
//..
// Note that &#39;SlowCharArrayPool&#39; must allocate the shared pointer itself from
// its &#39;d_spAllocator&#39; in addition to allocating the charArray from its pool.
// Moreover, note that since the same function will handle resetting the object
// and returning it to the pool, we must define a special function for that
// purpose and bind its arguments.
//
// We can solve both of these issues by using &#39;bdlcc::SharedObjectPool&#39;
// instead:
//..
//  class FastCharArrayPool {
//      typedef bdlcc::SharedObjectPool&lt;
//              CharArray,
//              bdlcc::ObjectPoolFunctors::DefaultCreator,
//              bdlcc::ObjectPoolFunctors::Clear&lt;CharArray&gt; &gt; CharArrayPool;
//
//      CharArrayPool d_charArrayPool;     // supply charArrays
//
//      static void createCharArray(void *address, bslma::Allocator *allocator)
//      {
//          new (address) CharArray(allocator);
//      }
//
//    private:
//      // Not implemented:
//      FastCharArrayPool(const FastCharArrayPool&amp;);
//
//    public:
//      FastCharArrayPool(bslma::Allocator *basicAllocator = 0)
//      : d_charArrayPool(bdlf::BindUtil::bind(
//                                         &amp;FastCharArrayPool::createCharArray,
//                                         bdlf::PlaceHolders::_1,
//                                         bdlf::PlaceHolders::_2),
//                        -1,
//                        basicAllocator)
//      {
//      }
//
//      void getCharArray(bsl::shared_ptr&lt;CharArray&gt; *charArray_sp)
//      {
//          *charArray_sp = d_charArrayPool.getObject();
//      }
//  };
//..
// Now the shared pointer and the object are allocated as one unit from the
// same allocator.  In addition, the resetter method is a fully-inlined class
// that is only responsible for resetting the object, improving efficiency and
// simplifying the design.  We can verify that use of &#39;bdlcc::SharedObjectPool&#39;
// reduces the number of allocation requests:
//..
//  bslma::TestAllocator slowAllocator, fastAllocator;
//  {
//      SlowCharArrayPool slowPool(&amp;slowAllocator);
//      FastCharArrayPool fastPool(&amp;fastAllocator);
//
//      bsl::shared_ptr&lt;CharArray&gt; charArray_sp;
//
//      fastPool.getCharArray(&amp;charArray_sp);
//      slowPool.getCharArray(&amp;charArray_sp);  // throw away the first array
//  }
//
//  assert(2 == slowAllocator.numAllocations());
//  assert(1 == fastAllocator.numAllocations());
//  assert(0 == slowAllocator.numBytesInUse());
//  assert(0 == fastAllocator.numBytesInUse());
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLCC_OBJECTPOOL
#include &lt;bdlcc_objectpool.h&gt;
#endif

#ifndef INCLUDED_BDLF_BIND
#include &lt;bdlf_bind.h&gt;
#endif

#ifndef INCLUDED_BDLF_PLACEHOLDER
#include &lt;bdlf_placeholder.h&gt;
#endif

#ifndef INCLUDED_BSLALG_CONSTRUCTORPROXY
#include &lt;bslalg_constructorproxy.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_SHAREDPTRREP
#include &lt;bslma_sharedptrrep.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_OBJECTBUFFER
#include &lt;bsls_objectbuffer.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSL_MEMORY
#include &lt;bsl_memory.h&gt;
#endif

namespace BloombergLP {
namespace bdlcc {

                         // ==========================
                         // class SharedObjectPool_Rep
                         // ==========================

template &lt;class TYPE, class RESETTER&gt;
class SharedObjectPool_Rep: public bslma::SharedPtrRep {

    typedef SharedObjectPool_Rep&lt;TYPE, RESETTER&gt; MyType;
    typedef ObjectPool&lt;MyType,
                            ObjectPoolFunctors::DefaultCreator,
                            ObjectPoolFunctors::Reset&lt;MyType&gt; &gt;
                                                      PoolType;

    // DATA
    bslalg::ConstructorProxy&lt;RESETTER&gt; d_objectResetter;

    PoolType                          *d_pool_p;   // object pool (held)
    bsls::ObjectBuffer&lt;TYPE&gt;           d_instance; // area for embedded
                                                   // instance

    // NOT IMPLEMENTED
    SharedObjectPool_Rep(const SharedObjectPool_Rep&amp;);
    SharedObjectPool_Rep&amp; operator=(const SharedObjectPool_Rep&amp;);

  public:
    // CREATORS
    template &lt;class CREATOR&gt;
    SharedObjectPool_Rep(
                    CREATOR*                                   objectCreator,
                    const bslalg::ConstructorProxy&lt;RESETTER&gt;&amp;  objectResetter,
                    PoolType                                  *pool,
                    bslma::Allocator                          *basicAllocator);
        // Construct a new rep object that, upon release, will invoke the
        // specified &#39;objectResetter&#39; and return itself to the specified
        // &#39;pool&#39;; then invoke &#39;objectCreator&#39; to construct an object of &#39;TYPE&#39;
        // embedded within the new rep object.  Use the specified
        // &#39;basicAllocator&#39; to supply memory.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.

    ~SharedObjectPool_Rep();
        // Destroy this representation object and the embedded instance of
        // &#39;TYPE&#39;.

    // MANIPULATORS
    virtual void disposeRep();
        // Release this representation object.  This method is invoked when the
        // number of weak references and the number of strong references reach
        // zero.  This virtual override will return the object, and this
        // representation, to the associated pool.

    virtual void disposeObject();
        // Release the object being managed by this representation.  This
        // method is invoked when the number of strong references reaches zero.
        // Note that if there are any weak references to the shared object then
        // this function does nothing, including not destroying the object or
        // returning it to the pool.

    void reset();
        // Invoke the object resetter specified at construction on the
        // associated object.

    virtual void *getDeleter(const std::type_info&amp; type);
        // Return NULL.  Shared object pools strictly control the delete policy
        // for their objects, and do not expose it to end users.

    // ACCESSORS
    virtual void *originalPtr() const;
        // Return (untyped) address of the object managed by this
        // representation.  This virtual override effectively returns
        // &quot;(void*)ptr()&quot;.

    TYPE *ptr();
        // Return a pointer to the in-place object.
};

                           // ======================
                           // class SharedObjectPool
                           // ======================

template &lt;class TYPE,
          class CREATOR=ObjectPoolFunctors::DefaultCreator,
          class RESETTER=ObjectPoolFunctors::Nil&lt;TYPE&gt; &gt;
class SharedObjectPool {

    typedef SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt; MyType;
    typedef SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;      RepType;
    typedef ObjectPool&lt;RepType,
                            ObjectPoolFunctors::DefaultCreator,
                            ObjectPoolFunctors::Reset&lt;RepType&gt; &gt;
                                                           PoolType;

    typename ObjectPool_ProxyPicker&lt;CREATOR&gt;::template Selector&lt;TYPE&gt;::Proxy
                                d_objectCreator; // functor for object creation

    bslalg::ConstructorProxy&lt;RESETTER&gt;
                                d_objectResetter;  // functor to reset object

    PoolType                    d_pool;           // object pool (owned)

  private:
    // NOT IMPLEMENTED
    SharedObjectPool(const SharedObjectPool&amp;);
    SharedObjectPool&amp; operator=(const SharedObjectPool&amp;);

    void constructRepObject(void *memory, bslma::Allocator *alloc);
        // Initializes a newly constructed SharedObjectPool_Rep object

  public:
    // TYPES
    typedef CREATOR    CreatorType;
    typedef RESETTER   ResetterType;

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(SharedObjectPool,
                                   bslma::UsesBslmaAllocator);

    // CREATORS
    explicit
    SharedObjectPool(int growBy = -1, bslma::Allocator *basicAllocator = 0);

    explicit
    SharedObjectPool(const CREATOR&amp;    objectCreator,
                     int               growBy = -1,
                     bslma::Allocator *basicAllocator = 0);

    explicit
    SharedObjectPool(const CREATOR&amp;    objectCreator,
                     bslma::Allocator *basicAllocator = 0);

    SharedObjectPool(const CREATOR&amp;    objectCreator,
                     const RESETTER&amp;   objectResetter,
                     int               growBy = -1,
                     bslma::Allocator *basicAllocator = 0);

        // Create an object pool that dispenses shared pointers to TYPE.  When
        // the pool is depleted, it increases its capacity according to the
        // optionally specified &#39;growBy&#39; value.  If &#39;growBy&#39; is positive, the
        // pool always increases by at least &#39;growBy&#39;.  If &#39;growBy&#39; is
        // negative, the amount of increase begins at &#39;-growBy&#39; and then grows
        // geometrically up to an implementation-defined maximum.  The
        // optionally specified &#39;objectCreator&#39; is called whenever objects must
        // be constructed.  If &#39;objectCreator&#39; is not specified and the
        // parameterized &#39;CREATOR&#39; is the default type (that is,
        // &#39;ObjectPoolFunctors::DefaultCreator&#39;), a function that calls the
        // default constructor of &#39;TYPE&#39; with placement new, passing this
        // pool&#39;s allocator if TYPE uses allocator, is used.  If the
        // parameterized &#39;CREATOR&#39; is some other type, and &#39;objectCreator&#39; is
        // not specified, the default value of the &#39;CREATOR&#39; type is used.  The
        // optionally specified &#39;objectResetter&#39; is invoked with a pointer to
        // an object of &#39;TYPE&#39; when the object is returned to the pool.  It
        // must reset the object into a valid state for reuse.  If
        // &#39;objectResetter&#39; is not specified, a default RESETTER object is
        // used.  Optionally specify a basic allocator to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  The behavior is undefined if &#39;growBy&#39; is 0.

    ~SharedObjectPool();
        // Destroy this object pool.  All objects created by this pool are
        // destroyed (even if some of them are still in use) and memory is
        // reclaimed.

    // MANIPULATORS
    bsl::shared_ptr&lt;TYPE&gt; getObject();
        // Return a pointer to an object from this object pool.  When the last
        // shared pointer to the object is destroyed, the object will be reset
        // as specified at construction and then returned to the pool.  If this
        // pool is empty, it is replenished according to the strategy specified
        // at construction.

    void increaseCapacity(int growBy);
        // Create the specified &#39;growBy&#39; objects and add them to this object
        // pool.  The behavior is undefined unless &#39;0 &lt;= growBy&#39;.

    void reserveCapacity(int growBy);
        // Create enough objects to satisfy requests for at least the specified
        // &#39;growBy&#39; objects before the next replenishment.  The behavior is
        // undefined unless &#39;0 &lt;= growBy&#39;.  Note that this method is different
        // from &#39;increaseCapacity&#39; in that the number of created objects may be
        // less than &#39;growBy&#39;.

    // ACCESSORS
    int numAvailableObjects() const;
        // Return a *snapshot* of the number of objects available in this pool.

    int numObjects() const;
        // Return the (instantaneous) number of objects managed by this pool.
        // This includes both the objects available in the pool and the objects
        // that were allocated from the pool and not yet released.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                         // --------------------------
                         // class SharedObjectPool_Rep
                         // --------------------------

// CREATORS
template &lt;class TYPE, class RESETTER&gt;
template &lt;class CREATOR&gt;
inline
SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;::SharedObjectPool_Rep(
                     CREATOR*                                   objectCreator,
                     const bslalg::ConstructorProxy&lt;RESETTER&gt;&amp;  objectResetter,
                     PoolType                                  *pool,
                     bslma::Allocator                          *basicAllocator)
: d_objectResetter(objectResetter,basicAllocator)
, d_pool_p(pool)
{
    (*objectCreator)(d_instance.buffer(), basicAllocator);
}

template &lt;class TYPE, class RESETTER&gt;
inline
SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;::~SharedObjectPool_Rep()
{
    d_instance.object().~TYPE();
}

// MANIPULATORS
template &lt;class TYPE, class RESETTER&gt;
inline
void SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;::reset()
{
    d_objectResetter.object()(&amp;d_instance.object());
}

template &lt;class TYPE, class RESETTER&gt;
inline
void SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;::disposeRep()
{
    d_pool_p-&gt;releaseObject(this);
}

template &lt;class TYPE, class RESETTER&gt;
inline
void *SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;::getDeleter(
                                                const std::type_info&amp; /*type*/)
{
    return 0;
}

template &lt;class TYPE, class RESETTER&gt;
inline
void SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;::disposeObject()
{
    // No-op
}

// ACCESSORS
template &lt;class TYPE, class RESETTER&gt;
inline
void *SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;::originalPtr() const
{
    return const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(d_instance.buffer()));
}

template &lt;class TYPE, class RESETTER&gt;
inline
TYPE *SharedObjectPool_Rep&lt;TYPE, RESETTER&gt;::ptr()
{
    return &amp;d_instance.object();
}

                             // ----------------
                             // SharedObjectPool
                             // ----------------

// PRIVATE
template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
void SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::constructRepObject(
                                                      void             *memory,
                                                      bslma::Allocator *alloc)
{
    RepType *r = new (memory) RepType(&amp;d_objectCreator.object(),
                                      d_objectResetter,
                                      &amp;d_pool,
                                      alloc);
    r-&gt;resetCountsRaw(0, 0);
}

}  // close package namespace

// CREATORS
#if defined(BSLS_PLATFORM_CMP_MSVC)
// Visual C++ complains about any use of the &#39;this&#39; pointer in a member
// initializer of a constructor.  The use cases below seem perfectly safe and
// correct, but there is no way to eliminate this warning from a prominent
// header file other than disabling it via a pragma.
#pragma warning(push)
#pragma warning(disable : 4355) // used &#39;this&#39; in member initializer
#endif

namespace bdlcc {

template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::SharedObjectPool(
                                              const CREATOR&amp;    objectCreator,
                                              const RESETTER&amp;   objectResetter,
                                              int               growBy,
                                              bslma::Allocator *basicAllocator)
: d_objectCreator(objectCreator,basicAllocator)
, d_objectResetter(objectResetter,basicAllocator)
, d_pool(bdlf::BindUtil::bind(&amp;MyType::constructRepObject, this,
                             bdlf::PlaceHolders::_1,
                             bdlf::PlaceHolders::_2),
         growBy, basicAllocator)
{
}

template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::SharedObjectPool(
                                              int               growBy,
                                              bslma::Allocator *basicAllocator)
: d_objectCreator(basicAllocator)
, d_objectResetter(basicAllocator)
, d_pool(bdlf::BindUtil::bind(&amp;MyType::constructRepObject, this,
                             bdlf::PlaceHolders::_1,
                             bdlf::PlaceHolders::_2),
         growBy, basicAllocator)
{
}

template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::SharedObjectPool(
                                              const CREATOR&amp;    objectCreator,
                                              int               growBy,
                                              bslma::Allocator *basicAllocator)
: d_objectCreator(objectCreator, basicAllocator)
, d_objectResetter(basicAllocator)
, d_pool(bdlf::BindUtil::bind(&amp;MyType::constructRepObject, this,
                             bdlf::PlaceHolders::_1,
                             bdlf::PlaceHolders::_2),
         growBy, basicAllocator)
{
}

template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::SharedObjectPool(
                                              const CREATOR&amp;    objectCreator,
                                              bslma::Allocator *basicAllocator)
: d_objectCreator(objectCreator, basicAllocator)
, d_objectResetter(basicAllocator)
, d_pool(bdlf::BindUtil::bind(&amp;MyType::constructRepObject, this,
                             bdlf::PlaceHolders::_1,
                             bdlf::PlaceHolders::_2),
         -1, basicAllocator)
{
}
}  // close package namespace

#if defined(BSLS_PLATFORM_CMP_MSVC)
// Restore warnings so as not to affect their state in other files.
#pragma warning(pop)
#endif

namespace bdlcc {

template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::~SharedObjectPool()
{
}

// MANIPULATORS
template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
bsl::shared_ptr&lt;TYPE&gt;
SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::getObject()
{
    RepType *rep = d_pool.getObject();
    bslma::SharedPtrRep *genericRep = rep;
    genericRep-&gt;resetCountsRaw(1, 0);

    return bsl::shared_ptr&lt;TYPE&gt;(rep-&gt;ptr(), genericRep);
}

template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
void
SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::increaseCapacity(int growBy)
{
    d_pool.increaseCapacity(growBy);
}

template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
void
SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::reserveCapacity(int growBy)
{
    d_pool.reserveCapacity(growBy);
}

// ACCESSORS
template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
int SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::numAvailableObjects() const
{
    return d_pool.numAvailableObjects();
}

template &lt;class TYPE, class CREATOR, class RESETTER&gt;
inline
int SharedObjectPool&lt;TYPE, CREATOR, RESETTER&gt;::numObjects() const
{
    return d_pool.numObjects();
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
