<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlmt::TcpTimerEventManager</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlmt.html">btlmt</a>      </li>
      <li><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html">btlmt::TcpTimerEventManager</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>btlmt::TcpTimerEventManager Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlmt::TcpTimerEventManager" --><!-- doxytag: inherits="btlso::TimerEventManager" -->
<p><code>#include &lt;<a class="el" href="btlmt__tcptimereventmanager_8h_source.html">btlmt_tcptimereventmanager.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlmt::TcpTimerEventManager:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlmt_1_1TcpTimerEventManager.png" usemap="#btlmt::TcpTimerEventManager_map" alt=""/>
  <map id="btlmt::TcpTimerEventManager_map" name="btlmt::TcpTimerEventManager_map">
<area href="classbtlso_1_1TimerEventManager.html" alt="btlso::TimerEventManager" shape="rect" coords="0,0,178,24"/>
</map>
</div>

<p><a href="classbtlmt_1_1TcpTimerEventManager-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">Callback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a19d3aed31ad25495a085b35e7e3f95b1">TcpTimerEventManager</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a11f0e73621155318859777d0e0187525">TcpTimerEventManager</a> (bool collectTimeMetrics, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a5db16bbfbb0c66c20a60405381706fbf">TcpTimerEventManager</a> (bool collectTimeMetrics, bool poolTimerMemory, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a70db182161c25a1527ef3cd2d4ae81a4">TcpTimerEventManager</a> (<a class="el" href="classbtlso_1_1EventManager.html">btlso::EventManager</a> *rawEventManager, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a04aec133d089bb526c3afeae0c8fcd6d">~TcpTimerEventManager</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#aa240ebb93ccd9129c060922539fc18f8">deregisterAllSocketEvents</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#aea424fad019e521f2b33948f96750304">deregisterAllTimers</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#aa54cd8ba17d83e412d4c9015ecd6822f">deregisterAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a955a7ae0ce302d1337b03f9d0bc75e71">deregisterSocketEvent</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;handle, <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a> event)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a26eedb6f5f4acba6056aa3c40f1a5250">deregisterSocket</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#aa29ea8bce844c187c6942a41da0874b6">deregisterTimer</a> (const void *timerId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a538e054096d8c97c77466c26b823e597">disable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#af5aadadedc8858fc4f7594d66154c800">enable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a0a782916fcc735b76d1794b3a3e876c3">enable</a> (const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;attribute)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a189115acbc54029980d2e0cc88ab8c38">execute</a> (const bsl::function&lt; void()&gt; &amp;functor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a891d92b7df449c5281cb603cc216d55a">clearExecuteQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a914282768790d7e528b3a0618547e950">registerSocketEvent</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;handle, <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a> event, const <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> &amp;cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a1453c33da941f40b7213eb92620cd2ce">registerTimer</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, const <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> &amp;cb)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a4f05c9498ac589e8d585170c1135ce0a">rescheduleTimer</a> (const void *timerId, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a538180b1e2af47cbc141c46e4ed1222f">hasLimitedSocketCapacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a89c99b80ef0a5a8f67e023f4b43d34af">isRegistered</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;handle, <a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a> event) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a09704333bb58c492499b7ecd067259fe">numEvents</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#aa351c616b0bc261a11d14679bf118481">numTimers</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a3fbfed5913ac549da9976137c06ef2ea">numSocketEvents</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;handle) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a211250700d79438e5c964b9971e2cc1d">numTotalSocketEvents</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlso_1_1TimeMetrics.html">btlso::TimeMetrics</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a353e25104dd5831809ca5c3317090c21">timeMetrics</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#ad8822ca70e00daf89c5d306840589714">dispatcherThreadHandle</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#afdf36c984e2fc32a2c4986ab470ec987">isEnabled</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a684c1066630aebfb0850bf4e71850565">hasTimeMetrics</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TimerEventManager.html#aaf9e2a2c3cbe722101a53d20b3621bae">registerSocketEvent</a> (const SocketHandle::Handle &amp;handle, EventType::Type event, const TimerEventManager::Callback &amp;callback)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1TimerEventManager.html#a069d2261a617c5158ff70f298687b1df">registerTimer</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;expiryTime, const TimerEventManager::Callback &amp;callback)=0</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#ac3862f815552ed7ea1d0e5792667323d">TcpTimerEventManager_TestUtil</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a thread-enabled implementation of an event manager for socket events and timers. The supported event types for sockets are ACCEPT, CONNECT, READ, and WRITE; only READ and WRITE can be registered simultaneously for a single socket. Timers are stable (i.e., the relative order of registrations is maintained). Callbacks are invoked from dedicated threads, created internally for this purpose by this component. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a721dbe10938308965a8a70b1430029af"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::Callback" ref="a721dbe10938308965a8a70b1430029af" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void()&gt; <a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">btlso::TimerEventManager::Callback</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a19d3aed31ad25495a085b35e7e3f95b1"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::TcpTimerEventManager" ref="a19d3aed31ad25495a085b35e7e3f95b1" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::TcpTimerEventManager::TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a11f0e73621155318859777d0e0187525"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::TcpTimerEventManager" ref="a11f0e73621155318859777d0e0187525" args="(bool collectTimeMetrics, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::TcpTimerEventManager::TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>collectTimeMetrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5db16bbfbb0c66c20a60405381706fbf"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::TcpTimerEventManager" ref="a5db16bbfbb0c66c20a60405381706fbf" args="(bool collectTimeMetrics, bool poolTimerMemory, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::TcpTimerEventManager::TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>collectTimeMetrics</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>poolTimerMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an event manager. Optionally specify <code>collectTimeMetrics</code> indicating whether this event manager should collect timing metrics. If <code>collectTimeMetrics</code> is unspecified or <code>true</code> then the event manager will provide a categorization of the time it spends processing data via <code><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a353e25104dd5831809ca5c3317090c21">timeMetrics()</a></code>, and if <code>collectTimeMetrics</code> is <code>false</code> the value of <code><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a353e25104dd5831809ca5c3317090c21">timeMetrics()</a></code> is unspecified. Optionally specify <code>poolTimerMemory</code> indicating whether the memory used for internal timers should be pooled. If <code>poolTimerMemory</code> is unspecified then the memory used for allocating timers will not be pooled. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>basicAllocator</code> refers to a <em>thread</em> <em>safe</em> allocator. Note that the dispatcher thread is NOT started by this method (i.e., it must be started explicitly). </p>

</div>
</div>
<a class="anchor" id="a70db182161c25a1527ef3cd2d4ae81a4"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::TcpTimerEventManager" ref="a70db182161c25a1527ef3cd2d4ae81a4" args="(btlso::EventManager *rawEventManager, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::TcpTimerEventManager::TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1EventManager.html">btlso::EventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>rawEventManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an event manager with timer support that uses the specified <code>rawEventManager</code> to monitor for socket events. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. <code>basicAllocator</code> must refer to a <em>thread</em> <em>safe</em> allocator, and the behavior is undefined, otherwise. The value of the event manager's <code><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a353e25104dd5831809ca5c3317090c21">timeMetrics()</a></code> object will be unspecified, clients interested in those metrics must use the <code><a class="el" href="classbtlso_1_1TimeMetrics.html">btlso::TimeMetrics</a></code> object provided to <code>rawEventManager</code> on its construction. Note that the dispatcher thread is NOT started by this method (and, therefore, must be started explicitly). </p>

</div>
</div>
<a class="anchor" id="a04aec133d089bb526c3afeae0c8fcd6d"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::~TcpTimerEventManager" ref="a04aec133d089bb526c3afeae0c8fcd6d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual btlmt::TcpTimerEventManager::~TcpTimerEventManager </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Terminate the dispatcher thread, if it is running, and destroy this event manager without invoking any registered callback. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa240ebb93ccd9129c060922539fc18f8"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::deregisterAllSocketEvents" ref="aa240ebb93ccd9129c060922539fc18f8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::TcpTimerEventManager::deregisterAllSocketEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister all callbacks associated with any event on any socket handle so that no callbacks are not invoked when any event occurs on any handle. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a3f9ed24912c0776c7da945f75a8fcd43">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="aea424fad019e521f2b33948f96750304"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::deregisterAllTimers" ref="aea424fad019e521f2b33948f96750304" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::TcpTimerEventManager::deregisterAllTimers </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all timer callbacks currently registered. The number of timers (as reported by <code>numTimers</code>) method is 0 after this method is completed. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#ab1d57adeb86b60497515cfd11654a1d5">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="aa54cd8ba17d83e412d4c9015ecd6822f"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::deregisterAll" ref="aa54cd8ba17d83e412d4c9015ecd6822f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::TcpTimerEventManager::deregisterAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister all callbacks currently registered. Note that the behavior is equivalent to the sequence: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbtlmt_1_1TcpTimerEventManager.html#aea424fad019e521f2b33948f96750304">deregisterAllTimers</a>();
          <a class="code" href="classbtlmt_1_1TcpTimerEventManager.html#aa240ebb93ccd9129c060922539fc18f8">deregisterAllSocketEvents</a>();
</pre></div><p><br/>
<br/>
 </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a810bbb83036ccf6d140dc0428df5194a">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a955a7ae0ce302d1337b03f9d0bc75e71"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::deregisterSocketEvent" ref="a955a7ae0ce302d1337b03f9d0bc75e71" args="(const btlso::SocketHandle::Handle &amp;handle, btlso::EventType::Type event)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::TcpTimerEventManager::deregisterSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister the callback associated with the specified <code>event</code> on the specified <code>handle</code> so that said callback will not be invoked if the <code>event</code> occurs. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a9e56ec1e396bf7fb1c4c66661456a050">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a26eedb6f5f4acba6056aa3c40f1a5250"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::deregisterSocket" ref="a26eedb6f5f4acba6056aa3c40f1a5250" args="(const btlso::SocketHandle::Handle &amp;handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::TcpTimerEventManager::deregisterSocket </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister all callbacks associated with any event on the specified <code>handle</code> such that no callback will be invoked if an event occurs on the <code>handle</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a8c5ae36b8a8ac616a8a2bfc714d79054">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="aa29ea8bce844c187c6942a41da0874b6"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::deregisterTimer" ref="aa29ea8bce844c187c6942a41da0874b6" args="(const void *timerId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void btlmt::TcpTimerEventManager::deregisterTimer </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>timerId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister the callback associated with the specified <code>timerId</code> (returned when the timer callback was registered) so that the callback will not be invoked at the appointed time. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a9bb2b4408ccc5baa21bbfa9b7e52c75b">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a538e054096d8c97c77466c26b823e597"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::disable" ref="a538e054096d8c97c77466c26b823e597" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::TcpTimerEventManager::disable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the internal thread responsible for monitoring sockets and dispatching timer and socket callbacks. Return 0 on success and a non-zero value otherwise. If this event manager is not already enabled, as reported by <code>isEnabled</code> method, this method returns immediately with 0. Otherwise, it will block until the internal thread exits. Note that <code>disable</code> will always fail if invoked, through a callback, in the internal thread. </p>

</div>
</div>
<a class="anchor" id="af5aadadedc8858fc4f7594d66154c800"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::enable" ref="af5aadadedc8858fc4f7594d66154c800" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::TcpTimerEventManager::enable </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a782916fcc735b76d1794b3a3e876c3"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::enable" ref="a0a782916fcc735b76d1794b3a3e876c3" args="(const bslmt::ThreadAttributes &amp;attribute)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::TcpTimerEventManager::enable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>attribute</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create the internal thread responsible for monitoring sockets and dispatching timer and socket callbacks, optionally setting the <code>attribute</code> of the new thread to the specified <code>attribute</code>. Return 0 on success and a non-zero value otherwise. If this event manager is already enabled, as reported by <code>isEnabled</code> method, this method returns immediately with 0. Otherwise, it will block until the internal thread is started or failure occurs. </p>

</div>
</div>
<a class="anchor" id="a189115acbc54029980d2e0cc88ab8c38"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::execute" ref="a189115acbc54029980d2e0cc88ab8c38" args="(const bsl::function&lt; void()&gt; &amp;functor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::TcpTimerEventManager::execute </td>
          <td>(</td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>functor</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Execute the specified <code>functor</code> in the internal thread, if it is started. </p>

</div>
</div>
<a class="anchor" id="a891d92b7df449c5281cb603cc216d55a"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::clearExecuteQueue" ref="a891d92b7df449c5281cb603cc216d55a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::TcpTimerEventManager::clearExecuteQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clear the functors enqueued to the execute queue. </p>

</div>
</div>
<a class="anchor" id="a914282768790d7e528b3a0618547e950"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::registerSocketEvent" ref="a914282768790d7e528b3a0618547e950" args="(const btlso::SocketHandle::Handle &amp;handle, btlso::EventType::Type event, const btlso::EventManager::Callback &amp;cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::TcpTimerEventManager::registerSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register the specified <code>cb</code> functor to be invoked whenever the specified <code>event</code> occurs on the socket specified by <code>handle</code>. Return 0 on success and a negative number on error. No two different socket events can have callbacks registered with the same socket handle other than read and write. Any invocation of this method that would cause this to occur will result in an error and the callback will not be registered. The callback is recurring (i.e., it remains registered until it is explicitly deregistered). Note that the callback will be invoked only from the internal thread and that the callback may be invoked before this method returns. </p>

</div>
</div>
<a class="anchor" id="a1453c33da941f40b7213eb92620cd2ce"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::registerTimer" ref="a1453c33da941f40b7213eb92620cd2ce" args="(const bsls::TimeInterval &amp;timeout, const btlso::EventManager::Callback &amp;cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* btlmt::TcpTimerEventManager::registerTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1EventManager.html#a9223eeeac7abf312a41bd5ea42bccbe7">btlso::EventManager::Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cb</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register the specified <code>cb</code> functor to be invoked when the absolute time of the specified <code>timeout</code> is reached or exceeded. Return a <code>void*</code> registration id which can be used to deregister this timer before expiration. Specifying a <code>timeout</code> previous to the current time will result in the associated <code>cb</code> being executed almost immediately. Note also that the callback is not recurring (i.e., after being invoked it is deregistered automatically). Note that the callback will be invoked only from the internal thread and that the callback may be invoked before this method returns. </p>

</div>
</div>
<a class="anchor" id="a4f05c9498ac589e8d585170c1135ce0a"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::rescheduleTimer" ref="a4f05c9498ac589e8d585170c1135ce0a" args="(const void *timerId, const bsls::TimeInterval &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::TcpTimerEventManager::rescheduleTimer </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>timerId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reschedule the timer indicated by the specified <code>timerId</code> such that the callback function supplied to <code>registerTimer</code> will be invoked after the specified <code>expiryTime</code> is reached. Return 0 on success, and a negative value otherwise. <code>expiryTime</code> is expressed as the absolute time from 00:00:00 UTC, January 1, 1970 (the epoch time defined by <code>bdetu_epoch</code>). The behavior is undefined unless <code>timerId</code> is a timer id returned from <code>registerTimer</code>, and has not subsequently been deregistered. Note that if <code>expiryTime</code> is earlier than the current time (<code><a class="el" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now()</a></code>) the associated callback will be invoked the first time that the callbacks are dispatched. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#ae6b96a1530a80e9ba161dd76fda7cd7e">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a538180b1e2af47cbc141c46e4ed1222f"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::hasLimitedSocketCapacity" ref="a538180b1e2af47cbc141c46e4ed1222f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool btlmt::TcpTimerEventManager::hasLimitedSocketCapacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this event manager has a limited socket capacity, and <code>false</code> otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#ae450cb4cae93242ef11d419f61cd9ab9">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a89c99b80ef0a5a8f67e023f4b43d34af"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::isRegistered" ref="a89c99b80ef0a5a8f67e023f4b43d34af" args="(const btlso::SocketHandle::Handle &amp;handle, btlso::EventType::Type event) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::TcpTimerEventManager::isRegistered </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">btlso::EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if a callback is registered to be invoked when a socket event of the specified <code>event</code> occurs on the specified socket <code>handle</code>, and 0 otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#aa9ca3d3c934a9f6c7c2d747a1dc84acd">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a09704333bb58c492499b7ecd067259fe"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::numEvents" ref="a09704333bb58c492499b7ecd067259fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::TcpTimerEventManager::numEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of callbacks registered with this event manager for either timers or sockets. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#ab2a349c2c66e5647300a30f0c3abf586">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="aa351c616b0bc261a11d14679bf118481"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::numTimers" ref="aa351c616b0bc261a11d14679bf118481" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::TcpTimerEventManager::numTimers </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of timers that are currently registered. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#a233cec4ccaab3ecd5536f80aed3d53c0">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a3fbfed5913ac549da9976137c06ef2ea"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::numSocketEvents" ref="a3fbfed5913ac549da9976137c06ef2ea" args="(const btlso::SocketHandle::Handle &amp;handle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlmt::TcpTimerEventManager::numSocketEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">btlso::SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of callbacks registered for the specified socket <code>handle</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1TimerEventManager.html#aa414b377a1fe2cf979811c46a64e90c2">btlso::TimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a211250700d79438e5c964b9971e2cc1d"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::numTotalSocketEvents" ref="a211250700d79438e5c964b9971e2cc1d" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::TcpTimerEventManager::numTotalSocketEvents </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of socket callbacks registered with this event manager. </p>

</div>
</div>
<a class="anchor" id="a353e25104dd5831809ca5c3317090c21"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::timeMetrics" ref="a353e25104dd5831809ca5c3317090c21" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1TimeMetrics.html">btlso::TimeMetrics</a>* btlmt::TcpTimerEventManager::timeMetrics </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable time metrics object that provides a breakdown of the time this event manager has spent processing data. Note that the metrics managed by the returned object have unspecified values unless <code>hasTimeMetrics</code> returns <code>true</code>. </p>

</div>
</div>
<a class="anchor" id="ad8822ca70e00daf89c5d306840589714"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::dispatcherThreadHandle" ref="ad8822ca70e00daf89c5d306840589714" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> btlmt::TcpTimerEventManager::dispatcherThreadHandle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the thread handle of the dispatcher thread of this object. </p>

</div>
</div>
<a class="anchor" id="afdf36c984e2fc32a2c4986ab470ec987"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::isEnabled" ref="afdf36c984e2fc32a2c4986ab470ec987" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::TcpTimerEventManager::isEnabled </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if the dispatch thread is created/running and 0 otherwise. </p>

</div>
</div>
<a class="anchor" id="a684c1066630aebfb0850bf4e71850565"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::hasTimeMetrics" ref="a684c1066630aebfb0850bf4e71850565" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool btlmt::TcpTimerEventManager::hasTimeMetrics </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the object returned by <code><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a353e25104dd5831809ca5c3317090c21">timeMetrics()</a></code> contains a valid value, and <code>false</code> otherwise. This value will be <code>false</code> if either the (optional) <code>collectTimeMetrics</code> value supplied at construction was <code>false</code>, or if a <code>rawEventManager</code> was provided at construction. Note that if the value is <code>false</code>, the value of the object returned by <code><a class="el" href="classbtlmt_1_1TcpTimerEventManager.html#a353e25104dd5831809ca5c3317090c21">timeMetrics()</a></code> is not specified. </p>

</div>
</div>
<a class="anchor" id="aaf9e2a2c3cbe722101a53d20b3621bae"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::registerSocketEvent" ref="aaf9e2a2c3cbe722101a53d20b3621bae" args="(const SocketHandle::Handle &amp;handle, EventType::Type event, const TimerEventManager::Callback &amp;callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int btlso::TimerEventManager::registerSocketEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89">EventType::Type</a>&nbsp;</td>
          <td class="paramname"> <em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">TimerEventManager::Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register the occurrence of the specified <code>event</code> on the specified socket <code>handle</code> such that the specified <code>callback</code> functor is invoked when this event occurs. Return 0 on success and a negative value otherwise. Socket event registrations stay in effect until they are subsequently deregistered; the callback is invoked each time the specified <code>event</code> is seen. Typically, <code><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a5ae2f7a5836b3e65f7dd633c844578ce">EventType::e_READ</a></code> and <code><a class="el" href="structbtlso_1_1EventType.html#a9765ecd8da4c8a8b7a02bfb7bfc87b89a7ab5e1901b2dcaf12f9a54938a81a030">EventType::e_WRITE</a></code> are the only events that can be registered simultaneously for a socket. Simultaneously registering for incompatible events for the same socket <code>handle</code> will result in undefined behavior. If a registration attempt is made for an event that is already registered, the callback associated with this event will be overwritten with the new one. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1TcpTimerEventManager.html#af90c9e1cb7b4ed18d5c8064d679472fb">btlso::TcpTimerEventManager</a>.</p>

</div>
</div>
<a class="anchor" id="a069d2261a617c5158ff70f298687b1df"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::registerTimer" ref="a069d2261a617c5158ff70f298687b1df" args="(const bsls::TimeInterval &amp;expiryTime, const TimerEventManager::Callback &amp;callback)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* btlso::TimerEventManager::registerTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>expiryTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1TimerEventManager.html#a721dbe10938308965a8a70b1430029af">TimerEventManager::Callback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register a timer such that the specified <code>callback</code> functor will be invoked after the specified <code>expiryTime</code> is reached. Return a unique identifier for the registered timer. Note that a timer can be deregistered at any time before it expires by passing this identifier to the <code>deregisterTimer</code> method. Specifying an <code>expiryTime</code> earlier than the current time (<code><a class="el" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now()</a></code>) will result in the associated <code>callback</code> being invoked the first time that the callbacks are dispatched. </p>

<p>Implemented in <a class="el" href="classbtlso_1_1TcpTimerEventManager.html#a18f42abe47d1ebef067878e42a8c732c">btlso::TcpTimerEventManager</a>.</p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac3862f815552ed7ea1d0e5792667323d"></a><!-- doxytag: member="btlmt::TcpTimerEventManager::TcpTimerEventManager_TestUtil" ref="ac3862f815552ed7ea1d0e5792667323d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structbtlmt_1_1TcpTimerEventManager__TestUtil.html">TcpTimerEventManager_TestUtil</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlmt__tcptimereventmanager_8h_source.html">btlmt_tcptimereventmanager.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
