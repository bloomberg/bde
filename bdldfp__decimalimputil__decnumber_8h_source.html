<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdldfp_decimalimputil_decnumber.h                                  -*-C++-*-
#ifndef INCLUDED_BDLDFP_DECIMALIMPUTIL_DECNUMBER
#define INCLUDED_BDLDFP_DECIMALIMPUTIL_DECNUMBER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$&quot;)

//@PURPOSE: Provide utility implementing decimal FP on the decNumber library.
//
//@CLASSES:
//  bdldfp::DecimalImpUtil_DecNumber: Namespace for decNumber FP functions
//
//@SEE_ALSO: bdldfp_decimal, bdldfp_decimalplatform
//
//@DESCRIPTION: This component, &#39;bdldfp::DecimalImpUtil_DecNumber&#39; is for
// internal use only by the &#39;bdldfp_decimal*&#39; components.  Direct use of any
// names declared in this component by any other code invokes undefined
// behavior.  In other words: this code may change, disappear, break, move
// without notice, and no support whatsoever will ever be provided for it.
// This component provides implementations of core Decimal Floating Point
// functionality using the Intel DFP library.
//
///Usage
///-----
// This section shows the intended use of this component.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLDFP_DECIMALPLATFORM
#include &lt;bdldfp_decimalplatform.h&gt;
#endif

#ifndef INCLUDED_BDLDFP_DENSELYPACKEDDECIMALIMPUTIL
#include &lt;bdldfp_denselypackeddecimalimputil.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_LOCALE
#include &lt;bsl_locale.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_DECSINGLE
extern &quot;C&quot; {
#include &lt;decSingle.h&gt;
}
#endif


namespace BloombergLP {
namespace bdldfp {

                          // ==============================
                          // class DecimalImpUtil_DecNumber
                          // ==============================

struct DecimalImpUtil_DecNumber {
    // This &#39;struct&#39; provides a namespace for implementation functions that
    // work in terms of the underlying C-style decimal floating point
    // implementation, decNumber.

    // TYPES

    typedef decSingle ValueType32;
    typedef decDouble ValueType64;
    typedef decQuad   ValueType128;

  private:

    // PRIVATE HELPERS
    static ValueType32 roundToDecimal32(long long int value);
    static ValueType32 roundToDecimal32(unsigned long long int value);
        // Return the specified integral &#39;value&#39; rounded to the closest
        // &#39;ValueType32&#39;.  The behavior is undefined if &#39;value&#39; can
        // be represented exactly in &#39;ValueType32&#39;.

    static ValueType64 roundToDecimal64(long long int value);
    static ValueType64 roundToDecimal64(unsigned long long int value);
        // Return the specified integral &#39;value&#39; rounded to the closest
        // &#39;ValueType32&#39;.  The behavior is undefined if &#39;value&#39; can
        // be represented exactly in &#39;ValueType32&#39;.

  public:

    static decContext *getDecNumberContext();
        // Return a pointer providing modifiable access to the floating point
        // environment of the &#39;decNumber&#39; library.  This function does not get
        // exposed through &#39;bdldfp::DecimalImpUtil&#39;.



    // CLASS METHODS

                        // Integer construction (32-bit)

    static ValueType32   int32ToDecimal32 (                   int value);
    static ValueType32  uint32ToDecimal32 (unsigned           int value);
    static ValueType32   int64ToDecimal32 (         long long int value);
    static ValueType32  uint64ToDecimal32 (unsigned long long int value);
        // Return a &#39;Decimal32&#39; object having the value closest to the
        // specified &#39;value&#39; following the conversion rules as defined by
        // IEEE-754:
        //
        //: o If &#39;value&#39; is zero then initialize this object to a zero with an
        //:   unspecified sign and an unspecified exponent.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and initialize this object to infinity
        //:   with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has a value that is not exactly
        //:   representable using &#39;std::numeric_limits&lt;Decimal32&gt;::max_digit&#39;
        //:   decimal digits then raise the &quot;inexact&quot; floating-point exception
        //:   and initialize this object to the value of &#39;other&#39; rounded
        //:   according to the rounding direction.
        //:
        //: o Otherwise initialize this object to the value of the &#39;value&#39;.
        //
        // The exponent 0 (quantum 1e-6) is preferred during conversion unless
        // it would cause unnecessary loss of precision.

                        // Integer construction (64-bit)

    static ValueType64   int32ToDecimal64 (                   int value);
    static ValueType64  uint32ToDecimal64 (unsigned           int value);
    static ValueType64   int64ToDecimal64 (         long long int value);
    static ValueType64  uint64ToDecimal64 (unsigned long long int value);
        // Return a &#39;Decimal64&#39; object having the value closest to the
        // specified &#39;value&#39; following the conversion rules as defined by
        // IEEE-754:
        //
        //: o If &#39;value&#39; is zero then initialize this object to a zero with an
        //:   unspecified sign and an unspecified exponent.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and initialize this object to infinity
        //:   with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has a value that is not exactly
        //:   representable using &#39;std::numeric_limits&lt;Decimal64&gt;::max_digit&#39;
        //:   decimal digits then raise the &quot;inexact&quot; floating-point exception
        //:   and initialize this object to the value of &#39;other&#39; rounded
        //:   according to the rounding direction.
        //:
        //: o Otherwise initialize this object to the value of the &#39;value&#39;.
        //
        // The exponent 0 (quantum 1e-15) is preferred during conversion unless
        // it would cause unnecessary loss of precision.

                        // Integer construction (128-bit)

    static ValueType128  int32ToDecimal128(                   int value);
    static ValueType128 uint32ToDecimal128(unsigned           int value);
    static ValueType128  int64ToDecimal128(         long long int value);
    static ValueType128 uint64ToDecimal128(unsigned long long int value);
        // Return a &#39;Decimal128&#39; object having the value closest to the
        // specified &#39;value&#39; subject to the conversion rules as defined by
        // IEEE-754:
        //
        //: o If &#39;value&#39; is zero then initialize this object to a zero with an
        //:   unspecified sign and an unspecified exponent.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and initialize this object to
        //:   infinity with the same sign as &#39;other&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has a value that is not exactly
        //:   representable using &#39;std::numeric_limits&lt;Decimal128&gt;::max_digit&#39;
        //:   decimal digits then raise the &quot;inexact&quot; floating-point exception
        //:   and initialize this object to the value of &#39;value&#39; rounded
        //:   according to the rounding direction.
        //:
        //: o Otherwise initialize this object to &#39;value&#39;.
        //
        // The exponent 0 (quantum 1e-33) is preferred during conversion unless
        // it would cause unnecessary loss of precision.

                        // Arithmetic functions

                        // Addition functions

    static ValueType64  add(ValueType64  lhs,  ValueType64  rhs);
    static ValueType128 add(ValueType128 lhs,  ValueType128 rhs);
        // Add the value of the specified &#39;rhs&#39; to the value of the specified
        // &#39;lhs&#39; as described by IEEE-754 and return the result.
        //
        //: o If either of &#39;lhs&#39; or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
        //:   floating-point exception and return a NaN.
        //:
        //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are infinities of differing signs,
        //:   raise the &quot;invalid&quot; floating-point exception and return a NaN.
        //:
        //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are infinities of the same sign then
        //:   return infinity of that sign.
        //:
        //: o Otherwise if &#39;rhs&#39; is zero (positive or negative), return &#39;lhs&#39;.
        //:
        //: o Otherwise if the sum of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value
        //:   that is larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then
        //:   raise the &quot;overflow&quot; floating-point exception and return infinity
        //:   with the same sign as that result.
        //:
        //: o Otherwise return the sum of the number represented by &#39;lhs&#39; and
        //:   the number represented by &#39;rhs&#39;.

                        // Subtraction functions

    static ValueType64  subtract(ValueType64  lhs,  ValueType64  rhs);
    static ValueType128 subtract(ValueType128 lhs,  ValueType128 rhs);
        // Subtract the value of the specified &#39;rhs&#39; from the value of the
        // specified &#39;lhs&#39; as described by IEEE-754 and return the result.
        //
        //: o If either &#39;lhs&#39; or &#39;rhs&#39; is NaN, then raise the &quot;invalid&quot;
        //:   floating-point exception and return a NaN.
        //:
        //: o Otherwise if &#39;lhs&#39; and the &#39;rhs&#39; have infinity values of the same
        //:   sign, then raise the &quot;invalid&quot; floating-point exception and
        //:   return a NaN.
        //:
        //: o Otherwise if &#39;lhs&#39; and the &#39;rhs&#39; have infinity values of
        //:   differing signs, then return &#39;lhs&#39;.
        //:
        //: o Otherwise if &#39;rhs&#39; has a zero value (positive or negative), then
        //:   return &#39;lhs&#39;.
        //:
        //: o Otherwise if subtracting the value of the &#39;rhs&#39; object from the
        //:   value of &#39;lhs&#39; results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and return infinity with the same sign
        //:   as that result.
        //:
        //: o Otherwise return the result of subtracting the value of &#39;rhs&#39;
        //:   from the value of &#39;lhs&#39;.

                        // Multiplication functions

    static ValueType64  multiply(ValueType64  lhs,  ValueType64  rhs);
    static ValueType128 multiply(ValueType128 lhs,  ValueType128 rhs);
        // Multiply the value of the specified &#39;lhs&#39; object by the value of the
        // specified &#39;rhs&#39; as described by IEEE-754 and return the result.
        //
        //: o If either of &#39;lhs&#39; or &#39;rhs&#39; is NaN, return a NaN.
        //:
        //: o Otherwise if one of the operands is infinity (positive or
        //:   negative) and the other is zero (positive or negative), then
        //:   raise the &quot;invalid&quot; floating-point exception raised and return a
        //:   NaN.
        //:
        //: o Otherwise if both &#39;lhs&#39; and &#39;rhs&#39; are infinity (positive or
        //:   negative), return infinity.  The sign of the returned value will
        //:   be positive if &#39;lhs&#39; and &#39;rhs&#39; have the same sign, and negative
        //:   otherwise.
        //:
        //: o Otherwise, if either &#39;lhs&#39; or &#39;rhs&#39; is zero, return zero.  The
        //:   sign of the returned value will be positive if &#39;lhs&#39; and &#39;rhs&#39;
        //:   have the same sign, and negative otherwise.
        //:
        //: o Otherwise if the product of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value
        //:   that is larger than &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then
        //:   raise the &quot;overflow&quot; floating-point exception and return infinity
        //:   with the same sign as that result.
        //:
        //: o Otherwise if the product of &#39;lhs&#39; and &#39;rhs&#39; has an absolute value
        //:   that is smaller than &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then
        //:   raise the &quot;underflow&quot; floating-point exception and return zero
        //:   with the same sign as that result.
        //:
        //: o Otherwise return the product of the value of &#39;rhs&#39; and the number
        //:   represented by &#39;rhs&#39;.

                        // Division functions

    static ValueType64  divide(ValueType64  lhs,  ValueType64  rhs);
    static ValueType128 divide(ValueType128 lhs,  ValueType128 rhs);
        // Divide the value of the specified &#39;lhs&#39; by the value of the
        // specified &#39;rhs&#39; as described by IEEE-754, and return the result.
        //
        //: o If &#39;lhs&#39; or &#39;rhs&#39; is NaN, raise the &quot;invalid&quot; floating-point
        //:   exception and return a NaN.
        //:
        //: o Otherwise if &#39;lhs&#39; and &#39;rhs&#39; are both infinity (positive or
        //:   negative) or both zero (positive or negative), raise the
        //:   &quot;invalid&quot; floating-point exception and return a NaN.
        //:
        //: o Otherwise if &#39;rhs&#39; has a positive zero value, raise the
        //:   &quot;overflow&quot; floating-point exception and return infinity with the
        //:   sign of &#39;lhs&#39;.
        //:
        //: o Otherwise if &#39;rhs&#39; has a negative zero value, raise the
        //:   &quot;overflow&quot; floating-point exception and return infinity with the
        //:   opposite sign as &#39;lhs&#39;.
        //:
        //: o Otherwise if dividing the value of &#39;lhs&#39; with the value of &#39;rhs&#39;
        //:   results in an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and return infinity with the same sign
        //:   as that result.
        //:
        //: o Otherwise if dividing the value of &#39;lhs&#39; with the value of &#39;rhs&#39;
        //:   results in an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and return zero with the
        //:   same sign as that result.
        //:
        //: o Otherwise return the result of dividing the value of &#39;lhs&#39; with
        //:   the value of &#39;rhs&#39;.

                        // Negation functions

    static ValueType32  negate(ValueType32  value);
    static ValueType64  negate(ValueType64  value);
    static ValueType128 negate(ValueType128 value);
        // Return the result of applying the unary - operator to the specified
        // &#39;value&#39; as described by IEEE-754.  Note that floating-point numbers
        // have signed zero, therefore this operation is not the same as
        // &#39;0-value&#39;.

                        // Comparison functions

                        // Less Than functions

    static bool less(ValueType32  lhs, ValueType32  rhs);
    static bool less(ValueType64  lhs, ValueType64  rhs);
    static bool less(ValueType128 lhs, ValueType128 rhs);
        // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than the
        // specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a &#39;Decimal64&#39;
        // object &#39;lhs&#39; is less than that of an object &#39;rhs&#39; if the
        // &#39;compareQuietLess&#39; operation (IEEE-754 defined, non-total ordering
        // comparison) considers the underlying IEEE representation of &#39;lhs&#39; to
        // be less than of that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is less than
        // &#39;rhs&#39; if:
        //
        //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
        //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; is positive, or
        //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; negative, or
        //: o &#39;lhs&#39; is not positive infinity, or
        //: o &#39;lhs&#39; is negative infinity and &#39;rhs&#39; is not, or
        //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number
        //:   of &#39;lhs&#39; is less than that of &#39;rhs&#39;
        //
        // This operation raises the &quot;invalid&quot; floating-point exception if
        // either or both operands are NaN.

                        // Greater Than functions

    static bool greater(ValueType32  lhs, ValueType32  rhs);
    static bool greater(ValueType64  lhs, ValueType64  rhs);
    static bool greater(ValueType128 lhs, ValueType128 rhs);
        // Return &#39;true&#39; if the specified &#39;lhs&#39; has a greater value than the
        // specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value of a &#39;Decimal64&#39;
        // object &#39;lhs&#39; is greater than that of an object &#39;rhs&#39; if the
        // &#39;compareQuietGreater&#39; operation (IEEE-754 defined, non-total
        // ordering comparison) considers the underlying IEEE representation of
        // &#39;lhs&#39; to be greater than of that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is
        // greater than &#39;rhs&#39; if:
        //
        //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
        //: o &#39;rhs&#39; is zero (positive or negative) and &#39;lhs&#39; positive, or
        //: o &#39;lhs&#39; is zero (positive or negative) and &#39;rhs&#39; negative, or
        //: o &#39;lhs&#39; is not negative infinity, or
        //: o &#39;lhs&#39; is positive infinity and &#39;rhs&#39; is not, or
        //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number
        //:   of &#39;lhs&#39; is greater than that of &#39;rhs&#39;
        //
        // This operation raises the &quot;invalid&quot; floating-point exception if
        // either or both operands are NaN.

                        // Less Or Equal functions

    static bool lessEqual(ValueType32  lhs, ValueType32  rhs);
    static bool lessEqual(ValueType64  lhs, ValueType64  rhs);
    static bool lessEqual(ValueType128 lhs, ValueType128 rhs);
        // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value less than or equal
        // the value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.  The value
        // of a &#39;Decimal64&#39; object &#39;lhs&#39; is less than or equal to the value of
        // an object &#39;rhs&#39; if the &#39;compareQuietLessEqual&#39; operation (IEEE-754
        // defined, non-total ordering comparison) considers the underlying
        // IEEE representation of &#39;lhs&#39; to be less or equal to that of &#39;rhs&#39;.
        // In other words, &#39;lhs&#39; is less or equal than &#39;rhs&#39; if:
        //
        //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
        //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
        //: o both &#39;lhs&#39; and &#39;rhs&#39; are positive infinity, or
        //: o &#39;lhs&#39; is negative infinity, or
        //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number
        //:   of &#39;lhs&#39; is less or equal to that of &#39;rhs&#39;
        //
        // This operation raises the &quot;invalid&quot; floating-point exception if
        // either or both operands are NaN.

                        // Greater Or Equal functions

    static bool greaterEqual(ValueType32  lhs, ValueType32  rhs);
    static bool greaterEqual(ValueType64  lhs, ValueType64  rhs);
    static bool greaterEqual(ValueType128 lhs, ValueType128 rhs);
        // Return &#39;true&#39; if the specified &#39;lhs&#39; has a value greater than or
        // equal to the value of the specified &#39;rhs&#39; and &#39;false&#39; otherwise.
        // The value of a &#39;Decimal64&#39; object &#39;lhs&#39; is greater or equal to a
        // &#39;Decimal64&#39; object &#39;rhs&#39; if the &#39;compareQuietGreaterEqual&#39; operation
        // (IEEE-754 defined, non-total ordering comparison ) considers the
        // underlying IEEE representation of &#39;lhs&#39; to be greater or equal to
        // that of &#39;rhs&#39;.  In other words, &#39;lhs&#39; is greater than or equal to
        // &#39;rhs&#39; if:
        //
        //: o neither &#39;lhs&#39; nor &#39;rhs&#39; are NaN, or
        //: o &#39;lhs&#39; and &#39;rhs&#39; are both zero (positive or negative), or
        //: o both &#39;lhs&#39; and &#39;rhs&#39; are negative infinity, or
        //: o &#39;lhs&#39; is positive infinity, or
        //: o &#39;lhs&#39; and &#39;rhs&#39; both represent a real number and the real number
        //:   of &#39;lhs&#39; is greater or equal to that of &#39;rhs&#39;
        //
        // This operation raises the &quot;invalid&quot; floating-point exception if
        // either or both operands are NaN.

                        // Equality functions

    static bool equal(ValueType32  lhs, ValueType32  rhs);
    static bool equal(ValueType64  lhs, ValueType64  rhs);
    static bool equal(ValueType128 lhs, ValueType128 rhs);
        // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value,
        // and &#39;false&#39; otherwise.  Two decimal objects have the same value if
        // the &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total
        // ordering comparison) considers the underlying IEEE representations
        // equal.  In other words, two decimal objects have the same value if:
        //
        //: o both have a zero value (positive or negative), or
        //:
        //: o both have the same infinity value (both positive or negative), or
        //:
        //: o both have the value of a real number that are equal, even if they
        //:   are represented differently (cohorts have the same value)
        //
        // This operation raises the &quot;invalid&quot; floating-point exception if
        // either or both operands are NaN.

                        // Inequality functions

    static bool notEqual(ValueType32  lhs, ValueType32  rhs);
    static bool notEqual(ValueType64  lhs, ValueType64  rhs);
    static bool notEqual(ValueType128 lhs, ValueType128 rhs);
        // Return &#39;false&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value,
        // and &#39;true&#39; otherwise.  Two decimal objects have the same value if
        // the &#39;compareQuietEqual&#39; operation (IEEE-754 defined, non-total
        // ordering comparison) considers the underlying IEEE representations
        // equal.  In other words, two decimal objects have the same value if:
        //
        //: o both have a zero value (positive or negative), or
        //:
        //: o both have the same infinity value (both positive or negative), or
        //:
        //: o both have the value of a real number that are equal, even if they
        //:   are represented differently (cohorts have the same value)
        //
        // This operation raises the &quot;invalid&quot; floating-point exception if
        // either or both operands are NaN.

                        // Inter-type Conversion functions

    static ValueType32  convertToDecimal32 (const ValueType64&amp;  input);
    static ValueType64  convertToDecimal64 (const ValueType32&amp;  input);
    static ValueType64  convertToDecimal64 (const ValueType128&amp; input);
    static ValueType128 convertToDecimal128(const ValueType32&amp;  input);
    static ValueType128 convertToDecimal128(const ValueType64&amp;  input);
        // Convert the specified &#39;input&#39; to the indicated result type.  Note
        // that a conversion from &#39;ValueType128&#39; to &#39;ValueType32&#39; is not
        // provided (because such a conversion is not provided by the
        // &#39;decNumber&#39; library).  A conversion from 128-bit to 32-bit
        // representations is *not* identical to the composing the conversions
        // from 128-bit to 64-bit, and 64-bit to 32-bit representations,
        // because rounding should only be performed once.

                        // Binary floating point conversion functions

    static ValueType32 binaryToDecimal32(      float value);
    static ValueType32 binaryToDecimal32(     double value);
        // Create a &#39;Decimal32&#39; object having the value closest to the
        // specified &#39;value&#39; following the conversion rules as defined by
        // IEEE-754:
        //
        //: o If &#39;value&#39; is NaN, return a NaN.
        //:
        //: o Otherwise if &#39;value&#39; is infinity (positive or negative), then
        //:   return an object equal to infinity with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; is a zero value, then return an object equal
        //:   to zero with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and return an infinity with the same
        //:   sign as &#39;value&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and return a zero with the
        //:   same sign as &#39;value&#39;.
        //:
        //: o Otherwise if &#39;value&#39; needs more than
        //:   &#39;std::numeric_limits&lt;Decimal32&gt;::max_digit&#39; significant decimal
        //:   digits to represent then raise the &quot;inexact&quot; floating-point
        //:   exception and return the &#39;value&#39; rounded according to the
        //:   rounding direction.
        //:
        //: o Otherwise return a &#39;Decimal32&#39; object representing &#39;value&#39;.

    static ValueType64 binaryToDecimal64(      float value);
    static ValueType64 binaryToDecimal64(     double value);
        // Create a &#39;Decimal64&#39; object having the value closest to the
        // specified &#39;value&#39; following the conversion rules as defined by
        // IEEE-754:
        //
        //: o If &#39;value&#39; is NaN, return a NaN.
        //:
        //: o Otherwise if &#39;value&#39; is infinity (positive or negative), then
        //:   return an object equal to infinity with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; is a zero value, then return an object equal
        //:   to zero with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max()&#39; then raise the &quot;overflow&quot;
        //:   floating-point exception and return an infinity with the same
        //:   sign as &#39;value&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and return a zero with the
        //:   same sign as &#39;value&#39;.
        //:
        //: o Otherwise if &#39;value&#39; needs more than
        //:   &#39;std::numeric_limits&lt;Decimal64&gt;::max_digit&#39; significant decimal
        //:   digits to represent then raise the &quot;inexact&quot; floating-point
        //:   exception and return the &#39;value&#39; rounded according to the
        //:   rounding direction.
        //:
        //: o Otherwise return a &#39;Decimal64&#39; object representing &#39;value&#39;.

    static ValueType128 binaryToDecimal128(      float value);
    static ValueType128 binaryToDecimal128(     double value);
        // Create a &#39;Decimal128&#39; object having the value closest to the
        // specified &#39;value&#39; following the conversion rules as defined by
        // IEEE-754:
        //
        //: o If &#39;value&#39; is NaN, return a NaN.
        //:
        //: o Otherwise if &#39;value&#39; is infinity (positive or negative), then
        //:   return an object equal to infinity with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; is a zero value, then return an object equal
        //:   to zero with the same sign.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is larger than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max()&#39; then raise the
        //:   &quot;overflow&quot; floating-point exception and return an infinity with
        //:   the same sign as &#39;value&#39;.
        //:
        //: o Otherwise if &#39;value&#39; has an absolute value that is smaller than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::min()&#39; then raise the
        //:   &quot;underflow&quot; floating-point exception and return a zero with the
        //:   same sign as &#39;value&#39;.
        //:
        //: o Otherwise if &#39;value&#39; needs more than
        //:   &#39;std::numeric_limits&lt;Decimal128&gt;::max_digit&#39; significant decimal
        //:   digits to represent then raise the &quot;inexact&quot; floating-point
        //:   exception and return the &#39;value&#39; rounded according to the
        //:   rounding direction.
        //:
        //: o Otherwise return a &#39;Decimal128&#39; object representing &#39;value&#39;.

    static ValueType32 makeDecimalRaw32(int significand, int exponent);
        // Create a &#39;ValueType32&#39; object representing a decimal floating point
        // number consisting of the specified &#39;significand&#39; and &#39;exponent&#39;,
        // with the sign given by &#39;significand&#39;.  The behavior is undefined
        // unless &#39;abs(significand) &lt;= 9,999,999&#39; and &#39;-101 &lt;= exponent &lt;= 90&#39;.

    static ValueType64 makeDecimalRaw64(unsigned long long int significand,
                                                           int exponent);
    static ValueType64 makeDecimalRaw64(         long long int significand,
                                                           int exponent);
    static ValueType64 makeDecimalRaw64(unsigned           int significand,
                                                           int exponent);
    static ValueType64 makeDecimalRaw64(                   int significand,
                                                           int exponent);
        // Create a &#39;ValueType64&#39; object representing a decimal floating point
        // number consisting of the specified &#39;significand&#39; and &#39;exponent&#39;,
        // with the sign given by &#39;significand&#39;.  The behavior is undefined
        // unless &#39;abs(significand) &lt;= 9,999,999,999,999,999&#39; and
        // &#39;-398 &lt;= exponent &lt;= 369&#39;.

    static ValueType128 makeDecimalRaw128(unsigned long long int significand,
                                                             int exponent);
    static ValueType128 makeDecimalRaw128(         long long int significand,
                                                             int exponent);
    static ValueType128 makeDecimalRaw128(unsigned           int significand,
                                                             int exponent);
    static ValueType128 makeDecimalRaw128(                   int significand,
                                                             int exponent);
        // Create a &#39;ValueType128&#39; object representing a decimal floating point
        // number consisting of the specified &#39;significand&#39; and &#39;exponent&#39;,
        // with the sign given by &#39;significand&#39;.  The behavior is undefined
        // unless &#39;-6176 &lt;= exponent &lt;= 6111&#39;.

                        // IEEE Scale B functions

    static ValueType32  scaleB(ValueType32  value, int exponent);
    static ValueType64  scaleB(ValueType64  value, int exponent);
    static ValueType128 scaleB(ValueType128 value, int exponent);
        // Return the result of multiplying the specified &#39;value&#39; by ten raised
        // to the specified &#39;exponent&#39;.  The quantum of &#39;value&#39; is scaled
        // according to IEEE 754&#39;s &#39;scaleB&#39; operations.  The result is
        // unspecified if &#39;value&#39; is NaN or infinity.  The behavior is
        // undefined unless &#39;-1999999997 &lt;= y &lt;= 99999999&#39;.


                        // Parsing functions

    static ValueType32 parse32 (const char *string);
        // Parse the specified &#39;string&#39; as a 32 bit decimal floating- point
        // value and return the result.  The parsing is as specified for the
        // &#39;strtod32&#39; function in section 9.6 of the ISO/EIC TR 24732 C Decimal
        // Floating-Point Technical Report, except that it is unspecified
        // whether the NaNs returned are quiet or signaling.  The behavior is
        // undefined unless &#39;input&#39; represents a valid 32 bit decimal
        // floating-point number in scientific or fixed notation, and no
        // unrelated characters precede (not even whitespace) that textual
        // representation and a terminating nul character immediately follows
        // it.  Note that this method does not guarantee the behavior of
        // ISO/EIC TR 24732 C when parsing NaN because the AIX compiler
        // intrinsics return a signaling NaN.

    static ValueType64 parse64(const char *string);
        // Parse the specified &#39;string&#39; string as a 64 bit decimal floating-
        // point value and return the result.  The parsing is as specified for
        // the &#39;strtod64&#39; function in section 9.6 of the ISO/EIC TR 24732 C
        // Decimal Floating-Point Technical Report, except that it is
        // unspecified whether the NaNs returned are quiet or signaling.  The
        // behavior is undefined unless &#39;input&#39; represents a valid 64 bit
        // decimal floating-point number in scientific or fixed notation, and
        // no unrelated characters precede (not even whitespace) that textual
        // representation and a terminating nul character immediately follows
        // it.  Note that this method does not guarantee the behavior of
        // ISO/EIC TR 24732 C when parsing NaN because the AIX compiler
        // intrinsics return a signaling NaN.

    static ValueType128 parse128(const char *string);
        // Parse the specified &#39;string&#39; string as a 128 bit decimal floating-
        // point value and return the result.  The parsing is as specified for
        // the &#39;strtod128&#39; function in section 9.6 of the ISO/EIC TR 24732 C
        // Decimal Floating-Point Technical Report, except that it is
        // unspecified whether the NaNs returned are quiet or signaling.  The
        // behavior is undefined unless &#39;input&#39; represents a valid 128 bit
        // decimal floating-point number in scientific or fixed notation, and
        // no unrelated characters precede (not even whitespace) that textual
        // representation and a terminating nul character immediately follows
        // it.  Note that this method does not guarantee the behavior of
        // ISO/EIC TR 24732 C when parsing NaN because the AIX compiler
        // intrinsics return a signaling NaN.

                        // Formatting Functions

    static void format(ValueType32  value, char *buffer);
    static void format(ValueType64  value, char *buffer);
    static void format(ValueType128 value, char *buffer);
        // Produce a string representation of the specified decimal &#39;value&#39;, in
        // the specified &#39;buffer&#39;, which is at least
        // &#39;BDLDFP_DECIMALPLATFORM_SNPRINTF_BUFFER_SIZE&#39; bytes in length.  The
        // string will be suitable for use with the &#39;strtod128&#39; function in
        // section 9.6 of the ISO/EIC TR 24732 C Decimal Floating-Point
        // Technical Report, except that it is unspecified whether the NaNs
        // returned are quiet or signaling.  The behavior is undefined unless
        // there are &#39;size&#39; bytes available in &#39;buffer&#39;.

                        // Densely Packed Conversion Functions

    static ValueType32  convertFromDPD(
                              DenselyPackedDecimalImpUtil::StorageType32  dpd);
    static ValueType64  convertFromDPD(
                              DenselyPackedDecimalImpUtil::StorageType64  dpd);
    static ValueType128 convertFromDPD(
                              DenselyPackedDecimalImpUtil::StorageType128 dpd);
        // Return a &#39;ValueTypeXX&#39; representing the specified &#39;dpd&#39;, which is
        // currently in Densely Packed Decimal (DPD) format.  This format is
        // compatible with the IBM compiler&#39;s native type, and the decNumber
        // library.

    static DenselyPackedDecimalImpUtil::StorageType32  convertToDPD(
                                                           ValueType32  value);
    static DenselyPackedDecimalImpUtil::StorageType64  convertToDPD(
                                                           ValueType64  value);
    static DenselyPackedDecimalImpUtil::StorageType128 convertToDPD(
                                                           ValueType128 value);
        // Return a &#39;DenselyPackedDecimalImpUtil::StorageTypeXX&#39; representing
        // the specified &#39;value&#39; in Densely Packed Decimal (DPD) format.  This
        // format is compatible with the IBM compiler&#39;s native type, and the
        // decNumber library.

                        // Binary Integral Conversion Functions

    // The &#39;decNumber&#39; library does not currently support conversion to or from
    // &#39;BID&#39;, so these functions are not provided.  This will cause a
    // compile-time failure for this implementation.  A portable implementation
    // of this algorithm is forthcoming.

  //static ValueType32  convertFromBID(
  //                         BinaryIntegralDecimalImpUtil::StorageType32  bid);
  //static ValueType64  convertFromBID(
  //                         BinaryIntegralDecimalImpUtil::StorageType64  bid);
  //static ValueType128 convertFromBID(
  //                         BinaryIntegralDecimalImpUtil::StorageType128 bid);
        // Return a &#39;ValueTypeXX&#39; representing the specified &#39;bid&#39;, which is
        // currently in Binary Integral Decimal (BID) format.  This format is
        // compatible with the Intel DFP implementation type.

  //static
  //BinaryIntegralDecimalImpUtil::StorageType32  convertToBID(
  //                                                       ValueType32  value);
  //static
  //BinaryIntegralDecimalImpUtil::StorageType64  convertToBID(
  //                                                       ValueType64  value);
  //static
  //BinaryIntegralDecimalImpUtil::StorageType128 convertToBID(
  //                                                       ValueType128 value);
        // Return a &#39;BinaryIntegralDecimalImpUtil::StorageTypeXX&#39; representing
        // the specified &#39;value&#39; in Binary Integral Decimal (BID) format.  This
        // format is compatible with the Intel DFP implementation type.
};

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                          // ------------------------------
                          // class DecimalImpUtil_DecNumber
                          // ------------------------------

// CLASS METHODS
inline decContext *DecimalImpUtil_DecNumber::getDecNumberContext()
{
    static decContext context = { 0, 0, 0, DEC_ROUND_HALF_EVEN, 0, 0, 0 };
    return &amp;context;
}

                        // Integer construction

inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::int32ToDecimal32(int value)
{
    // *Not* all &#39;int&#39; values are valid significands for a Decimal32.

    if (-9999999 &lt;= value &amp;&amp; value &lt;= 9999999) {
        DecimalImpUtil_DecNumber::ValueType32      result;
        DenselyPackedDecimalImpUtil::StorageType32 raw;
        raw = DenselyPackedDecimalImpUtil::makeDecimalRaw32(value, 0);
        bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
        return result;
    }
    return roundToDecimal32(static_cast&lt;long long&gt;(value));
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::int32ToDecimal64(int value)
{
    // All &#39;int&#39; values are valid significands for a Decimal64.

    DecimalImpUtil_DecNumber::ValueType64      result;
    DenselyPackedDecimalImpUtil::StorageType64 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw64(value, 0);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::int32ToDecimal128(int value)
{
    // All &#39;int&#39; values are valid significands for a Decimal128.

    DecimalImpUtil_DecNumber::ValueType128      result;
    DenselyPackedDecimalImpUtil::StorageType128 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw128(value, 0);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
    return result;
}


inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::uint32ToDecimal32(unsigned int value)
{
    // *Not* all &#39;unsigned int&#39; values are valid significands for a Decimal32.

    if (value &lt;= 9999999) {
        DecimalImpUtil_DecNumber::ValueType32      result;
        DenselyPackedDecimalImpUtil::StorageType32 raw;
        raw = DenselyPackedDecimalImpUtil::makeDecimalRaw32(value, 0);
        bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
        return result;
    }
    return roundToDecimal32(static_cast&lt;unsigned long long&gt;(value));
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::uint32ToDecimal64(unsigned int value)
{
    // All &#39;unsigned int&#39; values are valid significands for a Decimal64.

    DecimalImpUtil_DecNumber::ValueType64      result;
    DenselyPackedDecimalImpUtil::StorageType64 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw64(value, 0);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::uint32ToDecimal128(unsigned int value)
{
    // All &#39;unsigned int&#39; values are valid significands for a Decimal128.

    DecimalImpUtil_DecNumber::ValueType128      result;
    DenselyPackedDecimalImpUtil::StorageType128 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw128(value, 0);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));

    return result;
}


inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::int64ToDecimal32(long long int value)
{
    // *Not* all &#39;int64&#39; values are valid significands for a Decimal32.

    if (-9999999 &lt;= value &amp;&amp; value &lt;= 9999999) {
        int intValue = static_cast&lt;int&gt;(value);

        DecimalImpUtil_DecNumber::ValueType32      result;
        DenselyPackedDecimalImpUtil::StorageType32 raw;
        raw = DenselyPackedDecimalImpUtil::makeDecimalRaw32(intValue, 0);
        bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
        return result;
    }
    return roundToDecimal32(value);
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::int64ToDecimal64(long long int value)
{
    // *Not* all &#39;int64&#39; values are valid significands for a Decimal64.

    if (-9999999999999999LL &lt;= value &amp;&amp; value &lt;= 9999999999999999LL) {
        DecimalImpUtil_DecNumber::ValueType64      result;
        DenselyPackedDecimalImpUtil::StorageType64 raw;
        raw = DenselyPackedDecimalImpUtil::makeDecimalRaw64(value, 0);
        bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
        return result;
    }
    return roundToDecimal64(value);
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::int64ToDecimal128(long long int value)
{
    // All &#39;int64&#39; values are valid significands for a Decimal128.

    DecimalImpUtil_DecNumber::ValueType128      result;
    DenselyPackedDecimalImpUtil::StorageType128 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw128(value, 0);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));

    return result;
}


inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::uint64ToDecimal32(unsigned long long int value)
{
    // *Not* all &#39;Uint64&#39; values are valid significands for a Decimal32.

    if (value &lt;= 9999999) {
        int intValue = static_cast&lt;int&gt;(value);
        DecimalImpUtil_DecNumber::ValueType32      result;
        DenselyPackedDecimalImpUtil::StorageType32 raw;
        raw = DenselyPackedDecimalImpUtil::makeDecimalRaw32(intValue, 0);
        bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
        return result;
    }
    return roundToDecimal32(value);
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::uint64ToDecimal64(unsigned long long int value)
{
    // *Not* all &#39;Uint64&#39; values are valid significands for a Decimal64.

    if (value &lt;= 9999999999999999LL) {
        DecimalImpUtil_DecNumber::ValueType64      result;
        DenselyPackedDecimalImpUtil::StorageType64 raw;
        raw = DenselyPackedDecimalImpUtil::makeDecimalRaw64(value, 0);
        bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));
        return result;
    }
    return roundToDecimal64(value);
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::uint64ToDecimal128(unsigned long long int value)
{
    // All &#39;Uint64&#39; values are valid significands for a Decimal128.
    DecimalImpUtil_DecNumber::ValueType128      result;
    DenselyPackedDecimalImpUtil::StorageType128 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw128(value, 0);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(raw));

    return result;
}

                        // Arithmetic

                        // Addition Functions

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::add(DecimalImpUtil_DecNumber::ValueType64 lhs,
                              DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    DecimalImpUtil_DecNumber::ValueType64 result;
    decDoubleAdd(&amp;result, &amp;lhs, &amp;rhs, getDecNumberContext());
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::add(DecimalImpUtil_DecNumber::ValueType128 lhs,
                              DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    DecimalImpUtil_DecNumber::ValueType128 result;
    decQuadAdd(&amp;result, &amp;lhs, &amp;rhs, getDecNumberContext());
    return result;
}

                        // Subtraction Functions

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::subtract(DecimalImpUtil_DecNumber::ValueType64 lhs,
                                   DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    DecimalImpUtil_DecNumber::ValueType64 result;
    decDoubleSubtract(&amp;result, &amp;lhs, &amp;rhs, getDecNumberContext());
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::subtract(DecimalImpUtil_DecNumber::ValueType128 lhs,
                                   DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    DecimalImpUtil_DecNumber::ValueType128 result;
    decQuadSubtract(&amp;result, &amp;lhs, &amp;rhs, getDecNumberContext());
    return result;
}

                        // Multiplication Functions

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::multiply(DecimalImpUtil_DecNumber::ValueType64 lhs,
                                   DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    DecimalImpUtil_DecNumber::ValueType64 result;
    decDoubleMultiply(&amp;result, &amp;lhs, &amp;rhs, getDecNumberContext());
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::multiply(DecimalImpUtil_DecNumber::ValueType128 lhs,
                                   DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    DecimalImpUtil_DecNumber::ValueType128 result;
    decQuadMultiply(&amp;result, &amp;lhs, &amp;rhs, getDecNumberContext());
    return result;
}

                        // Division Functions

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::divide(DecimalImpUtil_DecNumber::ValueType64 lhs,
                                 DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    DecimalImpUtil_DecNumber::ValueType64 result;
    decDoubleDivide(&amp;result, &amp;lhs, &amp;rhs, getDecNumberContext());
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::divide(DecimalImpUtil_DecNumber::ValueType128 lhs,
                                 DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    DecimalImpUtil_DecNumber::ValueType128 result;
    decQuadDivide(&amp;result, &amp;lhs, &amp;rhs, getDecNumberContext());
    return result;
}

                        // Negation Functions

inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::negate(DecimalImpUtil_DecNumber::ValueType32 value)
{
	return convertToDecimal32(negate(convertToDecimal64(value)));
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::negate(DecimalImpUtil_DecNumber::ValueType64 value)
{
    DecimalImpUtil_DecNumber::ValueType64 result;
    decDoubleCopyNegate(&amp;result, &amp;value);
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::negate(DecimalImpUtil_DecNumber::ValueType128 value)
{
    DecimalImpUtil_DecNumber::ValueType128 result;
    decQuadCopyNegate(&amp;result, &amp;value);
    return result;
}

                        // Comparison Functions

                        // Less Than Functions

inline
bool
DecimalImpUtil_DecNumber::less(DecimalImpUtil_DecNumber::ValueType32 lhs,
                               DecimalImpUtil_DecNumber::ValueType32 rhs)
{
    return less(convertToDecimal64(lhs), convertToDecimal64(rhs));
}

inline
bool
DecimalImpUtil_DecNumber::less(DecimalImpUtil_DecNumber::ValueType64 lhs,
                               DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    ValueType64 comparison;
    decDoubleCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decDoubleIsNegative(&amp;comparison);
}

inline
bool
DecimalImpUtil_DecNumber::less(DecimalImpUtil_DecNumber::ValueType128 lhs,
                               DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    ValueType128 comparison;
    decQuadCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decQuadIsNegative(&amp;comparison);
}

                        // Greater Than Functions

inline
bool
DecimalImpUtil_DecNumber::greater(DecimalImpUtil_DecNumber::ValueType32 lhs,
                                  DecimalImpUtil_DecNumber::ValueType32 rhs)
{
    return greater(convertToDecimal64(lhs), convertToDecimal64(rhs));
}

inline
bool
DecimalImpUtil_DecNumber::greater(DecimalImpUtil_DecNumber::ValueType64 lhs,
                                  DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    ValueType64 comparison;
    decDoubleCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decDoubleIsPositive(&amp;comparison);
}

inline
bool
DecimalImpUtil_DecNumber::greater(DecimalImpUtil_DecNumber::ValueType128 lhs,
                                  DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    ValueType128 comparison;
    decQuadCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decQuadIsPositive(&amp;comparison);
}

                        // Less Or Equal Functions

inline
bool
DecimalImpUtil_DecNumber::lessEqual(DecimalImpUtil_DecNumber::ValueType32 lhs,
                                    DecimalImpUtil_DecNumber::ValueType32 rhs)
{
    return lessEqual(convertToDecimal64(lhs), convertToDecimal64(rhs));
}

inline
bool
DecimalImpUtil_DecNumber::lessEqual(DecimalImpUtil_DecNumber::ValueType64 lhs,
                                    DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    ValueType64 comparison;
    decDoubleCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decDoubleIsNegative(&amp;comparison) || decDoubleIsZero(&amp;comparison);
}

inline
bool
DecimalImpUtil_DecNumber::lessEqual(DecimalImpUtil_DecNumber::ValueType128 lhs,
                                    DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    ValueType128 comparison;
    decQuadCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decQuadIsNegative(&amp;comparison) || decQuadIsZero(&amp;comparison);
}

                        // Greater Or Equal Functions

inline
bool
DecimalImpUtil_DecNumber::greaterEqual(
                                     DecimalImpUtil_DecNumber::ValueType32 lhs,
                                     DecimalImpUtil_DecNumber::ValueType32 rhs)
{
    return greaterEqual(convertToDecimal64(lhs), convertToDecimal64(rhs));
}

inline
bool
DecimalImpUtil_DecNumber::greaterEqual(
                                     DecimalImpUtil_DecNumber::ValueType64 lhs,
                                     DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    ValueType64 comparison;
    decDoubleCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decDoubleIsPositive(&amp;comparison) || decDoubleIsZero(&amp;comparison);
}

inline
bool
DecimalImpUtil_DecNumber::greaterEqual(
                                    DecimalImpUtil_DecNumber::ValueType128 lhs,
                                    DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    ValueType128 comparison;
    decQuadCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decQuadIsPositive(&amp;comparison) || decQuadIsZero(&amp;comparison);
}

                        // Equality Functions

inline
bool
DecimalImpUtil_DecNumber::equal(DecimalImpUtil_DecNumber::ValueType32 lhs,
                                DecimalImpUtil_DecNumber::ValueType32 rhs)
{
    return equal(convertToDecimal64(lhs), convertToDecimal64(rhs));
}

inline
bool
DecimalImpUtil_DecNumber::equal(DecimalImpUtil_DecNumber::ValueType64 lhs,
                                DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    ValueType64 comparison;
    decDoubleCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decDoubleIsZero(&amp;comparison);
}

inline
bool
DecimalImpUtil_DecNumber::equal(DecimalImpUtil_DecNumber::ValueType128 lhs,
                                DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    ValueType128 comparison;
    decQuadCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return decQuadIsZero(&amp;comparison);
}

                        // Inequality Functions

inline
bool
DecimalImpUtil_DecNumber::notEqual(DecimalImpUtil_DecNumber::ValueType32 lhs,
                                   DecimalImpUtil_DecNumber::ValueType32 rhs)
{
    return notEqual(convertToDecimal64(lhs), convertToDecimal64(rhs));
}

inline
bool
DecimalImpUtil_DecNumber::notEqual(DecimalImpUtil_DecNumber::ValueType64 lhs,
                                   DecimalImpUtil_DecNumber::ValueType64 rhs)
{
    ValueType64 comparison;
    decDoubleCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return !decDoubleIsZero(&amp;comparison);
}

inline
bool
DecimalImpUtil_DecNumber::notEqual(DecimalImpUtil_DecNumber::ValueType128 lhs,
                                   DecimalImpUtil_DecNumber::ValueType128 rhs)
{
    ValueType128 comparison;
    decQuadCompare(&amp;comparison, &amp;lhs, &amp;rhs, getDecNumberContext());
    return !decQuadIsZero(&amp;comparison);
}

                        // Inter-type Conversion functions

inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::convertToDecimal32(
                            const DecimalImpUtil_DecNumber::ValueType64&amp; input)
{
    DecimalImpUtil_DecNumber::ValueType32 retval;
    decSingleFromWider(&amp;retval, &amp;input, getDecNumberContext());
    return retval;
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::convertToDecimal64(
                            const DecimalImpUtil_DecNumber::ValueType32&amp; input)
{
    DecimalImpUtil_DecNumber::ValueType64 retval;
    decSingleToWider(&amp;input, &amp;retval);
    return retval;
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::convertToDecimal64(
                           const DecimalImpUtil_DecNumber::ValueType128&amp; input)
{
    DecimalImpUtil_DecNumber::ValueType64 retval;
    decDoubleFromWider(&amp;retval, &amp;input, getDecNumberContext());
    return retval;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::convertToDecimal128(
                            const DecimalImpUtil_DecNumber::ValueType32&amp; input)
{
    return convertToDecimal128(convertToDecimal64(input));
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::convertToDecimal128(
                            const DecimalImpUtil_DecNumber::ValueType64&amp; input)
{
    DecimalImpUtil_DecNumber::ValueType128 retval;
    decDoubleToWider(&amp;input, &amp;retval);
    return retval;
}

                        // makeDecimalRaw Functions

inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::makeDecimalRaw32(int significand,
                                           int exponent)
{
    union {
        DecimalImpUtil_DecNumber::ValueType32      result;
        DenselyPackedDecimalImpUtil::StorageType32 raw;
    } rawAccess;
    rawAccess.raw = DenselyPackedDecimalImpUtil::makeDecimalRaw32(significand,
                                                                  exponent);

    return rawAccess.result;
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::makeDecimalRaw64(unsigned long long significand,
                                           int                exponent)
{
    union {
        DecimalImpUtil_DecNumber::ValueType64      result;
        DenselyPackedDecimalImpUtil::StorageType64 raw;
    } rawAccess;
    rawAccess.raw = DenselyPackedDecimalImpUtil::makeDecimalRaw64(significand,
                                                                  exponent);

    return rawAccess.result;
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::makeDecimalRaw64(long long significand,
                                           int       exponent)
{
    union {
        DecimalImpUtil_DecNumber::ValueType64      result;
        DenselyPackedDecimalImpUtil::StorageType64 raw;
    } rawAccess;
    rawAccess.raw = DenselyPackedDecimalImpUtil::makeDecimalRaw64(significand,
                                                                  exponent);

    return rawAccess.result;
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::makeDecimalRaw64(unsigned int significand,
                                           int          exponent)
{
    union {
        DecimalImpUtil_DecNumber::ValueType64      result;
        DenselyPackedDecimalImpUtil::StorageType64 raw;
    } rawAccess;
    rawAccess.raw = DenselyPackedDecimalImpUtil::makeDecimalRaw64(significand,
                                                                  exponent);

    return rawAccess.result;
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::makeDecimalRaw64(int significand,
                                           int exponent)
{
    union {
        DecimalImpUtil_DecNumber::ValueType64      result;
        DenselyPackedDecimalImpUtil::StorageType64 raw;
    } rawAccess;
    rawAccess.raw = DenselyPackedDecimalImpUtil::makeDecimalRaw64(significand,
                                                                  exponent);

    return rawAccess.result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::makeDecimalRaw128(unsigned long long significand,
                                            int                exponent)
{
    DecimalImpUtil_DecNumber::ValueType128      result;
    DenselyPackedDecimalImpUtil::StorageType128 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw128(significand,
                                                         exponent);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(result));

    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::makeDecimalRaw128(long long significand,
                                            int       exponent)
{
    DecimalImpUtil_DecNumber::ValueType128      result;
    DenselyPackedDecimalImpUtil::StorageType128 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw128(significand,
                                                         exponent);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(result));

    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::makeDecimalRaw128(unsigned int significand,
                                            int          exponent)
{
    DecimalImpUtil_DecNumber::ValueType128      result;
    DenselyPackedDecimalImpUtil::StorageType128 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw128(significand,
                                                         exponent);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(result));

    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::makeDecimalRaw128(int significand,
                                            int exponent)
{
    DecimalImpUtil_DecNumber::ValueType128      result;
    DenselyPackedDecimalImpUtil::StorageType128 raw;
    raw = DenselyPackedDecimalImpUtil::makeDecimalRaw128(significand,
                                                         exponent);
    bsl::memcpy(&amp;result, &amp;raw, sizeof(result));

    return result;
}

                        // IEEE Scale B Functions

inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::scaleB(
                                DecimalImpUtil_DecNumber::ValueType32 value,
                                int                                   exponent)
{
    return convertToDecimal32(scaleB(convertToDecimal64(value), exponent));
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::scaleB(
                                DecimalImpUtil_DecNumber::ValueType64 value,
                                int                                   exponent)
{
    DecimalImpUtil_DecNumber::ValueType64 result;
    DecimalImpUtil_DecNumber::ValueType64 decPower;
    decDoubleFromInt32(&amp;decPower, exponent);
    decDoubleScaleB(&amp;result, &amp;value, &amp;decPower, getDecNumberContext());
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::scaleB(
                               DecimalImpUtil_DecNumber::ValueType128 value,
                               int                                    exponent)
{
    DecimalImpUtil_DecNumber::ValueType128 result;
    DecimalImpUtil_DecNumber::ValueType128 decPower;
    decQuadFromInt32(&amp;decPower, exponent);
    decQuadScaleB(&amp;result, &amp;value, &amp;decPower, getDecNumberContext());
    return result;
}

                        // Parsing functions

inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::parse32(const char *string)
{
    DecimalImpUtil_DecNumber::ValueType32 result;
    decSingleFromString(&amp;result, string, getDecNumberContext());
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::parse64(const char *string)
{
    DecimalImpUtil_DecNumber::ValueType64 result;
    decDoubleFromString(&amp;result, string, getDecNumberContext());
    return result;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::parse128(const char *string)
{
    DecimalImpUtil_DecNumber::ValueType128 result;
    decQuadFromString(&amp;result, string, getDecNumberContext());
    return result;
}

                        // Formatting Functions

inline
void
DecimalImpUtil_DecNumber::format(DecimalImpUtil_DecNumber::ValueType32  value,
                                 char                                  *buffer)
{
    BSLS_ASSERT(buffer);

    decSingleToString(&amp;value, buffer);
}

inline
void
DecimalImpUtil_DecNumber::format(DecimalImpUtil_DecNumber::ValueType64  value,
                                 char                                  *buffer)
{
    BSLS_ASSERT(buffer);

    decDoubleToString(&amp;value, buffer);
}

inline
void
DecimalImpUtil_DecNumber::format(
                                DecimalImpUtil_DecNumber::ValueType128  value,
                                char                                   *buffer)
{
    BSLS_ASSERT(buffer);

    decQuadToString(&amp;value, buffer);
}

                        // Densely Packed Conversion Functions

inline
DecimalImpUtil_DecNumber::ValueType32
DecimalImpUtil_DecNumber::convertFromDPD(
                                DenselyPackedDecimalImpUtil::StorageType32 dpd)
{
    DecimalImpUtil_DecNumber::ValueType32 value;
    bsl::memcpy(&amp;value, &amp;dpd, sizeof(value));

    return value;
}

inline
DecimalImpUtil_DecNumber::ValueType64
DecimalImpUtil_DecNumber::convertFromDPD(
                                DenselyPackedDecimalImpUtil::StorageType64 dpd)
{
    DecimalImpUtil_DecNumber::ValueType64 value;
    bsl::memcpy(&amp;value, &amp;dpd, sizeof(value));

    return value;
}

inline
DecimalImpUtil_DecNumber::ValueType128
DecimalImpUtil_DecNumber::convertFromDPD(
                               DenselyPackedDecimalImpUtil::StorageType128 dpd)
{
    DecimalImpUtil_DecNumber::ValueType128 value;
    bsl::memcpy(&amp;value, &amp;dpd, sizeof(value));

    return value;
}

inline
DenselyPackedDecimalImpUtil::StorageType32
DecimalImpUtil_DecNumber::convertToDPD(
                                   DecimalImpUtil_DecNumber::ValueType32 value)
{
    DenselyPackedDecimalImpUtil::StorageType32 dpd;
    bsl::memcpy(&amp;dpd, &amp;value, sizeof(dpd));

    return dpd;
}

inline
DenselyPackedDecimalImpUtil::StorageType64
DecimalImpUtil_DecNumber::convertToDPD(
                                   DecimalImpUtil_DecNumber::ValueType64 value)
{
    DenselyPackedDecimalImpUtil::StorageType64 dpd;
    bsl::memcpy(&amp;dpd, &amp;value, sizeof(dpd));

    return dpd;
}

inline
DenselyPackedDecimalImpUtil::StorageType128
DecimalImpUtil_DecNumber::convertToDPD(
                                  DecimalImpUtil_DecNumber::ValueType128 value)
{
    DenselyPackedDecimalImpUtil::StorageType128 dpd;
    bsl::memcpy(&amp;dpd, &amp;value, sizeof(dpd));

    return dpd;
}

}  // close package namespace
}  // close enterprise namespace


#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
