<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlcc_timequeue.h                                                  -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLCC_TIMEQUEUE
#define INCLUDED_BDLCC_TIMEQUEUE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an efficient queue for time events.
//
//@CLASSES:
//     bdlcc::TimeQueue: Templatized time event queue
// bdlcc::TimeQueueItem: (&#39;struct&#39;) Templatized item in the time event queue
//
//@SEE_ALSO:
//
//@DESCRIPTION: This component provides a thread-safe and efficient templatized
// time queue.  The queue stores an ordered list of time values and associated
// &#39;DATA&#39;.  Each item added to the queue is assigned a unique identifier that
// can be used to efficiently remove the item making this queue suitable for
// conditions where time items are added and removed very frequently.
//
// Class &#39;bdlcc::TimeQueue&lt;DATA&gt;&#39; provides a public interface which is similar
// in structure and intent to &#39;bdlcc::Queue&lt;DATA&gt;&#39;, with the exception that
// each item stored in the &#39;bdlcc::TimeQueue&#39; is of type
// &#39;bdlcc::TimeQueueItem&lt;DATA&gt;&#39;.  This structure contains a single
// &#39;bsls::TimeInterval&#39; value along with the &#39;DATA&#39; value.
//
// Idiomatic usage of &#39;bdlcc::TimeQueue&#39; includes the member function &#39;popLE&#39;,
// which finds all items on the queue whose &#39;bsls::TimeInterval&#39; are less than
// a specified value, and transfers those items to a provided vector of items.
// Through the use of this member function, clients can retrieve and process
// multiple elements that have expired, that is, whose &#39;bsls::TimeInterval&#39;
// values are in the past.
//
// &#39;bdlcc::TimeQueue&#39; also makes use of an opaque data type
// &#39;bdlcc::TimeQueue::Handle&#39; which serves to identify an individual element on
// the Time Queue.  A value of type &#39;Handle&#39; is returned from the &#39;add&#39; member
// function, and can then be used to remove or modify the corresponding element
// on the queue.  In this way, the &#39;update&#39; member function can update the time
// value for a specific &#39;bdlcc::TimeQueueItem&#39; without removing it from the
// queue.
//
///&#39;bdlcc::TimeQueue::Handle&#39; Uniqueness, Reuse and &#39;numIndexBits&#39;
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// &#39;bdlcc::TimeQueue::Handle&#39; is an alias for a 32-bit &#39;int&#39; type.  A handle
// consists of two parts, the &quot;index section&quot; and the &quot;iteration section&quot;.  The
// index section, which is the low-order &#39;numIndexBits&#39; (which defaults to
// &#39;numIndexBits == 17&#39;), uniquely identifies the node.  Once a node is added,
// it never ceases to exist - it may be freed, but it will be kept on a free
// list to be eventually recycled, and the same index section will always
// identify that node.  The iteration section, the high-order
// &#39;32 - numIndexBits&#39;, is changed every time a node is freed, so that an
// out-of-date handle can be identified as out-of-date.  But since the
// iteration section has only a finite number of bits, if a node is freed and
// re-added enough times, old handle values will eventually be reused.
//
// Up to &#39;2 ** numIndexBits - 1&#39; nodes can exist in a given time queue.  A
// given handle won&#39;t be reused for a node until that node has been freed and
// reused &#39;2 ** (32 - numIndexBits) - 1&#39; times.
//
// &#39;numIndexBits&#39; is an optional parameter to the time queue constructors.  If
// unspecified, it has a value of 17.  The behavior is undefined unless the
// specified &#39;numIndexBits&#39; is in the range &#39;8 &lt;= numIndexBits &lt;= 24&#39;.
//
///Thread Safety
///- - - - - - -
// It is safe to access or modify two distinct &#39;bdlcc::TimeQueue&#39; objects
// simultaneously, each from a separate thread.  It is safe to access or modify
// a single &#39;bdlcc::TimeQueue&#39; object simultaneously from two or more separate
// threads.
//
// It is safe to enqueue objects in a &#39;bdlcc::TimeQueue&#39; object whose
// destructor may access or even modify the same &#39;bdlcc::TimeQueue&#39; object.
// However, there is no guarantee regarding the safety of enqueuing objects
// whose copy constructors or assignment operators may modify or even merely
// access the same &#39;bdlcc::TimeQueue&#39; object (except &#39;length&#39;).  Such attempts
// generally lead to a deadlock.
//
///Usage
///-----
// The following shows a typical usage of the &#39;bdlcc::TimeQueue&#39; class,
// implementing a simple threaded server &#39;my_Server&#39; that manages individual
// Connections (&#39;my_Connection&#39;) on behalf of multiple Sessions (&#39;my_Session&#39;).
// Each Connection is timed, such that input requests on that Connection will
// &quot;time out&quot; after a user-specified time interval.  When a specific Connection
// times out, that Connection is removed from the &#39;bdlcc::TimeQueue&#39; and the
// corresponding &#39;my_Session&#39; is informed.
//
// In this simplified example, class &#39;my_Session&#39; will terminate when its
// Connection times out.  A more sophisticated implementation of &#39;my_Session&#39;
// would attempt recovery, perhaps by closing and reopening the physical
// Connection.
//
///Forward Declarations
/// - - - - - - - - - -
// Class &#39;my_Server&#39; will spawn two service threads to monitor connections for
// available data and to manage time-outs, respectively.  Two forward-declared
// &quot;C&quot; functions are invoked as the threads are spawned.  The signature of each
// function follows the &quot;C&quot; standard &quot;&#39;void *&#39;&quot; interface for spawning threads.
// Each function will be called on a new thread when the &#39;start&#39; method is
// invoked for a given &#39;my_Server&#39; object.  Each function then delegates
// processing for the thread back to the &#39;my_Server&#39; object that spawned it.
//..
//  extern &quot;C&quot; {
//
//  void *my_connectionMonitorThreadEntry(void *server);
//
//  void *my_timerMonitorThreadEntry(void *server);
//
//  }
//..
//
///&#39;struct my_Connection&#39;
/// - - - - - - - - - - -
// The &#39;my_Connection&#39; structure is used by &#39;my_Server&#39; to manage a single
// physical connection on behalf of a &#39;my_Session&#39;.
//..
//  class my_Session;
//  struct my_Connection {
//      int         d_timerId;
//      my_Session *d_session_p;
//  };
//..
//
///Protocol Classes
/// - - - - - - - -
// Protocol class &#39;my_Session&#39; provides a pure abstract protocol to manage a
// single &quot;session&quot; to be associated with a specific connection on a server.
//..
//  class my_Session {
//      // Pure protocol class to process a data buffer of arbitrary size.
//      // Concrete implementations in the &quot;real world&quot; would typically manage
//      // an external connection like a socket.
//
//    public:
//      my_Session();
//      virtual int processData(void *data, int length) = 0;
//      virtual int handleTimeout(my_Connection *connection) = 0;
//      virtual ~my_Session();
//  };
//..
// The constructor and destructor do nothing:
//..
//  my_Session::my_Session()
//  {
//  }
//
//  my_Session::~my_Session()
//  {
//  }
//..
// Protocol class &#39;my_Server&#39; provides a partial implementation of a simple
// server that supports and monitors an arbitrary number of connections and
// handles incoming data for those connections.  Clients must provide a
// concrete implementation that binds connections to concrete &#39;my_Session&#39;
// objects and monitors all open connections for incoming requests.  The
// concrete implementation calls &#39;my_Server::newConnection()&#39; when a new
// connections is required, and implements the virtual function
// &#39;monitorConnections&#39; to monitor all open connections.
//..
//  class my_Server {
//      // Simple server supporting multiple Connections.
//
//      bsl::vector&lt;my_Connection*&gt;      d_connections;
//      bdlcc::TimeQueue&lt;my_Connection*&gt; d_timeQueue;
//      int                              d_ioTimeout;
//      bslmt::Mutex                     d_timerMonitorMutex;
//      bslmt::Condition                 d_timerChangedCond;
//      bslmt::ThreadUtil::Handle        d_connectionThreadHandle;
//      bslmt::ThreadUtil::Handle        d_timerThreadHandle;
//      volatile bool                    d_done;
//
//    protected:
//      void newConnection(my_Connection *connection);
//          // Add the specified &#39;connection&#39; to the current &#39;my_Server&#39;,
//          // setting the new timeout value to the current time plus the
//          // timeout value provided at construction of this &#39;my_Server&#39;
//          // instance.  If the added connection is the new &quot;top&quot; of the
//          // queue, signal that the minimum time on the queue has changed.
//          // Upon seeing this signal, the TimerMonitor thread will wake up
//          // and look for expired timers.
//          //
//          // Behavior is undefined if &#39;connection&#39; has already been added to
//          // any &#39;my_Server&#39; and has not been removed via member function
//          // &#39;closeConnection&#39;.
//
//      void removeConnection(my_Connection *connection);
//          // Remove the specified &#39;connection&#39; from the current &#39;my_Server&#39;,
//          // so that it will no longer be monitored for available data.
//
//      virtual void closeConnection(my_Connection *connection)=0;
//          // Provide a mechanism for a concrete implementation to close a
//          // specified &#39;connection&#39;.
//
//      void dataAvailable(my_Connection *connection,
//                         void          *buffer_p,
//                         int            length);
//          // Receive in the specified &#39;buffer_p&#39; a pointer to a data buffer
//          // of the specified &#39;length&#39; bytes, and pass this to the specified
//          // &#39;connection&#39; to be processed.  Behavior is undefined if
//          // &#39;connection&#39; is not currently added to this &#39;my_Server&#39; object,
//          // or if &#39;length&#39; &lt;= 0.
//
//    protected:
//      virtual void monitorConnections()=0;
//          // Monitor all connections in the current &#39;my_Server&#39;.  When data
//          // becomes available for a given connection, pass the data to that
//          // connection for processing.
//
//      void monitorTimers();
//          // Monitor all timers in the current &#39;my_Server&#39;, and handle each
//          // timer as it expires.
//
//      friend void *my_connectionMonitorThreadEntry(void *server);
//      friend void *my_timerMonitorThreadEntry(void *server);
//
//    private:
//      // Not implemented:
//      my_Server(const my_Server&amp;);
//
//    public:
//      // CREATORS
//      explicit
//      my_Server(int ioTimeout, bslma::Allocator *basicAllocator = 0);
//          // Construct a &#39;my_Server&#39; object with a timeout value of the
//          // specified &#39;ioTimeout&#39; seconds.  Use the optionally specified
//          // &#39;basicAllocator&#39; for all memory allocation for data members of
//          // &#39;my_Server&#39;.
//
//      virtual ~my_Server();
//
//      // MANIPULATORS
//      int start();
//          // Begin monitoring timers and connections.
//  };
//..
// The constructor is simple: it initializes the internal &#39;bdlcc::TimeQueue&#39;
// and sets the I/O timeout value.  The virtual destructor does nothing.
//..
//  my_Server::my_Server(int ioTimeout, bslma::Allocator *basicAllocator)
//  : d_timeQueue(basicAllocator)
//  , d_ioTimeout(ioTimeout)
//  , d_connectionThreadHandle(bslmt::ThreadUtil::invalidHandle())
//  , d_timerThreadHandle(bslmt::ThreadUtil::invalidHandle())
//  {
//  }
//
//  my_Server::~my_Server()
//  {
//      d_done = true;
//      d_timerChangedCond.broadcast();
//      if (bslmt::ThreadUtil::invalidHandle() != d_connectionThreadHandle) {
//          bslmt::ThreadUtil::join(d_connectionThreadHandle);
//      }
//      if (bslmt::ThreadUtil::invalidHandle()!= d_timerThreadHandle) {
//          bslmt::ThreadUtil::join(d_timerThreadHandle);
//      }
//  }
//..
// Member function &#39;newConnection&#39; adds the &#39;connection&#39; to the current set of
// connections to be monitored.  This is done in two steps.  First, the
// &#39;connection&#39; is added to the internal array, and then a timer is set for the
// &#39;connection&#39; by creating a corresponding entry in the internal
// &#39;bdlcc::TimeQueue&#39;.
//..
//  void my_Server::newConnection(my_Connection *connection)
//  {
//      d_connections.push_back(connection);
//      int isNewTop = 0;
//      connection-&gt;d_timerId = d_timeQueue.add(bdlt::CurrentTime::now() +
//                                                                 d_ioTimeout,
//                                              connection,
//                                              &amp;isNewTop);
//      if (isNewTop) {
//          bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_timerMonitorMutex);
//          d_timerChangedCond.signal();
//      }
//  }
//..
// Member function &#39;monitorConnections&#39;, provided by the concrete
// implementation class, can use the internal array to determine the set of
// connections to be monitored.
//
// Member function &#39;removeConnection&#39; removes the &#39;connection&#39; from the current
// set of connections to be monitored.  This is done in two steps, in reversed
// order from &#39;newConnection&#39;.  First, the &#39;connection&#39; is removed from the
// internal &#39;bdlcc::TimeQueue&#39;, and then the &#39;connection&#39; is removed from the
// internal array.
//
// The concrete implementation class must provide an implementation of virtual
// function &#39;closeConnection&#39;; this implementation must call &#39;removeConnection&#39;
// when the actual connection is to be removed from the &#39;my_Server&#39; object.
//
// Function &#39;closeConnection&#39; is in turn called by function &#39;monitorTimers&#39;,
// which manages the overall timer monitor thread.  Because &#39;monitorTimers&#39;
// takes responsibility for notifying other threads when the queue status
// changes, function &#39;removeConnection&#39; does not address these concerns.
//..
//  void my_Server::removeConnection(my_Connection *connection)
//  {
//      // Remove from d_timeQueue
//      d_timeQueue.remove(connection-&gt;d_timerId);
//      // Remove from d_connections
//      bsl::vector&lt;my_Connection*&gt;::iterator begin = d_connections.begin(),
//          end = d_connections.end(),
//          it = begin;
//      for (; it != end; ++it) {
//          if (connection == *it) {
//              d_connections.erase(it);
//          }
//      }
//  }
//..
// The &#39;dataAvailable&#39; function will be called when data becomes available for
// a specific connection.  It removes the connection from the timer queue while
// the connection is busy, processes the available data, and returns the
// connection to the queue with a new time value.
//..
//  void my_Server::dataAvailable(my_Connection *connection,
//                                void          *buffer_p,
//                                int            length)
//  {
//      if (connection-&gt;d_timerId) {
//          if (d_timeQueue.remove(connection-&gt;d_timerId))  return;   // RETURN
//          connection-&gt;d_timerId = 0;
//      }
//      connection-&gt;d_session_p-&gt;processData(buffer_p, length);
//
//      int isNewTop = 0;
//
//      connection-&gt;d_timerId = d_timeQueue.add(bdlt::CurrentTime::now() +
//                                                                 d_ioTimeout,
//                                              connection,
//                                              &amp;isNewTop);
//      if (isNewTop) {
//          bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_timerMonitorMutex);
//          d_timerChangedCond.signal();
//      }
//  }
//..
// Function &#39;monitorTimers&#39; manages the timer monitor thread; it is called when
// the thread is spawned, and checks repeatedly for expired timers; after each
// check, it does a timed wait based upon the minimum time value seen in the
// queue after all expired timers have been removed.
//..
//  void my_Server::monitorTimers()
//  {
//      while (!d_done) {
//          bsl::vector&lt;bdlcc::TimeQueueItem&lt;my_Connection*&gt; &gt; expiredTimers;
//          {
//              bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_timerMonitorMutex);
//              bsls::TimeInterval minTime;
//              int newLength;
//
//              d_timeQueue.popLE(bdlt::CurrentTime::now(),
//                                &amp;expiredTimers,
//                                &amp;newLength,
//                                &amp;minTime );
//
//              if (!expiredTimers.size()) {
//                  if (newLength) {
//                      // no expired timers, but unexpired timers remain.
//                      d_timerChangedCond.timedWait(&amp;d_timerMonitorMutex,
//                                                   minTime);
//                  }
//                  else {
//                      // no expired timers, and timer queue is empty.
//                      d_timerChangedCond.wait(&amp;d_timerMonitorMutex);
//                  }
//                  continue;
//              }
//          }
//
//          int length = static_cast&lt;int&gt;(expiredTimers.size());
//          if (length) {
//              bdlcc::TimeQueueItem&lt;my_Connection*&gt; *data =
//                                                      &amp;expiredTimers.front();
//              for (int i = 0; i &lt; length; ++i) {
//                  closeConnection(data[i].data());
//              }
//          }
//      }
//  }
//..
// Function &#39;start&#39; spawns two separate threads.  The first thread will monitor
// connections and handle any data received on them.  The second monitors the
// internal timer queue and removes connections that have timed out.  Function
// &#39;start&#39; calls &#39;bslmt::ThreadUtil::create&#39;, which expects a function pointer
// to a function with the standard &quot;C&quot; callback signature
// &#39;void *fn(void *data)&#39;.  This non-member function will call back into the
// &#39;my_Server&#39; object immediately.
//..
//  int my_Server::start()
//  {
//      bslmt::ThreadAttributes attr;
//
//      if (bslmt::ThreadUtil::create(&amp;d_connectionThreadHandle, attr,
//                                   &amp;my_connectionMonitorThreadEntry,
//                                   this)) {
//          return -1;                                                // RETURN
//      }
//
//      if (bslmt::ThreadUtil::create(&amp;d_timerThreadHandle, attr,
//                                   &amp;my_timerMonitorThreadEntry,
//                                   this)) {
//          return -1;                                                // RETURN
//      }
//      return 0;
//  }
//..
// Finally, we are now in a position to implement the two thread dispatchers:
//..
//  extern &quot;C&quot; {
//
//  void *my_connectionMonitorThreadEntry(void *server)
//  {
//      ((my_Server*)server)-&gt;monitorConnections();
//      return server;
//  }
//
//  void *my_timerMonitorThreadEntry(void *server)
//  {
//      ((my_Server*)server)-&gt;monitorTimers();
//      return server;
//  }
//
//  }
//..
// In order to test our server, we provide two concrete implementations of a
// test session and of a test server as follows.
//..
//  // myTestSession.h             -*-C++-*-
//
//  class my_TestSession : public my_Session {
//      // Concrete implementation of my_Session, providing simple test
//      // semantics In particular, implement the virtual function
//      // processData() to record all incoming data for the controlling
//      // connection, and virtual function handleTimeout() for handling
//      // timeouts.
//
//      int d_verbose;
//
//    public:
//      // CREATORS
//      explicit
//      my_TestSession(int verbose) : my_Session(), d_verbose(verbose) { }
//
//      // MANIPULATORS
//      virtual int handleTimeout(my_Connection *connection)
//      {
//          // Do something to handle timeout.
//          if (d_verbose) {
//              bsl::cout &lt;&lt; bdlt::CurrentTime::utc() &lt;&lt; &quot;: &quot;;
//              bsl::cout &lt;&lt; &quot;Connection &quot; &lt;&lt; connection &lt;&lt; &quot;timed out.\n&quot;;
//          }
//          return 0;
//      }
//
//      virtual int processData(void *data, int length)
//      {
//          // Do something with the data...
//          if (d_verbose) {
//              bsl::cout &lt;&lt; bdlt::CurrentTime::utc() &lt;&lt; &quot;: &quot;;
//              bsl::cout &lt;&lt; &quot;Processing data at address &quot; &lt;&lt; data
//                        &lt;&lt; &quot; and length &quot; &lt;&lt; length &lt;&lt; &quot;.\n&quot;;
//          }
//          return 0;
//      }
//  };
//
//  // myTestSession.h             -*-C++-*-
//
//  class my_TestServer :  public my_Server {
//      // Concrete implementation of my_Server, providing connection logic.
//
//      int d_verbose;
//
//    protected:
//      virtual void closeConnection(my_Connection *connection);
//          // Close the specified external &#39;connection&#39; and call
//          // &#39;removeConnection&#39; when done.
//
//      virtual void monitorConnections();
//          // Monitor all connections in the current &#39;my_Server&#39;.  When data
//          // becomes available for a given connection, pass the data to that
//          // connection for processing.
//
//    private:
//      // Not implemented:
//      my_TestServer(const my_TestServer&amp;);
//
//    public:
//      // CREATORS
//      explicit
//      my_TestServer(int               ioTimeout,
//                    int               verbose = 0,
//                    bslma::Allocator *basicAllocator = 0)
//      : my_Server(ioTimeout, basicAllocator)
//      , d_verbose(verbose)
//      {
//      }
//
//      virtual ~my_TestServer();
//  };
//
//  // myTestSession.cpp             -*-C++-*-
//
//  my_TestServer::~my_TestServer()
//  {
//  }
//
//  void my_TestServer::closeConnection(my_Connection *connection)
//  {
//      if (d_verbose) {
//          bsl::cout &lt;&lt; bdlt::CurrentTime::utc() &lt;&lt; &quot;: &quot;;
//          bsl::cout &lt;&lt; &quot;Closing connection &quot; &lt;&lt; connection &lt;&lt; bsl::endl;
//      }
//      delete connection;
//  }
//
//  void my_TestServer::monitorConnections()
//  {
//      my_Session *session = new my_TestSession(d_verbose);
//
//      // Simulate connection monitor logic...
//      my_Connection *connection1 = new my_Connection;
//      connection1-&gt;d_session_p = session;
//      newConnection(connection1);
//      if (d_verbose) {
//          bsl::cout &lt;&lt; bdlt::CurrentTime::utc() &lt;&lt; &quot;: &quot;;
//          bsl::cout &lt;&lt; &quot;Opening connection &quot; &lt;&lt; connection1 &lt;&lt; endl;
//      }
//
//      my_Connection *connection2 = new my_Connection;
//      connection2-&gt;d_session_p = session;
//      newConnection(connection2);
//      if (d_verbose) {
//          bsl::cout &lt;&lt; bdlt::CurrentTime::utc() &lt;&lt; &quot;: &quot;;
//          bsl::cout &lt;&lt; &quot;Opening connection &quot; &lt;&lt; connection2 &lt;&lt; endl;
//      }
//
//      bslmt::ThreadUtil::sleep(bsls::TimeInterval(2)); // 2s
//
//      // Simulate transmission...
//      const int  length = 1024;
//      const char*buffer[length];
//      if (d_verbose) {
//          bsl::cout &lt;&lt; bdlt::CurrentTime::utc() &lt;&lt; &quot;: &quot;;
//          bsl::cout &lt;&lt; &quot;Connection &quot; &lt;&lt; connection1
//                    &lt;&lt; &quot; receives &quot; &lt;&lt; length &lt;&lt; &quot; bytes &quot; &lt;&lt; endl;
//      }
//      dataAvailable(connection1, buffer, length);
//
//      // Wait for timeout to occur, otherwise session gets destroyed from
//      // stack too early.
//
//      bslmt::ThreadUtil::sleep(bsls::TimeInterval(8)); // 8s
//  }
//..
// The program that would exercise this test server would simply consist of:
//..
//  int usageExample(int verbose)
//  {
//      my_TestServer mX(5, verbose); // timeout for connections: 5s
//      mX.start();
//
//      // Wait sufficiently long to observe all events.
//      bslmt::ThreadUtil::sleep(bsls::TimeInterval(10)); // 10s
//
//      return 0;
//  }
//..
// The output of this program would look something as follows:
//..
//  17:10:35.000: Opening connection 0x00161880
//  17:10:35.000: Opening connection 0x001618b0
//  17:10:37.000: Connection 0x00161880 receives 1024 bytes
//  17:10:37.000: Processing data at address 0xfeefaf04 and length 1024.
//  17:10:40.000: Closing connection 0x001618b0
//  17:10:42.000: Closing connection 0x00161880
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLMA_CONCURRENTPOOLALLOCATOR
#include &lt;bdlma_concurrentpoolallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMT_LOCKGUARD
#include &lt;bslmt_lockguard.h&gt;
#endif

#ifndef INCLUDED_BSLMT_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMIC
#include &lt;bsls_atomic.h&gt;
#endif

#ifndef INCLUDED_BDLMA_POOL
#include &lt;bdlma_pool.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARDESTRUCTIONPRIMITIVES
#include &lt;bslalg_scalardestructionprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITUSESBSLMAALLOCATOR
#include &lt;bslalg_typetraitusesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENT
#include &lt;bsls_alignment.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSL_MAP
#include &lt;bsl_map.h&gt;
#endif

#ifndef INCLUDED_BSL_VECTOR
#include &lt;bsl_vector.h&gt;
#endif

namespace BloombergLP {
namespace bdlcc {template &lt;class DATA&gt;

class TimeQueueItem;

                              // ===============
                              // class TimeQueue
                              // ===============
template &lt;class DATA&gt;
class TimeQueue {
    // This parameterized class provides a public interface which is similar in
    // structure and intent to &#39;Queue&lt;DATA&gt;&#39;, with the exception that each item
    // stored in the &#39;TimeQueue&#39; has an associated time value.  Items are
    // retrieved or exchanged by proxy of a &#39;TimeQueueItem&lt;DATA&gt;&#39;, and are
    // referred to by an opaque data type &#39;TimeQueue::Handle&#39; which serves to
    // identify an individual element on the Time Queue.  Idiomatic usage of
    // &#39;TimeQueue&#39; includes the member function &#39;popLE&#39;, which finds all items
    // on the queue whose &#39;bsls::TimeInterval&#39; are less than a specified value
    // and transfers those items to a provided vector of items, and the member
    // function &#39;update&#39;, which can update the time value for a specific
    // &#39;TimeQueueItem&#39; without removing it from the queue.

    // TYPES
    enum {
        k_NUM_INDEX_BITS_MIN     = 8,
        k_NUM_INDEX_BITS_MAX     = 24,
        k_NUM_INDEX_BITS_DEFAULT = 17
    };

  public:
    // TYPES
    typedef int Handle;
        // &#39;Handle&#39; defines an alias for uniquely identifying a valid node in
        // the time queue.  Handles are returned when nodes are added to the
        // time queue, and must be supplied to the &#39;update&#39; and &#39;remove&#39;
        // methods to identify existing nodes.  When a node is removed, the
        // handle value becomes invalid, though invalidated handle values are
        // eventually reused.  See the component-level documentation for more
        // details.

    class Key {
        // This type is a wrapper around a void pointer that will be supplied
        // and used by clients to uniquely identify an item in the queue.

        // PRIVATE DATA MEMBERS
        const void *d_key;

      public:
        // CREATORS
        explicit Key(const void *key)
        : d_key(key)
            // Create a &#39;Key&#39; object having the specified &#39;key&#39; value.
        {}

        explicit Key(int key)
        : d_key(reinterpret_cast&lt;const void*&gt;(key))
            // Create a &#39;Key&#39; object having the specified &#39;key&#39; value cast to a
            // &#39;void *&#39;.
        {}

        ~Key()
            // Destroy this &#39;Key&#39; object.
        {}

        // ACCESSORS
        bool operator==(const Key&amp; rhs) const
            // Return &#39;true&#39; if this object has the same value as the specified
            // &#39;rhs&#39; object, and &#39;false&#39; otherwise.
        {
            return d_key == rhs.d_key;
        }

        bool operator!=(const Key&amp; rhs) const
            // Return &#39;true&#39; if this object does not have the same value as the
            // specified &#39;rhs&#39; object, and &#39;false&#39; otherwise.
        {
            return d_key != rhs.d_key;
        }
    };

  private:

    // PRIVATE TYPES
    struct Node {
        // This queue is implemented internally as a map of time values, each
        // entry in the map storing a doubly-linked circular list of items
        // having the same time value.  This struct provides the node in the
        // list.

        int                       d_index;
        bsls::TimeInterval         d_time;
        Key                       d_key;
        Node                     *d_prev_p;
        Node                     *d_next_p;
        bsls::ObjectBuffer&lt;DATA&gt;  d_data;

        // CREATORS
        Node()
        : d_index(0)
        , d_key(0)
        , d_prev_p(0)
        , d_next_p(0)
            // Create a &#39;Node&#39; having a time value of 0.
        {
        }

        explicit
        Node(const bsls::TimeInterval&amp; time)
        : d_index(0)
        , d_time(time)
        , d_key(0)
        , d_prev_p(0)
        , d_next_p(0)
            // Create a &#39;Node&#39; having the specified &#39;time&#39; value.
        {
        }
    };

    typedef bsl::map&lt;bsls::TimeInterval, Node*&gt; NodeMap;
        // Internal typedef for the time index map.

    typedef typename NodeMap::iterator         MapIter;
        // Internal typedefs for the iterator used to navigate the time index.

    // PRIVATE DATA MEMBERS
    const int                d_indexMask;
    const int                d_indexIterationMask;
    const int                d_indexIterationInc;

    mutable bslmt::Mutex      d_mutex;          // used for synchronizing
                                                // access
                                               // to this queue

    bsl::vector&lt;Node*&gt;       d_nodeArray;      // array of nodes in this queue

    bsls::AtomicPointer&lt;Node&gt; d_nextFreeNode_p; // pointer to the next free
                                                // node
                                               // in this queue (the free list
                                               // is singly linked only, using
                                               // d_next_p)

    NodeMap                  d_map;            // list of time values in
                                               // increasing time order

    bsls::AtomicInt           d_length;         // number of items currently in
                                               // this queue (not necessarily
                                               // equal to d_map.size())

    bslma::Allocator        *d_allocator_p;    // allocator (held, not owned)

    // PRIVATE MANIPULATORS
    void freeNode(Node *node);
        // Prepare the specified &#39;node&#39; for being reused on the free list by
        // incrementing the iteration count.  Set &#39;d_prev_p&#39; field to 0.

    void putFreeNode(Node *node);
        // Destroy the data located at the specified &#39;node&#39; and reattach this
        // &#39;node&#39; to the front of the free list starting at &#39;d_nextFreeNode_p&#39;,
        // making &#39;node&#39; the new &#39;d_nextFreeNode_p&#39;.  Note that the caller must
        // not have acquired the lock to this queue.

    void putFreeNodeList(Node *begin);
        // Destroy the &#39;DATA&#39; of every node in the singly-linked list starting
        // at the specified &#39;begin&#39; node and ending with a null pointer, and
        // reattach these nodes to the front of the free list starting at
        // &#39;d_nextFreeNode_p&#39;, making &#39;begin&#39; the new &#39;d_nextFreeNode_p&#39; and
        // calling &#39;freeNode&#39;.  Note that the caller must not have acquired the
        // lock to this queue.

  private:
    // NOT IMPLEMENTED
    TimeQueue(const TimeQueue&amp;);
    TimeQueue&amp; operator=(const TimeQueue&amp;);

  public:
    // CREATORS
    explicit TimeQueue(bslma::Allocator *basicAllocator = 0);
    explicit TimeQueue(int numIndexBits, bslma::Allocator *basicAllocator = 0);
        // Create an empty time queue.  Optionally specify &#39;numIndexBits&#39; to
        // configure the number of index bits used by this object.  If
        // &#39;numIndexBits&#39; is not specified a default value of 17 is used.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  The behavior is undefined unless &#39;8 &lt;= numIndexBits &lt;= 24&#39;.
        // See the component-level documentation for more information regarding
        // &#39;numIndexBits&#39;.

    explicit TimeQueue(bool              poolTimerMemory,
                       bslma::Allocator *basicAllocator = 0);
    TimeQueue(int               numIndexBits,
              bool              poolTimerMemory,
              bslma::Allocator *basicAllocator = 0);
        // [!DEPRECATED!] Use the other constructor overloads instead.  Note
        // that the specified &#39;poolTimerMemory&#39; argument controlled whether
        // additional memory used by an internal &#39;bsl::map&#39; was pooled.  When
        // &#39;bsl::map&#39; was modified to pool its own nodes, this option became
        // irrelevant and is now ignored.

    ~TimeQueue();
        // Destroy this time queue.

    // MANIPULATORS
    Handle add(const bsls::TimeInterval&amp;  time,
               const DATA&amp;                data,
               int                       *isNewTop = 0,
               int                       *newLength = 0);
    Handle add(const bsls::TimeInterval&amp;  time,
               const DATA&amp;                data,
               const Key&amp;                 key,
               int                       *isNewTop = 0,
               int                       *newLength = 0);
        // Add a new item to this queue having the specified &#39;time&#39; value, and
        // associated &#39;data&#39;.  Optionally use the specified &#39;key&#39; to uniquely
        // identify the item in subsequent calls to &#39;remove&#39; and &#39;update&#39;.
        // Optionally load into the optionally specified &#39;isNewTop&#39; a non-zero
        // value if the item is now the lowest item in this queue, and a 0
        // value otherwise.  If specified, load into the optionally specified
        // &#39;newLength&#39;, the new number of items in this queue.  Return a value
        // that may be used to identify the newly added item in future calls to
        // time queue on success, and
        // -1 if the maximum queue length has been reached.

    Handle add(const TimeQueueItem&lt;DATA&gt;&amp;  item,
               int                        *isNewTop = 0,
               int                        *newLength = 0);
        // Add the value of the specified &#39;item&#39; to this queue.  Optionally
        // load into the optionally specified &#39;isNewTop&#39; a non-zero value if
        // the replaces is now the lowest element in this queue, and a 0 value
        // otherwise.  If specified, load into the optionally specified
        // &#39;newLength&#39;, the new number of elements in this queue.  Return a
        // value that may be used to identify the newly added element in future
        // calls to time queue.

    int popFront(TimeQueueItem&lt;DATA&gt; *buffer = 0,
                 int                 *newLength = 0,
                 bsls::TimeInterval  *newMinTime = 0);
        // Atomically remove the top item from this queue, and optionally load
        // into the optionally specified &#39;buffer&#39; the time and associated data
        // of the item removed.  Optionally load into the optionally specified
        // &#39;newLength&#39;, the number of items remaining in the queue.  Optionally
        // load into the optionally specified &#39;newMinTime&#39; the new lowest time
        // in this queue.  Return 0 on success, and a non-zero value if there
        // are no items in the queue.  Note that if &#39;DATA&#39; follows the &#39;bdema&#39;
        // allocator model, the allocator of the &#39;buffer&#39; is used to supply
        // memory.

    void popLE(const bsls::TimeInterval&amp;          time,
               bsl::vector&lt;TimeQueueItem&lt;DATA&gt; &gt; *buffer = 0,
               int                               *newLength = 0,
               bsls::TimeInterval                *newMinTime = 0);
        // Remove from this queue all the items that have a time value less
        // than or equal to the specified &#39;time&#39;, and optionally append into
        // the optionally specified &#39;buffer&#39; a list of the removed items,
        // ordered by their corresponding time values (top item first).
        // Optionally load into the optionally specified &#39;newLength&#39; the number
        // of items remaining in this queue, and into the optionally specified
        // &#39;newMinTime&#39; the lowest remaining time value in this queue.  Note
        // that &#39;newMinTime&#39; is only loaded if there are items remaining in the
        // time queue; therefore, &#39;newLength&#39; should be specified and examined
        // to determine whether items remain, and &#39;newMinTime&#39; used only when
        // &#39;newLength&#39; &gt; 0.  Also note that if &#39;DATA&#39; follows the &#39;bdema&#39;
        // allocator model, the allocator of the &#39;buffer&#39; vector is used to
        // supply memory for the items appended to the &#39;buffer&#39;.

    void popLE(const bsls::TimeInterval&amp;          time,
               int                                maxTimers,
               bsl::vector&lt;TimeQueueItem&lt;DATA&gt; &gt; *buffer = 0,
               int                               *newLength = 0,
               bsls::TimeInterval                *newMinTime = 0);
        // Remove from this queue up to the specified &#39;maxTimers&#39; number of
        // items that have a time value less than or equal to the specified
        // &#39;time&#39;, and optionally append into the optionally specified &#39;buffer&#39;
        // a list of the removed items, ordered by their corresponding time
        // values (top item first).  Optionally load into the optionally
        // specified &#39;newLength&#39; the number of items remaining in this queue,
        // and into the optionally specified &#39;newMinTime&#39; the lowest remaining
        // time value in this queue.  The behavior is undefined unless
        // &#39;maxTimers&#39; &gt;= 0.  Note that &#39;newMinTime&#39; is only loaded if there
        // are items remaining in the time queue; therefore, &#39;newLength&#39; should
        // be specified and examined to determine whether items remain, and
        // &#39;newMinTime&#39; used only when &#39;newLength&#39; &gt; 0.  Also note that if
        // &#39;DATA&#39; follows the &#39;bdema&#39; allocator model, the allocator of the
        // &#39;buffer&#39; vector is used to supply memory.  Note finally that all the
        // items appended into &#39;buffer&#39; have a time value less than or equal to
        // the elements remaining in this queue.

    int remove(Handle               handle,
               int                 *newLength = 0,
               bsls::TimeInterval  *newMinTime = 0,
               TimeQueueItem&lt;DATA&gt; *item = 0);
    int remove(Handle               handle,
               const Key&amp;           key,
               int                 *newLength = 0,
               bsls::TimeInterval  *newMinTime = 0,
               TimeQueueItem&lt;DATA&gt; *item = 0);
        // Remove from this queue the item having the specified &#39;handle&#39;, and
        // optionally load into the optionally specified &#39;item&#39; the time and
        // data values of the recently removed item.  Optionally use the
        // specified &#39;key&#39; to uniquely identify the item.  If specified, load
        // into the optionally specified &#39;newMinTime&#39;, the resulting lowest
        // time value remaining in the queue.  Return 0 on success, and a
        // non-zero value if no item with the &#39;handle&#39; exists in the queue.
        // Note that if &#39;DATA&#39; follows the &#39;bdema&#39; allocator model, the
        // allocator of the &#39;item&#39; instance is used to supply memory.

    void removeAll(bsl::vector&lt;TimeQueueItem&lt;DATA&gt; &gt; *buffer = 0);
        // Optionally load all the items in this queue to the optionally
        // specified &#39;buffer&#39;, and remove all the items in this queue.  Note
        // that the allocator of the &#39;buffer&#39; vector is used to supply memory.

    int update(Handle                     handle,
               const bsls::TimeInterval&amp;  newTime,
               int                       *isNewTop = 0);
    int update(Handle                     handle,
               const Key&amp;                 key,
               const bsls::TimeInterval&amp;  newTime,
               int                       *isNewTop = 0);
        // Update the time value of the item having the specified &#39;handle&#39; to
        // the specified &#39;newTime&#39; and optionally load into the optionally
        // specified &#39;isNewTop&#39; a non-zero value if the modified item is now
        // the lowest time value in the time queue or zero otherwise.  Return 0
        // on success, and a non-zero value if there is currently no item
        // having the &#39;handle&#39; registered with this time queue.

    // ACCESSORS
    int length() const;
        // Return a &quot;snapshot&quot; of the current number of items in this queue.

    bool isRegisteredHandle(Handle handle) const;
    bool isRegisteredHandle(Handle handle, const Key&amp; key) const;
        // Return &#39;true&#39; if an item having specified &#39;handle&#39; is currently
        // registered with this time queue and false otherwise.

    int minTime(bsls::TimeInterval *buffer) const;
        // Load into the specified &#39;buffer&#39;, the time value of the lowest time
        // in this queue.  Return 0 on success, and a non-zero value if this
        // queue is empty.
};

                            // ====================
                            // struct TimeQueueItem
                            // ====================

template &lt;class DATA&gt;
class TimeQueueItem {
    // This parameterized structure holds a time, data and associated handle.
    // This structure is used in the interface of &#39;TimeQueue&lt;DATA&gt;&#39; to provide
    // thread-safe access to individual elements on the queue.  Note that
    // &#39;DATA&#39; must be default-constructible.

  public:
    // PUBLIC TYPES
    typedef typename TimeQueue&lt;DATA&gt;::Handle Handle;
    typedef typename TimeQueue&lt;DATA&gt;::Key    Key;

    BSLALG_DECLARE_NESTED_TRAITS(TimeQueueItem,
                                 bslalg::TypeTraitUsesBslmaAllocator);

  private:
    bsls::TimeInterval             d_time;    // Time value
    DATA                          d_data;    // Associated data value
    Handle                        d_handle;  // Associated handle
    Key                           d_key;     // Associated key

  public:
    // CREATORS
    explicit
    TimeQueueItem(bslma::Allocator *basicAllocator = 0);
        // Create an empty time queue item.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
        // zero, then use the currently installed default allocator.

    TimeQueueItem(const bsls::TimeInterval&amp;  time,
                  const DATA&amp;                data,
                  Handle                     handle,
                  bslma::Allocator          *basicAllocator = 0);
        // Create time queue item holding a copy of the specified &#39;data&#39;, with
        // the specified associated &#39;time&#39; and &#39;handle&#39; information.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is zero, then use the currently installed default
        // allocator.

    TimeQueueItem(const bsls::TimeInterval&amp;  time,
                  const DATA&amp;                data,
                  Handle                     handle,
                  const Key&amp;                 key,
                  bslma::Allocator          *basicAllocator = 0);
        // Create time queue item holding a copy of the specified &#39;data&#39;, with
        // the specified associated &#39;time&#39;, &#39;handle&#39;, and &#39;key&#39; information.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is zero, then use the currently installed default
        // allocator.

    TimeQueueItem(const TimeQueueItem&lt;DATA&gt;&amp;  original,
                  bslma::Allocator           *basicAllocator = 0);
        // Create a copy of the specified &#39;original&#39; time queue item.
        // Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is zero, then use the currently installed default
        // allocator.

    // MANIPULATORS
    bsls::TimeInterval&amp; time();
        // Return the modifiable time value associated with this item.

    DATA&amp; data();
        // Return the modifiable data instance associated with this item.

    Handle&amp; handle()
        // Return the modifiable handle value associated with this item.
    {
        // this definition was moved into the class declaration to work around
        // a Visual Studio .NET 2003 bug.

        return d_handle;
    }

    Key&amp; key();
        // Return the modifiable key value associated with this item.

    // ACCESSORS
    const bsls::TimeInterval&amp; time() const;
        // Return the non-modifiable time value associated with this item.

    const DATA&amp; data() const;
        // Return the non-modifiable data associated with this item.

    Handle handle() const
        // Return the non-modifiable handle value associated with this item.
    {
        // this definition was moved into the class declaration to work around
        // a Visual Studio .NET 2003 bug.

        return d_handle;
    }

    const Key&amp; key() const;
        // Return the non-modifiable key value associated with this item.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                                // ---------
                                // TimeQueue
                                // ---------

// PRIVATE MANIPULATORS
template &lt;class DATA&gt;
inline
void TimeQueue&lt;DATA&gt;::freeNode(Node *node)
{
    node-&gt;d_index = ((node-&gt;d_index + d_indexIterationInc) &amp;
                         d_indexIterationMask) | (node-&gt;d_index &amp; d_indexMask);

    if (!(node-&gt;d_index &amp; d_indexIterationMask)) {
        node-&gt;d_index += d_indexIterationInc;
    }
    node-&gt;d_prev_p = 0;
}

template &lt;class DATA&gt;
void TimeQueue&lt;DATA&gt;::putFreeNode(Node *node)
{
    node-&gt;d_data.object().~DATA();

    Node *nextFreeNode = d_nextFreeNode_p;
    node-&gt;d_next_p = nextFreeNode;
    while (nextFreeNode != d_nextFreeNode_p.testAndSwap(nextFreeNode, node)) {
        nextFreeNode = d_nextFreeNode_p;
        node-&gt;d_next_p = nextFreeNode;
    }
}

template &lt;class DATA&gt;
void TimeQueue&lt;DATA&gt;::putFreeNodeList(Node *begin)
{
    if (begin) {
        begin-&gt;d_data.object().~DATA();

        Node *end = begin;
        while (end-&gt;d_next_p) {
            end = end-&gt;d_next_p;
            end-&gt;d_data.object().~DATA();
        }

        Node *nextFreeNode = d_nextFreeNode_p;
        end-&gt;d_next_p = nextFreeNode;

        while (nextFreeNode !=
                           d_nextFreeNode_p.testAndSwap(nextFreeNode, begin)) {
            nextFreeNode = d_nextFreeNode_p;
            end-&gt;d_next_p = nextFreeNode;
        }
    }
    return;
}

// CREATORS
template &lt;class DATA&gt;
TimeQueue&lt;DATA&gt;::TimeQueue(bslma::Allocator *basicAllocator)
: d_indexMask((1 &lt;&lt; k_NUM_INDEX_BITS_DEFAULT) - 1)
, d_indexIterationMask(~(int)d_indexMask)
, d_indexIterationInc(d_indexMask + 1)
, d_nodeArray(basicAllocator)
, d_nextFreeNode_p(0)
, d_map(basicAllocator)
, d_length(0)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

template &lt;class DATA&gt;
TimeQueue&lt;DATA&gt;::TimeQueue(bool              poolTimerMemory,
                           bslma::Allocator *basicAllocator)
: d_indexMask((1 &lt;&lt; k_NUM_INDEX_BITS_DEFAULT) - 1)
, d_indexIterationMask(~(int)d_indexMask)
, d_indexIterationInc(d_indexMask + 1)
, d_nodeArray(basicAllocator)
, d_nextFreeNode_p(0)
, d_map(basicAllocator)
, d_length(0)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
    // The &#39;poolTimerMemory&#39; option has been deprecated (see method
    // documentation).

    (void)poolTimerMemory;
}

template &lt;class DATA&gt;
TimeQueue&lt;DATA&gt;::TimeQueue(int numIndexBits, bslma::Allocator *basicAllocator)
: d_indexMask((1 &lt;&lt; numIndexBits) - 1)
, d_indexIterationMask(~d_indexMask)
, d_indexIterationInc(d_indexMask + 1)
, d_nodeArray(basicAllocator)
, d_nextFreeNode_p(0)
, d_map(basicAllocator)
, d_length(0)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
    BSLS_ASSERT(k_NUM_INDEX_BITS_MIN &lt;= numIndexBits
             &amp;&amp; k_NUM_INDEX_BITS_MAX &gt;= numIndexBits);
}

template &lt;class DATA&gt;
TimeQueue&lt;DATA&gt;::TimeQueue(int               numIndexBits,
                           bool              poolTimerMemory,
                           bslma::Allocator *basicAllocator)
: d_indexMask((1 &lt;&lt; numIndexBits) - 1)
, d_indexIterationMask(~d_indexMask)
, d_indexIterationInc(d_indexMask + 1)
, d_nodeArray(basicAllocator)
, d_nextFreeNode_p(0)
, d_map(basicAllocator)
, d_length(0)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
    BSLS_ASSERT(k_NUM_INDEX_BITS_MIN &lt;= numIndexBits
             &amp;&amp; k_NUM_INDEX_BITS_MAX &gt;= numIndexBits);

    // The &#39;poolTimerMemory&#39; option has been deprecated (see method
    // documentation).

    (void)poolTimerMemory;

}

template &lt;class DATA&gt;
TimeQueue&lt;DATA&gt;::~TimeQueue()
{
    removeAll();
    if (!d_nodeArray.empty()) {
        Node **data = &amp;d_nodeArray.front();
        const int numNodes = static_cast&lt;int&gt;(d_nodeArray.size());
        for (int i = 0; i &lt; numNodes; ++i) {
            d_allocator_p-&gt;deleteObjectRaw(data[i]);
        }
    }
}

// MANIPULATORS
template &lt;class DATA&gt;
inline
typename TimeQueue&lt;DATA&gt;:: Handle TimeQueue&lt;DATA&gt;::add(
                                          const bsls::TimeInterval&amp;  time,
                                          const DATA&amp;                data,
                                          int                       *isNewTop,
                                          int                       *newLength)
{
    return add(time, data, Key(0), isNewTop, newLength);
}

template &lt;class DATA&gt;
typename TimeQueue&lt;DATA&gt;:: Handle TimeQueue&lt;DATA&gt;::add(
                                          const bsls::TimeInterval&amp;  time,
                                          const DATA&amp;                data,
                                          const Key&amp;                 key,
                                          int                       *isNewTop,
                                          int                       *newLength)

{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    Node *node;
    if (d_nextFreeNode_p) {
        // All allocation of nodes goes through this routine, which is guarded
        // by the mutex.  So no other thread will remove anything from the free
        // list while this code is executing.  However, other threads may add
        // to the free list.

        node = d_nextFreeNode_p;
        Node *next = node-&gt;d_next_p;
        while (node != d_nextFreeNode_p.testAndSwap(node, next)) {
            node = d_nextFreeNode_p;
            next = node-&gt;d_next_p;
        }
    }
    else {
        // The number of nodes cannot grow to a size larger than the range of
        // available indices.

        if ((int)d_nodeArray.size() &gt;= d_indexMask - 1) {
            return -1;                                                // RETURN
        }

        node = new (*d_allocator_p) Node;
        d_nodeArray.push_back(node);
        node-&gt;d_index =
                    static_cast&lt;int&gt;(d_nodeArray.size()) | d_indexIterationInc;
    }
    node-&gt;d_time = time;
    node-&gt;d_key  = key;
    bslalg::ScalarPrimitives::copyConstruct(&amp;node-&gt;d_data.object(),
                                            data,
                                            d_allocator_p);

    {
        MapIter it = d_map.find(time);

        if (d_map.end() == it) {
            node-&gt;d_prev_p = node;
            node-&gt;d_next_p = node;
            d_map[time] = node;
        }
        else {
            node-&gt;d_prev_p = it-&gt;second-&gt;d_prev_p;
            it-&gt;second-&gt;d_prev_p-&gt;d_next_p = node;
            node-&gt;d_next_p = it-&gt;second;
            it-&gt;second-&gt;d_prev_p = node;
        }
    }

    ++d_length;
    if (isNewTop) {
        *isNewTop = d_map.begin()-&gt;second == node &amp;&amp; node-&gt;d_prev_p == node;
    }

    if (newLength) {
        *newLength = d_length;
    }

    BSLS_ASSERT(-1 != node-&gt;d_index);
    return node-&gt;d_index;
}

template &lt;class DATA&gt;
inline
typename TimeQueue&lt;DATA&gt;::Handle TimeQueue&lt;DATA&gt;::add(
                                         const TimeQueueItem&lt;DATA&gt;&amp;  item,
                                         int                        *isNewTop,
                                         int                        *newLength)
{
    return add(item.time(), item.data(), item.key(), isNewTop, newLength);
}

template &lt;class DATA&gt;
int TimeQueue&lt;DATA&gt;::popFront(TimeQueueItem&lt;DATA&gt; *buffer,
                              int                 *newLength,
                              bsls::TimeInterval  *newMinTime)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    MapIter it = d_map.begin();

    if (d_map.end() == it) {
        return 1;                                                     // RETURN
    }
    Node *node = it-&gt;second;

    if (buffer) {
        buffer-&gt;time()   = node-&gt;d_time;
        buffer-&gt;data()   = node-&gt;d_data.object();
        buffer-&gt;handle() = node-&gt;d_index;
        buffer-&gt;key()    = node-&gt;d_key;
    }
    if (node-&gt;d_next_p != node) {
        node-&gt;d_prev_p-&gt;d_next_p = node-&gt;d_next_p;
        node-&gt;d_next_p-&gt;d_prev_p = node-&gt;d_prev_p;
        if (it-&gt;second == node) {
            it-&gt;second = node-&gt;d_next_p;
        }
    }
    else {
        d_map.erase(it);
    }

    freeNode(node);
    --d_length;

    if (d_length &amp;&amp; newMinTime &amp;&amp; !d_map.empty()) {
        *newMinTime = d_map.begin()-&gt;first;
    }

    if (newLength) {
        *newLength = d_length;
    }

    lock.release()-&gt;unlock();

    putFreeNode(node);
    return 0;
}

template &lt;class DATA&gt;
void TimeQueue&lt;DATA&gt;::popLE(const bsls::TimeInterval&amp;          time,
                            bsl::vector&lt;TimeQueueItem&lt;DATA&gt; &gt; *buffer,
                            int                               *newLength,
                            bsls::TimeInterval                *newMinTime)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    MapIter it = d_map.begin();

    Node *begin = 0;
    while (d_map.end() != it &amp;&amp; it-&gt;first &lt;= time) {
        Node *const first = it-&gt;second;
        Node *const last  = first-&gt;d_prev_p;
        Node *node = first;

        do {
            if (buffer) {
                buffer-&gt;push_back(TimeQueueItem&lt;DATA&gt;(
                                                         it-&gt;first,
                                                         node-&gt;d_data.object(),
                                                         node-&gt;d_index,
                                                         node-&gt;d_key,
                                                         d_allocator_p));
            }
            freeNode(node);
            node = node-&gt;d_next_p;
            --d_length;
        } while (node != first);

        last-&gt;d_next_p = begin;
        begin = first;

        MapIter condemned = it;
        ++it;
        d_map.erase(condemned);
    }

    if (newLength) {
        *newLength = d_length;
    }
    if (d_map.end() != it &amp;&amp; newMinTime) {
        *newMinTime = it-&gt;first;
    }

    lock.release()-&gt;unlock();
    putFreeNodeList(begin);
}

template &lt;class DATA&gt;
void TimeQueue&lt;DATA&gt;::popLE(const bsls::TimeInterval&amp;          time,
                            int                                maxTimers,
                            bsl::vector&lt;TimeQueueItem&lt;DATA&gt; &gt; *buffer,
                            int                               *newLength,
                            bsls::TimeInterval                *newMinTime)
{
    BSLS_ASSERT(0 &lt;= maxTimers);

    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    MapIter it = d_map.begin();

    Node *begin = 0;
    while (d_map.end() != it &amp;&amp; it-&gt;first &lt;= time &amp;&amp; 0 &lt; maxTimers) {
        Node *const first = it-&gt;second;
        Node *const last  = first-&gt;d_prev_p;
        Node *node  = first;
        Node *prevNode  = first-&gt;d_prev_p;

        do {
            if (buffer) {
                buffer-&gt;push_back(TimeQueueItem&lt;DATA&gt;(
                                                         it-&gt;first,
                                                         node-&gt;d_data.object(),
                                                         node-&gt;d_index,
                                                         node-&gt;d_key,
                                                         d_allocator_p));
            }
            freeNode(node);
            prevNode = node;
            node = node-&gt;d_next_p;
            --d_length;
            --maxTimers;
        } while (0 &lt; maxTimers &amp;&amp; node != first);

        prevNode-&gt;d_next_p = begin;
        begin = first;

        if (node == first) {
            MapIter condemned = it;
            ++it;
            d_map.erase(condemned);
        }
        else {
            node-&gt;d_prev_p = last;
            last-&gt;d_next_p = node;
            it-&gt;second = node;
            break;
        }
    }

    if (newLength) {
        *newLength = d_length;
    }
    if (d_map.end() != it &amp;&amp; newMinTime) {
        *newMinTime = it-&gt;first;
    }

    lock.release()-&gt;unlock();
    putFreeNodeList(begin);
}

template &lt;class DATA&gt;
inline
int TimeQueue&lt;DATA&gt;::remove(typename TimeQueue&lt;DATA&gt;::Handle  handle,
                            int                              *newLength,
                            bsls::TimeInterval               *newMinTime,
                            TimeQueueItem&lt;DATA&gt;              *item)
{
    return remove(handle, Key(0), newLength, newMinTime, item);
}

template &lt;class DATA&gt;
int TimeQueue&lt;DATA&gt;::remove(typename TimeQueue&lt;DATA&gt;::Handle  handle,
                            const Key&amp;                        key,
                            int                              *newLength,
                            bsls::TimeInterval               *newMinTime,
                            TimeQueueItem&lt;DATA&gt;              *item)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    int index = ((int)handle &amp; d_indexMask) - 1;
    if (index &lt; 0 || index &gt;= (int)d_nodeArray.size()) {
        return 1;                                                     // RETURN
    }
    Node *node = d_nodeArray[index];

    if (node-&gt;d_index != (int)handle
     || node-&gt;d_key != key
     || 0 == node-&gt;d_prev_p) {
        return 1;                                                     // RETURN
    }

    if (item) {
        item-&gt;time()   = node-&gt;d_time;
        item-&gt;data()   = node-&gt;d_data.object();
        item-&gt;handle() = node-&gt;d_index;
        item-&gt;key()    = node-&gt;d_key;
    }

    if (node-&gt;d_next_p != node) {
        node-&gt;d_prev_p-&gt;d_next_p = node-&gt;d_next_p;
        node-&gt;d_next_p-&gt;d_prev_p = node-&gt;d_prev_p;

        MapIter it = d_map.find(node-&gt;d_time);
        if (it-&gt;second == node) {
            it-&gt;second = node-&gt;d_next_p;
        }
    }
    else {
        d_map.erase(node-&gt;d_time);
    }
    freeNode(node);
    --d_length;

    if (newLength) {
        *newLength = d_length;
    }

    if (d_length &amp;&amp; newMinTime) {
        BSLS_ASSERT(! d_map.empty());

        *newMinTime = d_map.begin()-&gt;first;
    }

    lock.release()-&gt;unlock();

    putFreeNode(node);
    return 0;
}

template &lt;class DATA&gt;
void TimeQueue&lt;DATA&gt;::removeAll(bsl::vector&lt;TimeQueueItem&lt;DATA&gt; &gt; *buffer)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    MapIter it = d_map.begin();

    Node *begin = 0;
    while (d_map.end() != it) {
        Node *const first = it-&gt;second;
        Node *const last  = first-&gt;d_prev_p;
        Node *node = first;

        do {
            if (buffer) {
                buffer-&gt;push_back(TimeQueueItem&lt;DATA&gt;(
                                                         it-&gt;first,
                                                         node-&gt;d_data.object(),
                                                         node-&gt;d_index,
                                                         node-&gt;d_key,
                                                         d_allocator_p));
            }
            freeNode(node);
            node = node-&gt;d_next_p;
            --d_length;
        } while (node != first);

        last-&gt;d_next_p = begin;
        begin = first;

        MapIter condemned = it;
        ++it;
        d_map.erase(condemned);
    }

    lock.release()-&gt;unlock();
    putFreeNodeList(begin);
}

template &lt;class DATA&gt;
inline
int TimeQueue&lt;DATA&gt;::update(typename TimeQueue&lt;DATA&gt;::Handle  handle,
                            const bsls::TimeInterval&amp;         newTime,
                            int                              *isNewTop)
{
    return update(handle, Key(0), newTime, isNewTop);
}

template &lt;class DATA&gt;
int TimeQueue&lt;DATA&gt;::update(typename TimeQueue&lt;DATA&gt;::Handle  handle,
                            const Key&amp;                        key,
                            const bsls::TimeInterval&amp;         newTime,
                            int                              *isNewTop)
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    int index = ((int)handle &amp; d_indexMask) - 1;

    if (index &lt; 0 || (unsigned) index &gt;= d_nodeArray.size()) {
        return 1;                                                     // RETURN
    }
    Node *node = d_nodeArray[index];

    if (node-&gt;d_index != (int)handle || node-&gt;d_key != key) {
        return 1;                                                     // RETURN
    }

    if (node-&gt;d_prev_p != node) {
        node-&gt;d_prev_p-&gt;d_next_p = node-&gt;d_next_p;
        node-&gt;d_next_p-&gt;d_prev_p = node-&gt;d_prev_p;

        MapIter it = d_map.find(node-&gt;d_time);
        if (it-&gt;second == node) {
            it-&gt;second = node-&gt;d_next_p;
        }
    }
    else {
        d_map.erase(node-&gt;d_time);
    }
    node-&gt;d_time = newTime;

    MapIter it = d_map.find(newTime);

    if (d_map.end() == it) {
        node-&gt;d_prev_p = node;
        node-&gt;d_next_p = node;
        d_map[newTime] = node;
    }
    else {
        node-&gt;d_prev_p = it-&gt;second-&gt;d_prev_p;
        it-&gt;second-&gt;d_prev_p-&gt;d_next_p = node;
        node-&gt;d_next_p = it-&gt;second;
        it-&gt;second-&gt;d_prev_p = node;
    }

    if (isNewTop) {
        *isNewTop = d_map.begin()-&gt;second == node &amp;&amp; node-&gt;d_prev_p == node;
    }
    return 0;
}

// ACCESSORS
template &lt;class DATA&gt;
inline
int TimeQueue&lt;DATA&gt;::length() const
{
    return d_length;
}

template &lt;class DATA&gt;
inline
bool TimeQueue&lt;DATA&gt;::isRegisteredHandle(
                                 typename TimeQueue&lt;DATA&gt;::Handle handle) const
{
    return isRegisteredHandle(handle, Key(0));
}

template &lt;class DATA&gt;
inline
bool TimeQueue&lt;DATA&gt;::isRegisteredHandle(
                                    typename TimeQueue&lt;DATA&gt;::Handle handle,
                                    const Key&amp;                       key) const
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);
    int index = (handle &amp; d_indexMask) - 1;

    if ( 0 &gt; index || index &gt;= (int)d_nodeArray.size()) {
        return false;                                                 // RETURN
    }
    Node *node = d_nodeArray[index];

    if (node-&gt;d_index != (int)handle || node-&gt;d_key != key) {
        return false;                                                 // RETURN
    }

    return true;
}

template &lt;class DATA&gt;
inline
int TimeQueue&lt;DATA&gt;::minTime(bsls::TimeInterval *buffer) const
{
    bslmt::LockGuard&lt;bslmt::Mutex&gt; lock(&amp;d_mutex);

    if (d_map.empty()) {
        return 1;                                                     // RETURN
    }

    *buffer = d_map.begin()-&gt;first;
    return 0;
}

                            // --------------------
                            // struct TimeQueueItem
                            // --------------------

// CREATORS
template &lt;class DATA&gt;
TimeQueueItem&lt;DATA&gt;::TimeQueueItem(bslma::Allocator *basicAllocator)
: d_key(0)
{
    bslalg::ScalarDestructionPrimitives::destroy(&amp;d_data);
    bslalg::ScalarPrimitives::defaultConstruct(&amp;d_data, basicAllocator);
}

template &lt;class DATA&gt;
TimeQueueItem&lt;DATA&gt;::
TimeQueueItem(TimeQueueItem&lt;DATA&gt; const&amp;  original,
              bslma::Allocator           *basicAllocator)
: d_time(original.d_time)
// require that &#39;d_data&#39; be default-constructible, hopefully at no cost
, d_handle(original.d_handle)
, d_key(original.d_key)
{
    bslalg::ScalarDestructionPrimitives::destroy(&amp;d_data);
    bslalg::ScalarPrimitives::copyConstruct(&amp;d_data,
                                            original.d_data,
                                            basicAllocator);
}

template &lt;class DATA&gt;
TimeQueueItem&lt;DATA&gt;::
TimeQueueItem(const bsls::TimeInterval&amp;  time,
              const DATA&amp;                data,
              Handle                     handle,
              bslma::Allocator          *basicAllocator)
: d_time(time)
// require that &#39;d_data&#39; be default-constructible, hopefully at no cost
, d_handle(handle)
, d_key(0)
{
    bslalg::ScalarDestructionPrimitives::destroy(&amp;d_data);
    bslalg::ScalarPrimitives::copyConstruct(&amp;d_data,
                                            data,
                                            basicAllocator);
}

template &lt;class DATA&gt;
TimeQueueItem&lt;DATA&gt;::
TimeQueueItem(const bsls::TimeInterval&amp;  time,
              const DATA&amp;                data,
              Handle                     handle,
              const Key&amp;                 key,
              bslma::Allocator          *basicAllocator)
: d_time(time)
// require that &#39;d_data&#39; be default-constructible, hopefully at no cost
, d_handle(handle)
, d_key(key)
{
    bslalg::ScalarDestructionPrimitives::destroy(&amp;d_data);
    bslalg::ScalarPrimitives::copyConstruct(&amp;d_data,
                                            data,
                                            basicAllocator);
}

// MANIPULATORS
template &lt;class DATA&gt;
inline
bsls::TimeInterval&amp; TimeQueueItem&lt;DATA&gt;::time()
{
    return d_time;
}

template &lt;class DATA&gt;
inline
DATA&amp; TimeQueueItem&lt;DATA&gt;::data()
{
    return d_data;
}
}  // close package namespace

#if 0

namespace bdlcc {// this definition was moved into the class declaration

// to work around a Visual Studio .NET 2003 bug.
template &lt;typename DATA&gt;
inline
typename TimeQueueItem&lt;DATA&gt;::Handle&amp;
TimeQueueItem&lt;DATA&gt;::handle()
{
    return d_handle;
}
}  // close package namespace
#endif

namespace bdlcc {

template &lt;class DATA&gt;
inline
typename TimeQueueItem&lt;DATA&gt;::Key&amp;
TimeQueueItem&lt;DATA&gt;::key()
{
    return d_key;
}

// ACCESSORS
template &lt;class DATA&gt;
inline
const bsls::TimeInterval&amp; TimeQueueItem&lt;DATA&gt;::time() const
{
    return d_time;
}

template &lt;class DATA&gt;
inline
const DATA&amp; TimeQueueItem&lt;DATA&gt;::data() const
{
    return d_data;
}
}  // close package namespace

#if 0

namespace bdlcc {// this definition was moved into the class declaration

// to work around a Visual Studio .NET 2003 bug.
template &lt;typename DATA&gt;
inline
typename TimeQueueItem&lt;DATA&gt;::Handle
TimeQueueItem&lt;DATA&gt;::handle() const
{
    return d_handle;
}
}  // close package namespace
#endif

namespace bdlcc {

template &lt;class DATA&gt;
inline
const typename TimeQueueItem&lt;DATA&gt;::Key&amp;
TimeQueueItem&lt;DATA&gt;::key() const
{
    return d_key;
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
