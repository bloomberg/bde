<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Struct bslalg::ArrayPrimitives</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslalg.html">bslalg</a>      </li>
      <li><a class="el" href="structbslalg_1_1ArrayPrimitives.html">bslalg::ArrayPrimitives</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslalg::ArrayPrimitives Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslalg::ArrayPrimitives" -->
<p><code>#include &lt;<a class="el" href="bslalg__arrayprimitives_8h_source.html">bslalg_arrayprimitives.h</a>&gt;</code></p>

<p><a href="structbslalg_1_1ArrayPrimitives-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html">ArrayPrimitives_Imp</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a3fe03746f63d167b9f4edb03db11c5c6">Imp</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#ac756e623500f4007bf4aac5ab654f487">difference_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#ae5142ee3ecc1fcd5bae0f044e50fb94e">defaultConstruct</a> (TARGET_TYPE *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a> numElements, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aa9b0dd78c3bafc31fe4f8cdf8a5c3fca">uninitializedFillN</a> (TARGET_TYPE *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a> numElements, const TARGET_TYPE &amp;value, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR , class FWD_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#ab3b2faada6341d555ceb351bba426933">copyConstruct</a> (TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a5c38c0261136270c2cad4021180e41b1">destructiveMove</a> (TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a4fdfe68bbdd8bbadb815832996630fe0">destructiveMoveAndInsert</a> (TARGET_TYPE *toBegin, TARGET_TYPE **fromEndPtr, TARGET_TYPE *fromBegin, TARGET_TYPE *position, TARGET_TYPE *fromEnd, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a> numElements, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a0d06d0b5cf691e771e8c0c6c1a3085a2">destructiveMoveAndInsert</a> (TARGET_TYPE *toBegin, TARGET_TYPE **fromEndPtr, TARGET_TYPE *fromBegin, TARGET_TYPE *position, TARGET_TYPE *fromEnd, FWD_ITER first, FWD_ITER last, <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a> numElements, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#ab9582c15dd7302f7bed4f81c74677ab6">destructiveMoveAndMoveInsert</a> (TARGET_TYPE *toBegin, TARGET_TYPE **fromEndPtr, TARGET_TYPE **lastPtr, TARGET_TYPE *fromBegin, TARGET_TYPE *position, TARGET_TYPE *fromEnd, TARGET_TYPE *first, TARGET_TYPE *last, <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a> numElements, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a55381d543e412d18de7802b60ffe2b62">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a> numElements, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a0c3cde4db18167cf31b55428c0f6688f">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a> numElements, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#ac02f87e95a3fa98dd0087567c9b9ae4b">moveInsert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **fromEndPtr, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a> numElements, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#af4417e6879cc56bcadd7a23ad15d602c">erase</a> (TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#a8ae744e097db0b9b93b6d1b45c373f4e">rotate</a> (TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of independent utility functions that operate on arrays of elements of parameterized type <code>TARGET_TYPE</code>. Depending on the traits of <code>TARGET_TYPE</code>, the default and copy constructors, destructor, assignment operators, etc. may not be invoked, optimized away by no-op or bit-wise move or copy. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a3fe03746f63d167b9f4edb03db11c5c6"></a><!-- doxytag: member="bslalg::ArrayPrimitives::Imp" ref="a3fe03746f63d167b9f4edb03db11c5c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html">ArrayPrimitives_Imp</a> <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html">bslalg::ArrayPrimitives::Imp</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aee073b37feb7e3e840fa4c1a8bfa94be"></a><!-- doxytag: member="bslalg::ArrayPrimitives::size_type" ref="aee073b37feb7e3e840fa4c1a8bfa94be" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">bslalg::ArrayPrimitives::size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac756e623500f4007bf4aac5ab654f487"></a><!-- doxytag: member="bslalg::ArrayPrimitives::difference_type" ref="ac756e623500f4007bf4aac5ab654f487" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="structbslalg_1_1ArrayPrimitives.html#ac756e623500f4007bf4aac5ab654f487">bslalg::ArrayPrimitives::difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae5142ee3ecc1fcd5bae0f044e50fb94e"></a><!-- doxytag: member="bslalg::ArrayPrimitives::defaultConstruct" ref="ae5142ee3ecc1fcd5bae0f044e50fb94e" args="(TARGET_TYPE *begin, size_type numElements, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::defaultConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call the default constructor on each of the elements of an array of the specified <code>numElements</code> of the parameterized <code>TARGET_TYPE</code> starting at the <code>toBegin</code> address. If the parameterized <code>ALLOCATOR</code> is derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and <code>TARGET_TYPE</code> supports <code>bslma</code> allocators, then the specified <code>allocator</code> is passed to each <code>TARGET_TYPE</code> default constructor call. The behavior is undefined unless <code>begin &lt;= end</code>. If a <code>TARGET_TYPE</code> constructor throws an exception during the operation, then the destructor is called on any newly-constructed elements, leaving the input array in an uninitialized state. </p>

</div>
</div>
<a class="anchor" id="aa9b0dd78c3bafc31fe4f8cdf8a5c3fca"></a><!-- doxytag: member="bslalg::ArrayPrimitives::uninitializedFillN" ref="aa9b0dd78c3bafc31fe4f8cdf8a5c3fca" args="(TARGET_TYPE *begin, size_type numElements, const TARGET_TYPE &amp;value, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct copies of the specified <code>value</code> of the parameterized type <code>TARGET_TYPE</code> into the uninitialized array containing the specified <code>numElements</code> starting at the specified <code>begin</code> address. If the parameterized <code>ALLOCATOR</code> is derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and <code>TARGET_TYPE</code> supports <code>bslma</code> allocators, then the specified <code>allocator</code> is passed to each invocation of the <code>TARGET_TYPE</code> copy constructor. If a <code>TARGET_TYPE</code> constructor throws an exception during the operation, then the destructor is called on any newly-constructed elements, leaving the input array in an uninitialized state. Note that the argument order was chosen to maintain compatibility with the existing <code>bslalg</code>. </p>

</div>
</div>
<a class="anchor" id="ab3b2faada6341d555ceb351bba426933"></a><!-- doxytag: member="bslalg::ArrayPrimitives::copyConstruct" ref="ab3b2faada6341d555ceb351bba426933" args="(TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR , class FWD_ITER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy into an uninitialized array of the parameterized <code>TARGET_TYPE</code> beginning at the specified <code>toBegin</code> address, the elements in the array of <code>TARGET_TYPE</code> starting at the specified <code>fromBegin</code> address and ending immediately before the specified <code>fromEnd</code> address. If the parameterized <code>ALLOCATOR</code> is derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and <code>TARGET_TYPE</code> supports <code>bslma</code> allocators, then the specified <code>allocator</code> is passed to each invocation of the <code>TARGET_TYPE</code> copy constructor. If a <code>TARGET_TYPE</code> constructor throws an exception during the operation, then the destructor is called on any newly-constructed elements, leaving the input array in an uninitialized state. </p>

</div>
</div>
<a class="anchor" id="a5c38c0261136270c2cad4021180e41b1"></a><!-- doxytag: member="bslalg::ArrayPrimitives::destructiveMove" ref="a5c38c0261136270c2cad4021180e41b1" args="(TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::destructiveMove </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the elements of the parameterized <code>TARGET_TYPE</code> in the array starting at the specified <code>fromBegin</code> address and ending immediately before the specified <code>fromEnd</code> address into an uninitialized array of <code>TARGET_TYPE</code> beginning at the specified <code>toBegin</code> address. On return, the elements in the input range are invalid, i.e., their destructors must not be called after this operation returns. If the parameterized <code>ALLOCATOR</code> type is derived from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and <code>TARGET_TYPE</code> supports <code>bslma</code> allocators, then the specified <code>allocator</code> is used by the objects in their new location. If an exception is thrown by a <code>TARGET_TYPE</code> constructor during the operation, then the output array is left in an uninitialized state and the input elements remain in their original state. </p>

</div>
</div>
<a class="anchor" id="a4fdfe68bbdd8bbadb815832996630fe0"></a><!-- doxytag: member="bslalg::ArrayPrimitives::destructiveMoveAndInsert" ref="a4fdfe68bbdd8bbadb815832996630fe0" args="(TARGET_TYPE *toBegin, TARGET_TYPE **fromEndPtr, TARGET_TYPE *fromBegin, TARGET_TYPE *position, TARGET_TYPE *fromEnd, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::destructiveMoveAndInsert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>fromEndPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the elements of the parameterized <code>TARGET_TYPE</code> in the array starting at the specified <code>fromBegin</code> address and ending immediately before the specified <code>fromEnd</code> address into an uninitialized array of <code>TARGET_TYPE</code> at the specified <code>toBegin</code> address, inserting at the specified <code>position</code> (after translating from <code>fromBegin</code> to <code>toBegin</code>) the specified <code>numElements</code> copies of the specified <code>value</code>. Keep the pointer at the specified <code>fromEndptr</code> address pointing to the first uninitialized element in <code>[ fromBegin, fromEnd)</code> as the elements are moved from source to destination. The behavior is undefined unless <code>fromBegin &lt;= position &lt;= fromEnd</code> and the destination array contains at least <code>(fromEnd - fromBegin) + numElements</code> uninitialized elements. If a copy constructor or assignment operator for <code>TARGET_TYPE</code> throws an exception, then any elements created in the output array are destroyed and the elements in the range <code>[ fromBegin, *fromEndPtr )</code> will have unspecified but valid values. </p>

</div>
</div>
<a class="anchor" id="a0d06d0b5cf691e771e8c0c6c1a3085a2"></a><!-- doxytag: member="bslalg::ArrayPrimitives::destructiveMoveAndInsert" ref="a0d06d0b5cf691e771e8c0c6c1a3085a2" args="(TARGET_TYPE *toBegin, TARGET_TYPE **fromEndPtr, TARGET_TYPE *fromBegin, TARGET_TYPE *position, TARGET_TYPE *fromEnd, FWD_ITER first, FWD_ITER last, size_type numElements, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::destructiveMoveAndInsert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>fromEndPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the elements of the parameterized <code>TARGET_TYPE</code> in the array starting at the specified <code>fromBegin</code> address and ending immediately before the specified <code>fromEnd</code> address into an uninitialized array of <code>TARGET_TYPE</code> at the specified <code>toBegin</code> address, inserting at the specified <code>position</code> (after translating from <code>fromBegin</code> to <code>toBegin</code>) the specified <code>numElements</code> copies of the non-modifiable elements from the range starting at the specified <code>first</code> iterator of the parameterized <code>FWD_ITER</code> type and ending immediately before the specified <code>last</code> iterator. Keep the pointer at the specified <code>fromEndptr</code> to point to the first uninitialized element in <code>[fromBegin, fromEnd)</code> as the elements are moved from source to destination. The behavior is undefined unless <code>fromBegin &lt;= position &lt;= fromEnd</code> the destination array contains at least <code>(fromEnd - fromBegin) + numElements</code> uninitialized elements after <code>toBegin</code>, and <code>numElements</code> is the distance from <code>first</code> to <code>last</code>. If a copy constructor or assignment operator for <code>TARGET_TYPE</code> throws an exception, then any elements created in the output array are destroyed and the elements in the range <code>[ fromBegin, *fromEndPtr )</code> will have unspecified but valid values. </p>

</div>
</div>
<a class="anchor" id="ab9582c15dd7302f7bed4f81c74677ab6"></a><!-- doxytag: member="bslalg::ArrayPrimitives::destructiveMoveAndMoveInsert" ref="ab9582c15dd7302f7bed4f81c74677ab6" args="(TARGET_TYPE *toBegin, TARGET_TYPE **fromEndPtr, TARGET_TYPE **lastPtr, TARGET_TYPE *fromBegin, TARGET_TYPE *position, TARGET_TYPE *fromEnd, TARGET_TYPE *first, TARGET_TYPE *last, size_type numElements, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::destructiveMoveAndMoveInsert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>fromEndPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>lastPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the elements of the parameterized <code>TARGET_TYPE</code> in the array starting at the <code>fromBegin</code> address and ending immediately before the <code>fromEnd</code> address into an uninitialized array of <code>TARGET_TYPE</code> at the specified <code>toBegin</code> address, moving into the specified <code>position</code> (after translating from <code>fromBegin</code> to <code>toBegin</code>) the specified <code>numElements</code> of the <code>TARGET_TYPE</code> from the array starting at the specified <code>first</code> address and ending immediately before the specified <code>last</code> address. Keep the pointer at the specified <code>fromEndptr</code> address pointing to the first uninitialized element in <code>[fromBegin, fromEnd)</code>, and the pointer at the specified <code>lastPtr</code> address pointing to the end of the moved range as the elements from the range <code>[ first, last)</code> are moved from source to destination. The behavior is undefined unless <code>fromBegin &lt;= position &lt;= fromEnd</code>, the destination array contains at least <code>(fromEnd - fromBegin) + numElements</code> uninitialized elements after <code>toBegin</code>, and <code>numElements</code> is the distance from <code>first</code> to <code>last</code>. If a copy constructor or assignment operator for <code>TARGET_TYPE</code> throws an exception, then any elements in <code>[ *lastPtr, last )</code> as well as in <code>[ toBegin, ... )</code> are destroyed, and the elements in the ranges <code>[ first, *lastPtr )</code> and <code>[ fromBegin, *fromEndPtr )</code> will have unspecified but valid values. </p>

</div>
</div>
<a class="anchor" id="a55381d543e412d18de7802b60ffe2b62"></a><!-- doxytag: member="bslalg::ArrayPrimitives::insert" ref="a55381d543e412d18de7802b60ffe2b62" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>numElements</code> copies of the specified <code>value</code> into the array of the parameterized <code>TARGET_TYPE</code> starting at the <code>toBegin</code> address and ending immediately before the specified <code>toEnd</code> address, shifting the elements in the array by <code>numElements</code> positions towards larger addresses. The behavior is undefined unless the destination array contains at least <code>numElements</code> uninitialized elements after <code>toEnd</code>. If a copy constructor or assignment operator for <code>TARGET_TYPE</code> throws an exception, then any elements created after <code>toEnd</code> are destroyed and the elements in the range <code>[ toBegin, toEnd )</code> will have unspecified, but valid, values. </p>

</div>
</div>
<a class="anchor" id="a0c3cde4db18167cf31b55428c0f6688f"></a><!-- doxytag: member="bslalg::ArrayPrimitives::insert" ref="a0c3cde4db18167cf31b55428c0f6688f" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, size_type numElements, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>numElements</code> from the range starting at the <code>fromBegin</code> and ending immediately before the <code>fromEnd</code> iterators of the parameterized <code>FWD_ITER</code> type, into the array of elements of the parameterized <code>TARGET_TYPE</code> starting at the <code>toBegin</code> address and ending immediately before the <code>toEnd</code> address, shifting the elements in the array by the specified <code>numElements</code> positions towards larger addresses. The behavior is undefined unless the destination array contains <code>numElements</code> uninitialized elements after <code>toEnd</code>, <code>numElements</code> is the distance between <code>fromBegin</code> and <code>fromEnd</code>, and the input array and the destination array do not overlap. If a copy constructor or assignment operator for <code>TARGET_TYPE</code> throws an exception, then any elements created after <code>toEnd</code> are destroyed and the elements in the range <code>[ toBegin, toEnd )</code> will have unspecified, but valid, values. </p>

</div>
</div>
<a class="anchor" id="ac02f87e95a3fa98dd0087567c9b9ae4b"></a><!-- doxytag: member="bslalg::ArrayPrimitives::moveInsert" ref="ac02f87e95a3fa98dd0087567c9b9ae4b" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **fromEndPtr, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, size_type numElements, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::moveInsert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>fromEndPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the elements of the parameterized <code>TARGET_TYPE</code> in the array starting at the <code>toBegin</code> address and ending immediately before the <code>toEnd</code> address by the specified <code>numElements</code> positions towards larger addresses, and fill the specified <code>numElements</code> at the <code>toBegin</code> address by moving the elements from the array starting at the <code>fromBegin</code> and ending immediately before the <code>fromEnd</code> address. Keep the iterator at the specified <code>fromEndPtr</code> address pointing to the end of the range as the elements from <code>[ fromBegin, fromEnd )</code> are moved from source to destination. The behavior is undefined unless the destination array contains <code>numElements</code> uninitialized elements after <code>toEnd</code>, <code>numElements</code> is the distance from <code>fromBegin</code> to <code>fromEnd</code>, and the input and destination arrays do not overlap. If a copy constructor or assignment operator for <code>TARGET_TYPE</code> throws an exception, then any elements created after <code>toEnd</code> are destroyed, the elements in the ranges <code>[ toBegin, toEnd)</code> and <code>[ fromBegin, *fromEndPtr )</code> will have unspecified, but valid, values, and the elements in <code>[ *fromEndPtr, fromEnd )</code> will be destroyed. </p>

</div>
</div>
<a class="anchor" id="af4417e6879cc56bcadd7a23ad15d602c"></a><!-- doxytag: member="bslalg::ArrayPrimitives::erase" ref="af4417e6879cc56bcadd7a23ad15d602c" args="(TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::erase </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the elements of the parameterized <code>TARGET_TYPE</code> in the array starting at the specified <code>first</code> address and ending immediately before the specified <code>middle</code> address, and move the elements in the array starting at <code>middle</code> and ending at the specified <code>last</code> address down to the <code>first</code> address. If an assignment throws an exception during this process, all of the elements in the range <code>[ first, last )</code> will have unspecified but valid values, and no elements are destroyed. The behavior is undefined unless <code>first &lt;= middle &lt;= last</code>. </p>

</div>
</div>
<a class="anchor" id="a8ae744e097db0b9b93b6d1b45c373f4e"></a><!-- doxytag: member="bslalg::ArrayPrimitives::rotate" ref="a8ae744e097db0b9b93b6d1b45c373f4e" args="(TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives::rotate </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the elements of the parameterized <code>TARGET_TYPE</code> in the array starting at the specified <code>first</code> address and ending immediately before the specified <code>middle</code> address to the array of the same length ending at the specified <code>last</code> address (and thus starting at the <code>last - (middle - first)</code> address), and move the elements previously in the array starting at <code>middle</code> and ending at <code>last</code> down to the <code>first</code> address. If the assignment operator throws an exception during this process, all of the elements in <code>[ first, last )</code> will have unspecified, but valid, values. The behavior is undefined unless <code>first &lt;= middle &lt;= last</code>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bslalg__arrayprimitives_8h_source.html">bslalg_arrayprimitives.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:51 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
