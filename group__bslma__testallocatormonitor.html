<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslma_testallocatormonitor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslma_testallocatormonitor<br/>
<small>
[<a class="el" href="group__bslma.html">Package bslma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mechanism to summarize <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> object use.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Statistics</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Standard Usage</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mechanism to summarize <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> object use. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a> </td><td><code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> summary mechanism  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslma__testallocator.html" title="Provide instrumented malloc/free allocator to track memory usage.">Component bslma_testallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a single mechanism class, <code><a class="el" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a></code>, which is used, in concert with <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code>, in the implementation of test drivers. The <code><a class="el" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a></code> class provides boolean accessors indicating whether associated test allocator state has changed (or not) since construction of the monitor. Using <code><a class="el" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a></code> objects often result in test cases that are more concise, easier to read, and less error prone than test cases that directly access the test allocator for state information. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="statistics"></a> <a class="anchor" id="description.statistics"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Statistics: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The test allocator statistics tracked by the test allocator monitor along with the boolean accessors used to observe a change in those statistics are shown in the table below. The change (or lack of change) reported by these accessors are relative to the value of the test allocator statistic at the construction of the monitor. Note that each of these statistics count blocks of memory (i.e., number of allocations from the allocator), and do not depend on the number of bytes in those allocated blocks. <br/>
<br/>
<div class="fragment"><pre class="fragment">  Statistic        Is-Same Method Is-Up Method Is-Down Method
  --------------   -------------- ------------ --------------
  numBlocksInUse   isInUseSame    isInUseUp    isInUseDown
  numBlocksMax     isMaxSame      isMaxUp      none
  numBlocksTotal   isTotalSame    isTotalUp    none
</pre></div><br/>
<br/>
 The <code>numBlocksMax</code> and <code>numBlocksTotal</code> statistics have values that are monotonically non-decreasing; hence, they need no "Is-Down" methods. Note that if a monitor is created for an allocator with outstanding blocks ("in
 use"), then it is possible for the allocator's count of outstanding blocks to drop below the value seen by the monitor at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Standard Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Classes taking <code>bslma::allocator</code> objects have many requirements (and thus, many testing concerns) that other classes do not. Here we illustrate how <code><a class="el" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a></code> objects (in conjunction with <code><a class="el" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a></code> objects) can be used in a test driver to succinctly address many concerns of an object's use of allocators. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, for a test subject, we introduce <code>MyClass</code>, an unconstrained attribute class having a single, null-terminated ascii string attribute, <code>description</code>. For the sake of brevity, <code>MyClass</code> defines only a default constructor, a primary manipulator (the <code>setDescription</code> method), and a basic accessor (the <code>description</code> method). These suffice for the purposes of these example. Note that a proper attribute class would also implement value and copy constructors, <code>operator==</code>, an accessor for the allocator, and other methods. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyClass {
      <span class="comment">// This unconstrained (value-semantic) attribute class has a single,</span>
      <span class="comment">// null-terminated ascii string attribute, &#39;description&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span>               d_capacity;      <span class="comment">// available memory</span>
      <span class="keywordtype">char</span>             *d_description_p; <span class="comment">// string data</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *d_allocator_p;   <span class="comment">// held, not owned</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> MyClass(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0);
          <span class="comment">// Create a &#39;MyClass&#39; object having the (default) attribute values:</span>
          <span class="comment">//..</span>
          <span class="comment">//  description() == &quot;&quot;</span>
          <span class="comment">//..</span>
          <span class="comment">// Optionally specify a &#39;basicAllocator&#39; used to supply memory.  If</span>
          <span class="comment">// &#39;basicAllocator&#39; is 0, the currently installed default allocator</span>
          <span class="comment">// is used.</span>

      ~MyClass();
          <span class="comment">// Destroy this object.</span>

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> setDescription(<span class="keyword">const</span> <span class="keywordtype">char</span> *value);
          <span class="comment">// Set the null-terminated ascii string &#39;description&#39; attribute of</span>
          <span class="comment">// this object to the specified &#39;value&#39;.  On completion, the</span>
          <span class="comment">// &#39;description&#39; method returns the address of a copy of the ascii</span>
          <span class="comment">// string at &#39;value&#39;.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *description() <span class="keyword">const</span>;
          <span class="comment">// Return the value of the null-terminated ascii string</span>
          <span class="comment">// &#39;description&#39; attribute of this object.</span>
  };

  <span class="comment">// ========================================================================</span>
  <span class="comment">//                      INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// ========================================================================</span>

                          <span class="comment">// -------------</span>
                          <span class="comment">// class MyClass</span>
                          <span class="comment">// -------------</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyClass::MyClass(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator)
  : d_capacity(0)
  , d_description_p(0)
  , d_allocator_p(bslma::Default::allocator(basicAllocator))
  {
  }

  <span class="keyword">inline</span>
  MyClass::~MyClass()
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(0 &lt;= d_capacity);

      d_allocator_p-&gt;deallocate(d_description_p);
  }

  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> MyClass::setDescription(<span class="keyword">const</span> <span class="keywordtype">char</span> *value)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(value);

      <span class="keywordtype">int</span> size = std::strlen(value) + 1;
      <span class="keywordflow">if</span> (size &gt; d_capacity) {
          <span class="keywordtype">char</span> *newMemory = (<span class="keywordtype">char</span> *) d_allocator_p-&gt;allocate(size);
          d_allocator_p-&gt;deallocate(d_description_p);
          d_description_p = newMemory;
          d_capacity      = size;

      }
      std::memcpy(d_description_p, value, size);
  }
</pre></div><br/>
<br/>
 Notice that the implementation of the manipulator allocates/deallocates memory <em>before</em> updating the object. This ordering leaves the object unchanged in case the allocator throws an exception (part of the strong exception guarantee). This is an implementation detail, not a part of the contract (in this example). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ACCESSORS</span>
  <span class="keyword">inline</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *MyClass::description()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_description_p ? d_description_p : <span class="stringliteral">&quot;&quot;</span>;
  }
</pre></div><br/>
<br/>
 Then, we design a test-driver for <code>MyClass</code>. Our allocator-related concerns for <code>MyClass</code> include: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Concerns:
 &lt;ol&gt;
 &lt;li&gt;
 Any memory allocation is from the <span class="keywordtype">object</span> allocator.
 &lt;/li&gt;
 &lt;li&gt;
 Every <span class="keywordtype">object</span> releases any allocated memory at destruction.
 &lt;/li&gt;
 &lt;li&gt;
 No accessor allocates any memory.
 &lt;/li&gt;
 &lt;li&gt;
 All memory allocation is exception neutral.
 &lt;/li&gt;
 &lt;li&gt;
 QoI: The <span class="keywordflow">default</span> constructor allocates no memory.
 &lt;/li&gt;
 &lt;li&gt;
 QoI: When possible, memory is cached <span class="keywordflow">for</span> reuse.
 &lt;/li&gt;
 &lt;/ol&gt;
</pre></div><br/>
<br/>
 Notice that some of these concerns (e.g., C-5..6) are not part of the class's documented, contractual behavior. These are classified as Quality of Implementation (QoI) concerns. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we define a test plan. For example, a plan to test these concerns is: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Plan:
 &lt;ol&gt;
 &lt;li&gt;
 Setup global and <span class="keywordflow">default</span> allocators:
 &lt;br&gt;

 &lt;ol&gt;
 &lt;li&gt;
 Create two &lt;code&gt;<a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>&lt;/code&gt; objects and, <span class="keywordflow">for each</span> of these,
  create an associated &lt;code&gt;<a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a>&lt;/code&gt; <span class="keywordtype">object</span>.
 &lt;/li&gt;
 &lt;li&gt;
 Install the two allocators as the global and <span class="keywordflow">default</span> allocators.
 &lt;/ol&gt;

 &lt;/li&gt;
 &lt;li&gt;
 Confirm that <span class="keywordflow">default</span> construction allocates no memory: (C-5)

 &lt;ol&gt;
 &lt;li&gt;
 Construct a &lt;code&gt;<a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor&lt;/code&gt;</a> <span class="keywordtype">object</span> to be used passed to
  test objects on their construction, and an associated
 &lt;/li&gt;
 &lt;li&gt;
 In an inner block, <span class="keywordflow">default</span> construct an <span class="keywordtype">object</span> of &lt;code&gt;MyClass&lt;/code&gt; <span class="keyword">using</span> the
  designated <span class="stringliteral">&quot;object&quot;</span> test allocator.
 &lt;/li&gt;
 &lt;li&gt;
 Allow the <span class="keywordtype">object</span> to go out of scope (destroyed).  Confirm that no
  memory has been allocated from any of the allocators.
 &lt;/ol&gt;

 &lt;/li&gt;
 &lt;li&gt;
 Exercise an <span class="keywordtype">object</span> of &lt;code&gt;MyClass&lt;/code&gt; such that memory should be allocated, and
  then confirm that the <span class="keywordtype">object</span> allocator (only) is used: (C-2..4,6)

 &lt;ol&gt;
 &lt;li&gt;
 In another inner block, default construct a new test <span class="keywordtype">object</span> using the
  (as yet unused) <span class="keywordtype">object</span> allocator.
 &lt;/li&gt;
 &lt;li&gt;
 Force the test <span class="keywordtype">object</span> to allocate memory by setting its &lt;code&gt;descriptor&lt;/code&gt;
  attribute to a value whose size exceeds the size of the <span class="keywordtype">object</span> itself.
  Confirm that the attribute was set and that memory was allocated.
 &lt;/li&gt;
 &lt;li&gt;
 Confirm the the primary manipulator (the &lt;code&gt;setDescription&lt;/code&gt; method) is
  exception neutral (i.e., exceptions from the allocator are propagated
  and no memory is leaked).  Use the
  &lt;code&gt;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_*&lt;/code&gt; macros to manage the test,
  and use the test allocator monitor to confirm that memory is allocated
  on the no-exception code path.  (C-4)
 &lt;/li&gt;
 &lt;li&gt;
 When the <span class="keywordtype">object</span> is holding memory, create an additional test allocator
  monitor allocator for the <span class="keywordtype">object</span> allocator.  Use the basic accessor
  (i.e., the &lt;code&gt;description&lt;/code&gt; method) to confirm that the <span class="keywordtype">object</span> has the
  expected value.  Check this test allocator monitor to confirm that
  accessor allocated no memory.  (C-3)
 &lt;/li&gt;
 &lt;li&gt;
 Change the attribute to a smaller value and confirm that the current
  memory was reused (i.e., no memory is allocated). (C-6)
 &lt;/li&gt;
 &lt;li&gt;
 Destroy the test <span class="keywordtype">object</span> by allowing it to go out of scope, and confirm
  that all allocations are returned.  (C-2)
 &lt;/ol&gt;

 &lt;/li&gt;
 &lt;li&gt;
 Confirm that at no time were the global allocator or the default
  allocator were used.  (C-1)
 &lt;/li&gt;
 &lt;/ol&gt;
</pre></div><br/>
<br/>
 The implementation of the plan is shown below: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we implement the first portion of the plan. We create the trio of test allocators, their respective test allocator monitors, and install two of the allocators as the global and default allocators: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Setup global and default allocators&quot;</span> &lt;&lt; endl;

      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>        ga(<span class="stringliteral">&quot;global&quot;</span>,  veryVeryVeryVerbose);
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>        da(<span class="stringliteral">&quot;default&quot;</span>, veryVeryVeryVerbose);
      <a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a> gam(&amp;ga);
      <a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a> dam(&amp;da);

      <a class="code" href="structbslma_1_1Default.html#a4eff7796b5cbda07b9bcb8a98691ca8b">bslma::Default::setGlobalAllocator</a>(&amp;ga);
      <a class="code" href="structbslma_1_1Default.html#add7167d78cd52cc9f99ae8d98aa4360c">bslma::Default::setDefaultAllocatorRaw</a>(&amp;da);
</pre></div><br/>
<br/>
 Then, we default construct a test object using the object allocator, and then, immediately destroy it. The object allocator monitor, <code>oam</code>, shows that the allocator was not used. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;No allocation by Default Constructor &quot;</span> &lt;&lt; endl;

  <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>        oa(<span class="stringliteral">&quot;object&quot;</span>, veryVeryVeryVerbose);
  <a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a> oam(&amp;oa);

  {
      MyClass obj(&amp;oa);
      assert(oam.isTotalSame()); <span class="comment">// object allocator unused</span>
  }
</pre></div><br/>
<br/>
 Next, we pass the (still unused) object allocator to another test object. This time, we coerce the object into allocating memory by setting an attribute. (Setting an attribute larger than the receiving object means that the object cannot store the data within its own footprint and must allocate memory.) <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Exercise object&quot;</span> &lt;&lt; endl;

  {
      MyClass obj(&amp;oa);

      <span class="keyword">const</span> <span class="keywordtype">char</span> DESCRIPTION1[]=<span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                                <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>;
      assert(<span class="keyword">sizeof</span>(obj) &lt; <span class="keyword">sizeof</span>(DESCRIPTION1));

      <span class="keywordflow">if</span> (veryVerbose) cout &lt;&lt; <span class="stringliteral">&quot;\tPrimary Manipulator Allocates&quot;</span> &lt;&lt; endl;

      <a class="code" href="group__bslma__testallocator.html#ga54aebaa251b957630708f5f491fcadd3">BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN</a>(oa) {
          <span class="keywordflow">if</span> (veryVeryVerbose) { T_ T_ Q(ExceptionTestBody) }

          obj.setDescription(DESCRIPTION1);
          assert(oam.isTotalUp());  <span class="comment">// object allocator was used</span>
          assert(oam.isInUseUp());  <span class="comment">// some outstanding allocation(s)</span>
          assert(oam.isMaxUp());    <span class="comment">// a maximum was set</span>
      } <a class="code" href="group__bslma__testallocator.html#ga59220055a07373b5ed62d98ec6206523">BSLMA_TESTALLOCATOR_EXCEPTION_TEST_END</a>
</pre></div><br/>
<br/>
 Notice, as expected, memory was allocated from object allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now that the allocator has been used, we create a second monitor to capture the that state. Confirm that the basic accessor (the <code>description</code> method) does not use the allocator. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (veryVerbose) cout &lt;&lt; <span class="stringliteral">&quot;\tBasic Accessor does not allocate&quot;</span>
                        &lt;&lt; endl;

  <a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a> oam2(&amp;oa); <span class="comment">// Captures state of &#39;oa&#39;</span>
                                        <span class="comment">// with outstanding</span>
                                        <span class="comment">// allocations.</span>

  assert(0 == strcmp(DESCRIPTION1, obj.description()));
  assert(oam2.isTotalSame());  <span class="comment">// object allocator was not used</span>
</pre></div><br/>
<br/>
 Next, confirm that when a shorter value is assigned, the existing memory is reused. <br/>
<br/>
<div class="fragment"><pre class="fragment">  obj.setDescription(<span class="stringliteral">&quot;a&quot;</span>);
  assert(0 == std::strcmp(<span class="stringliteral">&quot;a&quot;</span>, obj.description()));

  assert(oam2.isTotalSame());  <span class="comment">// no allocations</span>
</pre></div><br/>
<br/>
 Notice that there are no allocations because the object had sufficient capacity in previously allocated memory to store the short string. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, as an additional test, we make the object allocate additional memory by setting a longer attribute: one that exceeds the capacity allocated for <code>DESCRIPTION1</code>. Use the second monitor to confirm that an allocation was performed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are tests where using a test allocator monitor does not suffice. Our test object is currently holding memory, if we assign a value that exceeds its current capacity there will be two operations on the object allocator: the allocation of larger memory, and the deallocation of its current memory: in that order, as part of the strong exception guarantee. Thus, the maximum number of allocations should go up by one, and no more. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that absence of memory leaks due to exceptions (the other part of the strong exception guarantee is confirmed during the destruction of the object test allocator at the end of this test, which featured exceptions. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> maxBeforeSet   = oa.numBlocksMax();
  <span class="keyword">const</span> <span class="keywordtype">char</span>        DESCRIPTION2[] = <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                                     <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                                     <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                                     <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                                     <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>;
  assert(<span class="keyword">sizeof</span>(DESCRIPTION1) &lt; <span class="keyword">sizeof</span>(DESCRIPTION2));

  obj.setDescription(DESCRIPTION2);
  assert(0 == std::strcmp(DESCRIPTION2, obj.description()));

  assert(oam2.isTotalUp());    <span class="comment">// The object allocator used.</span>

  assert(oam2.isInUseSame());  <span class="comment">// The outstanding block (allocation)</span>
                               <span class="comment">// count unchanged (even though byte</span>
                               <span class="comment">// outstanding byte count increased).</span>

  assert(oam2.isMaxUp());      <span class="comment">// Max increased as expected, but was</span>
                               <span class="comment">// did it change only by one?  The</span>
                               <span class="comment">// monitor cannot answer that</span>
                               <span class="comment">// question.</span>

  <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> maxAfterSet = oa.numBlocksMax();

  assert(1 == maxAfterSet - maxBeforeSet);
</pre></div><br/>
<br/>
 Notice that our test allocator monitor cannot confirm that the allocator's maximum increased by exactly one. In this case, we must extract our statistics directly from the test allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that increment in "max" occurs only the first time through the the allocate/deallocate scenario in <code>setDescription</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1TestAllocatorMonitor.html">bslma::TestAllocatorMonitor</a> oam3(&amp;oa);

  <span class="keyword">const</span> <span class="keywordtype">char</span> DESCRIPTION3[] = <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                              <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                              <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                              <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                              <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                              <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                              <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                              <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>
                              <span class="stringliteral">&quot;abcdefghijklmnopqrstuvwyz&quot;</span>;
  assert(<span class="keyword">sizeof</span>(DESCRIPTION2) &lt; <span class="keyword">sizeof</span>(DESCRIPTION3));

  obj.setDescription(DESCRIPTION3);
  assert(0 == std::strcmp(DESCRIPTION3, obj.description()));

  assert(oam3.isTotalUp());    <span class="comment">// The object allocator used.</span>

  assert(oam3.isInUseSame());  <span class="comment">// The outstanding block (allocation)</span>
                               <span class="comment">// count unchanged (even though byte</span>
                               <span class="comment">// outstanding byte count increased).</span>

  assert(oam3.isMaxSame());    <span class="comment">// A repeat of the scenario for</span>
                               <span class="comment">// &#39;DESCRIPTION2&#39;, so no change in the</span>
                               <span class="comment">// allocator&#39;s maximum.</span>
</pre></div><br/>
<br/>
 Now, we close scope and check that all object memory was deallocated <br/>
<br/>
<div class="fragment"><pre class="fragment">  }

  <span class="keywordflow">if</span> (veryVerbose) cout &lt;&lt; <span class="stringliteral">&quot;\tAll memory returned object allocator&quot;</span>
                        &lt;&lt; endl;

  assert(oam.isInUseSame());
</pre></div><br/>
<br/>
 Finally, we check that none of these operations used the default or global allocators. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (verbose) cout &lt;&lt; <span class="stringliteral">&quot;Global and Default allocators never used&quot;</span>
                        &lt;&lt; endl;

      assert(gam.isTotalSame());
      assert(dam.isTotalSame());
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
