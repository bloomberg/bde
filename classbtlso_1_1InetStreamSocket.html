<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlso::InetStreamSocket</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlso.html">btlso</a>      </li>
      <li><a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket&lt; ADDRESS &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlso::InetStreamSocket&lt; ADDRESS &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlso::InetStreamSocket" --><!-- doxytag: inherits="btlso::StreamSocket" -->
<p><code>#include &lt;<a class="el" href="btlso__inetstreamsocket_8h_source.html">btlso_inetstreamsocket.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlso::InetStreamSocket&lt; ADDRESS &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlso_1_1InetStreamSocket.png" usemap="#btlso::InetStreamSocket&lt; ADDRESS &gt;_map" alt=""/>
  <map id="btlso::InetStreamSocket&lt; ADDRESS &gt;_map" name="btlso::InetStreamSocket&lt; ADDRESS &gt;_map">
<area href="classbtlso_1_1StreamSocket.html" alt="btlso::StreamSocket&lt; ADDRESS &gt;" shape="rect" coords="0,0,224,24"/>
</map>
</div>

<p><a href="classbtlso_1_1InetStreamSocket-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a92f88c7a5c0754a56e4b221fe426e9bd">InetStreamSocket</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> handle, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a28bd4733bff3511406bf56cf5cdc558b">~InetStreamSocket</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a74237c27592bc477e1735d3bff9827bc">accept</a> (<a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt; ADDRESS &gt; **socket)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#abc361bc7c4bcdd9c9cf8fe65d196b7a5">accept</a> (<a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt; ADDRESS &gt; **socket, ADDRESS *peerAddress)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a2538fc6babbea46739d32847ab40505a">bind</a> (const ADDRESS &amp;address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a31eb95b48fe6a3296a649d29d542ebe1">connect</a> (const ADDRESS &amp;address)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#adab926d2c6602a4b344d5c13b9559276">listen</a> (int backlog)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a6a477eb389379df2a5cb4620e66ef74c">read</a> (char *buffer, int length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#ab896094717ff4053def5fa38d229322a">readv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a2579bddb8bc0e31bf30076e796cb6216">write</a> (const char *buffer, int length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a5d9308dc6319898401fdf2650c5bab4c">writev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a5eefd29c3aab98b238e4fac8ccbe0025">writev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#afcc8cd80e6573427791aaf64c1633414">setBlockingMode</a> (<a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fc">btlso::Flag::BlockingMode</a> mode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#aca27775f1d7b9c93b84b0d853b2c682d">shutdown</a> (<a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2c">btlso::Flag::ShutdownType</a> streamOption)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#aff89e88e24f5699423e1deb0f3801fa8">waitForConnect</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a746678891094500a8cbd03f98bce0637">waitForAccept</a> (const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a7181910a2b326f204730d9b251be308d">waitForIO</a> (<a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603">btlso::Flag::IOWaitType</a> type, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#ab8a4ff9006089719efa4d77b2a17d801">waitForIO</a> (<a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603">btlso::Flag::IOWaitType</a> type)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a087616cbf28317e1d2a46f5efd4035e0">setLingerOption</a> (const SocketOptUtil::LingerData &amp;options)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a05d3883c28bdbeed2fffd9d91fd64c74">setOption</a> (int level, int option, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a5650ec77f080226fda5cf2936ddb936e">blockingMode</a> (<a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fc">btlso::Flag::BlockingMode</a> *result) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a201558e806377bf44ab203eaf45dd2bc">localAddress</a> (ADDRESS *result) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a89eac6c93160150711c1007544ecd893">peerAddress</a> (ADDRESS *result) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a3a4bcfce7dc655694ca357de924c3695">handle</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a034dbde89fd63538947db5b0afb879ea">connectionStatus</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#a91741f4c0d010f8a2e0de359983ed0f6">lingerOption</a> (SocketOptUtil::LingerData *result) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlso_1_1InetStreamSocket.html#ae7aea87150a434d483d47bbb2a0674d5">socketOption</a> (int *result, int level, int option) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class ADDRESS&gt;<br/>
 class btlso::InetStreamSocket&lt; ADDRESS &gt;</h3>

<p>This class implements the <code><a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt;ADDRESS&gt;</code> protocol to provide stream-based socket communications. The class is templatized to provide a family of type-safe address specializations (e.g., "IPv4", "IPv6"). Various socket-related operations, including accepting and initiating connections and blocking/non-blocking I/O operations, are provided. Vector I/O operations are also supported. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a92f88c7a5c0754a56e4b221fe426e9bd"></a><!-- doxytag: member="btlso::InetStreamSocket::InetStreamSocket" ref="a92f88c7a5c0754a56e4b221fe426e9bd" args="(SocketHandle::Handle handle, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::<a class="el" href="classbtlso_1_1InetStreamSocket.html">InetStreamSocket</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a>&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a stream socket attached to the specified socket <code>handle</code> that uses the specified <code>allocator</code> to supply memory. If <code>allocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless socket <code>handle</code> refers to a valid system socket. </p>

</div>
</div>
<a class="anchor" id="a28bd4733bff3511406bf56cf5cdc558b"></a><!-- doxytag: member="btlso::InetStreamSocket::~InetStreamSocket" ref="a28bd4733bff3511406bf56cf5cdc558b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::~<a class="el" href="classbtlso_1_1InetStreamSocket.html">InetStreamSocket</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this <code><a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a></code> object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a74237c27592bc477e1735d3bff9827bc"></a><!-- doxytag: member="btlso::InetStreamSocket::accept" ref="a74237c27592bc477e1735d3bff9827bc" args="(StreamSocket&lt; ADDRESS &gt; **socket)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt; ADDRESS &gt; **&nbsp;</td>
          <td class="paramname"> <em>socket</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept an incoming connection request and load the address of a new stream socket of type <code><a class="el" href="classbtlso_1_1InetStreamSocket.html">InetStreamSocket</a>&lt;ADDRESS&gt;</code> into the specified <code>socket</code>. Return 0 on success, and a non-zero value otherwise. If this socket is in blocking mode, this function waits until a connection request is received or an error occurs. If this socket is in non-blocking mode and there is no pending connection request, this call returns immediately with an error status of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code>. Note that this socket must be listening for connections (<code>listen</code>). </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#ab139be1cd56e921ccb5c59b89d30f324">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="classbtlso_1_1InetStreamSocketCloseGuard.html#a87e89b3ecdd167e1c4a50ac7bfeb8068">btlso::InetStreamSocketCloseGuard::release()</a>.</p>

</div>
</div>
<a class="anchor" id="abc361bc7c4bcdd9c9cf8fe65d196b7a5"></a><!-- doxytag: member="btlso::InetStreamSocket::accept" ref="abc361bc7c4bcdd9c9cf8fe65d196b7a5" args="(StreamSocket&lt; ADDRESS &gt; **socket, ADDRESS *peerAddress)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">StreamSocket</a>&lt; ADDRESS &gt; **&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>peerAddress</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept an incoming connection request, load the address of a new stream socket of type <code><a class="el" href="classbtlso_1_1InetStreamSocket.html">InetStreamSocket</a>&lt;ADDRESS&gt;</code> into the specified <code>socket</code>, and load the address of the peer into the specified <code>peerAddress</code>. Return 0 on success, and a non-zero value otherwise. If this socket is in blocking mode, this function waits until a connection request is received or an error occurs. If this socket is in non-blocking mode and there is no pending connection request, this call returns immediately with an error status of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code>. Note that this socket must be listening for connections (<code>listen</code>). </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a00310c3cd419984c2378429b7d9a48af">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2538fc6babbea46739d32847ab40505a"></a><!-- doxytag: member="btlso::InetStreamSocket::bind" ref="a2538fc6babbea46739d32847ab40505a" args="(const ADDRESS &amp;address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::bind </td>
          <td>(</td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate the specified <code>address</code> with this socket. Return 0 on success, and a non-zero value otherwise. Note that in order to receive connections on a socket, it must have an address associated with it. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a228da49e63aa2168283bbbc3ef50595b">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a31eb95b48fe6a3296a649d29d542ebe1"></a><!-- doxytag: member="btlso::InetStreamSocket::connect" ref="a31eb95b48fe6a3296a649d29d542ebe1" args="(const ADDRESS &amp;address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::connect </td>
          <td>(</td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a connection to a peer process at the specified <code>address</code>. Return 0 on success, and a non-zero value otherwise. If this socket is in blocking mode, the call waits until a connection is established or an error occurs. If this socket is in non-blocking mode and the connection cannot be established immediately <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> is returned. The <code>waitForConnect</code> method may then be used to determine when the connection request has completed. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#ab9ba5360e01c83b23deb820b22e83a80">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="adab926d2c6602a4b344d5c13b9559276"></a><!-- doxytag: member="btlso::InetStreamSocket::listen" ref="adab926d2c6602a4b344d5c13b9559276" args="(int backlog)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::listen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register this socket for accepting up to the specified <code>backlog</code> simultaneous connection requests. Return 0 on success, and a non-zero value otherwise. The behavior is undefined unless <code>0 &lt; backlog</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a1369dadeaee4f34e57fac195f04ae94f">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a6a477eb389379df2a5cb4620e66ef74c"></a><!-- doxytag: member="btlso::InetStreamSocket::read" ref="a6a477eb389379df2a5cb4620e66ef74c" args="(char *buffer, int length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::read </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read up to the specified <code>length</code> bytes from this socket into the specified <code>buffer</code>; return the non-negative number of bytes read, or a negative value on error. If this socket is in blocking mode, if there are less than <code>length</code> bytes of data available, the call waits for data to arrive. If this socket is in non-blocking mode, the function reads as many bytes as possible without blocking, and returns the number of bytes read, or <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> if zero bytes were immediately available. If the connection has been closed and there is no data available, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaba6dbf82bcd9911aa5d306af0886653b">SocketHandle::e_ERROR_EOF</a></code> is returned. If the call is interrupted before data is available, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. The behavior is undefined unless <code>0 &lt; length</code> and <code>buffer</code> refers to at least <code>length</code> writable bytes. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#aded1055cfd215bd6ae9cfd1723559a4a">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="ab896094717ff4053def5fa38d229322a"></a><!-- doxytag: member="btlso::InetStreamSocket::readv" ref="ab896094717ff4053def5fa38d229322a" args="(const btls::Iovec *buffers, int numBuffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::readv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read from this socket into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as defined by the <code>length</code> methods of each <code><a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a></code> structure. Return the non-negative total number of bytes read, or a negative value on error. If this socket is in blocking mode, if there are less than <code>length</code> bytes of data available, the call waits for data to arrive. If this socket is in non-blocking mode, the function reads as many bytes as possible without blocking, and returns the number of bytes read or <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> if zero bytes were immediately available. If the connection has been closed, and there is no data available, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaba6dbf82bcd9911aa5d306af0886653b">SocketHandle::e_ERROR_EOF</a></code> is returned. If the call is interrupted before data is available, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. The behavior is undefined unless <code>0 &lt; numBuffers</code>. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a5e77dab51358dfdb603aa7f3a58d2a8c">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a2579bddb8bc0e31bf30076e796cb6216"></a><!-- doxytag: member="btlso::InetStreamSocket::write" ref="a2579bddb8bc0e31bf30076e796cb6216" args="(const char *buffer, int length)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::write </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write up to the specified <code>length</code> bytes to this socket from the specified <code>buffer</code>; return the non-negative number of bytes written, or a negative value on error. If this socket is in blocking mode the call blocks until the data is fully written. If this socket is in non-blocking mode, the function writes as many bytes as possible without blocking, and returns the number of bytes written, or <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> if no bytes were written. If the connection has been closed, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcae59989ad2ee76ca0439e2e0ed1172481">SocketHandle::e_ERROR_CONNDEAD</a></code> is returned. If the call is interrupted before any data is written, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. The behavior is undefined unless <code>0 &lt; length</code>. Note that a successful call to this function does not guarantee that the data has been transmitted successfully, but simply that the data was written successfully to the underlying socket's transmit buffers. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#ae37bd2f372b33e69824a67cc863ac4f0">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a5d9308dc6319898401fdf2650c5bab4c"></a><!-- doxytag: member="btlso::InetStreamSocket::writev" ref="a5d9308dc6319898401fdf2650c5bab4c" args="(const btls::Iovec *buffers, int numBuffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#ae4ad0aa34f9d01d28e4a00e76db73a0c">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocket.html#a5eefd29c3aab98b238e4fac8ccbe0025">btlso::InetStreamSocket&lt; ADDRESS &gt;::writev()</a>.</p>

</div>
</div>
<a class="anchor" id="a5eefd29c3aab98b238e4fac8ccbe0025"></a><!-- doxytag: member="btlso::InetStreamSocket::writev" ref="a5eefd29c3aab98b238e4fac8ccbe0025" args="(const btls::Ovec *buffers, int numBuffers)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write to this socket from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as reported by the <code>length</code> methods of each <code><a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a></code> structure; return the non-negative total number of bytes written, or a negative value on error. If this socket is in blocking mode the call blocks until the data is fully written. If this socket is in non-blocking mode, the function writes as many bytes as possible without blocking, and returns the number of bytes written, or <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code>, if no bytes were written. If the connection has been closed, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcae59989ad2ee76ca0439e2e0ed1172481">SocketHandle::e_ERROR_CONNDEAD</a></code> is returned. If the call is interrupted before any data is written, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. The behavior is undefined unless <code>0 &lt; numBuffers</code>. Note that a successful call to this function does not guarantee that the data has been transmitted successfully, but simply that the data was successfully written to the underlying socket's transmit buffers. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#addad83353c2364adeb6608d5631b3d5f">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="classbtlso_1_1InetStreamSocket.html#a5d9308dc6319898401fdf2650c5bab4c">btlso::InetStreamSocket&lt; ADDRESS &gt;::writev()</a>.</p>

</div>
</div>
<a class="anchor" id="afcc8cd80e6573427791aaf64c1633414"></a><!-- doxytag: member="btlso::InetStreamSocket::setBlockingMode" ref="afcc8cd80e6573427791aaf64c1633414" args="(btlso::Flag::BlockingMode mode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::setBlockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fc">btlso::Flag::BlockingMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the current blocking mode of this socket to the specified <code>mode</code>. Return 0 on success, an a non-zero value otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a8f80641594fa36ea7f7809158e0d4765">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1IoUtil.html#a8bd3c039e5e8092477597f87beb923bea9940936e13beac2e46f0e37b66e71fe5">btlso::IoUtil::e_BLOCKING</a>, <a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fcabe88a3df38de6cc28f4e8e8d24edada3">btlso::Flag::e_BLOCKING_MODE</a>, and <a class="el" href="structbtlso_1_1IoUtil.html#a8bd3c039e5e8092477597f87beb923bea16f4b7a32b4b8ca003ec018fa9d0aea0">btlso::IoUtil::e_NONBLOCKING</a>.</p>

</div>
</div>
<a class="anchor" id="aca27775f1d7b9c93b84b0d853b2c682d"></a><!-- doxytag: member="btlso::InetStreamSocket::shutdown" ref="aca27775f1d7b9c93b84b0d853b2c682d" args="(btlso::Flag::ShutdownType streamOption)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::shutdown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2c">btlso::Flag::ShutdownType</a>&nbsp;</td>
          <td class="paramname"> <em>streamOption</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shut down the input and/or output stream(s) indicated by the specified <code>streamOption</code> of the full-duplexed connection associated with this socket. Return 0 on success, and a non-zero value otherwise. Specifying <code>SHUTDOWN_RECEIVE</code> or <code>SHUTDOWN_SEND</code> closes the input or output streams, respectively, leaving the other stream unaffected. Specifying <code>SHUTDOWN_BOTH</code> closes both streams. Once the input(output) stream has been closed, any attempted read(write) operations will fail. Any data received after successfully shutting down the input stream will be acknowledged but silently discarded. Note that this function is typically used to transmit an EOF indication to the peer. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#ab55c62d3593db6d976223ce9a07aa6c8">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="bdldfp__decimalplatform_8h.html#aad4341bfba32e91bc625aa81d538ec44">BSLMF_ASSERT()</a>, <a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2cae99441ff83acac352bf89870691bed6c">btlso::Flag::e_SHUTDOWN_BOTH</a>, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7ab8c652c9e5ada32da6eb143d8b389535">btlso::SocketImpUtil::e_SHUTDOWN_BOTH</a>, <a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2cabb5f96053dbbb98403d7e68695e74c67">btlso::Flag::e_SHUTDOWN_RECEIVE</a>, <a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2caa6dae76d7a9491301519fd7429312885">btlso::Flag::e_SHUTDOWN_SEND</a>, and <a class="el" href="structbtlso_1_1SocketImpUtil.html#ad0fe311b3f4f8409ace35cb491bac37a">btlso::SocketImpUtil::shutDown()</a>.</p>

</div>
</div>
<a class="anchor" id="aff89e88e24f5699423e1deb0f3801fa8"></a><!-- doxytag: member="btlso::InetStreamSocket::waitForConnect" ref="aff89e88e24f5699423e1deb0f3801fa8" args="(const bsls::TimeInterval &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::waitForConnect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait until a pending outgoing connection request completes or until the specified absolute <code>timeout</code> is reached, whichever occurs first. Return 0 if the connection request has completed, and a non-zero value otherwise. Note that the completion of a connection request does not imply that a connection has been successfully established; a call to <code>connectionStatus</code> should be made to determine if the connection request completed successfully. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a3338803effb33adf0ff7fedc7c5748de">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="classbsls_1_1TimeInterval.html#a6a37e5f3c58f4e02724d5fc6321d4d08">bsls::TimeInterval::nanoseconds()</a>, <a class="el" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now()</a>, <a class="el" href="classbsls_1_1TimeInterval.html#aff5c7e04f8c57985059393dc5e1ed638">bsls::TimeInterval::seconds()</a>, and <a class="el" href="namespacebdlat__TypeCategoryFunctions.html#a89ed08d780f2b22d61ca225f73f8dda5">bdlat_TypeCategoryFunctions::select()</a>.</p>

</div>
</div>
<a class="anchor" id="a746678891094500a8cbd03f98bce0637"></a><!-- doxytag: member="btlso::InetStreamSocket::waitForAccept" ref="a746678891094500a8cbd03f98bce0637" args="(const bsls::TimeInterval &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::waitForAccept </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for an incoming connection request on this socket or until the specified absolute <code>timeout</code> is reached, whichever occurs first. Return 0 if a connection request has been received, and a non-zero value otherwise. Note that once a connection request has been received, a call to <code>accept</code> can be made to establish the connection. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a72523ccb4195df6352c44ebcc0230632">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603a827c77ec30c7230217bd7f54ddd1f950">btlso::Flag::e_IO_READ</a>, and <a class="el" href="classbtlso_1_1InetStreamSocket.html#a7181910a2b326f204730d9b251be308d">btlso::InetStreamSocket&lt; ADDRESS &gt;::waitForIO()</a>.</p>

</div>
</div>
<a class="anchor" id="a7181910a2b326f204730d9b251be308d"></a><!-- doxytag: member="btlso::InetStreamSocket::waitForIO" ref="a7181910a2b326f204730d9b251be308d" args="(btlso::Flag::IOWaitType type, const bsls::TimeInterval &amp;timeout)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::waitForIO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603">btlso::Flag::IOWaitType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for an I/O of the specified <code>type</code> to occur or until the specified absolute <code>timeout</code> is reached, whichever occurs first. Return IO_READ, IO_WRITE or IO_RW if the corresponding event occurred, and a non-zero value otherwise. If a timeout occurred, a value of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaed8b3922b102aeab5676b53dcad04a36" title="A system call timed out.">SocketHandle::e_ERROR_TIMEDOUT</a></code> is returned. If this call is interrupted, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a31c0d188e12127ebaface69f4b8783e1">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603a827c77ec30c7230217bd7f54ddd1f950">btlso::Flag::e_IO_READ</a>, <a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603a5c1c8ea8448cdf10c3ff568d870aa862">btlso::Flag::e_IO_RW</a>, <a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603a2f390da77568c5f784f5364ce74890cd">btlso::Flag::e_IO_WRITE</a>, <a class="el" href="classbsls_1_1TimeInterval.html#a6a37e5f3c58f4e02724d5fc6321d4d08">bsls::TimeInterval::nanoseconds()</a>, <a class="el" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now()</a>, <a class="el" href="classbsls_1_1TimeInterval.html#aff5c7e04f8c57985059393dc5e1ed638">bsls::TimeInterval::seconds()</a>, and <a class="el" href="namespacebdlat__TypeCategoryFunctions.html#a89ed08d780f2b22d61ca225f73f8dda5">bdlat_TypeCategoryFunctions::select()</a>.</p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocket.html#a746678891094500a8cbd03f98bce0637">btlso::InetStreamSocket&lt; ADDRESS &gt;::waitForAccept()</a>.</p>

</div>
</div>
<a class="anchor" id="ab8a4ff9006089719efa4d77b2a17d801"></a><!-- doxytag: member="btlso::InetStreamSocket::waitForIO" ref="ab8a4ff9006089719efa4d77b2a17d801" args="(btlso::Flag::IOWaitType type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::waitForIO </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603">btlso::Flag::IOWaitType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for an I/O of the specified <code>type</code> to occur. Return <code>type</code> if the corresponding event occurred, and a negative value otherwise. If this call is interrupted, <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcaa825442e99a0335ef585c93891c9809c">SocketHandle::e_ERROR_INTERRUPTED</a></code> is returned. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a3919f6b708d8fd1688db037010ca0c99">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603a827c77ec30c7230217bd7f54ddd1f950">btlso::Flag::e_IO_READ</a>, <a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603a5c1c8ea8448cdf10c3ff568d870aa862">btlso::Flag::e_IO_RW</a>, <a class="el" href="structbtlso_1_1Flag.html#ae2b47258cd1bb9705e49f806d7997603a2f390da77568c5f784f5364ce74890cd">btlso::Flag::e_IO_WRITE</a>, and <a class="el" href="namespacebdlat__TypeCategoryFunctions.html#a89ed08d780f2b22d61ca225f73f8dda5">bdlat_TypeCategoryFunctions::select()</a>.</p>

</div>
</div>
<a class="anchor" id="a087616cbf28317e1d2a46f5efd4035e0"></a><!-- doxytag: member="btlso::InetStreamSocket::setLingerOption" ref="a087616cbf28317e1d2a46f5efd4035e0" args="(const SocketOptUtil::LingerData &amp;options)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::setLingerOption </td>
          <td>(</td>
          <td class="paramtype">const SocketOptUtil::LingerData &amp;&nbsp;</td>
          <td class="paramname"> <em>options</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the current linger options of this socket to the specified <code>options</code>. Return 0 on success, and a non-zero value otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#ae59b472fb1959cb9671246e4538866d9">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca5ca10da3e0f3ffaa2748632f0f7eed1b">btlso::SocketHandle::e_ERROR_UNCLASSIFIED</a>, <a class="el" href="classbtlso_1_1InetStreamSocket.html#a3a4bcfce7dc655694ca357de924c3695">btlso::InetStreamSocket&lt; ADDRESS &gt;::handle()</a>, <a class="el" href="structbtlso_1_1SocketOptUtil.html#a3134417992f0fab8ca89a1480b2e410da97de2ee51f5a998359a8b3f01aa43b92">btlso::SocketOptUtil::k_LINGER</a>, <a class="el" href="structbtlso_1_1SocketOptUtil.html#a4ed4579b98bf97bb0f7dcaed4dd72c28a30cdb6b13d24538f164fd37921fe733e">btlso::SocketOptUtil::k_SOCKETLEVEL</a>, and <a class="el" href="classbtlso_1_1InetStreamSocket.html#a05d3883c28bdbeed2fffd9d91fd64c74">btlso::InetStreamSocket&lt; ADDRESS &gt;::setOption()</a>.</p>

</div>
</div>
<a class="anchor" id="a05d3883c28bdbeed2fffd9d91fd64c74"></a><!-- doxytag: member="btlso::InetStreamSocket::setOption" ref="a05d3883c28bdbeed2fffd9d91fd64c74" args="(int level, int option, int value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::setOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified socket <code>option</code> (of the specified <code>level</code>) on this socket to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. See <code>btlso_socketoptutil</code> for the list of commonly supported options. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a2cd961ca861c0534a7c7f73e0744693f">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca5ca10da3e0f3ffaa2748632f0f7eed1b">btlso::SocketHandle::e_ERROR_UNCLASSIFIED</a>, and <a class="el" href="classbtlso_1_1InetStreamSocket.html#a3a4bcfce7dc655694ca357de924c3695">btlso::InetStreamSocket&lt; ADDRESS &gt;::handle()</a>.</p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocket.html#a087616cbf28317e1d2a46f5efd4035e0">btlso::InetStreamSocket&lt; ADDRESS &gt;::setLingerOption()</a>.</p>

</div>
</div>
<a class="anchor" id="a5650ec77f080226fda5cf2936ddb936e"></a><!-- doxytag: member="btlso::InetStreamSocket::blockingMode" ref="a5650ec77f080226fda5cf2936ddb936e" args="(btlso::Flag::BlockingMode *result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::blockingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fc">btlso::Flag::BlockingMode</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the current blocking mode of this socket. Return 0 on success, and a non-zero value without affecting <code>result</code> otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a99150fb3d4155be3d4b9a48aa472bb50">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1IoUtil.html#a8bd3c039e5e8092477597f87beb923bea9940936e13beac2e46f0e37b66e71fe5">btlso::IoUtil::e_BLOCKING</a>, <a class="el" href="structbtlso_1_1Flag.html#a6bb664788c2b800137e439ace24e65fcabe88a3df38de6cc28f4e8e8d24edada3">btlso::Flag::e_BLOCKING_MODE</a>, and <a class="el" href="structbtlso_1_1IoUtil.html#a9233e506eebe0a4a29d26201382bc4f5">btlso::IoUtil::getBlockingMode()</a>.</p>

</div>
</div>
<a class="anchor" id="a201558e806377bf44ab203eaf45dd2bc"></a><!-- doxytag: member="btlso::InetStreamSocket::localAddress" ref="a201558e806377bf44ab203eaf45dd2bc" args="(ADDRESS *result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::localAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the local address of this socket. Return 0 on success, and a non-zero value without affecting <code>result</code> otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#ad3df3ae4d09eff7bcce5360fc9b6ffb2">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a89eac6c93160150711c1007544ecd893"></a><!-- doxytag: member="btlso::InetStreamSocket::peerAddress" ref="a89eac6c93160150711c1007544ecd893" args="(ADDRESS *result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::peerAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the address of the peer connected to this socket. Return 0 on success, and a non-zero value without affecting <code>result</code> otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a06b531daeac4d0467f78dfdb10cb9c73">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocket.html#a034dbde89fd63538947db5b0afb879ea">btlso::InetStreamSocket&lt; ADDRESS &gt;::connectionStatus()</a>.</p>

</div>
</div>
<a class="anchor" id="a3a4bcfce7dc655694ca357de924c3695"></a><!-- doxytag: member="btlso::InetStreamSocket::handle" ref="a3a4bcfce7dc655694ca357de924c3695" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::handle </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the OS handle associated with this socket. Note that direct manipulation of the underlying stream may result in undefined behavior. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#ae81e54f647121c797201d61067c785bf">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocket.html#a91741f4c0d010f8a2e0de359983ed0f6">btlso::InetStreamSocket&lt; ADDRESS &gt;::lingerOption()</a>, <a class="el" href="classbtlso_1_1InetStreamSocket.html#a087616cbf28317e1d2a46f5efd4035e0">btlso::InetStreamSocket&lt; ADDRESS &gt;::setLingerOption()</a>, <a class="el" href="classbtlso_1_1InetStreamSocket.html#a05d3883c28bdbeed2fffd9d91fd64c74">btlso::InetStreamSocket&lt; ADDRESS &gt;::setOption()</a>, and <a class="el" href="classbtlso_1_1InetStreamSocket.html#ae7aea87150a434d483d47bbb2a0674d5">btlso::InetStreamSocket&lt; ADDRESS &gt;::socketOption()</a>.</p>

</div>
</div>
<a class="anchor" id="a034dbde89fd63538947db5b0afb879ea"></a><!-- doxytag: member="btlso::InetStreamSocket::connectionStatus" ref="a034dbde89fd63538947db5b0afb879ea" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::connectionStatus </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Test the connection status of this socket. Return 0 if this socket has an established connection, and a non-zero value otherwise. If there is no established or pending connection, a value of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcae59989ad2ee76ca0439e2e0ed1172481">SocketHandle::e_ERROR_CONNDEAD</a></code> is returned. A value of <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcae59989ad2ee76ca0439e2e0ed1172481">SocketHandle::e_ERROR_CONNDEAD</a></code> is also returned if a non-blocking connection request fails. Note that this method is typically used to determine the result of a non-blocking connection request. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a7d1d22e0609c240f1851e77b96646043">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="classbtlso_1_1InetStreamSocket.html#a89eac6c93160150711c1007544ecd893">btlso::InetStreamSocket&lt; ADDRESS &gt;::peerAddress()</a>.</p>

</div>
</div>
<a class="anchor" id="a91741f4c0d010f8a2e0de359983ed0f6"></a><!-- doxytag: member="btlso::InetStreamSocket::lingerOption" ref="a91741f4c0d010f8a2e0de359983ed0f6" args="(SocketOptUtil::LingerData *result) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::lingerOption </td>
          <td>(</td>
          <td class="paramtype">SocketOptUtil::LingerData *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the value of this socket's current linger options. The behavior is undefined if <code>result</code> is 0. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a1898c0b78ac2e2d6b86551c9e05c517f">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca5ca10da3e0f3ffaa2748632f0f7eed1b">btlso::SocketHandle::e_ERROR_UNCLASSIFIED</a>, <a class="el" href="structbtlso_1_1SocketOptUtil.html#a1749da237501cea31a8d55bd42ed6c0f">btlso::SocketOptUtil::getOption()</a>, <a class="el" href="classbtlso_1_1InetStreamSocket.html#a3a4bcfce7dc655694ca357de924c3695">btlso::InetStreamSocket&lt; ADDRESS &gt;::handle()</a>, <a class="el" href="structbtlso_1_1SocketOptUtil.html#a3134417992f0fab8ca89a1480b2e410da97de2ee51f5a998359a8b3f01aa43b92">btlso::SocketOptUtil::k_LINGER</a>, and <a class="el" href="structbtlso_1_1SocketOptUtil.html#a4ed4579b98bf97bb0f7dcaed4dd72c28a30cdb6b13d24538f164fd37921fe733e">btlso::SocketOptUtil::k_SOCKETLEVEL</a>.</p>

</div>
</div>
<a class="anchor" id="ae7aea87150a434d483d47bbb2a0674d5"></a><!-- doxytag: member="btlso::InetStreamSocket::socketOption" ref="ae7aea87150a434d483d47bbb2a0674d5" args="(int *result, int level, int option) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classbtlso_1_1InetStreamSocket.html">btlso::InetStreamSocket</a>&lt; ADDRESS &gt;::socketOption </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load int the specified <code>result</code> the value of the specified socket <code>option</code> of the specified <code>level</code> socket option on this socket. Return 0 on success and a non-zero value otherwise. </p>

<p>Implements <a class="el" href="classbtlso_1_1StreamSocket.html#a30213f8b75c868edff6f4dda65f03991">btlso::StreamSocket&lt; ADDRESS &gt;</a>.</p>

<p>References <a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca5ca10da3e0f3ffaa2748632f0f7eed1b">btlso::SocketHandle::e_ERROR_UNCLASSIFIED</a>, <a class="el" href="structbtlso_1_1SocketOptUtil.html#a1749da237501cea31a8d55bd42ed6c0f">btlso::SocketOptUtil::getOption()</a>, and <a class="el" href="classbtlso_1_1InetStreamSocket.html#a3a4bcfce7dc655694ca357de924c3695">btlso::InetStreamSocket&lt; ADDRESS &gt;::handle()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlso__inetstreamsocket_8h_source.html">btlso_inetstreamsocket.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:15 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
