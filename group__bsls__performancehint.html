<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bsls_performancehint Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Component bsls_performancehint<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide performance hints for code optimization.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
</table>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Branch Prediction</a> <ul>
<li>
<a href="#4.1.1">Warning</a> </li>
<li>
<a href="#4.1.2">Limitations</a> </li>
</ul>
</li>
<li>
<a href="#4.2">Data Cache Prefetching</a> <ul>
<li>
<a href="#4.2.1">Warning</a> </li>
</ul>
</li>
<li>
<a href="#4.3">Optimization Fence</a> <ul>
<li>
<a href="#4.3.1">Warning</a> </li>
</ul>
</li>
<li>
<a href="#4.4">Usage</a> <ul>
<li>
<a href="#4.4.1">Example 1: Using the Branch Prediction Macros</a> </li>
<li>
<a href="#4.4.2">Example 2: Using <code>BSLS_PERFORMANCEHINT_PREDICT_EXPECT</code></a> </li>
<li>
<a href="#4.4.3">Example 3: Cache Line Prefetching</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide performance hints for code optimization. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bsls::PerformanceHint </td><td>namespace for performance optimization hints  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BSLS_PERFORMANCEHINT_PREDICT_LIKELY(X) </td><td><code>X</code> probably evaluates to non-zero  </td></tr>
<tr>
<td>BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(X) </td><td><code>X</code> probably evaluates to zero  </td></tr>
<tr>
<td>BSLS_PERFORMANCEHINT_PREDICT_EXPECT(X, Y) </td><td><code>X</code> probably evaluates to <code>Y</code>  </td></tr>
<tr>
<td>BSLS_PERFORMANCEHINT_UNLIKELY_HINT </td><td>annotate block unlikely to be taken  </td></tr>
<tr>
<td>BSLS_PERFORMANCEHINT_OPTIMIZATION_FENCE </td><td>prevent compiler optimizations  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides performance hints for the compiler or hardware. There are currently two types of hints that are supported: <ul>
<li>
branch prediction  </li>
<li>
data cache prefetching  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="branch_prediction"></a> <a class="anchor" id="description.branch_prediction"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Branch Prediction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The three macros provided, <code>BSLS_PERFORMANCEHINT_PREDICT_LIKELY</code>, <code>BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</code>, and <code>BSLS_PERFORMANCEHINT_PREDICT_EXPECT</code>, can be used to optimize compiler generated code for branch prediction. The compiler, when given the hint under <em>optimized</em> mode (i.e., with <code>BDE_BUILD_TARGET_OPT</code> defined) will rearrange the assembly instructions it generates to minimize the number of jumps needed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following describes the macros provided by this component: <br/>
<br/>
<div class="fragment"><pre class="fragment">                Macro Name                          Description of Macro
 ----------------------------------------       -----------------------------
 BSLS_PERFORMANCEHINT_PREDICT_LIKELY(expr)      Hint to the compiler that the
                                                specified *integral* &#39;expr&#39;
                                                expression is likely to
                                                evaluate to non-zero.
                                                Returns &#39;true&#39; or &#39;false&#39;
                                                depending on the result of
                                                the expression.

 BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY(expr)    Hint to the compiler that the
                                                specified *integral* &#39;expr&#39;
                                                expression is likely to
                                                evaluate to zero.  Returns
                                                &#39;true&#39; or &#39;false&#39; depending
                                                on the result of the
                                                expression.

 BSLS_PERFORMANCEHINT_PREDICT_EXPECT(expr, value)
                                                Hint to the compiler that the
                                                specified *integral* &#39;expr&#39;
                                                expression is likely to
                                                evaluate to the specified
                                                &#39;value&#39;.  Returns the result
                                                of the expression.

 BSLS_PERFORMANCEHINT_UNLIKELY_HINT             Hint to the compiler that the
                                                block which contains the hint
                                                is unlikely chosen.  Use this
                                                in conjunction with the
                                                &#39;PREDICT_UNLIKELY&#39; clause for
                                                maximum portability.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="warning"></a> <a class="anchor" id="branch_prediction.warning"></a> <a class="anchor" id="description.branch_prediction.warning"></a> <a class="anchor" id="4.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Warning: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Please use the macros provided in this component <em>with</em> <em>caution</em>. Always profile your code to get an idea of actual usage before attempting to optimize with these macros. Furthermore, these macros are merely <em>hints</em> to the compiler. Whether or not they will have visible effect on performance is not guaranteed. Note that one can perform similar optimization with a profile-based compilation. When compiled with the proper options, the compiler can collect usage information of the code, and such information can then be passed back to recompile the code in a more optimized form. Please refer to the compiler manual for more information. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="limitations"></a> <a class="anchor" id="branch_prediction.limitations"></a> <a class="anchor" id="description.branch_prediction.limitations"></a> <a class="anchor" id="4.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Limitations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There is a bug in gcc 4.2, 4.3, and 4.4 such that when using the branch prediction macros with multiple conditions, the generated code might not be properly optimized. For example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(a &amp;&amp; b)) {
      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 The work-around is simply to split the conditions: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">if</span> (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(a)
   &amp;&amp; BSLS_PERFORMANCEHINT_PREDICT_LIKELY(b)) {
      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 This applies to all of the "likely", "unlikely", and "expect" macros defined in this component. Note that a bug report has been filed: <br/>
<br/>
<div class="fragment"><pre class="fragment">  http:<span class="comment">//gcc.gnu.org/bugzilla/show_bug.cgi?id=42233</span>
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="data_cache_prefetching"></a> <a class="anchor" id="description.data_cache_prefetching"></a> <a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>Data Cache Prefetching: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The two functions provided in the <code>bsls::PerformanceHint</code> <code>struct</code> are <code>prefetchForReading</code> and <code>prefetchForWriting</code>. Use of these functions will cause the compiler to generate prefetch instructions to prefetch one cache line worth of data at the specified address into the cache line to minimize processor stalls. <br/>
<br/>
<div class="fragment"><pre class="fragment">       Function Name                       Description of Function
  ------------------------         ------------------------------------------
  prefetchForReading(address)      Prefetches one cache line worth of data at
                                   the specified &#39;address&#39; for reading.

  prefetchForWriting(address)      Prefetches one cache line worth of data at
                                   the specified &#39;address&#39; for writing.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="data_cache_prefetching.warning"></a> <a class="anchor" id="description.data_cache_prefetching.warning"></a> <a class="anchor" id="4.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Warning: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>These functions must be used <em>with</em> <em>caution</em>. Inappropriate use of these functions degrades performance. Note that there should be sufficient time for the prefetch instruction to finish before the specified address is accessed, otherwise prefetching will be pointless. A profiler should be used to understand the program's behavior before attempting to optimize with these functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="optimization_fence"></a> <a class="anchor" id="description.optimization_fence"></a> <a class="anchor" id="4.3"></a> </dd></dl>
<dl class="user"><dt><b>Optimization Fence: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The macro <code>BSLS_PERFORMANCEHINT_OPTIMIZATION_FENCE</code> prevents some compiler optimizations, particularly compiler instruction reordering. This fence does <em>not</em> map to a CPU instruction and has no impact on processor instruction re-ordering, and therefore should not be used to synchronize memory between threads. The fence may be useful in unusual contexts, like performing benchmarks, or working around bugs identified in the compiler's optimizer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="optimization_fence.warning"></a> <a class="anchor" id="description.optimization_fence.warning"></a> <a class="anchor" id="4.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Warning: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This macro should be used <em>with</em> <em>caution</em>. The macro will generally decrease the performance of code on which it is applied, and is not implemented on all platforms. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="4.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following series of examples illustrates use of the macros and functions provided by this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_the_branch_prediction_macros"></a> <a class="anchor" id="usage.example_1~3A_using_the_branch_prediction_macros"></a> <a class="anchor" id="description.usage.example_1~3A_using_the_branch_prediction_macros"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="4.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using the Branch Prediction Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following demonstrates the use of <code>BSLS_PERFORMANCEHINT_PREDICT_LIKELY</code> and <code>BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</code> to generate more efficient assembly instructions. Note the use of <code>BSLS_PERFORMANCEHINT_UNLIKELY_HINT</code> inside the <code>if</code> branch for maximum portability. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> global;

  <span class="keywordtype">void</span> foo()
  {
      global = 1;
  }

  <span class="keywordtype">void</span> bar()
  {
      global = 2;
  }

  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv)
  {
      argc = std::atoi(argv[1]);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> x = 0; x &lt; argc; ++x) {
          <span class="keywordtype">int</span> y = std::rand() % 10;

          <span class="comment">// Correct usage of &#39;BSLS_PERFORMANCEHINT_PREDICT_LIKELY&#39; since</span>
          <span class="comment">// there are nine of ten chance that this branch is taken.</span>

          <span class="keywordflow">if</span> (BSLS_PERFORMANCEHINT_PREDICT_LIKELY(8 != y)) {
              foo();
          }
          <span class="keywordflow">else</span> {
              BSLS_PERFORMANCEHINT_UNLIKELY_HINT;
              bar();
          }
      }
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 An excerpt of the assembly code generated using <code>xlC</code> Version 10 on AIX from this small program is: <br/>
<br/>
<div class="fragment"><pre class="fragment">  b8:   2c 00 00 08     cmpwi   r0,8
  bc:   41 82 00 38     beq-    f4 &lt;.main+0xb4&gt;
                         ^
                         Note that <span class="keywordflow">if</span> <span class="keyword">register</span> r0 (y) equals 8, branch to
                         instruction f4 (a jump).  The &#39;-&#39; after &#39;beq&#39;
                         indicates that the branch is unlikely to be taken.
                         The predicted code path continues the &#39;if&#39;
                         statement, which calls &#39;foo&#39; below.

  c0:   4b ff ff 41     bl      0 &lt;.foo__Fv&gt;
  ...
  f4:   4b ff ff 2d     bl      20 &lt;.bar__Fv&gt;
</pre></div><br/>
<br/>
 Now, if <code>BSLS_PERFORMANCEHINT_PREDICT_LIKELY</code> is changed to <code>BSLS_PERFORMANCEHINT_PREDICT_UNLIKELY</code>, and the <code>BSLS_PERFORMANCEHINT_UNLIKELY_HINT</code> is moved to the first branch, the following assembly code will be generated: <br/>
<br/>
<div class="fragment"><pre class="fragment">  b8:   2c 00 00 08     cmpwi   r0,8
  bc:   40 c2 00 38     bne-    f4 &lt;.main+0xb4&gt;
                         ^
                         Note that the test became a <span class="stringliteral">&quot;branch not equal&quot;</span>
                         test.  The predicted code path now continues to the
                         <span class="stringliteral">&#39;else&#39;</span> statement, which calls <span class="stringliteral">&#39;bar&#39;</span> below.

  c0:   4b ff ff 61     bl      20 &lt;.bar__Fv&gt;
  ...
  f4:   4b ff ff 0d     bl      0 &lt;.foo__Fv&gt;
</pre></div><br/>
<br/>
 A timing analysis shows that effective use of branch prediction can have a material effect on code efficiency: <br/>
<br/>
<div class="fragment"><pre class="fragment">  $time ./unlikely.out 100000000

  real    0m2.022s
  user    0m2.010s
  sys     0m0.013s

  $time ./likely.out 100000000

  real    0m2.159s
  user    0m2.149s
  sys     0m0.005s
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_bsls_performancehint_predict_expect"></a> <a class="anchor" id="usage.example_2~3A_using_bsls_performancehint_predict_expect"></a> <a class="anchor" id="description.usage.example_2~3A_using_bsls_performancehint_predict_expect"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="4.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using BSLS_PERFORMANCEHINT_PREDICT_EXPECT: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This macro is essentially the same as the <code>__builtin_expect(expr, value)</code> macro that is provided by some compilers. This macro allows the user to define more complex hints to the compiler, such as the optimization of <code>switch</code> statements. For example, given: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> x = std::rand() % 4;
</pre></div><br/>
<br/>
 the following is incorrect usage of <code>BSLS_PERFORMANCEHINT_PREDICT_EXPECT</code>, since the probability of getting a 3 is equivalent to the other possibilities ( 0, 1, 2 ): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">switch</span> (BSLS_PERFORMANCEHINT_PREDICT_EXPECT(x, 3)) {
    <span class="keywordflow">case</span> 1: <span class="comment">//..</span>
            <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 2: <span class="comment">//..</span>
            <span class="keywordflow">break</span>;
    <span class="keywordflow">case</span> 3: <span class="comment">//..</span>
            <span class="keywordflow">break</span>;
    <span class="keywordflow">default</span>: <span class="keywordflow">break</span>;
  }
</pre></div><br/>
<br/>
 However, this is sufficient to illustrate the intent of this macro. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_cache_line_prefetching"></a> <a class="anchor" id="usage.example_3~3A_cache_line_prefetching"></a> <a class="anchor" id="description.usage.example_3~3A_cache_line_prefetching"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="4.4.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Cache Line Prefetching: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following demonstrates use of <code>prefetchForReading</code> and <code>prefetchForWriting</code> to prefetch data cache lines: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">int</span> SIZE = 10 * 1024 * 1024;

  <span class="keywordtype">void</span> add(<span class="keywordtype">int</span> *arrayA, <span class="keywordtype">int</span> *arrayB)
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; SIZE / 8; ++i){
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);

          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
      }
  }

  <span class="keywordtype">int</span> array1[SIZE];
  <span class="keywordtype">int</span> array2[SIZE];

  <span class="keywordtype">int</span> main()
  {
      BloombergLP::bsls::Stopwatch timer;
      timer.start();
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; ++i) {
          add(array1, array2);
      }
      std::printf(<span class="stringliteral">&quot;time: %f\n&quot;</span>, timer.elapsedTime());
      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 The above code simply adds two arrays together multiple times. Using <code><a class="el" href="classbsls_1_1Stopwatch.html">bsls::Stopwatch</a></code>, we recorded the running time and printed it to <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  $./prefetch.sundev1.tsk
  time: 8.446806
</pre></div><br/>
<br/>
 Now, we can observe that in the <code>add</code> function, <code>arrayA</code> and <code>arrayB</code> are accessed sequentially for the majority of the program. <code>arrayA</code> is used for writing and <code>arrayB</code> is used for reading. Making use of prefetch, we add calls to <code>prefetchForReading</code> and <code>prefetchForWriting</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> add(<span class="keywordtype">int</span> *arrayA, <span class="keywordtype">int</span> *arrayB)
  {
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; SIZE / 8; ++i){
          bsls::PerformanceHint::prefetchForWriting((<span class="keywordtype">int</span> *) arrayA + 16);
          bsls::PerformanceHint::prefetchForReading((<span class="keywordtype">int</span> *) arrayB + 16);

          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);

          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
          *(arrayA++) = *arrayA + *(arrayB++);
      }
  }
</pre></div><br/>
<br/>
 Adding the prefetch improves the program's efficiency: <br/>
<br/>
<div class="fragment"><pre class="fragment">  $./prefetch.sundev1.tsk
  time: 6.442100
</pre></div><br/>
<br/>
 Note that we prefetch the address <code>16 * sizeof(int)</code> bytes away from <code>arrayA</code>. This is such that the prefetch instruction has sufficient time to finish before the data is actually accessed. To see the difference, if we changed <code>+ 16</code> to <code>+ 4</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  $./prefetch.sundev1.tsk
  time: 6.835928
</pre></div><br/>
<br/>
 And we get less of an improvement in speed. Similarly, if we prefetch too far away from the data use, the data might be removed from the cache before it is looked at and the prefetch is wasted. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:54 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
