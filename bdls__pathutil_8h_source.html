<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdls_pathutil.h                                                    -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLS_PATHUTIL
#define INCLUDED_BDLS_PATHUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide portable file path manipulation.
//
//@CLASSES:
//  bdls::PathUtil: Portable utility methods for manipulating paths
//
//@SEE_ALSO: bdls_filesystemutil
//
//@DESCRIPTION: This component provides utility methods for manipulating
// strings that represent paths in the filesystem.  Class methods of
// &#39;bdls::PathUtil&#39; include platform-independent operations to add or remove
// filenames or relative paths at the end of a path string (by &quot;filenames&quot; we
// are referring to the names of any filesystem item, including regular files
// and directories).  There are also methods to parse the path to delimit the
// &quot;root&quot; as defined for the current platform; see &quot;Parsing and Performance&quot;
// below.
//
// Paths that have a root are called *absolute* paths, whereas paths that do
// not have a root are *relative* paths.
//
// Note that this component does not perform filesystem operations.  In
// particular, no effort is made to verify the existence or accessibility of
// any segment of any path.
//
///Parsing and Performance
///-----------------------
// Most methods of this component will perform basic parsing of the beginning
// part of the path to determine what part of it is the &quot;root&quot; as defined for
// the current platform.  This parsing is trivial on Unix platforms but is
// slightly more involved for the Windows operating system.  To accommodate
// client code which is willing to store parsing results in order to maximize
// performance, all methods which parse the &quot;root&quot; of the path accept an
// optional argument delimiting the &quot;root&quot;; if this argument is specified,
// parsing is skipped.
//
///Usage
///-----
// We start with strings representing an absolute native path and a relative
// native path, respectively:
//..
//  #ifdef BSLS_PLATFORM_OS_WINDOWS
//      bsl::string tempPath  = &quot;c:\\windows\\temp&quot;;
//      bsl::string otherPath = &quot;22jan08\\log.txt&quot;;
//  #else
//      bsl::string tempPath  = &quot;/var/tmp&quot;;
//      bsl::string otherPath = &quot;22jan08/log.txt&quot;;
//  #endif
//..
// &#39;tempPath&#39; is an absolute path, since it has a root.  It also has a leaf
// element (&quot;temp&quot;):
//..
//  assert(false == bdls::PathUtil::isRelative(tempPath));
//  assert(true  == bdls::PathUtil::isAbsolute(tempPath));
//  assert(true  == bdls::PathUtil::hasLeaf(tempPath));
//..
// We can add filenames to the path one at a time, or we can add another path
// if is relative.  We can also remove filenames from the end of the path one
// at a time:
//..
//  bdls::PathUtil::appendRaw(&amp;tempPath, &quot;myApp&quot;);
//  bdls::PathUtil::appendRaw(&amp;tempPath, &quot;logs&quot;);
//  assert(true == bdls::PathUtil::isRelative(otherPath));
//  assert(0 == bdls::PathUtil::appendIfValid(&amp;tempPath, otherPath));
//  assert(true == bdls::PathUtil::hasLeaf(tempPath));
//  bdls::PathUtil::popLeaf(tempPath);
//  bdls::PathUtil::appendRaw(&amp;tempPath, &quot;log2.txt&quot;);
//
//  #ifdef BSLS_PLATFORM_OS_WINDOWS
//      assert(&quot;c:\\windows\\temp\\myApp\\logs\\22jan08\\log2.txt&quot; ==
//                                                                   tempPath);
//  #else
//      assert(&quot;/var/tmp/myApp/logs/22jan08/log2.txt&quot; == tempPath);
//  #endif
//..
// A relative path may be appended to any other path, even itself.  An absolute
// path may not be appended to any path, or undefined behavior will result:
//..
//   assert(0 == bdls::PathUtil::appendIfValid(&amp;otherPath, otherPath));  // OK
//   /* bdls::PathUtil::append(&amp;otherPath, tempPath); */ // UNDEFINED BEHAVIOR!
//..
// Note that there is no attempt to distinguish filenames that are regular
// files from filenames that are directories, or to verify the existence of
// paths in the filesystem.  On POSIX:
//..
//   assert(&quot;22jan08/log.txt/22jan08/log.txt&quot; == otherPath);
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_STRING
#include &lt;bsl_string.h&gt;
#endif

namespace BloombergLP {

namespace bdls {
                              // ===============
                              // struct PathUtil
                              // ===============

struct PathUtil {
    // This struct contains utility methods for platform-independent
    // manipulation of filesystem paths.  No method of this struct provides
    // any filesystem operations.

    // CLASS METHODS
    static int appendIfValid(bsl::string              *path,
                             const bslstl::StringRef&amp;  filename);
        // Append the specified &#39;filename&#39; to the end of the specified &#39;path&#39;
        // if &#39;filename&#39; represents a relative path.  Return 0 on success, and
        // a non-zero value otherwise.  Note that any filesystem separator
        // characters at the end of &#39;filename&#39; or &#39;path&#39; will be discarded.

    static void appendRaw(bsl::string *path,
                          const char  *filename,
                          int          length = -1,
                          int          rootEnd = -1);
        // Append the specified &#39;filename&#39; up to the optionally specified
        // &#39;length&#39; to the end of the specified &#39;path&#39;.  If &#39;length&#39; is
        // negative, append the entire string.  If the optionally specified
        // &#39;rootEnd&#39; offset is non-negative, it is taken as the position in
        // &#39;path&#39; of the character following the root.  The behavior is
        // undefined if &#39;filename&#39; represents an absolute path or if either
        // &#39;filename&#39; or &#39;path&#39; ends with the filesystem separator character.
        // The behavior is also undefined if &#39;filename&#39; points to any part of
        // &#39;path&#39; (i.e., &#39;filename&#39; may not be an alias for &#39;path&#39;).

    static int popLeaf(bsl::string *path, int rootEnd = -1);
        // Remove from the specified &#39;path&#39; the rightmost filename following
        // the root; that is, remove the leaf element.  If the optionally
        // specified &#39;rootEnd&#39; offset is non-negative, it is taken as the
        // position in &#39;path&#39; of the character following the root.  Return 0 on
        // success, and a nonzero value otherwise; in particular, return a
        // nonzero value if &#39;path&#39; does not have a leaf.

    static int getBasename(bsl::string              *leaf,
                           const bslstl::StringRef&amp;  path,
                           int                       rootEnd = -1);
        // Load into the specified &#39;leaf&#39; the value of the rightmost filename
        // in the specified &#39;path&#39; that follows the root; that is, the leaf
        // element.  If the optionally specified &#39;rootEnd&#39; offset is
        // non-negative, it is taken as the position in &#39;path&#39; of the character
        // following the root.  Return 0 on success, and a non-zero value
        // otherwise; in particular, return nonzero if &#39;path&#39; does not have a
        // leaf.  Note that &#39;getBasename&#39; is a synonym for &#39;getLeaf&#39;.

    static int getDirname(bsl::string              *dirname,
                          const bslstl::StringRef&amp;  path,
                          int                       rootEnd = -1);
        // Load into the specified &#39;dirname&#39; the value of the directory part
        // of the specified &#39;path&#39;, that is, the root if it exists and all the
        // filenames except the last one (the leaf).  If the optionally
        // specified &#39;rootEnd&#39; offset is non-negative, it is taken as the
        // position in &#39;path&#39; of the character following the root.  Return 0 on
        // success, and a non-zero value otherwise; in particular, return a
        // nonzero value if &#39;path&#39; does not have a leaf.  Note that in the
        // case of a relative path with a single filename, the function will
        // succeed and &#39;dirname&#39; will be the empty string.

    static int getLeaf(bsl::string              *leaf,
                       const bslstl::StringRef&amp;  path,
                       int                       rootEnd = -1);
        // Load into the specified &#39;leaf&#39; the value of the rightmost filename
        // in the specified &#39;path&#39; that follows the root; that is, the leaf
        // element.  If the optionally specified &#39;rootEnd&#39; offset is
        // non-negative, it is taken as the position in &#39;path&#39; of the character
        // following the root.  Return 0 on success, and a non-zero value
        // otherwise; in particular, return nonzero if &#39;path&#39; does not have a
        // leaf.  Note that &#39;getBasename&#39; is a synonym for &#39;getLeaf&#39;.

    static int getRoot(bsl::string              *root,
                       const bslstl::StringRef&amp;  path,
                       int                       rootEnd = -1);
        // Load into the specified &#39;root&#39; the value of the root part of the
        // specified &#39;path&#39;.  If the optionally specified &#39;rootEnd&#39; offset is
        // non-negative, it is taken as the position in &#39;path&#39; of the character
        // following the root.  Return 0 on success, and a non-zero value
        // otherwise; in particular, return a nonzero value if &#39;path&#39; is
        // relative.  Note that the meaning of the root part is
        // platform-dependent.

    static bool isAbsolute(const bslstl::StringRef&amp; path, int rootEnd = -1);
        // Return &#39;true&#39; if the specified &#39;path&#39; is absolute (has a root), and
        // &#39;false&#39; otherwise.  If the optionally specified &#39;rootEnd&#39; offset is
        // non-negative, it is taken as the position in &#39;path&#39; of the character
        // following the root.

    static bool isRelative(const bslstl::StringRef&amp; path, int rootEnd = -1);
        // Return &#39;true&#39; if the specified &#39;path&#39; is relative (lacks a root),
        // and &#39;false&#39; otherwise.  If the optionally specified &#39;rootEnd&#39; offset
        // is non-negative, it is taken as the position in &#39;path&#39; of the
        // character following the root.

    static bool hasLeaf(const bslstl::StringRef&amp; path, int rootEnd = -1);
        // Return &#39;true&#39; if the specified &#39;path&#39; has a filename following the
        // root, and &#39;false&#39; otherwise.  If the optionally specified &#39;rootEnd&#39;
        // offset is non-negative, it is taken as the position in &#39;path&#39; of
        // the character following the root.

    static int getRootEnd(const bslstl::StringRef&amp; path);
        // Return the 0-based position in the specified &#39;path&#39; of the character
        // following the root.  Note that a return value of 0 indicates a
        // relative path.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                               // --------------
                               // class PathUtil
                               // --------------

// CLASS METHODS
inline
int PathUtil::getBasename(bsl::string                    *leaf,
                                const bslstl::StringRef&amp;  path,
                                int                       rootEnd)
{
    BSLS_ASSERT_SAFE(leaf);

    return getLeaf(leaf, path, rootEnd);
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
