<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslalg_hashtableanchor.h                                           -*-C++-*-
#ifndef INCLUDED_BSLALG_HASHTABLEANCHOR
#define INCLUDED_BSLALG_HASHTABLEANCHOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a type holding the constituent parts of a hash table.
//
//@CLASSES:
// bslalg::HashTableAnchor: (in-core) bucket-array and node list
//
//@SEE_ALSO: bslstl_hashtable, bslalg_hashtableimputil
//
//@DESCRIPTION: This component provides a single, complex-constrained
// *in*-*core* (value-semantic) attribute class, &#39;bslalg::HashTableAnchor&#39;,
// that is used to hold (not own) the array of buckets and the list of nodes
// that form the key data elements of a hash-table.  This class is typically
// used with the utilities provided in &#39;bslstl_hashtableimputil&#39;.  Note that
// the decision to store nodes in a linked list (i.e., resolving collisions
// through chaining) is intended to facilitate a hash-table implementation
// meeting the requirements of a C++11 standard unordered container.
//
///Attributes
///----------
//..
//  Name                Type                  Simple Constraints
//  ------------------  -------------------   ------------------
//  bucketArrayAddress  HashTableBucket *     none
//
//  bucketArraySize     size_t                none
//
//  listRootAddress     BidirectionalLink *   none
//
//
//  Complex Constraint
//  -------------------------------------------------------------------------
//  &#39;bucketArrayAddress&#39; must refer to a contiguous sequence of valid
//  &#39;bslalg::HashTableBucket&#39; objects of at least the specified
//  &#39;bucketArraySize&#39; or both &#39;bucketArrayAddress&#39; and &#39;bucketArraySize&#39; must
//  be 0.
//..
//
//: o &#39;listRootAddress&#39;: address of the head of the linked list of nodes
//:   holding the elements contained in a hash table
//:
//: o &#39;bucketArrayAddress&#39;: address of the first element of the sequence of
//:   &#39;HashTableBucket&#39; objects, each of which refers to the first and last
//:   node (from &#39;listRootAddress&#39;) in that bucket
//:
//: o &#39;bucketArraySize&#39;: the number of (contiguous) buckets in the array of
//:   buckets at &#39;bucketArrayAddress&#39;
//
///Usage
///-----
// This section illustrates intended use of this component.
//
// Suppose we want to create a hash table that keeps track of pointers.
// Pointers can be added (&#39;insert&#39;ed) or removed (&#39;erase&#39;d) from the table, and
// the table will keep track, at any time, of whether a pointer is currently
// stored in the table using the &#39;count&#39; method.  It will also be table to
// return the total number of objects stored in the table (the &#39;size&#39; method).
// Redundant &#39;insert&#39;s have no effect -- a given pointer may only be stored in
// the table once.
//
// First, we create our class:
//..
//  class PtrHashSet : public bslalg::HashTableAnchor {
//      // PRIVATE TYPES
//      typedef bsls::Types::UintPtr              UintPtr;
//      typedef bslalg::BidirectionalNode&lt;void *&gt; Node;
//      typedef bslalg::HashTableBucket           Bucket;
//      typedef bslalg::BidirectionalLinkListUtil Util;
//
//      // DATA
//      double            d_maxLoadFactor;
//      unsigned          d_numNodes;
//      bslma::Allocator *d_allocator_p;
//
//      // PRIVATE MANIPULATORS
//      void grow();
//          // Roughly double the number of buckets, such that the number of
//          // buckets shall always be &#39;2^N - 1&#39;.
//
//      // PRIVATE ACCESSORS
//      bool checkInvariants() const;
//          // Perform sanity checks on this table, returning &#39;true&#39; if all the
//          // tests pass and &#39;false&#39; otherwise.  Note that many of the checks
//          // are done with the &#39;ASSERTV&#39; macro and will cause messages to be
//          // written to the console.
//
//      bool find(Node **node, Bucket **bucket, const void *ptr) const;
//          // If the specified value &#39;ptr&#39; is stored in this table, return
//          // pointers to its node and bucket in the specified &#39;node&#39; and
//          // &#39;bucket&#39;.  If it is not in this table, return the bucket it
//          // should be in, and a pointer to the first node, if any, in that
//          // bucket.  If the bucket is empty, return with
//          // &#39;*node == listRootAddress()&#39;.  Return &#39;true&#39; if &#39;ptr&#39; was found
//          // in the table and &#39;false&#39; otherwise.  Note that it is permissible
//          // to pass 0 to &#39;node&#39; and / or &#39;bucket&#39;, in which case these
//          // arguments are ignored.
//
//    private:
//      // NOT IMPLEMENTED
//      PtrHashSet(const PtrHashSet&amp;, bslma::Allocator *);
//      PtrHashSet&amp; operator=(const PtrHashSet&amp;);
//
//    public:
//      // CREATORS
//      explicit
//      PtrHashSet(bslma::Allocator *allocator = 0);
//          // Create a &#39;PtrHashSet&#39;, using the specified &#39;allocator&#39;.  If no
//          // allocator is specified, use the default allocator.
//
//      ~PtrHashSet();
//          // Destroy this &#39;PtrHashSet&#39;, freeing all its memory.
//
//      // MANIPULATORS
//      bool insert(void *ptr);
//          // If the specfied &#39;ptr&#39; is not in this hash table, add it,
//          // returning &#39;true&#39;.  If it is already in the table, return &#39;false&#39;
//          // with no action taken.
//
//      bool erase(void *ptr);
//          // If the specfied &#39;ptr&#39; is in this hash table, remove it,
//          // returning &#39;true&#39;.  If it is not found in the table, return
//          // &#39;false&#39; with no action taken.
//
//      // ACCESSORS
//      native_std::size_t count(void *ptr) const;
//          // Return 1 if the specified value &#39;ptr&#39; is in this table and 0
//          // otherwise.
//
//      native_std::size_t size() const;
//          // Return the number of discrete values that are stored in this
//          // table.
//  };
//
//  // PRIVATE MANIPULATORS
//  void PtrHashSet::grow()
//  {
//      // &#39;bucketArraySize&#39; will always be &#39;2^N - 1&#39;, so that when pointers
//      // are aligned by some 2^N they&#39;re likely to be relatively prime.
//
//      native_std::size_t newBucketArraySize = bucketArraySize() * 2 + 1;
//      native_std::size_t newBucketArraySizeInBytes =
//                                         newBucketArraySize * sizeof(Bucket);
//      memset(bucketArrayAddress(), 0x5a, size() * sizeof(Bucket));
//      d_allocator_p-&gt;deallocate(bucketArrayAddress());
//      setBucketArrayAddressAndSize(
//               (Bucket *) d_allocator_p-&gt;allocate(newBucketArraySizeInBytes),
//               newBucketArraySize);
//      memset(bucketArrayAddress(), 0, newBucketArraySizeInBytes);
//      Node *newListRootAddress = 0;
//
//      unsigned numNodes = 0;
//      for (Node *node = (Node *) listRootAddress(); node; ++numNodes) {
//          Node *rippedOut = node;
//          node = (Node *) node-&gt;nextLink();
//
//          native_std::size_t index =
//                            (UintPtr) rippedOut-&gt;value() % bucketArraySize();
//          Bucket&amp; bucket = bucketArrayAddress()[index];
//          if (bucket.first()) {
//              if (0 == bucket.first()-&gt;previousLink()) {
//                  newListRootAddress = rippedOut;
//              }
//              Util::insertLinkBeforeTarget(rippedOut, bucket.first());
//              bucket.setFirst(rippedOut);
//          }
//          else {
//              Util::insertLinkBeforeTarget(rippedOut,
//                                           newListRootAddress);
//              newListRootAddress = rippedOut;
//              bucket.setFirstAndLast(rippedOut, rippedOut);
//          }
//      }
//      assert(size() == numNodes);
//
//      setListRootAddress(newListRootAddress);
//
//      checkInvariants();
//  }
//
//  // PRIVATE ACCESSORS
//  bool PtrHashSet::checkInvariants() const
//  {
//      bool ok;
//
//      unsigned numNodes = 0;
//      Node *prev = 0;
//      for (Node *node = (Node *) listRootAddress(); node;
//                             prev = node, node = (Node *) node-&gt;nextLink()) {
//          ok = node-&gt;previousLink() == prev;
//          assert(ok &amp;&amp; &quot;node-&gt;previousLink() == prev&quot;);
//          if (!ok) return false;                                    // RETURN
//          ++numNodes;
//      }
//      ok = size() == numNodes;
//      assert(ok &amp;&amp; &quot;size() == numNodes&quot;);
//      if (!ok) return false;                                        // RETURN
//
//      numNodes = 0;
//      for (unsigned i = 0; i &lt; bucketArraySize(); ++i) {
//          Bucket&amp; bucket = bucketArrayAddress()[i];
//          if (bucket.first()) {
//              ++numNodes;
//              for (Node *node = (Node *) bucket.first();
//                                bucket.last() != node;
//                                          node = (Node *) node-&gt;nextLink()) {
//                  ++numNodes;
//              }
//          }
//          else {
//              ok = !bucket.last();
//              assert(ok &amp;&amp; &quot;!bucket.last()&quot;);
//              if (!ok) return false;                                // RETURN
//          }
//      }
//      ok = size() == numNodes;
//      assert(ok &amp;&amp; &quot;size() == numNodes&quot;);
//
//      return ok;
//  }
//
//  bool PtrHashSet::find(Node **node, Bucket **bucket, const void *ptr) const
//  {
//      Node   *dummyNodePtr;
//      Bucket *dummyBucketPtr;
//      if (!node  ) node   = &amp;dummyNodePtr;
//      if (!bucket) bucket = &amp;dummyBucketPtr;
//
//      Node *&amp; nodePtrRef = *node;
//      unsigned index = (UintPtr) ptr % bucketArraySize();
//      Bucket&amp; bucketRef = bucketArrayAddress()[index];
//      *bucket = &amp;bucketRef;
//      if (bucketRef.first()) {
//          Node *begin      = (Node *) bucketRef.first();
//          Node * const end = (Node *) bucketRef.last()-&gt;nextLink();
//          for (Node *n = begin; end != n; n = (Node *) n-&gt;nextLink()) {
//              if (n-&gt;value() == ptr) {
//                  // found
//
//                  nodePtrRef = n;
//                  return true;                                      // RETURN
//              }
//          }
//          // not found
//
//          nodePtrRef = begin;
//          return false;                                             // RETURN
//      }
//      // empty bucket
//
//      nodePtrRef = (Node *) listRootAddress();
//      return false;
//  }
//
//  // CREATORS
//  PtrHashSet::PtrHashSet(bslma::Allocator *allocator)
//  : HashTableAnchor(0, 0, 0)
//  , d_maxLoadFactor(0.4)
//  , d_numNodes(0)
//  {
//      enum { NUM_BUCKETS = 3 };
//
//      d_allocator_p = bslma::Default::allocator(allocator);
//      native_std::size_t bucketArraySizeInBytes =
//                                                NUM_BUCKETS * sizeof(Bucket);
//      setBucketArrayAddressAndSize(
//                  (Bucket *) d_allocator_p-&gt;allocate(bucketArraySizeInBytes),
//                  NUM_BUCKETS);
//      memset(bucketArrayAddress(), 0, bucketArraySizeInBytes);
//  }
//
//  PtrHashSet::~PtrHashSet()
//  {
//      BSLS_ASSERT_SAFE(checkInvariants());
//
//      for (Node *node = (Node *) listRootAddress(); node; ) {
//          Node *toDelete = node;
//          node = (Node *) node-&gt;nextLink();
//
//          memset(toDelete, 0x5a, sizeof(*toDelete));
//          d_allocator_p-&gt;deallocate(toDelete);
//      }
//
//      d_allocator_p-&gt;deallocate(bucketArrayAddress());
//  }
//
//  // MANIPULATORS
//  bool PtrHashSet::erase(void *ptr)
//  {
//      Bucket *bucket;
//      Node   *node;
//
//      if (!find(&amp;node, &amp;bucket, ptr)) {
//          return false;                                             // RETURN
//      }
//
//      if (bucket-&gt;first() == node) {
//          if (bucket-&gt;last() == node) {
//              bucket-&gt;reset();
//          }
//          else {
//              bucket-&gt;setFirst(node-&gt;nextLink());
//          }
//      }
//      else if (bucket-&gt;last() == node) {
//          bucket-&gt;setLast(node-&gt;previousLink());
//      }
//
//      --d_numNodes;
//      Util::unlink(node);
//
//      d_allocator_p-&gt;deallocate(node);
//
//      checkInvariants();
//
//      return true;
//  }
//
//  bool PtrHashSet::insert(void *ptr)
//  {
//      Bucket *bucket;
//      Node *insertionPoint;
//
//      if (find(&amp;insertionPoint, &amp;bucket, ptr)) {
//          // Already in set, do nothing.
//
//          return false;                                             // RETURN
//      }
//
//      if (bucketArraySize() * d_maxLoadFactor &lt; d_numNodes + 1) {
//          grow();
//          bool found = find(&amp;insertionPoint, &amp;bucket, ptr);
//          BSLS_ASSERT_SAFE(!found);
//      }
//
//      ++d_numNodes;
//      Node *node = (Node *) d_allocator_p-&gt;allocate(sizeof(Node));
//
//      Util::insertLinkBeforeTarget(node, insertionPoint);
//      node-&gt;value() = ptr;
//      if (listRootAddress() == insertionPoint) {
//          BSLS_ASSERT_SAFE(0 == node-&gt;previousLink());
//          setListRootAddress(node);
//      }
//
//      if (bucket-&gt;first()) {
//          BSLS_ASSERT_SAFE(bucket-&gt;first() == insertionPoint);
//
//          bucket-&gt;setFirst(node);
//      }
//      else {
//          BSLS_ASSERT_SAFE(!bucket-&gt;last());
//
//          bucket-&gt;setFirstAndLast(node, node);
//      }
//
//      assert(count(ptr));
//
//      checkInvariants();
//
//      return true;
//  }
//
//  // ACCESSORS
//  native_std::size_t PtrHashSet::count(void *ptr) const
//  {
//      return find(0, 0, ptr);
//  }
//
//  native_std::size_t PtrHashSet::size() const
//  {
//      return d_numNodes;
//  }
//..
// Then, in &#39;main&#39;, we create a test allocator for use in this example to
// ensure that no memory is leaked:
//..
//  bslma::TestAllocator ta(&quot;test&quot;, veryVeryVeryVerbose);
//..
// Next, we declare our table using that allocator:
//..
//  PtrHashSet phs(&amp;ta);
//..
// Then, we create an area of memory from which our pointers will come:
//..
//  enum { SEGMENT_LENGTH = 1000 };
//  char *pc = (char *) ta.allocate(SEGMENT_LENGTH);
//..
// Next, we iterate through the length of the segment, insert those pointers
// for which &#39;ptr - pc == N * 7&#39; is true.  We keep a count of the number of
// items we insert into the table in the variable &#39;sevens&#39;:
//..
//  unsigned sevens = 0;
//  for (int i = 0; i &lt; SEGMENT_LENGTH; i += 7) {
//      ++sevens;
//      bool status = phs.insert(&amp;pc[i]);
//      assert(status);
//  }
//..
// Then, we verify the number of objects we&#39;ve placed in the table:
//..
//  assert(phs.size() == sevens);
//..
// Next, we iterate through ALL pointers in the &#39;pc&#39; array, using the &#39;count&#39;
// method to verify that the ones we expect are in the table:
//..
//  for (int i = 0; i &lt; SEGMENT_LENGTH; ++i) {
//      assert(phs.count(&amp;pc[i]) == (0 == i % 7));
//  }
//..
// Then, we iterate, deleting all elements from the table for which
// &#39;ptr - pc == 3 * N&#39; is true.  We keep a count of the number of elements
// which were in the table which we delete in the variable &#39;killed&#39;:
//..
//  unsigned killed = 0;
//  for (int i = 0; i &lt; SEGMENT_LENGTH; i += 3) {
//      const bool deleted = phs.erase(&amp;pc[i]);
//      assert(deleted == (0 == i % 7));
//      killed += deleted;
//  }
//..
// Next, we verify the number of remaining elements in the table:
//..
//  assert(killed &lt; sevens);
//  assert(phs.size() == sevens - killed);
//..
// Then, in verbose mode we print our tallies:
//..
//  if (verbose) {
//      printf(&quot;sevens = %u, killed = %u, phs.size() = %u\n&quot;, sevens,
//                                          killed, (unsigned) phs.size());
//  }
//..
// Now, we iterate through every element of the &#39;pc&#39; array, verifying that the
// surviving elements are exactly those for which &#39;ptr - pc&#39; was divisible by 7
// and not by 3:
//..
//  for (int i = 0; i &lt; SEGMENT_LENGTH; ++i) {
//      const bool present = phs.count(&amp;pc[i]);
//      assert(present == ((0 == i % 7) &amp;&amp; (0 != i % 3)));
//  }
//..
// Finally, we clean up our &#39;pc&#39; array:
//..
//  ta.deallocate(pc);
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;
#define INCLUDED_CSTDDEF
#endif

namespace BloombergLP {

namespace bslalg {

struct HashTableBucket;  // This is known to be a POD struct.

                        // =============================
                        // class bslalg::HashTableAnchor
                        // =============================

class HashTableAnchor {
    // This complex constrained *in*-*core* (value-semantic) attribute class
    // characterizes the key data elements of a hash table.  See the
    // &quot;Attributes&quot; section under @DESCRIPTION in the component-level
    // documentation for/ information on the class attributes.  Note that the
    // class invariant is the identically the complex constraint of this
    // component.
    //
    // This class:
    //: o supports a complete set of *value-semantic* operations
    //:   o except for &#39;bdex&#39; serialization and default construction
    //: o is *in-core*
    //: o is *exception-neutral* (agnostic)
    //: o is *alias-safe*
    //: o is &#39;const&#39; *thread-safe*
    // For terminology see &#39;bsldoc_glossary&#39;.

    // DATA
    HashTableBucket     *d_bucketArrayAddress_p;  // address of the array of
                                                  // buckets (held, not owned)

    native_std::size_t   d_bucketArraySize;       // size of &#39;d_bucketArray&#39;

    BidirectionalLink   *d_listRootAddress_p;     // head of the list of
                                                  // elements in the hash-table
                                                  // (held, not owned)

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(HashTableAnchor,
                                   bsl::is_trivially_copyable);

    // CREATORS
    HashTableAnchor(HashTableBucket    *bucketArrayAddress,
                    native_std::size_t  bucketArraySize,
                    BidirectionalLink  *listRootAddress);
        // Create a &#39;bslalg::HashTableAnchor&#39; object having the specified
        // &#39;bucketArrayAddress&#39;, &#39;bucketArraySize&#39;, and &#39;listRootAddress&#39;
        // attributes.  The behavior is undefined unless &#39;bucketArrayAddress&#39;
        // refers to a contiguous sequence of valid &#39;bslalg::HashTableBucket&#39;
        // objects of at least &#39;bucketArraySize&#39; or unless both
        // &#39;bucketArrayAddress&#39; and &#39;bucketArraySize&#39; are 0.

    HashTableAnchor(const HashTableAnchor&amp; original);
        // Create a &#39;bslalg::HashTableAnchor&#39; object having the same value
        // as the specified &#39;original&#39; object.

    // ~bslalg::HashTableAnchor(); = default
        // Destroy this object.

    // MANIPULATORS
    bslalg::HashTableAnchor&amp; operator=(const bslalg::HashTableAnchor&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.

    void setBucketArrayAddressAndSize(HashTableBucket    *bucketArrayAddress,
                                      native_std::size_t  bucketArraySize);
        // Set the bucket array address and bucket array size attributes of
        // this object to the specified &#39;bucketArrayAddress&#39; and
        // &#39;bucketArraySize&#39; values.  The behavior is undefined unless
        // &#39;bucketArrayAddress&#39; refers to a contiguous sequence of valid
        // &#39;bslalg::HashTableBucket&#39; objects of at least &#39;bucketArraySize&#39;, or
        // unless both &#39;bucketArrayAddress&#39; and &#39;bucketArraySize&#39; are 0.

    void setListRootAddress(BidirectionalLink *value);
        // Set the &#39;listRootAddress&#39; attribute of this object to the
        // specified &#39;value&#39;.

                                  // Aspects

    void swap(HashTableAnchor&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.

    // ACCESSORS
    HashTableBucket *bucketArrayAddress() const;
        // Return the value of the &#39;bucketArrayAddress&#39; attribute of this
        // object.

    native_std::size_t bucketArraySize() const;
        // Return the value of the &#39;bucketArraySize&#39; attribute of this object.

    BidirectionalLink *listRootAddress() const;
        // Return the value &#39;listRootAddress&#39; attribute of this object.
};

// FREE OPERATORS
bool operator==(const HashTableAnchor&amp; lhs, const HashTableAnchor&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;bslalg::HashTableAnchor&#39; objects
    // have the same value if all of the corresponding values of their
    // &#39;bucketArrayAddress&#39;, &#39;bucketArraySize&#39;, and &#39;listRootAddress&#39;
    // attributes are the same.

bool operator!=(const HashTableAnchor&amp; lhs, const HashTableAnchor&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;bslalg::HashTableAnchor&#39;
    // objects do not have the same value if any of the corresponding values of
    // their &#39;bucketArrayAddress&#39;, &#39;bucketArraySize&#39;, or &#39;listRootAddress&#39;
    // attributes are not the same.

// FREE FUNCTIONS
void swap(HashTableAnchor&amp; a, HashTableAnchor&amp; b);
    // Efficiently exchange the values of the specified &#39;a&#39; and &#39;b&#39; objects.
    // This function provides the no-throw exception-safety guarantee.  The
    // behavior is undefined unless the two objects were created with the same
    // allocator.

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                        // -----------------------------
                        // class bslalg::HashTableAnchor
                        // -----------------------------

// CREATORS
inline
HashTableAnchor::HashTableAnchor(bslalg::HashTableBucket   *bucketArrayAddress,
                                 native_std::size_t         bucketArraySize,
                                 bslalg::BidirectionalLink *listRootAddress)
: d_bucketArrayAddress_p(bucketArrayAddress)
, d_bucketArraySize(bucketArraySize)
, d_listRootAddress_p(listRootAddress)
{
    BSLS_ASSERT_SAFE(   (!bucketArrayAddress &amp;&amp; !bucketArraySize)
                     || (bucketArrayAddress &amp;&amp; 0 &lt; bucketArraySize));
    BSLS_ASSERT_SAFE(!listRootAddress || !(listRootAddress-&gt;previousLink()));
}

inline
HashTableAnchor::HashTableAnchor(const HashTableAnchor&amp; original)
: d_bucketArrayAddress_p(original.d_bucketArrayAddress_p)
, d_bucketArraySize(original.d_bucketArraySize)
, d_listRootAddress_p(original.d_listRootAddress_p)
{
}

// MANIPULATORS
inline
HashTableAnchor&amp; HashTableAnchor::operator=(const HashTableAnchor&amp; rhs)
{
    d_bucketArrayAddress_p = rhs.d_bucketArrayAddress_p;
    d_bucketArraySize      = rhs.d_bucketArraySize;
    d_listRootAddress_p    = rhs.d_listRootAddress_p;
    return *this;
}

inline
void HashTableAnchor::setBucketArrayAddressAndSize(
                                        HashTableBucket    *bucketArrayAddress,
                                        native_std::size_t  bucketArraySize)
{
    BSLS_ASSERT_SAFE(( bucketArrayAddress &amp;&amp; 0 &lt; bucketArraySize)
                  || (!bucketArrayAddress &amp;&amp;    !bucketArraySize));

    d_bucketArrayAddress_p = bucketArrayAddress;
    d_bucketArraySize      = bucketArraySize;
}

inline
void HashTableAnchor::setListRootAddress(BidirectionalLink *value)
{
    BSLS_ASSERT_SAFE(!value || !value-&gt;previousLink());

    d_listRootAddress_p = value;
}

                                  // Aspects

inline
void HashTableAnchor::swap(HashTableAnchor&amp; other)
{
    bslalg::ScalarPrimitives::swap(*this, other);
}

// ACCESSORS
inline
BidirectionalLink *HashTableAnchor::listRootAddress() const
{
    return d_listRootAddress_p;
}

inline
std::size_t HashTableAnchor::bucketArraySize() const
{
    return d_bucketArraySize;
}

inline
HashTableBucket *HashTableAnchor::bucketArrayAddress() const
{
    return d_bucketArrayAddress_p;
}

}  // close namespace bslalg

// FREE OPERATORS
inline
void bslalg::swap(bslalg::HashTableAnchor&amp; a, bslalg::HashTableAnchor&amp; b)
{
    a.swap(b);
}

inline
bool bslalg::operator==(const bslalg::HashTableAnchor&amp; lhs,
                        const bslalg::HashTableAnchor&amp; rhs)
{
    return lhs.bucketArrayAddress() == rhs.bucketArrayAddress()
        &amp;&amp; lhs.bucketArraySize()    == rhs.bucketArraySize()
        &amp;&amp; lhs.listRootAddress()    == rhs.listRootAddress();
}

inline
bool bslalg::operator!=(const bslalg::HashTableAnchor&amp; lhs,
                        const bslalg::HashTableAnchor&amp; rhs)
{
    return lhs.bucketArrayAddress() != rhs.bucketArrayAddress()
        || lhs.bucketArraySize()    != rhs.bucketArraySize()
        || lhs.listRootAddress()    != rhs.listRootAddress();
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
