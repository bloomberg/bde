<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslstl_stack Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a> &#124;
<a href="#friend-members">Friends</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_stack<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an STL-compliant stack class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Stack__HasAllocatorType.html">bsl::Stack_HasAllocatorType&lt; CONTAINER &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><b>bsl::Stack_HasAllocatorType&lt; CONTAINER &gt;::NoType</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1stack.html">bsl::stack&lt; VALUE, CONTAINER &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CONTAINER::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga049154bcb2e807493ae2aa517897d59a">bsl::stack::reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CONTAINER::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gad3bfb8dcad9b25596668f804bc35ba14">bsl::stack::const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CONTAINER::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga16b0ff47987080a59abd2bf968433aaf">bsl::stack::size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CONTAINER&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga349ea093959cdd009cf54d94a812a5f6">bsl::stack::container_type</a></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__bslstl__stack.html#gga86183438786aa9ea50477eee372dfa13a0b5c74707a1b1c1f24870cd4db679d19">bsl::Stack_HasAllocatorType::VALUE</a> =  (sizeof(YesType) == sizeof(match&lt;CONTAINER&gt;(0)))
 }</td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gabc94d0b42075c78f8220eea0d399cada">bsl::stack::BSLMF_NESTED_TRAIT_DECLARATION_IF</a> (stack, BloombergLP::bslma::UsesBslmaAllocator, BloombergLP::bslma::UsesBslmaAllocator&lt; container_type &gt;::value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga26e79cb7b8b1903bca968560a1ed1a27">bsl::stack::stack</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga60828434bf2cad9edf7d4a3ce21074b5">bsl::stack::stack</a> (const ALLOCATOR &amp;basicAllocator, typename enable_if&lt; Stack_HasAllocatorType&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gafe8ed9108cce577712f356c48e6ef4d2">bsl::stack::stack</a> (const CONTAINER &amp;container)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gab58aca1418225c2d974ddd119b33eda7">bsl::stack::stack</a> (const CONTAINER &amp;container, const ALLOCATOR &amp;basicAllocator, typename enable_if&lt; Stack_HasAllocatorType&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga5a37ac264b76ef5c0648a086c6a37c98">bsl::stack::stack</a> (const stack &amp;original)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga5b3bde0f8f8374fa7cb9b934e1d573b0">bsl::stack::stack</a> (const stack &amp;original, const ALLOCATOR &amp;basicAllocator, typename enable_if&lt; Stack_HasAllocatorType&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">stack &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gad1ecf1fac20e23acbbf585975cf5f36c">bsl::stack::operator=</a> (const stack &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga6ea8dca86df1d438bda9c202688ce5ba">bsl::stack::emplace</a> (Args &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga9441bfa0f0291b1802e0eff45681ef0b">bsl::stack::pop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaa097f254e38f0347f17cd2760d9b1e12">bsl::stack::push</a> (const value_type &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga706a56c3a308ede5033b91d457c47283">bsl::stack::swap</a> (stack &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaa5a73a760fff15dad4bc5ca5401efdac">bsl::stack::top</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga69047b47cd75afc96756f3b2514c2c83">bsl::stack::empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gab70dac49a2459d5d37ba846c6a49a6b9">bsl::stack::size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaac25745575dc8bb06410028f36871728">bsl::stack::top</a> () const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga4de7c661423b992c4efac216574915f1">bsl::operator==</a> (const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga585bf4a1dfbacb8e796ceee38e0b667e">bsl::operator!=</a> (const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaf40f0bba0cda8cd451cefafd1e09cf8b">bsl::operator&lt;</a> (const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga5400f7f0238a7c6c2ab6e880686473a9">bsl::operator&gt;</a> (const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gad92196ff0aec88dd3db886ea825d6645">bsl::operator&lt;=</a> (const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga083c333856bdb6110947f806405c1cda">bsl::operator&gt;=</a> (const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE , class CONTAINER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga69a3b02c7015296255025773a76d7a8c">bsl::swap</a> (stack&lt; VALUE, CONTAINER &gt; &amp;lhs, stack&lt; VALUE, CONTAINER &gt; &amp;rhs)</td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">container_type &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaab885033eb2a989a69d138d46d12fc90">bsl::stack::c</a></td></tr>
<tr><td colspan="2"><h2><a name="friend-members"></a>
Friends</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VAL , class CONT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaf30201118019d91cd8690f2726752e96">bsl::stack::operator==</a> (const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VAL , class CONT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga966a7ded1d506afdf737e0cad5937979">bsl::stack::operator!=</a> (const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VAL , class CONT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaf02d88c961086a38f6a636167f22a432">bsl::stack::operator&lt;</a> (const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VAL , class CONT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gab3c09766c44c1047991d764f0c9f7e8a">bsl::stack::operator&gt;</a> (const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VAL , class CONT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#ga273a74c99b76badf1d16243752b5d77e">bsl::stack::operator&lt;=</a> (const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VAL , class CONT &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__stack.html#gaeece956ed15cb6661c4bab83a2bf5622">bsl::stack::operator&gt;=</a> (const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Requirements of Parametrized <code>CONTAINER</code> Type</a> </li>
<li>
<a href="#3.2">Note on Parameterized <code>VALUE</code> Type</a> </li>
<li>
<a href="#3.3">Memory Allocation</a> </li>
<li>
<a href="#3.4"><code>bslma</code>-Style Allocators</a> </li>
<li>
<a href="#3.5">Operations</a> </li>
<li>
<a href="#3.6">Usage</a> <ul>
<li>
<a href="#3.6.1">Example 1: Household Chores To Do List</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an STL-compliant stack class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bslstl::stack </td><td>STL-compliant stack template  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__deque.html" title="Provide an STL-compliant deque class.">Component bslstl_deque</a>, <a class="el" href="group__bslstl__vector.html" title="Provide an STL-compliant vector class.">Component bslstl_vector</a>, <a class="el" href="group__bslstl__list.html" title="Provide an STL-compliant list class.">Component bslstl_list</a>, <a class="el" href="group__bslstl__queue.html" title="Provide container adapter class template queue.">Component bslstl_queue</a>, <a class="el" href="group__bslstl__priorityqueue.html" title="Provide container adapter class template priority_queue.">Component bslstl_priorityqueue</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class template <code>bslstl::stack</code>, a container adapter that takes an underlying container and provides a stack interface which the user accesses primarily through <code>push</code>, <code>pop</code>, and <code>top</code> operations. A <code>deque</code> (the default), <code>vector</code>, or <code>list</code> may be used, but any container which supports <code>push_back</code>, <code>pop_back</code>, <code>back</code>, and <code>size</code>, plus a template specialization <code>uses_allocator::type</code>, may be used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="requirements_of_parametrized_container_type"></a> <a class="anchor" id="description.requirements_of_parametrized_container_type"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Requirements of Parametrized CONTAINER Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This class will accept <code><a class="el" href="classbsl_1_1queue.html">bsl::queue</a></code>, <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>, or <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code> as the template parameter <code>CONTAINER</code>. In addition, other container classes could be supplied for the CONTAINER argument, but the supplied <code>CONTAINER</code> template parameter must support the following public types: <ul>
<li>
value_type  </li>
<li>
reference  </li>
<li>
const_reference  </li>
<li>
size_type  </li>
</ul>
In addition, the supplied <code>CONTAINER</code> template parameter must support the following methods, (depending on the methods of <code>stack</code> being used): <ul>
<li>
constructors used must take a parameter of type <code>allocator_type</code>  </li>
<li>
void push_back(const value_type&amp;)  </li>
<li>
void pop_back()  </li>
<li>
value_type&amp; back()  </li>
<li>
size_type <a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a>  </li>
<li>
<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>  </li>
<li>
<code>operator=</code>  </li>
<li>
<a class="el" href="namespacestd.html#a1a88896f0ee62750b5e3b43e0d90a6c8">std::swap</a>(CONTAINER&amp;, CONTAINER&amp;) must work  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="note_on_parameterized_value_type"></a> <a class="anchor" id="description.note_on_parameterized_value_type"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Note on Parameterized VALUE Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the <code>CONTAINER</code> type is specified, the <code>VALUE</code> type specified is ignored and <code>CONTAINER::value_type</code> is used in its place. It is recommended, if <code>CONTAINER</code> is specified, that a type equivalent to <code>CONTAINER::value_type</code> be specified to the <code>VALUE</code> template parameter so as not to mislead readers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>No memory allocator template arg is directly supplied to this class, the allocator type used is the allocator specified for the container class. Some functions of this template only exist if type <code>CONTAINER::allocator_type</code> exists, and if it does exist it is assumed to be the allocator type used by <code>CONTAINER</code>, and that <code>CONTAINER</code> supports constructors of this type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="description.bslma-style_allocators"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The constructors of this class take, as optional parameters, allocators of the object's parameterized <code>CONTAINER::allocator_type</code> type, and allocators of this type are propagated to all constructors of the underlying container. In the case of container types <code><a class="el" href="classbsl_1_1deque.html">bsl::deque</a></code> (the default type), <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>, and <code><a class="el" href="classbsl_1_1list.html">bsl::list</a></code>, <code>CONTAINER::allocator_type</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> which is implicitly convertible from <code>bslma_Allocator *</code>, and which can be converted to a <code>bslma_Allocator *</code> through the <code>mechanism</code> accessor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Hence if the underlying container takes <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then the <code>stack</code> object can take <code>bslma_Allocator *</code>s to supply memory allocation. If no allocator is specified, <code>allocator()</code> is used, which winds up using <code>bslma::Default::allocator(0)</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operations"></a> <a class="anchor" id="description.operations"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section describes the run-time complexity of operations on instances of <code>stack</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Legend
  ------
  <span class="charliteral">&#39;C&#39;</span>             - parameterized container-type of the stack
  <span class="charliteral">&#39;V&#39;</span>             - <span class="stringliteral">&#39;C::value_type&#39;</span>
  <span class="charliteral">&#39;c&#39;</span>             - container of type <span class="charliteral">&#39;C&#39;</span>
  <span class="stringliteral">&#39;nc&#39;</span>            - number of elements in container <span class="charliteral">&#39;c&#39;</span>
  <span class="charliteral">&#39;s&#39;</span>, <span class="charliteral">&#39;t&#39;</span>        - two distinct objects of type <span class="stringliteral">&#39;stack&lt;V, C&gt;&#39;</span>
  <span class="charliteral">&#39;n&#39;</span>, <span class="charliteral">&#39;m&#39;</span>        - number of elements in <span class="charliteral">&#39;s&#39;</span> and <span class="charliteral">&#39;t&#39;</span> respectively
  <span class="stringliteral">&#39;al&#39;</span>            - a STL-style memory allocator
  <span class="charliteral">&#39;v&#39;</span>             - an <span class="keywordtype">object</span> of type <span class="charliteral">&#39;V&#39;</span>

  +----------------------------------------------------+--------------------+
  | Note: the following estimations of operation complexity assume the      |
  | underlying container is a <span class="stringliteral">&#39;bsl::deque&#39;</span>, <span class="stringliteral">&#39;bsl::vector&#39;</span>, or <span class="stringliteral">&#39;bsl::list&#39;</span>.  |
  +----------------------------------------------------+--------------------+
  | Operation                                          | Complexity         |
  +====================================================+====================+
  | stack&lt;V, C&gt; s;    (<span class="keywordflow">default</span> construction)           | O(1)               |
  | stack&lt;V, C&gt; s(al);                                 |                    |
  +----------------------------------------------------+--------------------+
  | stack&lt;V, C&gt; s(c);                                  | O(nc)              |
  | stack&lt;V, C&gt; s(c, al);                              |                    |
  +----------------------------------------------------+--------------------+
  | stack&lt;V, C&gt; s(t);                                  | O(n)               |
  | stack&lt;V, C&gt; s(t, al);                              |                    |
  +----------------------------------------------------+--------------------+
  | s.~stack(V, C&gt;(); (destruction)                    | O(n)               |
  +----------------------------------------------------+--------------------+
  | s = t;          (assignment)                       | O(n)               |
  +----------------------------------------------------+--------------------+
  | s.push(v)                                          | O(1)               |
  +----------------------------------------------------+--------------------+
  | s.pop()                                            | O(1)               |
  +----------------------------------------------------+--------------------+
  | s.top()                                            | O(1)               |
  +----------------------------------------------------+--------------------+
  | s == t, s != t                                     | O(n)               |
  +---------------------------------------------------+--------------------+
  | s &lt; t, s &lt;= t, s &gt; t, s &gt;= t                       | O(n)               |
  +----------------------------------------------------+--------------------+
  | s.swap(t), <a class="code" href="group__bslstl__deque.html#ga4ffc73dd2ce1f86230d22d2284773f1d">swap</a>(s,t)                               | depends on the     |
  |                                                    | container; <span class="keywordflow">for</span>     |
  |                                                    | deque, vector, and |
  |                                                    | list:              |
  |                                                    | O(1) if &#39;s&#39; and    |
  |                                                    | &#39;t&#39; use the same   |
  |                                                    | allocator,         |
  |                                                    | O(n + m) otherwise |
  +----------------------------------------------------+--------------------+
  | s.size()                                           | O(1) if &#39;C&#39; is     |
  |                                                    | deque or vector    |
  +----------------------------------------------------+--------------------+
  | s.empty()                                          | O(1)               |
  +----------------------------------------------------+--------------------+
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this section we show intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_household_chores_to_do_list"></a> <a class="anchor" id="usage.example_1~3A_household_chores_to_do_list"></a> <a class="anchor" id="description.usage.example_1~3A_household_chores_to_do_list"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.6.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Household Chores To Do List: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose a husband wants to keep track of chores his wife has asked him to do. Over the years of being married, he has noticed that his wife generally wants the most recently requested task done first. If she has a new task in mind that is low-priority, she will avoid asking for it until higher priority tasks are finished. When he has finished all tasks, he is to report to his wife that he is ready for more. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the class implementing the <code>to-do</code> list. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ToDoList {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1stack.html">bsl::stack&lt;const char *&gt;</a> d_stack;

    <span class="keyword">public</span>:
      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> enqueueTask(<span class="keyword">const</span> <span class="keywordtype">char</span> *task);
          <span class="comment">// Add the specified &#39;task&#39;, a string describing a task, to the</span>
          <span class="comment">// list.  Note the lifetime of the string referred to by &#39;task&#39;</span>
          <span class="comment">// must exceed the lifetime of the task in this list.</span>

      <span class="keywordtype">bool</span> finishTask();
          <span class="comment">// Remove the current task from the list.  Return &#39;true&#39; if a task</span>
          <span class="comment">// was removed and it was the last task on the list, and return</span>
          <span class="comment">// &#39;false&#39; otherwise.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *currentTask() <span class="keyword">const</span>;
          <span class="comment">// Return the string representing the current task.  If there</span>
          <span class="comment">// is no current task, return the string &quot;&lt;EMPTY&gt;&quot;, which is</span>
          <span class="comment">// not a valid task.</span>
  };

  <span class="comment">// MANIPULATORS</span>
  <span class="keywordtype">void</span> ToDoList::enqueueTask(<span class="keyword">const</span> <span class="keywordtype">char</span> *task)
  {
      d_stack.push(task);
  }

  <span class="keywordtype">bool</span> ToDoList::finishTask()
  {
      <span class="keywordflow">if</span> (!d_stack.empty()) {
          d_stack.pop();

          <span class="keywordflow">return</span> d_stack.empty();
      }

      <span class="keywordflow">return</span> <span class="keyword">false</span>;
  };

  <span class="comment">// ACCESSORS</span>
  <span class="keyword">const</span> <span class="keywordtype">char</span> *ToDoList::currentTask()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">if</span> (d_stack.empty()) {
          <span class="keywordflow">return</span> <span class="stringliteral">&quot;&lt;EMPTY&gt;&quot;</span>;
      }

      <span class="keywordflow">return</span> d_stack.top();
  }
</pre></div><br/>
<br/>
 Then, create an object of type <code>ToDoList</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>ToDoList toDoList; </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, a few tasks are requested: <br/>
<br/>
<div class="fragment"><pre class="fragment">  toDoList.enqueueTask(<span class="stringliteral">&quot;Change the car&#39;s oil.&quot;</span>);
  toDoList.enqueueTask(<span class="stringliteral">&quot;Pay the bills.&quot;</span>);
</pre></div><br/>
<br/>
 Then, the husband watches the Yankee's game on TV. Upon returning to the list he consults the list to see what task is up next: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(!strcmp(<span class="stringliteral">&quot;Pay the bills.&quot;</span>, toDoList.currentTask()));
</pre></div><br/>
<br/>
 Next, he sees that he has to pay the bills. When the bills are finished, he flushes that task from the list: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">false</span> == toDoList.finishTask());
</pre></div><br/>
<br/>
 Then, he consults the list for the next task. <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(!strcmp(<span class="stringliteral">&quot;Change the car&#39;s oil.&quot;</span>, toDoList.currentTask()));
</pre></div><br/>
<br/>
 Next, he sees he has to change the car's oil. Before he can get started, another request comes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  toDoList.enqueueTask(<span class="stringliteral">&quot;Get some hot dogs.&quot;</span>);
  assert(!strcmp(<span class="stringliteral">&quot;Get some hot dogs.&quot;</span>, toDoList.currentTask()));
</pre></div><br/>
<br/>
 Then, he drives the car to the convenience store and picks up some hot dogs and buns. Upon returning home, he gives the hot dogs to his wife, updates the list, and consults it for the next task. <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">false</span> == toDoList.finishTask());
  assert(!strcmp(<span class="stringliteral">&quot;Change the car&#39;s oil.&quot;</span>, toDoList.currentTask()));
</pre></div><br/>
<br/>
 Next, he finishes the oil change, updates the list, and consults it for the next task. <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(<span class="keyword">true</span> == toDoList.finishTask());
  assert(!strcmp(<span class="stringliteral">&quot;&lt;EMPTY&gt;&quot;</span>, toDoList.currentTask()));
</pre></div><br/>
<br/>
 Finally, the wife has now been informed that everything is done, and she makes another request: <br/>
<br/>
<div class="fragment"><pre class="fragment">  toDoList.enqueueTask(<span class="stringliteral">&quot;Clean the rain gutters.&quot;</span>);
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga049154bcb2e807493ae2aa517897d59a"></a><!-- doxytag: member="bsl::stack::reference" ref="ga049154bcb2e807493ae2aa517897d59a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CONTAINER::reference <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gad3bfb8dcad9b25596668f804bc35ba14"></a><!-- doxytag: member="bsl::stack::const_reference" ref="gad3bfb8dcad9b25596668f804bc35ba14" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CONTAINER::const_reference <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::const_reference<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga16b0ff47987080a59abd2bf968433aaf"></a><!-- doxytag: member="bsl::stack::size_type" ref="ga16b0ff47987080a59abd2bf968433aaf" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CONTAINER::size_type <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::size_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga349ea093959cdd009cf54d94a812a5f6"></a><!-- doxytag: member="bsl::stack::container_type" ref="ga349ea093959cdd009cf54d94a812a5f6" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CONTAINER <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::container_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Enumeration Type Documentation</h2>
<a class="anchor" id="ga86183438786aa9ea50477eee372dfa13"></a><!-- doxytag: member="bsl::Stack_HasAllocatorType::@390" ref="ga86183438786aa9ea50477eee372dfa13" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="gga86183438786aa9ea50477eee372dfa13a0b5c74707a1b1c1f24870cd4db679d19"></a><!-- doxytag: member="VALUE" ref="gga86183438786aa9ea50477eee372dfa13a0b5c74707a1b1c1f24870cd4db679d19" args="" -->VALUE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gabc94d0b42075c78f8220eea0d399cada"></a><!-- doxytag: member="bsl::stack::BSLMF_NESTED_TRAIT_DECLARATION_IF" ref="gabc94d0b42075c78f8220eea0d399cada" args="(stack, BloombergLP::bslma::UsesBslmaAllocator, BloombergLP::bslma::UsesBslmaAllocator&lt; container_type &gt;::value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::BSLMF_NESTED_TRAIT_DECLARATION_IF </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::UsesBslmaAllocator&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BloombergLP::bslma::UsesBslmaAllocator&lt; <a class="el" href="group__bslstl__stack.html#ga349ea093959cdd009cf54d94a812a5f6">container_type</a> &gt;::value&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga26e79cb7b8b1903bca968560a1ed1a27"></a><!-- doxytag: member="bsl::stack::stack" ref="ga26e79cb7b8b1903bca968560a1ed1a27" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::stack </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty stack. No allocator will be provided to the underlying container, and the container's memory allocation will be provided by whatever is the default for the container type. </p>

</div>
</div>
<a class="anchor" id="ga60828434bf2cad9edf7d4a3ce21074b5"></a><!-- doxytag: member="bsl::stack::stack" ref="ga60828434bf2cad9edf7d4a3ce21074b5" args="(const ALLOCATOR &amp;basicAllocator, typename enable_if&lt; Stack_HasAllocatorType&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::stack </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structbsl_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="classbsl_1_1Stack__HasAllocatorType.html">Stack_HasAllocatorType</a>&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct an empty stack, and use the specified <code>basicAllocator</code> to supply memory. If <code>CONTAINER::allocator_type</code> does not exist, this constructor may not be used. </p>

</div>
</div>
<a class="anchor" id="gafe8ed9108cce577712f356c48e6ef4d2"></a><!-- doxytag: member="bsl::stack::stack" ref="gafe8ed9108cce577712f356c48e6ef4d2" args="(const CONTAINER &amp;container)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::stack </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a stack whose underlying container has the value of the specified <code>container</code>. </p>

</div>
</div>
<a class="anchor" id="gab58aca1418225c2d974ddd119b33eda7"></a><!-- doxytag: member="bsl::stack::stack" ref="gab58aca1418225c2d974ddd119b33eda7" args="(const CONTAINER &amp;container, const ALLOCATOR &amp;basicAllocator, typename enable_if&lt; Stack_HasAllocatorType&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::stack </td>
          <td>(</td>
          <td class="paramtype">const CONTAINER &amp;&nbsp;</td>
          <td class="paramname"> <em>container</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structbsl_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="classbsl_1_1Stack__HasAllocatorType.html">Stack_HasAllocatorType</a>&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a stack whose underlying container has the value of the specified <code>container</code>, and use the specified <code>basicAllocator</code> to supply memory. If <code>CONTAINER::allocator_type</code> does not exist, this constructor may not be used. </p>

</div>
</div>
<a class="anchor" id="ga5a37ac264b76ef5c0648a086c6a37c98"></a><!-- doxytag: member="bsl::stack::stack" ref="ga5a37ac264b76ef5c0648a086c6a37c98" args="(const stack &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::stack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a stack having the same value as the specified <code>original</code>. </p>

</div>
</div>
<a class="anchor" id="ga5b3bde0f8f8374fa7cb9b934e1d573b0"></a><!-- doxytag: member="bsl::stack::stack" ref="ga5b3bde0f8f8374fa7cb9b934e1d573b0" args="(const stack &amp;original, const ALLOCATOR &amp;basicAllocator, typename enable_if&lt; Stack_HasAllocatorType&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::stack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structbsl_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="classbsl_1_1Stack__HasAllocatorType.html">Stack_HasAllocatorType</a>&lt; CONTAINER &gt;::VALUE, ALLOCATOR &gt;::type *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a stack having the same value as the specified stack <code>original</code>, and use the specified <code>basicAllocator</code> to supply memory. If <code>CONTAINER::allocator_type</code> does not exist, this constructor may not be used. </p>

</div>
</div>
<a class="anchor" id="gad1ecf1fac20e23acbbf585975cf5f36c"></a><!-- doxytag: member="bsl::stack::operator=" ref="gad1ecf1fac20e23acbbf585975cf5f36c" args="(const stack &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">stack&amp; <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and return a reference providing modifiable access to this object. </p>

</div>
</div>
<a class="anchor" id="ga6ea8dca86df1d438bda9c202688ce5ba"></a><!-- doxytag: member="bsl::stack::emplace" ref="ga6ea8dca86df1d438bda9c202688ce5ba" args="(Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga9441bfa0f0291b1802e0eff45681ef0b"></a><!-- doxytag: member="bsl::stack::pop" ref="ga9441bfa0f0291b1802e0eff45681ef0b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::pop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the top element from this stack. The behavior is undefined if the stack is empty. </p>

</div>
</div>
<a class="anchor" id="gaa097f254e38f0347f17cd2760d9b1e12"></a><!-- doxytag: member="bsl::stack::push" ref="gaa097f254e38f0347f17cd2760d9b1e12" args="(const value_type &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::push </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html#acd5e331f31dd328887de2a7a7500997a">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Push the specified <code>value</code> onto the top of the stack. </p>

</div>
</div>
<a class="anchor" id="ga706a56c3a308ede5033b91d457c47283"></a><!-- doxytag: member="bsl::stack::swap" ref="ga706a56c3a308ede5033b91d457c47283" args="(stack &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this object with the value of the specified <code>other</code> object. </p>

</div>
</div>
<a class="anchor" id="gaa5a73a760fff15dad4bc5ca5401efdac"></a><!-- doxytag: member="bsl::stack::top" ref="gaa5a73a760fff15dad4bc5ca5401efdac" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reference <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::top </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the element at the top of this stack. The behavior is undefined if the stack is empty. </p>

</div>
</div>
<a class="anchor" id="ga69047b47cd75afc96756f3b2514c2c83"></a><!-- doxytag: member="bsl::stack::empty" ref="ga69047b47cd75afc96756f3b2514c2c83" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this stack contains no elements and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="gab70dac49a2459d5d37ba846c6a49a6b9"></a><!-- doxytag: member="bsl::stack::size" ref="gab70dac49a2459d5d37ba846c6a49a6b9" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements contained in this stack. </p>

</div>
</div>
<a class="anchor" id="gaac25745575dc8bb06410028f36871728"></a><!-- doxytag: member="bsl::stack::top" ref="gaac25745575dc8bb06410028f36871728" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reference <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::top </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the element at the top of this stack. The behavior is undefined if the stack is empty. </p>

</div>
</div>
<a class="anchor" id="ga4de7c661423b992c4efac216574915f1"></a><!-- doxytag: member="bsl::operator==" ref="ga4de7c661423b992c4efac216574915f1" args="(const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator== </td>
          <td>(</td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code>stack</code> objects have the same value if their underlying containers have the same value. </p>

</div>
</div>
<a class="anchor" id="ga585bf4a1dfbacb8e796ceee38e0b667e"></a><!-- doxytag: member="bsl::operator!=" ref="ga585bf4a1dfbacb8e796ceee38e0b667e" args="(const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator!= </td>
          <td>(</td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code>stack</code> objects have the same value if their underlying containers have the same value. </p>

</div>
</div>
<a class="anchor" id="gaf40f0bba0cda8cd451cefafd1e09cf8b"></a><!-- doxytag: member="bsl::operator&lt;" ref="gaf40f0bba0cda8cd451cefafd1e09cf8b" args="(const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> is less than the specified <code>rhs</code>. One <code>stack</code> object is less than another if its underlying container is less than the other's underlying container. </p>

</div>
</div>
<a class="anchor" id="ga5400f7f0238a7c6c2ab6e880686473a9"></a><!-- doxytag: member="bsl::operator&gt;" ref="ga5400f7f0238a7c6c2ab6e880686473a9" args="(const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> is greater than the specified <code>rhs</code>. One <code>stack</code> object is greater than another if its underlying container is greater than the other's underlying container. </p>

</div>
</div>
<a class="anchor" id="gad92196ff0aec88dd3db886ea825d6645"></a><!-- doxytag: member="bsl::operator&lt;=" ref="gad92196ff0aec88dd3db886ea825d6645" args="(const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> is less than or equal to the specified <code>rhs</code>. One <code>stack</code> object is less than or equal to another if its underlying container is less than or equal to the other's underlying container. </p>

</div>
</div>
<a class="anchor" id="ga083c333856bdb6110947f806405c1cda"></a><!-- doxytag: member="bsl::operator&gt;=" ref="ga083c333856bdb6110947f806405c1cda" args="(const stack&lt; VALUE, CONTAINER &gt; &amp;lhs, const stack&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bsl::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> is greater than or equal to the specified <code>rhs</code>. One <code>stack</code> object is greater than or equal to another if its underlying container is greater than or equal to the other's underlying container. </p>

</div>
</div>
<a class="anchor" id="ga69a3b02c7015296255025773a76d7a8c"></a><!-- doxytag: member="bsl::swap" ref="ga69a3b02c7015296255025773a76d7a8c" args="(stack&lt; VALUE, CONTAINER &gt; &amp;lhs, stack&lt; VALUE, CONTAINER &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bsl::swap </td>
          <td>(</td>
          <td class="paramtype">stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stack&lt; VALUE, CONTAINER &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the contents of <code>lhs</code> and <code>rhs</code>. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> use the same allocator. </p>

</div>
</div>
<hr/><h2>Variable Documentation</h2>
<a class="anchor" id="gaab885033eb2a989a69d138d46d12fc90"></a><!-- doxytag: member="bsl::stack::c" ref="gaab885033eb2a989a69d138d46d12fc90" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">container_type&amp; <a class="el" href="classbsl_1_1stack.html">bsl::stack</a>&lt; VALUE, CONTAINER &gt;::c<code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>We are required by the standard to have the </p>

</div>
</div>
<hr/><h2>Friends</h2>
<a class="anchor" id="gaf30201118019d91cd8690f2726752e96"></a><!-- doxytag: member="bsl::stack::operator==" ref="gaf30201118019d91cd8690f2726752e96" args="(const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class VAL , class CONT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga966a7ded1d506afdf737e0cad5937979"></a><!-- doxytag: member="bsl::stack::operator!=" ref="ga966a7ded1d506afdf737e0cad5937979" args="(const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class VAL , class CONT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaf02d88c961086a38f6a636167f22a432"></a><!-- doxytag: member="bsl::stack::operator&lt;" ref="gaf02d88c961086a38f6a636167f22a432" args="(const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class VAL , class CONT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gab3c09766c44c1047991d764f0c9f7e8a"></a><!-- doxytag: member="bsl::stack::operator&gt;" ref="gab3c09766c44c1047991d764f0c9f7e8a" args="(const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class VAL , class CONT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga273a74c99b76badf1d16243752b5d77e"></a><!-- doxytag: member="bsl::stack::operator&lt;=" ref="ga273a74c99b76badf1d16243752b5d77e" args="(const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class VAL , class CONT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaeece956ed15cb6661c4bab83a2bf5622"></a><!-- doxytag: member="bsl::stack::operator&gt;=" ref="gaeece956ed15cb6661c4bab83a2bf5622" args="(const stack&lt; VAL, CONT &gt; &amp;, const stack&lt; VAL, CONT &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE , class CONTAINER  = deque&lt;VALUE&gt;&gt; </div>
<div class="memtemplate">
template&lt;class VAL , class CONT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1stack.html">stack</a>&lt; VAL, CONT &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:08 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
