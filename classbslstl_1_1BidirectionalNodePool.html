<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bslstl::BidirectionalNodePool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslstl.html">bslstl</a>      </li>
      <li><a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslstl::BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslstl::BidirectionalNodePool" -->
<p><code>#include &lt;<a class="el" href="bslstl__bidirectionalnodepool_8h_source.html">bslstl_bidirectionalnodepool.h</a>&gt;</code></p>

<p><a href="classbslstl_1_1BidirectionalNodePool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classbslstl_1_1SimplePool.html#a0942034bd664d85601a4f06ee0d7e8d0">Pool::AllocatorType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#abb295a3569c12aea953f2f37f78a93de">AllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorTraits::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a86718bca9aec0dd2b820fb1b16c63db1">size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a88d9e32275c2c22bc5bd759a09ffe8c2">BidirectionalNodePool</a> (const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#abb295a3569c12aea953f2f37f78a93de">AllocatorType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a4ec281896cf13af1997ce2220bf8609f">allocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#aee5935c04e238ee29e8d8d7956e4c2e0">createNode</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class SOURCE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#ac60074cabbc0e534fa6d0d894c0cee06">createNode</a> (const SOURCE &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FIRST_ARG , class SECOND_ARG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a6c3d73300caa6115d5fa13968e253e8e">createNode</a> (const FIRST_ARG &amp;first, const SECOND_ARG &amp;second)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#addbbd1eaf60f637ff303aaf2cc774e99">cloneNode</a> (const <a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#abd045b73dae98b346bc5454ed3e31c4a">deleteNode</a> (<a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *linkNode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#afc857cf4749719dc6b62f8af48fb457b">reserveNodes</a> (<a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a86718bca9aec0dd2b820fb1b16c63db1">size_type</a> numNodes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a2e346a6110a652da1098456c6903cd85">swapRetainAllocators</a> (<a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a98e5e8315662d88020dc3a71707c0224">swapExchangeAllocators</a> (<a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a09036a2f2eb9c668ae3fd47782f4aba6">release</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbslstl_1_1BidirectionalNodePool.html#abb295a3569c12aea953f2f37f78a93de">AllocatorType</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a2e3ce4c906c0a66c069031d1ce479998">allocator</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class VALUE, class ALLOCATOR&gt;<br/>
 class bslstl::BidirectionalNodePool&lt; VALUE, ALLOCATOR &gt;</h3>

<p>This class provides methods for creating and destroying nodes using the appropriate allocator-traits of the (template parameter) type <code>ALLOCATOR</code>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="abb295a3569c12aea953f2f37f78a93de"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::AllocatorType" ref="abb295a3569c12aea953f2f37f78a93de" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classbslstl_1_1SimplePool.html#a0942034bd664d85601a4f06ee0d7e8d0">Pool::AllocatorType</a> <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1BidirectionalNodePool.html#abb295a3569c12aea953f2f37f78a93de">AllocatorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a86718bca9aec0dd2b820fb1b16c63db1"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::size_type" ref="a86718bca9aec0dd2b820fb1b16c63db1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorTraits::size_type <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a86718bca9aec0dd2b820fb1b16c63db1">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a88d9e32275c2c22bc5bd759a09ffe8c2"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::BidirectionalNodePool" ref="a88d9e32275c2c22bc5bd759a09ffe8c2" args="(const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::<a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a> </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a></code> object that will use the specified <code>allocator</code> to supply memory for allocated node objects. If the (template parameter) <code>ALLOCATOR</code> is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then <code>allocator</code> shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4ec281896cf13af1997ce2220bf8609f"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::allocator" ref="a4ec281896cf13af1997ce2220bf8609f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#abb295a3569c12aea953f2f37f78a93de">AllocatorType</a>&amp; <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the allocator supplying memory for the memory pool maintained by this object. The behavior is undefined if the allocator used by this object is changed with this method. Note that this method provides modifiable access to enable a client to call non-'const' methods on the allocator. </p>

</div>
</div>
<a class="anchor" id="aee5935c04e238ee29e8d8d7956e4c2e0"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::createNode" ref="aee5935c04e238ee29e8d8d7956e4c2e0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::createNode </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a node of the type <code>BidirectionalNode&lt;VALUE&gt;</code>, and default construct an object of the (template parameter) type <code>VALUE</code> at the <code>value</code> attribute of the node. Return the address of the Node. Note that the <code>next</code> and <code>prev</code> attributes of the returned node will be uninitialized. </p>

</div>
</div>
<a class="anchor" id="ac60074cabbc0e534fa6d0d894c0cee06"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::createNode" ref="ac60074cabbc0e534fa6d0d894c0cee06" args="(const SOURCE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
<div class="memtemplate">
template&lt;class SOURCE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::createNode </td>
          <td>(</td>
          <td class="paramtype">const SOURCE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a node of the type <code>BidirectionalNode&lt;VALUE&gt;</code>, and construct an object of the (template parameter) type <code>VALUE</code>, using its single-argument constructor passing the specified <code>value</code> as the argument, at the <code>value</code> attribute of the node. Return the address of the node. Note that the <code>next</code> and <code>prev</code> attributes of the returned node will be uninitialized. </p>

</div>
</div>
<a class="anchor" id="a6c3d73300caa6115d5fa13968e253e8e"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::createNode" ref="a6c3d73300caa6115d5fa13968e253e8e" args="(const FIRST_ARG &amp;first, const SECOND_ARG &amp;second)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
<div class="memtemplate">
template&lt;class FIRST_ARG , class SECOND_ARG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::createNode </td>
          <td>(</td>
          <td class="paramtype">const FIRST_ARG &amp;&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SECOND_ARG &amp;&nbsp;</td>
          <td class="paramname"> <em>second</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a node of the type <code>BidirectionalNode&lt;VALUE&gt;</code>, and construct an object of the (template parameter) type <code>VALUE</code>, using its two-arguments constructor passing the specified <code>first</code> as the first argument and the specified <code>second</code> as the second argument, at the <code>value</code> attribute of the node. Return the address of the node. Note that the <code>next</code> and <code>prev</code> attributes of the returned node will be uninitialized. </p>

</div>
</div>
<a class="anchor" id="addbbd1eaf60f637ff303aaf2cc774e99"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::cloneNode" ref="addbbd1eaf60f637ff303aaf2cc774e99" args="(const bslalg::BidirectionalLink &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a>* <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::cloneNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a node of the type <code>BidirectionalNode&lt;VALUE&gt;</code>, and copy-construct an object of the (template parameter) type <code>VALUE</code> having the same value as the specified <code>original</code> at the <code>value</code> attribute of the node. Return the address of the node. Note that the <code>next</code> and <code>prev</code> attributes of the returned node will be uninitialized. </p>

</div>
</div>
<a class="anchor" id="abd045b73dae98b346bc5454ed3e31c4a"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::deleteNode" ref="abd045b73dae98b346bc5454ed3e31c4a" args="(bslalg::BidirectionalLink *linkNode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::deleteNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1BidirectionalLink.html">bslalg::BidirectionalLink</a> *&nbsp;</td>
          <td class="paramname"> <em>linkNode</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the <code>VALUE</code> attribute of the specified <code>linkNode</code> and return the memory footprint of <code>linkNode</code> to this pool for potential reuse. The behavior is undefined unless <code>node</code> refers to a <code><a class="el" href="classbslalg_1_1BidirectionalNode.html">bslalg::BidirectionalNode</a>&lt;VALUE&gt;</code> that was allocated by this pool. </p>

</div>
</div>
<a class="anchor" id="afc857cf4749719dc6b62f8af48fb457b"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::reserveNodes" ref="afc857cf4749719dc6b62f8af48fb457b" args="(size_type numNodes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::reserveNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a86718bca9aec0dd2b820fb1b16c63db1">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numNodes</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reserve memory from this pool to satisfy memory requests for at least the specified <code>numNodes</code> before the pool replenishes. The behavior is undefined unless <code>0 &lt; numNodes</code>. </p>

</div>
</div>
<a class="anchor" id="a2e346a6110a652da1098456c6903cd85"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::swapRetainAllocators" ref="a2e346a6110a652da1098456c6903cd85" args="(BidirectionalNodePool &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::swapRetainAllocators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the nodes of this object with those of the specified <code>other</code> object. This method provides the no-throw exception-safety guarantee. The behavior is undefined unless <code><a class="el" href="classbslstl_1_1BidirectionalNodePool.html#a4ec281896cf13af1997ce2220bf8609f">allocator()</a> == other.allocator()</code>. </p>

</div>
</div>
<a class="anchor" id="a98e5e8315662d88020dc3a71707c0224"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::swapExchangeAllocators" ref="a98e5e8315662d88020dc3a71707c0224" args="(BidirectionalNodePool &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::swapExchangeAllocators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1BidirectionalNodePool.html">BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the nodes and the allocator of this object with those of the specified <code>other</code> object. This method provides the no-throw exception-safety guarantee. </p>

</div>
</div>
<a class="anchor" id="a09036a2f2eb9c668ae3fd47782f4aba6"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::release" ref="a09036a2f2eb9c668ae3fd47782f4aba6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a2e3ce4c906c0a66c069031d1ce479998"></a><!-- doxytag: member="bslstl::BidirectionalNodePool::allocator" ref="a2e3ce4c906c0a66c069031d1ce479998" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbslstl_1_1BidirectionalNodePool.html#abb295a3569c12aea953f2f37f78a93de">AllocatorType</a>&amp; <a class="el" href="classbslstl_1_1BidirectionalNodePool.html">bslstl::BidirectionalNodePool</a>&lt; VALUE, ALLOCATOR &gt;::allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing non-modifiable access to the allocator supplying memory for the memory pool maintained by this object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslstl__bidirectionalnodepool_8h_source.html">bslstl_bidirectionalnodepool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:09 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
