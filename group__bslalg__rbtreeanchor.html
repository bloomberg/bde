<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslalg_rbtreeanchor Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslalg_rbtreeanchor<br/>
<small>
[<a class="el" href="group__bslalg.html">Package bslalg</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Encapsulate root, first, and last nodes of a tree with a count.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslalg.html">bslalg</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Sentinel Node</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Creating a Simple Tree</a> </li>
<li>
<a href="#3.2.2">Example 2: Creating an Insert Function for a Binary Tree</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Encapsulate root, first, and last nodes of a tree with a count. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslalg_1_1RbTreeAnchor.html">bslalg::RbTreeAnchor</a> </td><td>(in-core) node-addresses and node count  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslalg__rbtreenode.html" title="Provide a base class for a red-black binary tree node.">Component bslalg_rbtreenode</a>, <a class="el" href="group__bslalg__rbtreeutil.html" title="Provide a suite of primitive algorithms on red-black trees.">Component bslalg_rbtreeutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a single class, <code>RbTreeAnchor</code>, providing access to the addresses of the root, first, and sentinel nodes of a tree, as well as the count of the number of nodes. A sentinel node is a value-less node, owned by the <code>RbTreeAnchor</code> for the tree, that is used as the end-point for iteration over the nodes in a tree. <code>RbTreeAnchor</code> provides modifiers for the <code>firstNode</code>, <code>rootNode</code>, and <code>numNodes</code> properties, however the the sentinel node for a tree is located at a fixed address and cannot be modified. An <code>RbTreeAnchor</code> is similar to an in-core unconstrained attribute class, except that it does not supply equality-comparison, copy-construction, and copy-assignment operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="sentinel_node"></a> <a class="anchor" id="description.sentinel_node"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Sentinel Node: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The sentinel node is an <code>RbTreeNode</code> object which does not have a value, and provides a fixed end-point for navigation over the tree. However, a sentinel node's attributes have different interpretations than those of other <code>RbTreeNode</code> objects. Specifically, a sentinel node's <code>leftChild</code> refers to the root of the tree, and its <code>rightChild</code> refers to the first node of the tree. The following diagram shows the composition of a tree with <code>RbTreeAnchor</code> and <code>RbTreeNode</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">                        .------------------------.
                 .------|      RbTreeAnchor      |-------.
                 |      |                        |       |
       firstNode |      |    .--------------.    |       | rootNode
                 |      |    |  RbTreeNode  |    |       |
                 |      |    |  (sentinel)  |    |       |
                 |      |    `--------------<span class="stringliteral">&#39;    |       |</span>
<span class="stringliteral">                 |      |      /    ^      \     |       |</span>
<span class="stringliteral">                 |      `-----/-----|-------\----&#39;</span>       |
                 V           /      |        \           V
                  __________/       |         \__________
                 |                  |                    |
                 |                  |                    |
        sentinel |             root |                    | sentinel
   *right*-child |       parentNode |                    | *left*-child
                 |                  |                    |
                 |           .--------------.            |
                 |           |  RbTreeNode  | &lt;----------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                 |           |    (root)    |</span>
<span class="stringliteral">                 |           `--------------&#39;</span>
                 |                /   \.
                 |     .------------. .------------.
                 |     | RbTreeNode | | RbTreeNode |
                 |     `------------<span class="stringliteral">&#39; `------------&#39;</span>
                 |         /                \.
                 |    .-----------------------------.
                 |    |                             |
                 |    |    [Tree of RbTreeNodes]    |
                 |    |                             |
                 |    |_____________________________|
                 V   /                               \.
        .------------.                                .------------.
        | RbTreeNode |                                | RbTreeNode |
        |   (first)  |                                |   (last)   |
        `------------<span class="stringliteral">&#39;                                `------------&#39;</span>
</pre></div><br/>
<br/>
 Notice that, counter-intuitively, the sentinel's right-child refers to the left-most (first) node of the tree. Also notice that <code>RbTreeAnchor</code> doesn't hold a direct reference to the last (i.e., the right-most) node of the tree. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Simple Tree: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates creating a simple tree of integer values using <code>RbTreeAnchor</code>. Note that, in practice, clients should use associated utilities to manage such a tree (see <code>bslalg_rbtreeutil</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a node-type, <code>IntTreeNode</code>, that inherits from <code>RbTreeNode</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>IntTreeNode : <span class="keyword">public</span> RbTreeNode {
      <span class="comment">// A red-black tree node containing an integer data-value.</span>

      <span class="keywordtype">int</span> d_value;  <span class="comment">// &quot;payload&quot; value represented by the node</span>
  };
</pre></div><br/>
<br/>
 Then, we define <code>main</code> for our example, and create three nodes that we'll use to construct a tree: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keyword">const</span> <span class="keywordtype">char</span> *argv[])
  {
      IntTreeNode A, B, C;
</pre></div><br/>
<br/>
 Next, we create an <code>RbTreeAnchor</code>, <code>myTree</code>, which will hold the addresses of the root node and the first node of our tree along with a count of nodes, and then verify the attribute values of the default constructed object: <br/>
<br/>
<div class="fragment"><pre class="fragment">      RbTreeAnchor myTree;
      assert(0                 == myTree.rootNode());
      assert(myTree.sentinel() == myTree.firstNode());
      assert(0                 == myTree.numNodes());
</pre></div><br/>
<br/>
 Then, we describe the structure of the tree we wish to construct. <br/>
<br/>
<div class="fragment"><pre class="fragment">          A (value: 2, BLACK)
              /       \.
             /         \.
  B (value: 1, RED)   C ( value: 5, RED )
</pre></div><br/>
<br/>
 Next, we set the properties for the nodes <code>A</code>, <code>B</code>, and <code>C</code> to form a valid tree whose structure matches that description: <br/>
<br/>
<div class="fragment"><pre class="fragment">      A.d_value = 2;
      A.makeBlack();
      A.setParent(myTree.sentinel());
      A.setLeftChild(&amp;B);
      A.setRightChild(&amp;C);

      B.d_value = 1;
      B.makeRed();
      B.setParent(&amp;A);
      B.setLeftChild(0);
      B.setRightChild(0);

      C.d_value = 3;
      C.makeRed();
      C.setParent(&amp;A);
      C.setLeftChild(0);
      C.setRightChild(0);
</pre></div><br/>
<br/>
 Now, we assign the address of <code>A</code> and <code>B</code> as the root node and the first node of <code>myTree</code> respectively and set the number of nodes to 3: <br/>
<br/>
<div class="fragment"><pre class="fragment">      myTree.reset(&amp;A, &amp;B, 3);
</pre></div><br/>
<br/>
 Finally, we verify the attributes of <code>myTree</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(&amp;A == myTree.rootNode());
      assert(&amp;B == myTree.firstNode());
      assert(3  == myTree.numNodes());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Creating an Insert Function for a Binary Tree: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates creating a function that inserts elements into a binary search tree. Note that, for simplicity, this function does <em>not</em> create a balanced red-black tree (see <code>bslalg_rbtreeutil</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a comparison functor for <code>IntTreeNode</code> objects used by the insertion function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>IntTreeNodeComparator {
      <span class="comment">// This class defines a comparator providing a comparison operation</span>
      <span class="comment">// between two &#39;IntTreeNode&#39; objects.</span>

      <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> RbTreeNode&amp; lhs, <span class="keyword">const</span> RbTreeNode&amp; rhs)<span class="keyword">  const</span>
<span class="keyword">      </span>{
          <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>IntTreeNode&amp;<span class="keyword">&gt;</span>(lhs).d_value &lt;
                 static_cast&lt;const IntTreeNode&amp;&gt;(rhs).d_value;
      }
  };
</pre></div><br/>
<br/>
 Then, we declare the signature of a function <code>insertNode</code>, which takes three arguments: (1) the anchor of the tree in which to insert the node (2) the new node to insert into the tree, and (3) a comparator, which is used to compare the payload values of the tree nodes. Note that the parameterized comparator is needed because a node's value is not accessible through the supplied <code>RbTreeNode</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> NODE_COMPARATOR&gt;
  <span class="keywordtype">void</span> insertNode(RbTreeAnchor           *searchTree,
                  RbTreeNode             *newNode,
                  <span class="keyword">const</span> NODE_COMPARATOR&amp;  comparator)
      <span class="comment">// Insert into the specified &#39;searchTree&#39;, ordered according to the</span>
      <span class="comment">// specified &#39;comparator&#39;, the specified &#39;newNode&#39;.  If there are</span>
      <span class="comment">// multiple nodes having the same value as &#39;newNode&#39;, insert &#39;newNode&#39;</span>
      <span class="comment">// in the last position according to an infix traversal of the tree.</span>
      <span class="comment">// The behavior is undefined unless the &#39;comparator&#39; provides a</span>
      <span class="comment">// strict weak ordering on the nodes in the tree.</span>
  {
</pre></div><br/>
<br/>
 Next, we find the location where <code>newNode</code> can be inserted into <code>searchTree</code> without violating the ordering imposed by <code>comparator</code>, and then updates <code>searchTree</code> with a potentially updated root node and first node. <br/>
<br/>
<div class="fragment"><pre class="fragment">      RbTreeNode *parent = searchTree-&gt;sentinel();
      RbTreeNode *node   = searchTree-&gt;rootNode();
      <span class="keywordtype">bool</span>        isLeftChild;

      newNode-&gt;setLeftChild(0);
      newNode-&gt;setRightChild(0);

      <span class="keywordflow">if</span> (!node) {
</pre></div><br/>
<br/>
 If the root node of <code>searchTree</code> is 0, we use the <code>reset</code> function set the root node and the first node of <code>searchTree</code> to <code>newNode</code> and set the number of nodes to 1: <br/>
<br/>
<div class="fragment"><pre class="fragment">          searchTree-&gt;reset(newNode, newNode, 1);
          newNode-&gt;setParent(parent);
          <span class="keywordflow">return</span>;                                                   <span class="comment">// RETURN</span>
      }

      <span class="comment">// Find the leaf node that would be a valid parent of &#39;newNode&#39;.</span>

      <span class="keywordflow">do</span> {
          parent = node;
          isLeftChild = comparator(*newNode, *node);
          <span class="keywordflow">if</span> (isLeftChild) {
              node = parent-&gt;leftChild();
          }
          <span class="keywordflow">else</span> {
              node = parent-&gt;rightChild();
          }
      } <span class="keywordflow">while</span> (node);

      <span class="comment">// Insert &#39;newNode&#39; into &#39;searchTree&#39; and the location that&#39;s been</span>
      <span class="comment">// found.</span>
</pre></div><br/>
<br/>
 Then, we insert <code>newNode</code> into the appropriate position by setting it as a child of <code>parent</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (isLeftChild) {
          <span class="comment">// If &#39;newNode&#39; is a left-child, it may be the new first node, but</span>
          <span class="comment">// cannot be the new last node.</span>

          parent-&gt;setLeftChild(newNode);
          newNode-&gt;setParent(parent);
          <span class="keywordflow">if</span> (parent == searchTree-&gt;firstNode()) {
              searchTree-&gt;setFirstNode(newNode);
          }
      }
      <span class="keywordflow">else</span> {
          parent-&gt;setRightChild(newNode);
          newNode-&gt;setParent(parent);
      }
</pre></div><br/>
<br/>
 Next, we complete the insert function by incrementing the number of nodes in the tree: <br/>
<br/>
<div class="fragment"><pre class="fragment">      searchTree-&gt;incrementNumNodes();
  }
</pre></div><br/>
<br/>
 Now, we create 5 <code>IntTreeNode</code> objects and insert them into a tree using the <code>insertNode</code> function. <br/>
<br/>
<div class="fragment"><pre class="fragment">  IntTreeNode nodes[5];

  nodes[0].d_value = 3;
  nodes[1].d_value = 1;
  nodes[2].d_value = 5;
  nodes[3].d_value = 2;
  nodes[4].d_value = 0;

  IntTreeNodeComparator comparator;

  RbTreeAnchor anchor;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 5; ++i) {
      insertNode(&amp;anchor, nodes + i, comparator);
  }
</pre></div><br/>
<br/>
 Finally, we verify that the <code>RbTreeAnchor</code> refers to the correct <code>TreeNode</code> with its <code>firstNode</code> and <code>rootNode</code> attributes. <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(0 == static_cast&lt;IntTreeNode *&gt;(anchor.firstNode())-&gt;d_value);
  assert(3 == static_cast&lt;IntTreeNode *&gt;(anchor.rootNode())-&gt;d_value);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:41 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
