<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// btlso_event.h                                                      -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BTLSO_EVENT
#define INCLUDED_BTLSO_EVENT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide component to describe an event on a socket.
//
//@CLASSES:
//  btlso::Event: representation of an event on a socket
//  btlso::EventHash: namespace for a hash function
//
//@DESCRIPTION: This component provides an unconstrained (value-semantic)
// attribute class, &#39;btlso::Event&#39;, which represents an event on a particular
// socket.  The two attributes are the socket handle and the event type.  The
// recognized events are &#39;btlso::EventType::e_ACCEPT&#39;,
// &#39;btlso::EventType::e_CONNECT&#39;, &#39;btlso::EventType::e_READ&#39;, and
// &#39;btlso::EventType::e_WRITE&#39;.  Accessors and manipulators are provided for
// the socket handle and the event type.  In order to facilitate storing
// &#39;btlso::Event&#39; objects into associative containers, a hash functor,
// &#39;btlso::EventHash&#39;, is also provided.
//
///Attributes
///----------
//..
//  Name    Type                 Constraints
//  ------  ----                 -----------
//  handle  SocketHandle::Handle none
//  type    EventType::Type      none
//..
//: o &#39;handle&#39;: The socket handle on which the event is registered.
//:
//: o &#39;type&#39;: The event type corresponding to the event registered.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Implementing an Event Manager
/// - - - - - - - - - - - - - - - - - - - -
// First, we define a class, &#39;my_EventManager&#39;, that allows clients to register
// an asynchronous callback that is invoked when a certain event on a socket
// handle is complete.  As an example, objects of this class would allow users
// to register a read callback that is invoked when there is data available on
// a socket.
//
// The definition of the &#39;my_EventManager&#39; class is provided below with
// non-relevant portions elided for brevity:
//..
//  class my_EventManager {
//      // This class allows clients to register asynchronous callbacks that
//      // are invoked when certain events fire on a socket handle.
//
//    public:
//      // TYPES
//      typedef bsl::function&lt;void()&gt; Callback;
//
//    private:
//      typedef bsl::unordered_map&lt;btlso::Event,
//                                 Callback,
//                                 btlso::EventHash&gt; CallbacksMap;
//
//      // DATA
//      CallbacksMap d_callbacks;
//
//      . . .
//
//    public:
//      // CREATORS
//      my_EventManager(bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;my_EventManager&#39; object.  Optionally specify a
//          // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is
//          // 0, the currently installed default allocator is used.
//
//      ~my_EventManager();
//
//      // MANIPULATORS
//      int registerEvent(btlso::SocketHandle::Handle handle,
//                        btlso::EventType::Type      eventType,
//                        Callback&amp;                   callback);
//          // Register the specified &#39;callback&#39; to be invoked when the
//          // specified &#39;eventType&#39; fires on the specified &#39;handle&#39;.  Return
//          // 0 on success and non-zero value otherwise.
//
//      . . .
//  };
//..
// Then, we provide the function definitions for the &#39;my_EventManager&#39; class:
//..
//  // CREATORS
//  my_EventManager::my_EventManager(bslma::Allocator *basicAllocator)
//  : d_callbacks(basicAllocator)
//  {
//  }
//
//  my_EventManager::~my_EventManager()
//  {
//  }
//
//  // MANIPULATORS
//  int my_EventManager::registerEvent(btlso::SocketHandle::Handle handle,
//                                     btlso::EventType::Type      eventType,
//                                     Callback&amp;                   callback)
//  {
//..
// Next, we create a &#39;btlso_Event&#39; object
//..
//      btlso::Event event(handle, eventType);
//..
// Then, we confirm if a callback is already registered for &#39;event&#39;.  If so we
// simply update the callback:
//..
//      CallbacksMap::iterator iter = d_callbacks.find(event);
//      if (d_callbacks.end() != iter) {
//          iter-&gt;second = callback;
//          return 0;
//      }
//..
// Next, we add the event to the callbacks map:
//..
//      bool insertedEvent = d_callbacks.insert(
//                                     bsl::make_pair(event, callback)).second;
//      assert(insertedEvent);
//
//      return 0;
//  }
//..
// Now, we specify a read callback:
//..
//  void readCallback(btlso::SocketHandle::Handle handle)
//      // Process data read from the specified &#39;handle&#39;.
//  {
//      // . . .
//  }
//..
// Finally, we construct a &#39;my_EventManager&#39; object and register an event:
//..
//      my_EventManager             manager;
//
//      btlso::SocketHandle::Handle handle;
//
//      // Open the socket &#39;handle&#39;
//
//      // . . .
//
//      btlso::EventType::Type    eventType = btlso::EventType::e_READ;
//      my_EventManager::Callback callback  = bdlf::BindUtil::bind(
//                                                               &amp;readCallback,
//                                                               handle);
//
//      const int rc = manager.registerEvent(handle, eventType, callback);
//      assert(0 == rc);
//..

#ifndef INCLUDED_BTLSCM_VERSION
#include &lt;btlscm_version.h&gt;
#endif

#ifndef INCLUDED_BTLSO_SOCKETHANDLE
#include &lt;btlso_sockethandle.h&gt;
#endif

#ifndef INCLUDED_BTLSO_EVENTTYPE
#include &lt;btlso_eventtype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

namespace BloombergLP {

namespace btlso {

                             // ===========
                             // class Event
                             // ===========

class Event {
    // This attribute class represents an event on a socket.  The recognized
    // events are &#39;btlso::EventType::e_ACCEPT&#39;, &#39;btlso::EventType::e_CONNECT&#39;,
    // &#39;btlso::EventType::e_READ&#39;, and &#39;btlso::EventType::e_WRITE&#39;.  Accessors
    // and manipulators are provided for the socket handle and the event type.

    // DATA
    SocketHandle::Handle d_handle;
    EventType::Type      d_type;

    // FRIENDS
    friend bool operator==(const Event&amp; lhs, const Event&amp; rhs);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(Event, bsl::is_trivially_copyable)

    // CREATORS
    Event(const SocketHandle::Handle&amp; handle, const EventType::Type type);
        // Construct an &#39;Event&#39; object corresponding to the specified event
        // &#39;type&#39; on the specified socket &#39;handle&#39;.

    Event(const Event&amp; original);
        // Create an &#39;Event&#39; object having the same value as the specified
        // &#39;original&#39; object.

    ~Event();
        // Destroy this event object.

    // MANIPULATORS
    void setHandle(const SocketHandle::Handle&amp; handle);
        // Reset the handle stored by this object to the specified &#39;handle&#39;.
        // The type remains unchanged.

    void setType(EventType::Type type);
        // Reset the type stored by this object to the specified &#39;type&#39;.  The
        // socket handle remains unchanged.

    // ACCESSORS
    SocketHandle::Handle handle() const;
        // Get the socket handle of this event.

    EventType::Type type() const;
        // Get the type of this event.
};

// FREE OPERATORS
bool operator==(const Event&amp; lhs, const Event&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; events have the same
    // value, and &#39;false&#39; otherwise.  Two events have the same value if and
    // only if they have the same socket handle and event type field values.

bool operator!=(const Event&amp; lhs, const Event&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; events do not have the
    // same value, and &#39;false&#39; otherwise.  Two events have the same value if
    // and only if they have the same socket handle and event type field
    // values.

                           // ===============
                           // class EventHash
                           // ===============

struct EventHash {
    // This &#39;struct&#39; provides a functor that computes a hash value for a
    // &#39;Event&#39; object, and is suitable for use with &#39;bsl::unordered_map&#39; or
    // other unordered associative containers.

    // ACCESSORS
    bsl::size_t operator()(const Event&amp; event) const;
        // Return the hash value for the specified &#39;event&#39;.
};

// ============================================================================
//                        INLINE FUNCTION DEFINITIONS
// ============================================================================

                             // -----------
                             // class Event
                             // -----------

// CREATORS
inline
Event::Event(const Event&amp; original)
: d_handle(original.d_handle)
, d_type(original.d_type)
{
}

inline
Event::Event(const SocketHandle::Handle&amp; handle, const EventType::Type type)
: d_handle(handle)
, d_type(type)
{
}

inline
Event::~Event()
{
}

// MANIPULATORS
inline
void Event::setHandle(const SocketHandle::Handle&amp; handle)
{
    d_handle = handle;
}

inline
void Event::setType(const EventType::Type type)
{
    d_type = type;
}

// ACCESSORS
inline
SocketHandle::Handle Event::handle() const
{
    return d_handle;
}

inline
EventType::Type Event::type() const
{
    return d_type;
}

}  // close package namespace

// FREE OPERATORS
inline
bool btlso::operator==(const Event&amp; lhs, const Event&amp; rhs)
{
    return lhs.d_handle == rhs.d_handle &amp;&amp; lhs.d_type == rhs.d_type;
}

inline
bool btlso::operator!=(const Event&amp; lhs, const Event&amp; rhs)
{
    return !(lhs == rhs);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
