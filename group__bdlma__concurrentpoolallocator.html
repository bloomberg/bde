<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlma_concurrentpoolallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_concurrentpoolallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide thread-safe memory-pooling allocator of fixed-size blocks.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Protocol Hierarchy</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Uniform Sized Allocations</a> </li>
<li>
<a href="#3.2.2">Example 2: Variable Allocation Size</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide thread-safe memory-pooling allocator of fixed-size blocks. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> </td><td>thread-safe allocator of pooled blocks  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a class, <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code>, that implements the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol and provides a thread-safe allocator of pooled memory blocks of uniform size (the "pooled size"). The pooled size is either (1) configured at construction, or (2) equal to the size of the first block allocated through the allocator. All of the allocation requests of sizes up to the pooled size are satisfied with blocks from the underlying pool. All requests of sizes larger than the pooled size will be satisfied through the external allocator (the allocator supplied at construction, or the default allocator if no allocator was provided). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="protocol_hierarchy"></a> <a class="anchor" id="description.protocol_hierarchy"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Protocol Hierarchy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The interface hierarchy (defined by direct public inheritance) of <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> is as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,-------------------.
  ( <a class="code" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> )
   `-------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">             |       ctor/dtor</span>
<span class="stringliteral">             |       objectSize</span>
<span class="stringliteral">             V</span>
<span class="stringliteral">     ,----------------.</span>
<span class="stringliteral">    ( bslma::Allocator )</span>
<span class="stringliteral">     `----------------&#39;</span>
                     allocate
                     deallocate
</pre></div><br/>
<br/>
 <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> provides a concrete, thread-safe implementation of the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> is intended to be used in either of the following two cases. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The first case is where frequent allocation and deallocation of memory occurs through the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol and all of the allocated blocks have the same size. In this case, the size of blocks to pool is determined the first time <code>allocate</code> is called and need not be specified at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The second case is where frequent allocation and deallocation of memory occurs through the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> protocol, most of the allocations have similar sizes, and a likely maximum for the largest allocation is known at the time of construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_uniform_sized_allocations"></a> <a class="anchor" id="usage.example_1~3A_uniform_sized_allocations"></a> <a class="anchor" id="description.usage.example_1~3A_uniform_sized_allocations"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Uniform Sized Allocations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates the use of <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> when all allocations are of uniform size. A <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> is used in the implementation of a "work
 queue" where each "item" enqueued by a producer thread is of identical size. Concurrently, a consumer dequeues each work item when it becomes available, verifies the content (a sequence number in ASCII), and deallocates the work item. The concurrent allocations and deallocations are valid because <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> is thread-safe. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, an abstract of the example will be given with focus and commentary on the relevant details of <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code>. Details pertaining to queue management, thread creation, thread synchronization, etc., can be seen in the full listing at the end of this example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The parent thread creates the <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> and work queue by the statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> poolAlloc;
  my1_WorkQueue queue(&amp;poolAlloc);
</pre></div><br/>
<br/>
 Note that since the default constructor is used to create <code>poolAlloc</code>, the pooled size has not yet been fixed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The work queue is defined by the following data structures. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my1_WorkItem {
      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> *d_item;  <span class="comment">// represents work to perform</span>
  };

  <span class="keyword">struct </span>my1_WorkQueue {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;my1_WorkItem&gt;</a>  d_queue;    <span class="comment">// queue of work requests</span>
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>             d_mx;       <span class="comment">// protects the shared queue</span>
      <a class="code" href="classbslmt_1_1Condition.html">bslmt::Condition</a>         d_cv;       <span class="comment">// signals existence of new work</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>        *d_alloc_p;  <span class="comment">// pooled allocator</span>

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my1_WorkQueue(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_alloc_p(bslma::Default::allocator(basicAllocator))
      {
      }
  };
</pre></div><br/>
<br/>
 The producer and consumer threads are given the address of the work queue as their sole argument. Here, the producer allocates a work item, initializes it with a sequence number in ASCII, enqueues it, and signals its presence to the consumer thread. This action is done 50 times, and then a 51st, empty work item is added to inform the consumer of the end of the queue. The first allocation of a work item (100 bytes) fixes the pooled size. Each subsequent allocation is that same size (100 bytes). The producer's actions are shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
  <span class="keywordtype">void</span> *my1_producer(<span class="keywordtype">void</span> *arg)
  {
      my1_WorkQueue *queue = (my1_WorkQueue *)arg;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; ++i) {
          <span class="keywordtype">char</span> b[100];
          bsl::sprintf(b, <span class="stringliteral">&quot;%d&quot;</span>, i);
          <span class="keywordtype">int</span> len = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(bsl::strlen(b));

          my1_WorkItem request;

          <span class="comment">// Fixed allocation size sufficient for content.</span>

          request.d_item = (<span class="keywordtype">char</span> *)queue-&gt;d_alloc_p-&gt;allocate(100);

          bsl::memcpy(request.d_item, b, len+1);

          <span class="comment">// Enqueue item and signal any waiting threads.</span>
          <span class="comment">// ...</span>
      }

      <span class="comment">// Add empty item.</span>
      <span class="comment">// ...</span>

      <span class="keywordflow">return</span> queue;
  }
</pre></div><br/>
<br/>
 When the consumer thread finds that the queue is not empty it dequeues the item, verifies its content (a sequence number in ASCII), returns the work item to the pool, and checks for the next item. If the queue is empty, the consumer blocks until signaled by the producer. An empty work item indicates that the producer will send no more items, so the consumer exits. The consumer's actions are shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span>
  <span class="keywordtype">void</span> *my1_consumer(<span class="keywordtype">void</span> *arg)
  {
      my1_WorkQueue *queue = (my1_WorkQueue *)arg;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; ; ++i) {

          <span class="comment">// Block until work item on queue.</span>
          <span class="comment">// ...</span>

          <span class="comment">// Dequeue item.</span>
          <span class="comment">// ...</span>

          <span class="comment">// Break when end-of-work item received.</span>
          <span class="comment">// ...</span>

          <span class="keywordtype">char</span> b[100];
          bsl::sprintf(b, <span class="stringliteral">&quot;%d&quot;</span>, i);
          assert(bsl::strcmp(b, item.d_item) == 0);   <span class="comment">// check content</span>

          queue-&gt;d_alloc_p-&gt;deallocate(item.d_item);  <span class="comment">// deallocate</span>
      }

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 A complete listing of the example's structures and functions follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my1_WorkItem {
      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> *d_item;  <span class="comment">// represents work to perform</span>
  };

  <span class="keyword">struct </span>my1_WorkQueue {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;my1_WorkItem&gt;</a>  d_queue;    <span class="comment">// queue of work requests</span>
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>             d_mx;       <span class="comment">// protects the shared queue</span>
      <a class="code" href="classbslmt_1_1Condition.html">bslmt::Condition</a>         d_cv;       <span class="comment">// signals existence of new work</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>        *d_alloc_p;  <span class="comment">// pooled allocator</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my1_WorkQueue(<span class="keyword">const</span> my1_WorkQueue&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my1_WorkQueue(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_alloc_p(bslma::Default::allocator(basicAllocator))
      {
      }
  };

  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *my1_producer(<span class="keywordtype">void</span> *arg)
  {
      my1_WorkQueue *queue = (my1_WorkQueue *)arg;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; ++i) {

          <span class="keywordtype">char</span> b[100];
          bsl::sprintf(b, <span class="stringliteral">&quot;%d&quot;</span>, i);
          <span class="keywordtype">int</span> len = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(bsl::strlen(b));

          my1_WorkItem request;
          request.d_item = (<span class="keywordtype">char</span> *)queue-&gt;d_alloc_p-&gt;allocate(100);
          bsl::memcpy(request.d_item, b, len+1);

          <span class="keywordflow">if</span> (veryVerbose) {
              <span class="comment">// Assume thread-safe implementations of &#39;cout&#39; and &#39;endl&#39;</span>
              <span class="comment">// exist (named &#39;MTCOUT&#39; and &#39;MTENDL&#39;, respectively).</span>

              MTCOUT &lt;&lt; <span class="stringliteral">&quot;Enqueuing &quot;</span> &lt;&lt; request.d_item &lt;&lt; MTENDL;
          }

          queue-&gt;d_mx.lock();
          queue-&gt;d_queue.push_back(request);
          queue-&gt;d_mx.unlock();
          queue-&gt;d_cv.signal();
      }

      my1_WorkItem request;
      request.d_item = 0;

      queue-&gt;d_mx.lock();
      queue-&gt;d_queue.push_back(request);
      queue-&gt;d_mx.unlock();
      queue-&gt;d_cv.signal();

      <span class="keywordflow">return</span> queue;
  }

  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *my1_consumer(<span class="keywordtype">void</span> *arg)
  {
      my1_WorkQueue *queue = (my1_WorkQueue *)arg;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; ; ++i) {

          queue-&gt;d_mx.lock();
          <span class="keywordflow">while</span> (0 == queue-&gt;d_queue.size()) {
              queue-&gt;d_cv.wait(&amp;queue-&gt;d_mx);
          }

          my1_WorkItem item = queue-&gt;d_queue.front();
          queue-&gt;d_queue.pop_front();
          queue-&gt;d_mx.unlock();

          <span class="keywordflow">if</span> (0 == item.d_item) {
              <span class="keywordflow">break</span>;
          }

          <span class="comment">// Process the work requests.</span>
          <span class="keywordflow">if</span> (veryVerbose) {
              <span class="comment">// Assume thread-safe implementations of &#39;cout&#39; and &#39;endl&#39;</span>
              <span class="comment">// exist (named &#39;MTCOUT&#39; and &#39;MTENDL&#39;, respectively).</span>

              MTCOUT &lt;&lt; <span class="stringliteral">&quot;Processing &quot;</span> &lt;&lt; item.d_item &lt;&lt; MTENDL;
          }

          <span class="keywordtype">char</span> b[100];
          bsl::sprintf(b, <span class="stringliteral">&quot;%d&quot;</span>, i);
          assert(bsl::strcmp(b, item.d_item) == 0);

          queue-&gt;d_alloc_p-&gt;deallocate(item.d_item);
      }

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 In the application <code>main</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <a class="code" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> poolAlloc;
      my1_WorkQueue queue(&amp;poolAlloc);

      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> attributes;

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> producerHandle;
      <span class="keywordtype">int</span> status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;producerHandle,
                                             attributes,
                                             &amp;my1_producer,
                                             &amp;queue);
      assert(0 == status);

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> consumerHandle;
      status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;consumerHandle,
                                         attributes,
                                         &amp;my1_consumer,
                                         &amp;queue);
      assert(0 == status);
      status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(consumerHandle);
      assert(0 == status);
      status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(producerHandle);
      assert(0 == status);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_variable_allocation_size"></a> <a class="anchor" id="usage.example_2~3A_variable_allocation_size"></a> <a class="anchor" id="description.usage.example_2~3A_variable_allocation_size"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Variable Allocation Size: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates the use of <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> when allocations are of varying size. A <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> is used in the implementation of a "work
 queue" where each "item" enqueued by a producer thread varies in size, but all items are smaller than a known maximum. Concurrently, a consumer thread dequeues each work item when it is available, verifies its content (a sequence number in ASCII), and deallocates the work item. The concurrent allocations and deallocations are valid because <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> is thread-safe. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, an abstract of the example will be given with focus and commentary on the relevant details of <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code>. Details pertaining to queue management, thread creation, thread synchronization, etc., can be seen in the full listing at the end of this example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The parent thread creates the <code><a class="el" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a></code> and work queue by the statements: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> poolAlloc(100);
  my1_WorkQueue queue(&amp;poolAlloc);
</pre></div><br/>
<br/>
 Note that the pooled size (100) is specified in the construction of <code>poolAlloc</code>. Any requests in excess of that size will be satisfied by implicit calls to the default allocator, not from the underlying pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The work queue is defined by the following data structures. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my2_WorkItem {
      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> *d_item;  <span class="comment">// represents work to perform</span>
  };

  <span class="keyword">struct </span>my2_WorkQueue {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;my2_WorkItem&gt;</a>  d_queue;    <span class="comment">// queue of work requests</span>
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>             d_mx;       <span class="comment">// protects the shared queue</span>
      <a class="code" href="classbslmt_1_1Condition.html">bslmt::Condition</a>         d_cv;       <span class="comment">// signals existence of new work</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>        *d_alloc_p;  <span class="comment">// pooled allocator</span>

      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my2_WorkQueue(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_queue(basic_Allocator)
      , d_alloc_p(bslma::Default::allocator(basic_Allocator))
      {
      }
  };
</pre></div><br/>
<br/>
 In this example (unlike Example 1), the given allocator is used not only for the work items, but is also passed to the constructor of <code>d_queue</code> so that it also serves memory for the operations of <code><a class="el" href="classbsl_1_1list.html">bsl::list</a>&lt;my2_WorkItem&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The producer and consumer threads are given the address of the work queue as their sole argument. Here, the producer allocates a work item, initializes it with a sequence number in ASCII, enqueues it, and signals its presence to the consumer thread. The action is done 50 times, and then a 51st, empty work item is added to inform the consumer of the end of the queue. In this example, each work item is sized to match the length of its contents, the sequence number in ASCII. The producer's actions are shown below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *my2_producer(<span class="keywordtype">void</span> *arg)
  {
      my2_WorkQueue *queue = (my2_WorkQueue *)arg;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; ++i) {

          <span class="keywordtype">char</span> b[100];
          bsl::sprintf(b, <span class="stringliteral">&quot;%d&quot;</span>, i);
          <span class="keywordtype">int</span> len = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(bsl::strlen(b));

          my2_WorkItem request;

          <span class="comment">// Allocate item to exactly match space needed for content.</span>

          request.d_item = (<span class="keywordtype">char</span> *)queue-&gt;d_alloc_p-&gt;allocate(len+1);

          bsl::memcpy(request.d_item, b, len+1);

          <span class="comment">// Enqueue item and signal any waiting threads.</span>
          <span class="comment">// ...</span>
      }

      <span class="comment">// Add empty item.</span>
      <span class="comment">// ...</span>

      <span class="keywordflow">return</span> queue;
  }
</pre></div><br/>
<br/>
 The actions of this consumer thread are essentially the same as those of the consumer thread in Example 1. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the consumer thread finds that the queue is not empty, it dequeues the item, verifies its content (a sequence number in ASCII), returns the work item to the pool, and checks for the next item. If the queue is empty, the consumer blocks until signaled by the producer. An empty work item indicates that the producer will send no more items, so the consumer exits. The consumer's actions are shown below. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *my2_consumer(<span class="keywordtype">void</span> *arg)
  {
      my2_WorkQueue *queue = (my2_WorkQueue *)arg;

      <span class="keywordflow">while</span> (<span class="keywordtype">int</span> i = 0; ; ++i) {

          <span class="comment">// Block until work item on queue.</span>
          <span class="comment">// ...</span>

          <span class="comment">// Deque item.</span>
          <span class="comment">// ...</span>

          <span class="comment">// Break when end-of-work item received.</span>
          <span class="comment">// ...</span>

          <span class="keywordtype">char</span> b[100];
          bsl::sprintf(b, <span class="stringliteral">&quot;%d&quot;</span>, i);
          assert(bsl::strcmp(b, item.d_item) == 0);   <span class="comment">// verify content</span>

          queue-&gt;d_alloc_p-&gt;deallocate(item.d_item);  <span class="comment">// deallocate</span>
      }

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 A complete listing of the example's structures and functions follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>my2_WorkItem {
      <span class="comment">// DATA</span>
      <span class="keywordtype">char</span> *d_item;  <span class="comment">// represents work to perform</span>
  };

  <span class="keyword">struct </span>my2_WorkQueue {
      <span class="comment">// DATA</span>
      <a class="code" href="classbsl_1_1list.html">bsl::list&lt;my2_WorkItem&gt;</a>  d_queue;    <span class="comment">// queue of work requests</span>
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>             d_mx;       <span class="comment">// protects the shared queue</span>
      <a class="code" href="classbslmt_1_1Condition.html">bslmt::Condition</a>         d_cv;       <span class="comment">// signals existence of new work</span>
      <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a>        *d_alloc_p;  <span class="comment">// pooled allocator</span>

    <span class="keyword">private</span>:
      <span class="comment">// Not implemented:</span>
      my2_WorkQueue(<span class="keyword">const</span> my2_WorkQueue&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> my2_WorkQueue(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
      : d_queue(basicAllocator)
      , d_alloc_p(basicAllocator)
      {
      }
  };

  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *my2_producer(<span class="keywordtype">void</span> *arg)
  {
      my2_WorkQueue *queue = (my2_WorkQueue *)arg;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 50; ++i) {

          <span class="keywordtype">char</span> b[100];
          bsl::sprintf(b, <span class="stringliteral">&quot;%d&quot;</span>, i);
          <span class="keywordtype">int</span> len = <span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span><span class="keyword">&gt;</span>(bsl::strlen(b));

          my2_WorkItem request;
          request.d_item = (<span class="keywordtype">char</span> *)queue-&gt;d_alloc_p-&gt;allocate(len+1);
          bsl::memcpy(request.d_item, b, len+1);

          <span class="keywordflow">if</span> (veryVerbose) {
              <span class="comment">// Assume thread-safe implementations of &#39;cout&#39; and &#39;endl&#39;</span>
              <span class="comment">// exist (named &#39;MTCOUT&#39; and &#39;MTENDL&#39;, respectively).</span>

              MTCOUT &lt;&lt; <span class="stringliteral">&quot;Enqueuing &quot;</span> &lt;&lt; request.d_item &lt;&lt; MTENDL;
          }

          queue-&gt;d_mx.lock();
          queue-&gt;d_queue.push_back(request);
          queue-&gt;d_mx.unlock();
          queue-&gt;d_cv.signal();
      }

      my2_WorkItem request;
      request.d_item = 0;

      queue-&gt;d_mx.lock();
      queue-&gt;d_queue.push_back(request);
      queue-&gt;d_mx.unlock();
      queue-&gt;d_cv.signal();

      <span class="keywordflow">return</span> queue;
  }

  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *my2_consumer(<span class="keywordtype">void</span> *arg)
  {
      my2_WorkQueue *queue = (my2_WorkQueue *)arg;

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; ; ++i) {

          queue-&gt;d_mx.lock();
          <span class="keywordflow">while</span> (0 == queue-&gt;d_queue.size()) {
              queue-&gt;d_cv.wait(&amp;queue-&gt;d_mx);
          }

          my2_WorkItem item = queue-&gt;d_queue.front();
          queue-&gt;d_queue.pop_front();
          queue-&gt;d_mx.unlock();

          <span class="keywordflow">if</span> (0 == item.d_item) {
              <span class="keywordflow">break</span>;
          }

          <span class="comment">// Process the work requests.</span>
          <span class="keywordflow">if</span> (veryVerbose) {
              <span class="comment">// Assume thread-safe implementations of &#39;cout&#39; and &#39;endl&#39;</span>
              <span class="comment">// exist (named &#39;MTCOUT&#39; and &#39;MTENDL&#39;, respectively).</span>

              MTCOUT &lt;&lt; <span class="stringliteral">&quot;Processing &quot;</span> &lt;&lt; item.d_item &lt;&lt; MTENDL;
          }

          <span class="keywordtype">char</span> b[100];
          bsl::sprintf(b, <span class="stringliteral">&quot;%d&quot;</span>, i);
          assert(bsl::strcmp(b, item.d_item) == 0);

          queue-&gt;d_alloc_p-&gt;deallocate(item.d_item);
      }

      <span class="keywordflow">return</span> 0;
  }
</pre></div><br/>
<br/>
 In the application's <code>main</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  {
      <a class="code" href="classbdlma_1_1ConcurrentPoolAllocator.html">bdlma::ConcurrentPoolAllocator</a> poolAlloc(100);
      my2_WorkQueue queue(&amp;poolAlloc);

      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> attributes;

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> producerHandle;
      <span class="keywordtype">int</span> status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;producerHandle,
                                            attributes,
                                            &amp;my2_producer,
                                            &amp;queue);
      assert(0 == status);

      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> consumerHandle;
      status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;consumerHandle,
                                        attributes,
                                        &amp;my2_consumer,
                                        &amp;queue);
      assert(0 == status);
      status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(consumerHandle);
      assert(0 == status);
      status = <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(producerHandle);
      assert(0 == status);
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:45 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
