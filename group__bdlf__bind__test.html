<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlf_bind_test Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlf_bind_test<br/>
<small>
[<a class="el" href="group__bdlf.html">Package bdlf</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a test apparatus for bdlf_bind.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlf.html">bdlf</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Testing <code>bdlf::Bind</code> <em>Without</em> Allocators</a> </li>
<li>
<a href="#3.1.2">Testing <code>bdlf_bind</code> <em>With</em> Allocators</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a test apparatus for bdlf_bind. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbdlf_1_1Bind__TestUtil.html">bdlf::Bind_TestUtil</a> </td><td>utility class for static test methods  </td></tr>
<tr>
<td><a class="el" href="structbdlf_1_1Bind__TestSlotsBase.html">bdlf::Bind_TestSlotsBase</a> </td><td>base class for tracking arg &amp; alloc objects  </td></tr>
<tr>
<td><a class="el" href="classbdlf_1_1Bind__TestArgNoAlloc.html">bdlf::Bind_TestArgNoAlloc</a> </td><td>argument type parameterized by index  </td></tr>
<tr>
<td><a class="el" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a> </td><td>invocable supporting up to 14 arguments  </td></tr>
<tr>
<td><a class="el" href="structbdlf_1_1Bind__TestFunctionsNoAlloc.html">bdlf::Bind_TestFunctionsNoAlloc</a> </td><td>global versions of test type methods  </td></tr>
<tr>
<td><a class="el" href="classbdlf_1_1Bind__TestArgAlloc.html">bdlf::Bind_TestArgAlloc</a> </td><td>argument type parameterized by index  </td></tr>
<tr>
<td><a class="el" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a> </td><td>invocable supporting up to 14 arguments  </td></tr>
<tr>
<td><a class="el" href="structbdlf_1_1Bind__TestFunctionsAlloc.html">bdlf::Bind_TestFunctionsAlloc</a> </td><td>global versions of test type methods  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlf__bind.html" title="Provide a signature-specific function object (functor).">Component bdlf_bind</a> <a class="el" href="group__bdlf__bind__test.html" title="Provide a test apparatus for bdlf_bind.">Component bdlf_bind_test</a>[0--14] </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a test apparatus for testing the <code>bdlf_bind</code> component. This apparatus would usually be part of the test driver of that component, but is factored out in this component since the <code>bdlf_bind</code> test driver is so large and induces such long compilation times that the testing has been delegated to many components <code>bdlf_bind_test[0-14]</code> whose sole purpose is to share the testing <code>bdlf_bind</code>. Thus this component provides all the common apparatus for these delegate components. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This apparatus comprises test classes for tracking argument values and allocators, using a slot mechanism. In the case of a test class that does <em>not</em> take allocators, the slot at any index contains an integer which tracks the value of the argument with same index that was passed to the test type invocation. In the case of a test class that <em>does</em> take allocators, the slot at any index contains the address of the allocator used to allocate the value of the argument with same index that was passed to the test type invocation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The two test types provided, <code><a class="el" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a></code> and <code><a class="el" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a></code> support this slot mechanism. They are invocable with up to 14 parameters, either as function objects (using <code>operator()</code>), via member functions (using the <code>testFunc[0--14]</code> methods), or via global functions that take a pointer to the object as first argument (provided as static methods of the utility classes <code><a class="el" href="structbdlf_1_1Bind__TestFunctionsNoAlloc.html">bdlf::Bind_TestFunctionsNoAlloc</a></code> and <code><a class="el" href="structbdlf_1_1Bind__TestFunctionsAlloc.html">bdlf::Bind_TestFunctionsAlloc</a></code>), thus supporting all protocols for binding an invocable in the <code>bdlf_bind</code> component. Additional classes <code>bdlf::Bind_TestSlots</code>, <code><a class="el" href="classbdlf_1_1Bind__TestArgNoAlloc.html">bdlf::Bind_TestArgNoAlloc</a></code>, and <code><a class="el" href="classbdlf_1_1Bind__TestArgAlloc.html">bdlf::Bind_TestArgAlloc</a></code> augment the test apparatus. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following shows how to use the test apparatus to test the <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> constructors, i.e., to explicitly construct <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> objects (as opposed to using the factory method <code><a class="el" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a></code>) and exercise them to ascertain that they work as expected. For more examples of use, see the test drivers <code>bdlf_bind_test[0--14]</code> themselves. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="testing_bdlf~3A~3Abind_without_allocators"></a> <a class="anchor" id="usage.testing_bdlf~3A~3Abind_without_allocators"></a> <a class="anchor" id="description.usage.testing_bdlf~3A~3Abind_without_allocators"></a> <a class="anchor" id="testing_bdlf"></a> <a class="anchor" id="usage.testing_bdlf"></a> <a class="anchor" id="description.usage.testing_bdlf"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Testing bdlf::Bind Without Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this test code, we bind a <code><a class="el" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a></code> invocable by a <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> object constructed with and without placeholders. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> usageExampleNoAlloc(<span class="keywordtype">int</span> veryVeryVerbose)
  {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>          allocator0(veryVeryVerbose);
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>         *Z0 = &amp;allocator0;
      <a class="code" href="classbslma_1_1DefaultAllocatorGuard.html">bslma::DefaultAllocatorGuard</a>  allocGuard(Z0);

      <span class="keyword">const</span> <span class="keywordtype">int</span>                         N1 = -1;
      <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestArgNoAlloc.html">bdlf::Bind_TestArgNoAlloc&lt;1&gt;</a> I1 = 1;

      <span class="comment">// 1 argument to function object, without placeholders.</span>
      {
          <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_ALLOCS = Z0-&gt;<a class="code" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a>();

                <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a>  mX;
          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a>&amp; X = mX;

          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a> EXPECTED_X(I1);
          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a> DEFAULT_X(N1);
          assert(EXPECTED_X != X);
          assert(DEFAULT_X  == X);

          <span class="comment">// For passing to the constructor of &#39;bdlf::Bind&#39;.</span>

          <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a> *FUNC;
          <span class="keyword">typedef</span> <a class="code" href="structbdlf_1_1Bind__Tuple1.html">bdlf::Bind_Tuple1&lt;bdlf::Bind_TestArgNoAlloc&lt;1&gt;</a> &gt; ListType;
          <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Bind.html">bdlf::Bind&lt;bslmf::Nil, FUNC, ListType&gt;</a> Bind;

                ListType  mL(I1);     <span class="comment">// list of arguments</span>
          <span class="keyword">const</span> ListType&amp; L = mL;     <span class="comment">// non-modifiable list of arguments</span>

                ListType  mM(N1);     <span class="comment">// list of arguments</span>
          <span class="keyword">const</span> ListType&amp; M = mM;     <span class="comment">// non-modifiable list of arguments</span>

          <span class="comment">// Testing &#39;bdlf::Bind&#39; objects constructed explicitly.</span>

                Bind  mB1(&amp;mX, L);
          <span class="keyword">const</span> Bind&amp; B1 = mB1;
          assert(EXPECTED_X != X);
          assert(1 == mB1());
          assert(EXPECTED_X == X);

                Bind  mB2(&amp;mX, M, Z0);
          <span class="keyword">const</span> Bind&amp; B2 = mB2;
          assert(DEFAULT_X != X);
          assert(1 == mB2());
          assert(DEFAULT_X == X);

          Bind mB3(B1);
          assert(EXPECTED_X != X);
          assert(1 == mB3());
          assert(EXPECTED_X == X);

          Bind mB4(B2, Z0);
          assert(DEFAULT_X != X);
          assert(1 == mB4());
          assert(DEFAULT_X == X);

          assert(NUM_ALLOCS == Z0-&gt;<a class="code" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a>());
      }

      <span class="comment">// 1 argument to function object, *with* placeholders.</span>
      {
          <span class="keyword">using namespace </span>bdlf::PlaceHolders;

          <span class="keyword">const</span> <span class="keywordtype">int</span> NUM_ALLOCS = Z0-&gt;<a class="code" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a>();

                <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a>  mX;
          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a>&amp; X = mX;

          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a> EXPECTED_X(I1);
          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a> DEFAULT_X(N1);
          assert(EXPECTED_X != X);
          assert(DEFAULT_X  == X);

          <span class="comment">// For passing to the constructor of &#39;bdlf::Bind&#39;.</span>

          <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Bind__TestTypeNoAlloc.html">bdlf::Bind_TestTypeNoAlloc</a> *FUNC;
          <span class="keyword">typedef</span> <a class="code" href="structbdlf_1_1Bind__Tuple1.html">bdlf::Bind_Tuple1&lt;PH1&gt;</a> ListType;
          <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Bind.html">bdlf::Bind&lt;bslmf::Nil, FUNC, ListType&gt;</a> Bind;

                ListType  mL(<a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>);     <span class="comment">// list of arguments</span>
          <span class="keyword">const</span> ListType&amp; L = mL;     <span class="comment">// non-modifiable list of arguments</span>

                Bind  mB1(&amp;mX, L);
          <span class="keyword">const</span> Bind&amp; B1 = mB1;
          assert(EXPECTED_X != X);
          assert(1 == mB1(I1));
          assert(EXPECTED_X == X);

                Bind  mB2(&amp;mX, L, Z0);
          <span class="keyword">const</span> Bind&amp; B2 = mB2;
          assert(DEFAULT_X != X);
          assert(1 == mB2(N1));
          assert(DEFAULT_X == X);

          Bind mB3(B1);
          assert(EXPECTED_X != X);
          assert(1 == mB3(I1));
          assert(EXPECTED_X == X);

          Bind mB4(B2, Z0);
          assert(DEFAULT_X != X);
          assert(1 == mB4(N1));
          assert(DEFAULT_X == X);

          assert(NUM_ALLOCS == Z0-&gt;<a class="code" href="classbslma_1_1TestAllocator.html#a464a6bc3f5125e8b0d303efbd339afec">numAllocations</a>());
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="testing_bdlf_bind_with_allocators"></a> <a class="anchor" id="usage.testing_bdlf_bind_with_allocators"></a> <a class="anchor" id="description.usage.testing_bdlf_bind_with_allocators"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Testing bdlf_bind With Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this test code, we bind a <code><a class="el" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a></code> invocable using a <code><a class="el" href="classbdlf_1_1Bind.html">bdlf::Bind</a></code> object constructed with and without placeholders. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> usageExampleAlloc(<span class="keywordtype">int</span> veryVeryVerbose)
  {
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>  allocator0(veryVeryVerbose);
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>  allocator1(veryVeryVerbose);
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a>  allocator2(veryVeryVerbose);

      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> *Z0 = &amp;allocator0;
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> *Z1 = &amp;allocator1;
      <a class="code" href="classbslma_1_1TestAllocator.html">bslma::TestAllocator</a> *Z2 = &amp;allocator2;

      <a class="code" href="classbslma_1_1DefaultAllocatorGuard.html">bslma::DefaultAllocatorGuard</a> allocGuard(Z0);

      <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestArgAlloc.html">bdlf::Bind_TestArgAlloc&lt;1&gt;</a> NV1 = -1;
      <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestArgAlloc.html">bdlf::Bind_TestArgAlloc&lt;1&gt;</a>  V1 =  1;

      <span class="comment">// 1 argument to function object, *without* placeholders.</span>
      {
                <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a>  mX(Z1);
          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a>&amp; X = mX;

          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a> EXPECTED_X(Z1, V1);
          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a> DEFAULT_X(Z1, NV1);
          assert(EXPECTED_X != X);
          assert(DEFAULT_X  == X);

          <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a> *FUNC;
          <span class="keyword">typedef</span> <a class="code" href="structbdlf_1_1Bind__Tuple1.html">bdlf::Bind_Tuple1&lt;bdlf::Bind_TestArgAlloc&lt;1&gt;</a> &gt; ListType;
          <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Bind.html">bdlf::Bind&lt;bslmf::Nil, FUNC, ListType&gt;</a> Bind;

          <span class="comment">// For passing to the constructor of &#39;bdlf::Bind&#39;.</span>

                ListType  mL(V1);  <span class="comment">// list of arguments</span>
          <span class="keyword">const</span> ListType&amp; L = mL;  <span class="comment">// non-modifiable list of arguments</span>

                ListType  mM(NV1); <span class="comment">// list of arguments</span>
          <span class="keyword">const</span> ListType&amp; M = mM;  <span class="comment">// non-modifiable list of arguments</span>

                Bind  mB1(&amp;mX, L);
          <span class="keyword">const</span> Bind&amp; B1 = mB1;
          assert(EXPECTED_X != X);
          assert(1 == mB1());
          assert(EXPECTED_X == X);

                Bind  mB2(&amp;mX, M, Z2);
          <span class="keyword">const</span> Bind&amp; B2 = mB2;
          assert(DEFAULT_X != X);
          assert(1 == mB2());
          assert(DEFAULT_X == X);

          Bind mB3(B1);
          assert(EXPECTED_X != X);
          assert(1 == mB3());
          assert(EXPECTED_X == X);

          Bind mB4(B2, Z2);
          assert(DEFAULT_X != X);
          assert(1 == mB4());
          assert(DEFAULT_X == X);
      }

      <span class="comment">// 1 argument to function object, *with* placeholders.</span>
      {
          <span class="keyword">using namespace </span>bdlf::PlaceHolders;

                <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a>  mX(Z1);
          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a>&amp; X = mX;

          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a> EXPECTED_X(Z1, V1);
          <span class="keyword">const</span> <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a> DEFAULT_X(Z1, NV1);
          assert(EXPECTED_X != X);
          assert(DEFAULT_X  == X);

          <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Bind__TestTypeAlloc.html">bdlf::Bind_TestTypeAlloc</a> *FUNC;
          <span class="keyword">typedef</span> <a class="code" href="structbdlf_1_1Bind__Tuple1.html">bdlf::Bind_Tuple1&lt;PH1&gt;</a> ListType;
          <span class="keyword">typedef</span> <a class="code" href="classbdlf_1_1Bind.html">bdlf::Bind&lt;bslmf::Nil, FUNC, ListType&gt;</a> Bind;

          <span class="comment">// For passing to the constructor of &#39;bdlf::Bind&#39;.</span>

                ListType  mL(<a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>);  <span class="comment">// list of arguments</span>
          <span class="keyword">const</span> ListType&amp; L = mL;  <span class="comment">// non-modifiable list of arguments</span>

                Bind  mB1(&amp;mX, L);
          <span class="keyword">const</span> Bind&amp; B1 = mB1;
          assert(EXPECTED_X != X);
          assert(1 == mB1(V1));
          assert(EXPECTED_X == X);

                Bind  mB2(&amp;mX, L, Z2);
          <span class="keyword">const</span> Bind&amp; B2 = mB2;
          assert(DEFAULT_X != X);
          assert(1 == mB2(NV1));
          assert(DEFAULT_X == X);

          Bind mB3(B1);
          assert(EXPECTED_X != X);
          assert(1 == mB3(V1));
          assert(EXPECTED_X == X);

          Bind mB4(B2, Z2);
          assert(DEFAULT_X != X);
          assert(1 == mB4(NV1));
          assert(DEFAULT_X == X);
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:43 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
