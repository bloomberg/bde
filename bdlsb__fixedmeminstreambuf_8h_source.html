<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlsb_fixedmeminstreambuf.h                                        -*-C++-*-
#ifndef INCLUDED_BDLSB_FIXEDMEMINSTREAMBUF
#define INCLUDED_BDLSB_FIXEDMEMINSTREAMBUF

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an input &#39;basic_streambuf&#39; using a client buffer.
//
//@CLASSES:
//   bdlsb::FixedMemInStreamBuf: input stream buffer using client memory
//
//@SEE_ALSO: bdlsb_fixedmemoutstreambuf, bdlsb_memoutstreambuf
//
//@DESCRIPTION: This component defines a class, &#39;bdlsb::FixedMemInStreamBuf&#39;,
// that implements the input portion of the &#39;bsl::basic_streambuf&#39; protocol
// using a client-supplied memory buffer.  Method names necessarily correspond
// to the protocol-specified method names.  Clients supply the character buffer
// at stream buffer construction, and can later reinitialize the stream buffer
// with a different character buffer by calling the &#39;pubsetbuf&#39; method.
//
// This component provides none of the output-related functionality of
// &#39;basic_streambuf&#39; (see Streaming Architecture, below), nor does it use
// locales in any way.
//
///Streaming Architecture
///----------------------
// Stream buffers are designed to decouple device handling from content
// formatting, providing the requisite device handling and possible buffering
// services, and leaving the formatting to the client stream.  The standard
// C++ IOStreams library further partitions streaming into input streaming and
// output streaming, separating responsibilities for each at both the stream
// layer and the stream buffer layer.  The BDE streaming library for &#39;bdex&#39;,
// including all of &#39;bdlsb&#39;, follows this model.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Use of the &#39;bdlsb::FixedMemInStreamBuf&#39;
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// &#39;bdlsb::FixedMemInStreamBuf&#39; can be used in situations when you already
// have an array of bytes in memory and you&#39;d like to wrap it in an input
// stream to extract data in a formatted manner.  A
// &#39;bdlsb::FixedMemInStreamBuf&#39; object refers to an externally managed buffer
// that is supplied either at construction, or using the &#39;pubsetbuf&#39; method of
// the &#39;bsl::streambuf&#39; base-class.
//
// First, we create an array of characters to provide data that needs to be
// parsed, and construct &#39;bdlsb::FixedMemInStreamBuf&#39; on that array:
//..
//  {
//      const char *inputText = &quot;1 1 2 3 5 8 13 21&quot;;
//      bdlsb::FixedMemInStreamBuf buffer(inputText, strlen(inputText));
//..
// Notice that &#39;bdlsb::FixedMemInStreamBuf&#39; can be used with buffers referring
// to stack memory or to heap memory.
//
// Then, we use &#39;buffer&#39; to construct a &#39;bsl::istream&#39;:
//..
//      bsl::istream stream(&amp;buffer);
//..
// Finally, we can input the data from the stream in a formatted manner:
//..
//      int value;
//      while (stream &gt;&gt; value) {
//          cout &lt;&lt; &quot;Value is: &quot; &lt;&lt; value &lt;&lt; endl;
//      }
//  }
//..
//
///Example 2: Scanning Input Data
/// - - - - - - - - - - - - - - -
// This example illustrates scanning of the input stream buffer for particular
// pattern ( digits, in our case ) and then using stream to read out found
// number.
//
// First, we create an array of characters to provide data that needs to be
// parsed, and construct &#39;bdlsb::FixedMemInStreamBuf&#39; on that array:
//..
//  {
//      const char *inputText = &quot;The answer is: 42.&quot;;
//      bdlsb::FixedMemInStreamBuf buffer(inputText, strlen(inputText));
//..
// Then, we use &#39;buffer&#39; to construct a &#39;bsl::istream&#39; that will be used later
// to read found number:
//..
//      bsl::istream stream(&amp;buffer);
//..
// Next, we scan input buffer one character at a time searching for the first
// digit:
//..
//      char ch;
//      do {
//          ch = buffer.sbumpc();
//
//          if ( (ch &gt;= &#39;0&#39;) &amp;&amp; (ch &lt;= &#39;9&#39;) ) {
//..
// Now, when the digit character is found, we return the first digit into the
// input stream buffer for subsequent read:
//..
//              buffer.sputbackc(ch);
//              int n;
//..
// Finally, we read out the whole number:
//..
//              stream &gt;&gt; n;
//              assert( 42 == n );
//              cout &lt;&lt; &quot;The answer is &quot; &lt;&lt; n &lt;&lt; &quot; indeed...&quot; &lt;&lt; endl;
//              break;
//          }
//      } while ( ch != EOF );
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSL_IOS
#include &lt;bsl_ios.h&gt;       // for &#39;bsl::streamsize&#39;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#if defined(BSLS_PLATFORM_CMP_MSVC) &amp;&amp; defined(min)
    // Note: on Windows -&gt; WinDef.h:#define min(a,b) ...
#undef min
#endif

namespace BloombergLP {
namespace bdlsb {

                       // =========================
                       // class FixedMemInStreamBuf
                       // =========================

class FixedMemInStreamBuf : public bsl::streambuf {
    // This class implements the input functionality of the &#39;basic_streambuf&#39;
    // protocol, using client-supplied &#39;char *&#39; memory.

    // DATA
    char            *d_buffer_p;      // buffer (held, not owned)
    bsl::size_t      d_bufferSize;    // length of buffer

    // NOT IMPLEMENTED
    FixedMemInStreamBuf(const FixedMemInStreamBuf&amp;);
    FixedMemInStreamBuf&amp; operator=(const FixedMemInStreamBuf&amp;);

  protected:
    // PROTECTED MANIPULATORS
    virtual pos_type seekoff(
                            off_type                offset,
                            bsl::ios_base::seekdir  way,
                            bsl::ios_base::openmode which = bsl::ios_base::in);
        // Set the position indicator to the relative specified &#39;offset&#39; from
        // the base position indicated by the specified &#39;way&#39; and return the
        // resulting absolute position on success or pos_type(-1) on failure.
        // Optionally specify &#39;which&#39; area of the stream buffer.  The seek
        // operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::in&#39; or if the resulting absolute position is less
        // than zero or greater than the value returned by &#39;length&#39;.

    virtual pos_type seekpos(
                            pos_type                position,
                            bsl::ios_base::openmode which = bsl::ios_base::in);
        // Set the position indicator to the specified &#39;position&#39; and return
        // the resulting absolute position on success or pos_type(-1) on
        // failure.  Optionally specify &#39;which&#39; area of the stream buffer.  The
        // &#39;seekpos&#39; operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::in&#39; or if position is less then zero or greater
        // than the value returned by &#39;length&#39;.

    virtual FixedMemInStreamBuf *setbuf(char  *buffer, bsl::streamsize length);
    FixedMemInStreamBuf *setbuf(const char *buffer, bsl::streamsize length);
        // Reinitialize this stream buffer to use the specified character
        // &#39;buffer&#39; having the specified &#39;length&#39;.  Return the pointer
        // providing modifiable access the this stream buffer.  The behavior is
        // undefined unless &#39;buffer != 0 &amp;&amp; length &gt; 0&#39; or &#39;length == 0&#39;.  Upon
        // re-initialization for use of the new buffer, neither the content nor
        // the next input position indicator are preserved.  Note that &#39;buffer&#39;
        // is held but not owned.

    virtual bsl::streamsize showmanyc();
        // Return the number of characters currently available for reading
        // from this stream buffer, or -1 if there are none.

    virtual bsl::streamsize xsgetn(char_type       *destination,
                                   bsl::streamsize  length);
        // Read the specified &#39;length&#39; number of characters into the specified
        // &#39;destination&#39;.  Return the number of characters successfully read.
        // The behavior is undefined unless &#39;0 &lt;= length&#39;.

  public:
    // CREATORS
    FixedMemInStreamBuf(const char *buffer, bsl::size_t length);
        // Create a &#39;FixedMemInStreamBuf&#39; that provides access to the character
        // sequence in the specified &#39;buffer&#39; of the specified &#39;length&#39;.  The
        // behavior is undefined unless &#39;buffer != 0 &amp;&amp; length &gt; 0&#39; or
        // &#39;length == 0&#39;.

    ~FixedMemInStreamBuf();
        // Destroy this stream buffer.

    // MANIPULATORS
    FixedMemInStreamBuf *pubsetbuf(char            *buffer,
                                   bsl::streamsize  length);
    FixedMemInStreamBuf *pubsetbuf(const char      *buffer,
                                   bsl::streamsize  length);
        // Reinitialize this stream buffer to use the specified character
        // &#39;buffer&#39; having the specified &#39;length&#39;.  Return the address of this
        // modifiable stream buffer.  The behavior is undefined unless
        // &#39;buffer != 0 &amp;&amp; length &gt; 0&#39; or &#39;length == 0&#39;.  Upon reinitialization
        // for use of the new buffer, neither the content nor the next input
        // position indicator is preserved.  Note that &#39;buffer&#39; is held but not
        // owned.

    // ACCESSORS
    const char *data() const;
        // Return the address of the non-modifiable character buffer held by
        // this stream buffer.

    bsl::size_t length() const;
        // Return the number of characters from the current input position to
        // the end of the stream buffer.  The function returns the same value
        // as &#39;seekoff(0, bsl::ios_base::beg)&#39;.  The length is modified by a
        // call to &#39;seekpos&#39;, &#39;seekoff&#39; or by reading characters from the
        // buffer.
};

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                       // -------------------------
                       // class FixedMemInStreamBuf
                       // -------------------------

// PROTECTED MANIPULATORS
inline
FixedMemInStreamBuf::pos_type
FixedMemInStreamBuf::seekpos(pos_type                position,
                             bsl::ios_base::openmode which)
{
    return seekoff(static_cast&lt;off_type&gt;(position), bsl::ios_base::beg, which);
}


inline
FixedMemInStreamBuf *FixedMemInStreamBuf::setbuf(char            *buffer,
                                                 bsl::streamsize  length)

{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    // Reset pointers and length.
    d_buffer_p    = buffer;
    d_bufferSize  = static_cast&lt;bsl::size_t&gt;(length);
    setg(d_buffer_p, d_buffer_p, d_buffer_p + d_bufferSize);
    return this;
}

inline
FixedMemInStreamBuf *FixedMemInStreamBuf::setbuf(const char      *buffer,
                                                 bsl::streamsize  length)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    return setbuf(const_cast&lt;char *&gt;(buffer), length);
}

inline
bsl::streamsize FixedMemInStreamBuf::showmanyc()
{
    bsl::streamsize numChars = egptr() - gptr();
    if (0 == numChars) {
        return -1;                                                    // RETURN
    }
    return numChars;
}

inline
bsl::streamsize FixedMemInStreamBuf::xsgetn(char_type       *destination,
                                            bsl::streamsize  length)
{
    BSLS_ASSERT_SAFE(destination);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    bsl::streamsize charsLeft = egptr() - gptr();

    bsl::streamsize canCopy = charsLeft &lt; length ? charsLeft : length;

    bsl::memcpy(destination, gptr(), canCopy);
    gbump(static_cast&lt;int&gt;(canCopy));
    return canCopy;
}

// CREATORS
inline
FixedMemInStreamBuf::FixedMemInStreamBuf(const char  *buffer,
                                         bsl::size_t  length)
: d_buffer_p(const_cast&lt;char *&gt;(buffer))
, d_bufferSize(length)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);

    setg(d_buffer_p, d_buffer_p, d_buffer_p + d_bufferSize);
}

inline
FixedMemInStreamBuf::~FixedMemInStreamBuf()
{
}

// MANIPULATORS
inline
FixedMemInStreamBuf *FixedMemInStreamBuf::pubsetbuf(const char     *buffer,
                                                    bsl::streamsize length)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    return setbuf(buffer, length);
}

inline
FixedMemInStreamBuf *FixedMemInStreamBuf::pubsetbuf(char           *buffer,
                                                    bsl::streamsize length)
{
    BSLS_ASSERT_SAFE(buffer || 0 == length);
    BSLS_ASSERT_SAFE(0 &lt;= length);

    return setbuf(buffer, length);
}

// ACCESSORS
inline
const char *FixedMemInStreamBuf::data() const
{
    return d_buffer_p;
}

inline
bsl::size_t FixedMemInStreamBuf::length() const
{
    return egptr() - gptr();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
