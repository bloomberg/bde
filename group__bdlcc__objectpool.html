<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlcc_objectpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlcc_objectpool<br/>
<small>
[<a class="el" href="group__bdlcc.html">Package bdlcc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread-safe object pool.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlcc.html">bdlcc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Object Construction and Destruction</a> <ul>
<li>
<a href="#3.1.1">Integrating with <code>bslma::ManagedPtr</code> and <code>bsl::shared_ptr</code></a> </li>
</ul>
</li>
<li>
<a href="#3.2">Creator and Resetter Template Contract</a> </li>
<li>
<a href="#3.3">Exception safety</a> </li>
<li>
<a href="#3.4">Pool replenishment policy</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Handling Database Queries</a> </li>
<li>
<a href="#3.5.2">Object Pool Creation and Functor Argument</a> </li>
<li>
<a href="#3.5.3">Creating an Object Pool that Constructs Default Objects</a> </li>
<li>
<a href="#3.5.4">Creating an Object Pool that Constructs Non-Default Objects</a> </li>
<li>
<a href="#3.5.5">Modified <code>queryHandler</code></a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread-safe object pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a> </td><td>thread-enabled container of managed objects  </td></tr>
<tr>
<td><a class="el" href="structbdlcc_1_1ObjectPoolFunctors.html">bdlcc::ObjectPoolFunctors</a> </td><td>namespace for resetter/creator implementations  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlcc__sharedobjectpool.html" title="Provide a thread-safe pool of shared objects.">Component bdlcc_sharedobjectpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a generic thread-safe pool of objects, <code><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a></code>, using the acquire-release idiom and a <code>struct</code> with useful functors for a pool of objects, <code><a class="el" href="structbdlcc_1_1ObjectPoolFunctors.html">bdlcc::ObjectPoolFunctors</a></code>. An object pool provides two main methods: <code>getObject</code>, which returns an object from the pool, and <code>releaseObject</code>, which returns an object to the pool for further reuse (thus avoiding the overhead of object construction and destruction). A major requirement of using the object pool is that any call to <code>getObject</code> can be satisfied by any object in the pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="object_construction_and_destruction"></a> <a class="anchor" id="description.object_construction_and_destruction"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Object Construction and Destruction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The object pool owns the memory required to store the pooled objects, and manages the construction, resetting, and destruction of objects. The user may supply functors to create objects and to reset them to a valid state for their return to the pool. Alternatively, this component supplies reasonable defaults. Upon destruction, the object pool deallocates all memory associated with the objects in the pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The object pool also implements the <code><a class="el" href="classbdlma_1_1Factory.html">bdlma::Factory</a></code> protocol for TYPE. Its <code>createObject</code> and <code>deleteObject</code> methods are provided <em>only</em> for this purpose and should not be invoked directly (they are just synonyms for <code>getObject</code> and <code>releaseObject</code>, respectively). The pool can thus be used anywhere a <code><a class="el" href="classbdlma_1_1Factory.html">bdlma::Factory</a></code> (or, therefore, a <code><a class="el" href="classbdlma_1_1Deleter.html">bdlma::Deleter</a></code>) is expected. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="integrating_with_bslma~3A~3Amanagedptr_and_bsl~3A~3Ashared_ptr"></a> <a class="anchor" id="object_construction_and_destruction.integrating_with_bslma~3A~3Amanagedptr_and_bsl~3A~3Ashared_ptr"></a> <a class="anchor" id="description.object_construction_and_destruction.integrating_with_bslma~3A~3Amanagedptr_and_bsl~3A~3Ashared_ptr"></a> <a class="anchor" id="integrating_with_bslma"></a> <a class="anchor" id="object_construction_and_destruction.integrating_with_bslma"></a> <a class="anchor" id="description.object_construction_and_destruction.integrating_with_bslma"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Integrating with bslma::ManagedPtr and bsl::shared_ptr: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A <code><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a></code> is designed to work with both managed and shared pointer types. Note however, that <code>bdlcc_sharedobjectpool</code> is an object-pool specifically designed for use with shared pointers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Because <code><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a></code> provides a <code>deleteObject</code> method, it can serve as a factory of both <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code> and <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> objects. For example, to create a managed pointer from an object pool of <code>bsl::string</code> objects: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool&lt;bsl::string&gt;</a> pool;
  <a class="code" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr&lt;bsl::string&gt;</a> managedPtr(pool.<a class="code" href="classbdlcc_1_1ObjectPool.html#a2aa05cd506bc83b24c0869a3326db5f9">getObject</a>(), &amp;pool);
</pre></div><br/>
<br/>
 To create a shared pointer (using the same object pool): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *allocator = <a class="code" href="structbslma_1_1Default.html#a418cbb340801caa455fd33177d1ff8d5">bslma::Default::allocator</a>();
  <a class="code" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr&lt;bsl::string&gt;</a> sharedPtr(pool.<a class="code" href="classbdlcc_1_1ObjectPool.html#a2aa05cd506bc83b24c0869a3326db5f9">getObject</a>(), &amp;pool, allocator);
</pre></div><br/>
<br/>
 Note that an allocator is a <em>required</em> argument to the <code><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a></code> constructor used here, and the provided allocator is used to supply memory for the internal representation of the pointer, and not to allocate memory for the object itself. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creator_and_resetter_template_contract"></a> <a class="anchor" id="description.creator_and_resetter_template_contract"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Creator and Resetter Template Contract: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a></code> is templated on two types <code>CREATOR</code> and <code>RESETTER</code> in addition to the underlying object <code>TYPE</code>. Objects of these types may be provided at construction. The namespace <code><a class="el" href="structbdlcc_1_1ObjectPoolFunctors.html">bdlcc::ObjectPoolFunctors</a></code> provides several commonly used implementations. The creator will be invoked as: <code>void(*)(void*, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*)</code>. The resetter will be invoked as: <code>void(*)(TYPE*)</code>. The creator functor is called to construct a new object of the parameterized <code>TYPE</code> when the pool must be expanded (and thus it typically invokes placement <code>new</code> and passes its allocator argument to the constructor of <code>TYPE</code>). The resetter functor is called before each object is returned to the pool, and is required to put the object into a state such that it is ready to be reused. The defaults for these types are as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">    CREATOR  = <a class="code" href="structbdlcc_1_1ObjectPoolFunctors.html#a1e1490eacdd2d04969b1365b9d508382">bdlcc::ObjectPoolFunctors::DefaultCreator</a>
    RESETTER = <a class="code" href="classbdlcc_1_1ObjectPoolFunctors_1_1Nil.html">bdlcc::ObjectPoolFunctors::Nil</a>
</pre></div><br/>
<br/>
 <code><a class="el" href="classbdlcc_1_1ObjectPoolFunctors_1_1Nil.html">bdlcc::ObjectPoolFunctors::Nil</a></code> is a no-op; it is only suitable if the objects stored in the pool are <em>always</em> in a valid state to be reused. Otherwise another kind of <code>RESETTER</code> should be provided. In <code><a class="el" href="structbdlcc_1_1ObjectPoolFunctors.html">bdlcc::ObjectPoolFunctors</a></code>, the classes <code>Clear</code>, <code>RemoveAll</code>, and <code>Reset</code> are all acceptable types for <code>RESETTER</code>. Since these functor types are fully inlined, it is generally most efficient to define <code>reset</code> (or <code>clear</code> or <code>removeAll</code>) in the underlying <code>TYPE</code> and allow the functor to call that method. The <code>CREATOR</code> functor defaults to an object that invokes the default constructor with placement new, passing the allocator argument if the type traits of the object indicate it uses an allocator (see <code>bslalg_typetraits</code>). If a custom creator functor or a custom <code>CREATOR</code> type is specified, it is the user's responsibility to ensure that it correctly passes its allocator argument to the constructor of <code>TYPE</code> if <code>TYPE</code> takes an allocator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception_safety"></a> <a class="anchor" id="description.exception_safety"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Exception safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are two potential sources of exceptions in this component: memory allocation and object construction. The object pool is exception-neutral with full guarantee of rollback for the following methods: if an exception is thrown in <code>getObject</code>, <code>reserveCapacity</code>, or <code>increaseCapacity</code>, then the pool is in a valid unmodified state (i.e., identical to its state prior to the call to <code>getObject</code>). No other method of <code><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a></code> can throw. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="pool_replenishment_policy"></a> <a class="anchor" id="description.pool_replenishment_policy"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Pool replenishment policy: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>growBy</code> parameter can be specified in the pool's constructor to instruct the pool how to increase its capacity each time the pool is depleted. If <code>growBy</code> is positive, the pool always replenishes itself with enough objects to satisfy at least <code>growBy</code> object requests before the next replenishment. If <code>growBy</code> is negative, the pool will increase its capacity geometrically until it exceeds the internal maximum (which is implementation-defined), and after that it will be replenished with constant number of objects. If <code>growBy</code> is not specified, it defaults to -1 (i.e., geometric increase beginning at 1). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_handling_database_queries"></a> <a class="anchor" id="usage.example_1~3A_handling_database_queries"></a> <a class="anchor" id="description.usage.example_1~3A_handling_database_queries"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Handling Database Queries: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, we simulate a database server accepting queries from clients and executing each query in a separate thread. Client requests are simulated by function <code>getClientQuery</code> which returns a query to be executed. The class <code>Query</code> encapsulates a database query and <code>queryFactory</code> is an object of a query factory class <code>QueryFactory</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      k_CONNECTION_OPEN_TIME  = 100,  <span class="comment">// (simulated) time to open a</span>
                                      <span class="comment">// connection (in microseconds)</span>

      k_CONNECTION_CLOSE_TIME = 8,    <span class="comment">// (simulated) time to close a</span>
                                      <span class="comment">// connection (in microseconds)</span>

      k_QUERY_EXECUTION_TIME  = 4     <span class="comment">// (simulated) time to execute a query</span>
                                      <span class="comment">// (in microseconds)</span>
  };

  <span class="keyword">class </span>my_DatabaseConnection
      <span class="comment">// This class simulates a database connection.</span>
  {
    <span class="keyword">public</span>:
      my_DatabaseConnection()
      {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(k_CONNECTION_OPEN_TIME);
      }

      ~my_DatabaseConnection()
      {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(k_CONNECTION_CLOSE_TIME);
      }

      <span class="keywordtype">void</span> executeQuery(Query *query)
      {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(k_QUERY_EXECUTION_TIME);
          (void)query;
      }
  };
</pre></div><br/>
<br/>
 The server runs several threads which, on each iteration, obtain a new client request from the query factory, and process it, until the desired total number of requests is achieved. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> serverThread(<a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> *queries,
                               <span class="keywordtype">int</span>              max,
                               <span class="keywordtype">void</span>             (*queryHandler)(Query*))
  {
      <span class="keywordflow">while</span> (++(*queries) &lt;= max) {
          Query *query = queryFactory-&gt;createQuery();
          queryHandler(query);
      }
  }
</pre></div><br/>
<br/>
 We first give an implementation that does not uses the object pool. Later we will give an implementation using an object pool to manage the database connections. We also keep track of total response time for each case. When object pool is <em>not</em> used, each thread, in order to execute a query, creates a <em>new</em> database connection, calls its <code>executeQuery</code> method to execute the query and finally closes the connection. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> queryHandler1(Query *query)
      <span class="comment">// Handle the specified &#39;query&#39; without using an objectpool.</span>
  {
      bsls::Types::Int64 t1 = <a class="code" href="structbsls_1_1TimeUtil.html#a5a3f353e27dfd55ec23efbb8dfa21e80">bsls::TimeUtil::getTimer</a>();
      my_DatabaseConnection connection;
      connection.executeQuery(query);
      bsls::Types::Int64 t2 = <a class="code" href="structbsls_1_1TimeUtil.html#a5a3f353e27dfd55ec23efbb8dfa21e80">bsls::TimeUtil::getTimer</a>();

      totalResponseTime1 += t2 - t1;

      queryFactory-&gt;destroyQuery(query);

      <span class="comment">// &#39;connection&#39; is implicitly destroyed on function return.</span>
  }
</pre></div><br/>
<br/>
 The main thread starts and joins these threads: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      k_NUM_THREADS = 8,
      k_NUM_QUERIES = 10000
  };

  <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> numQueries(0);
  <a class="code" href="classbslmt_1_1ThreadGroup.html">bslmt::ThreadGroup</a> tg;

  tg.<a class="code" href="classbslmt_1_1ThreadGroup.html#acee906734abe40e5da1cb126fd63c5f5">addThreads</a>(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;serverThread,
                                     &amp;numQueries,
                                     static_cast&lt;int&gt;(k_NUM_QUERIES),
                                     &amp;queryHandler1),
                k_NUM_THREADS);
  tg.<a class="code" href="classbslmt_1_1ThreadGroup.html#adc617061ba84d7c29ca0f6e3c27a982d">joinAll</a>();
</pre></div><br/>
<br/>
 In above strategy, clients always incur the delay associated with opening and closing a database connection. Now we show an implementation that will use object pool to <em>pool</em> the database connections. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="object_pool_creation_and_functor_argument"></a> <a class="anchor" id="usage.object_pool_creation_and_functor_argument"></a> <a class="anchor" id="description.usage.object_pool_creation_and_functor_argument"></a> <a class="anchor" id="3.5.2"></a> </dd></dl>
<dl class="user"><dt><b>Object Pool Creation and Functor Argument: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In order to create an object pool, we may specify, at construction time, a functor encapsulating object creation. The pool invokes this functor to create an object in a memory location supplied by the allocator specified at construction and owned by the pool. By default, the creator invokes the default constructor of the underlying type, passing the pool's allocator if the type uses the <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> protocol to supply memory (as specified by the "Uses Bslma Allocator" trait, see <code>bslalg_typetraits</code>). If this behavior is not sufficient, we can supply our own functor for type creation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creating_an_object_pool_that_constructs_default_objects"></a> <a class="anchor" id="usage.creating_an_object_pool_that_constructs_default_objects"></a> <a class="anchor" id="description.usage.creating_an_object_pool_that_constructs_default_objects"></a> <a class="anchor" id="3.5.3"></a> </dd></dl>
<dl class="user"><dt><b>Creating an Object Pool that Constructs Default Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the default constructor of our type is sufficient, whether or not that type uses <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, we can simply use the default behavior of <code><a class="el" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool&lt;my_DatabaseConnection&gt;</a> pool(-1);
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creating_an_object_pool_that_constructs_non-default_objects"></a> <a class="anchor" id="usage.creating_an_object_pool_that_constructs_non-default_objects"></a> <a class="anchor" id="description.usage.creating_an_object_pool_that_constructs_non-default_objects"></a> <a class="anchor" id="3.5.4"></a> </dd></dl>
<dl class="user"><dt><b>Creating an Object Pool that Constructs Non-Default Objects: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this example, if we decide that connection IDs must be supplied to objects allocated from the pool, we must define a function which invokes placement new appropriately. When using a custom creator functor, it is the responsibility of client code to pass the pool's allocator (supplied as the second argument to the functor) to the new object if it uses <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>. <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">void</span> createConnection(<span class="keywordtype">void</span> *arena, <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *alloc, <span class="keywordtype">int</span> <span class="keywordtype">id</span>)
    {
       <span class="keyword">new</span> (arena) my_DatabaseConnection(<span class="keywordtype">id</span>, alloc);
    }
</pre></div><br/>
<br/>
 then... <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keywordtype">int</span> myId = 100;
    <a class="code" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool&lt;my_DatabaseConnection&gt;</a> pool(
                             <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;createConnection,
                                                 <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">bdlf::PlaceHolders::_1</a>,
                                                 <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a1b20b113c529e7825ad00bb527fcc6ad">bdlf::PlaceHolders::_2</a>,
                                                 myId));
</pre></div><br/>
<br/>
 Whichever creator we choose, the modified server looks like <br/>
<br/>
<div class="fragment"><pre class="fragment">  connectionPool = &amp;pool;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_QUERIES; ++i) {
      my_Query *query = getClientQuery();
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;threads[i], queryHandler2, (<span class="keywordtype">void</span> *)query);
  }
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; k_NUM_QUERIES; ++i) {
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(threads[i]);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="modified_queryhandler"></a> <a class="anchor" id="usage.modified_queryhandler"></a> <a class="anchor" id="description.usage.modified_queryhandler"></a> <a class="anchor" id="3.5.5"></a> </dd></dl>
<dl class="user"><dt><b>Modified queryHandler: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now each thread, instead of creating a new connection, gets a connection from the object pool. After using the connection, the client returns it back to the pool for further reuse. The modified <code>queryHandler</code> is following. <br/>
<br/>
<div class="fragment"><pre class="fragment">    <a class="code" href="classbdlcc_1_1ObjectPool.html">bdlcc::ObjectPool&lt;my_DatabaseConnection&gt;</a> *connectionPool;

    <span class="keywordtype">void</span> queryHandler2(Query *query)
        <span class="comment">// Process the specified &#39;query&#39;.</span>
    {
        bsls::Types::Int64 t1 = <a class="code" href="structbsls_1_1TimeUtil.html#a5a3f353e27dfd55ec23efbb8dfa21e80">bsls::TimeUtil::getTimer</a>();
        my_DatabaseConnection *connection = connectionPool-&gt;<a class="code" href="classbdlcc_1_1ObjectPool.html#a2aa05cd506bc83b24c0869a3326db5f9">getObject</a>();
        connection-&gt;executeQuery(query);
        bsls::Types::Int64 t2 = <a class="code" href="structbsls_1_1TimeUtil.html#a5a3f353e27dfd55ec23efbb8dfa21e80">bsls::TimeUtil::getTimer</a>();

        totalResponseTime2 += t2 - t1;

        connectionPool-&gt;<a class="code" href="classbdlcc_1_1ObjectPool.html#a762eb19f3ddc452f85bd5e4b5c24ecb5">releaseObject</a>(connection);
        queryFactory-&gt;destroyQuery(query);
    }
</pre></div><br/>
<br/>
 The total response time for each strategy is: <br/>
<br/>
<div class="fragment"><pre class="fragment"> totalResponseTime1 = 199970775520
 totalResponseTime2 = 100354490480
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:39 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
