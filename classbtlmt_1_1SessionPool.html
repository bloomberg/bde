<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlmt::SessionPool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlmt.html">btlmt</a>      </li>
      <li><a class="el" href="classbtlmt_1_1SessionPool.html">btlmt::SessionPool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>btlmt::SessionPool Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlmt::SessionPool" -->
<p><code>#include &lt;<a class="el" href="btlmt__sessionpool_8h_source.html">btlmt_sessionpool.h</a>&gt;</code></p>

<p><a href="classbtlmt_1_1SessionPool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89a">SessionState</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aa0bef0ef104ba3e9a832417d0c82951a0">e_SESSION_UP</a> =  1, 
<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aaae5a7fb66fafadfeece1b1322ceb0a08">e_SESSION_DOWN</a> =  2, 
<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aad795c27362f5a95120b66e4e826ca20f">e_SESSION_ALLOC_FAILED</a> =  3, 
<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aa3ab565cb1eabe6693c5138d8efd2ec98">e_SESSION_STARTUP_FAILED</a> =  4, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aa5065cf306d335a6017cdac867b834a98">e_WRITE_QUEUE_LOWWATER</a> =  5, 
<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aa17c3d0f245bde63c62b3ea65d6402d46">e_WRITE_QUEUE_HIGHWATER</a> =  6, 
<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aa5cc598e6f6a5998ca50c94566f8374da">e_ACCEPT_FAILED</a> =  7, 
<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aa90e0e7c16736e45cc5933aa0db047c2d">e_CONNECT_ATTEMPT_FAILED</a> =  8, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aabcf72de265b16a1952d8dd712db68f23">e_CONNECT_FAILED</a> =  9, 
<a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89aac2170049d69c3384f29ded6ce1102bd9">e_CONNECT_ABORTED</a> =  10
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a95872d425443f4b788fabb5a4f39856e">ConnectResolutionMode</a> { <a class="el" href="classbtlmt_1_1SessionPool.html#a95872d425443f4b788fabb5a4f39856ead655346629a27a9625ae74c9749e52bd">e_RESOLVE_ONCE</a> =  0, 
<a class="el" href="classbtlmt_1_1SessionPool.html#a95872d425443f4b788fabb5a4f39856ea7356291cb014ac3784cec7067e2a7b54">e_RESOLVE_AT_EACH_ATTEMPT</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#ad12993100d93a1269a3da642f4b981d9">PoolState</a> { <a class="el" href="classbtlmt_1_1SessionPool.html#ad12993100d93a1269a3da642f4b981d9a95865851c2caddc7405ea0a3f5c48a6b">e_SESSION_LIMIT_REACHED</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int <br class="typebreak"/>
state, int handle, <a class="el" href="classbtlmt_1_1Session.html">Session</a> <br class="typebreak"/>
*session, void *userData)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionStateCallback</a> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int <br class="typebreak"/>
state, int source, void <br class="typebreak"/>
*userData)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a99f7e1aac1e835c18b1ad25682c6ec75">SessionPoolStateCallback</a> )</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#af4ce1563fcbd9f36e2361467025d9724">BSLMF_NESTED_TRAIT_DECLARATION</a> (<a class="el" href="classbtlmt_1_1SessionPool.html">SessionPool</a>, <a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#acb8fe5673aa8bf8f36bdcae9eac13f8e">SessionPool</a> (const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;config, const <a class="el" href="classbtlmt_1_1SessionPool.html#a99f7e1aac1e835c18b1ad25682c6ec75">SessionPoolStateCallback</a> &amp;poolStateCallback, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a87c1949ab308025f3e497e623230558d">SessionPool</a> (<a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> *blobBufferFactory, const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;config, const <a class="el" href="classbtlmt_1_1SessionPool.html#a99f7e1aac1e835c18b1ad25682c6ec75">SessionPoolStateCallback</a> &amp;poolStateCallback, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a0d2199a5367c7970d96bdb2923f44d5e">~SessionPool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a37c0bb356461c9be423ae0d15209bbf6">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#ac241af61891949226cff10fa52be0837">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a0b4111d1d3a671e2a6b73ef6435a942c">stopAndRemoveAllSessions</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a18935f6ec09bac9a714db7d865ced9ae">listen</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, int portNumber, int backlog, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *factory, void *userData=0, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a5bb11ad0bf1039d222ea1455e0854e97">listen</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, int portNumber, int backlog, int reuseAddress, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *factory, void *userData=0, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#aa65ea6eec1c14ffa7824a79e73df4052">listen</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;endpoint, int backlog, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *factory, void *userData=0, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a11e8c6d26c840a409ed0d39effeeb0ac">listen</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;endpoint, int backlog, int reuseAddress, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *factory, void *userData=0, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a810c4f39e806cd44790e8347b17b99c4">closeHandle</a> (int handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#ad0bae03a026012c5d07ea7e1973abae5">connect</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, const char *hostname, int port, int numAttempts, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *socket, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *factory, void *userData=0, <a class="el" href="classbtlmt_1_1SessionPool.html#a95872d425443f4b788fabb5a4f39856e">ConnectResolutionMode</a> resolutionMode=e_RESOLVE_ONCE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#ac821ba154510168bc6c04e0fced36ca3">connect</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, const char *hostname, int port, int numAttempts, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *factory, void *userData=0, <a class="el" href="classbtlmt_1_1SessionPool.html#a95872d425443f4b788fabb5a4f39856e">ConnectResolutionMode</a> resolutionMode=e_RESOLVE_ONCE, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0, const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *localAddress=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#af514d80e40a7a57c95607b19d785f0d7">connect</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> const &amp;endpoint, int numAttempts, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *socket, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *factory, void *userData=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a5ad1a3553cec19e154309f651e44a715">connect</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> const &amp;endpoint, int numAttempts, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *factory, void *userData=0, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0, const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *localAddress=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#ae52dbcbd92671559fb4a7a7fd0ddfe9d">import</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *streamSocket, <a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *socketFactory, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *sessionFactory, void *userData=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a9363f920d26e30dc692e8a1522f72d1a">import</a> (int *handleBuffer, const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;callback, <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *streamSocket, <a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *sessionFactory, void *userData=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a99d3efee5dbf196d4660d0ac081a3587">setWriteQueueWatermarks</a> (int handleId, int lowWatermark, int highWatermark)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#afafeeac972b76eb93c6ae841590cc30b">config</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#aaeca7d07e73ae6a8f56447e63bf83827">getChannelHandleStatistics</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="structbtlmt_1_1ChannelPool_1_1HandleInfo.html">ChannelPool::HandleInfo</a> &gt; *handleInfo) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a345736669f5c424c92a51732a609fe33">numSessions</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#af037d29b86280afe9d750b1e39c48148">portNumber</a> (int handle) const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1SessionPool.html#a9759a4b9555db39882e10988c1e00f23">SessionPoolSessionIterator</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a mechanism for establishing and managing network connections. A session pool can be configured at construction by passing in a <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a></code> object and allows the establishment of both server sessions via the <code>listen</code> method and client sessions via the <code>connect</code> method. The connection initiation methods take a <code><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a></code> object that allows users to return a <code><a class="el" href="classbtlmt_1_1Session.html">Session</a></code> object that the session pool stores as a reference for the connection. During the allocation of the <code><a class="el" href="classbtlmt_1_1Session.html">Session</a></code> object clients are provided an <code><a class="el" href="classbtlmt_1_1AsyncChannel.html">AsyncChannel</a></code> that they can use for exchanging data with the other endpoint in the connection. An existing socket can be imported into a session pool and this will create a session enabled both for read and for write. All of the callbacks invoked by session pool are run in a number of threads created at start up. <a class="el" href="classbtlmt_1_1Session.html">Session</a> pool ensures that callback methods of a particular connection are always invoked on the same thread so users dont have to synchroninze data associated with a particular connection. <a class="el" href="classbtlmt_1_1Session.html">Session</a> pool can be started or stopped via the <code>start</code> and <code>stop</code> methods respectively. Once started and until stopped, the session pool dispatches incoming and outgoing connections, messages, and other session functions to the processing threads. Once stopped, the channel pool can be started again and the channels will resume their operations. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a2175efd4427f49e1e5f2c70346e7a60b"></a><!-- doxytag: member="btlmt::SessionPool::SessionStateCallback" ref="a2175efd4427f49e1e5f2c70346e7a60b" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int state, int handle, <a class="el" href="classbtlmt_1_1Session.html">Session</a> *session, void *userData) <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">btlmt::SessionPool::SessionStateCallback</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><a class="el" href="classbtlmt_1_1Session.html">Session</a> callback. </p>

</div>
</div>
<a class="anchor" id="a99f7e1aac1e835c18b1ad25682c6ec75"></a><!-- doxytag: member="btlmt::SessionPool::SessionPoolStateCallback" ref="a99f7e1aac1e835c18b1ad25682c6ec75" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int state, int source, void *userData) <a class="el" href="classbtlmt_1_1SessionPool.html#a99f7e1aac1e835c18b1ad25682c6ec75">btlmt::SessionPool::SessionPoolStateCallback</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pool callback. </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a4471b4199deb1c044105be42448ed89a"></a><!-- doxytag: member="btlmt::SessionPool::SessionState" ref="a4471b4199deb1c044105be42448ed89a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1SessionPool.html#a4471b4199deb1c044105be42448ed89a">btlmt::SessionPool::SessionState</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aa0bef0ef104ba3e9a832417d0c82951a0"></a><!-- doxytag: member="e_SESSION_UP" ref="a4471b4199deb1c044105be42448ed89aa0bef0ef104ba3e9a832417d0c82951a0" args="" -->e_SESSION_UP</em>&nbsp;</td><td>
<p>new session has been allocated </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aaae5a7fb66fafadfeece1b1322ceb0a08"></a><!-- doxytag: member="e_SESSION_DOWN" ref="a4471b4199deb1c044105be42448ed89aaae5a7fb66fafadfeece1b1322ceb0a08" args="" -->e_SESSION_DOWN</em>&nbsp;</td><td>
<p>session went down </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aad795c27362f5a95120b66e4e826ca20f"></a><!-- doxytag: member="e_SESSION_ALLOC_FAILED" ref="a4471b4199deb1c044105be42448ed89aad795c27362f5a95120b66e4e826ca20f" args="" -->e_SESSION_ALLOC_FAILED</em>&nbsp;</td><td>
<p>session allocation failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aa3ab565cb1eabe6693c5138d8efd2ec98"></a><!-- doxytag: member="e_SESSION_STARTUP_FAILED" ref="a4471b4199deb1c044105be42448ed89aa3ab565cb1eabe6693c5138d8efd2ec98" args="" -->e_SESSION_STARTUP_FAILED</em>&nbsp;</td><td>
<p>the call to <code>start</code> failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aa5065cf306d335a6017cdac867b834a98"></a><!-- doxytag: member="e_WRITE_QUEUE_LOWWATER" ref="a4471b4199deb1c044105be42448ed89aa5065cf306d335a6017cdac867b834a98" args="" -->e_WRITE_QUEUE_LOWWATER</em>&nbsp;</td><td>
<p>write queue low watermark reached </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aa17c3d0f245bde63c62b3ea65d6402d46"></a><!-- doxytag: member="e_WRITE_QUEUE_HIGHWATER" ref="a4471b4199deb1c044105be42448ed89aa17c3d0f245bde63c62b3ea65d6402d46" args="" -->e_WRITE_QUEUE_HIGHWATER</em>&nbsp;</td><td>
<p>write queue high watermark reached </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aa5cc598e6f6a5998ca50c94566f8374da"></a><!-- doxytag: member="e_ACCEPT_FAILED" ref="a4471b4199deb1c044105be42448ed89aa5cc598e6f6a5998ca50c94566f8374da" args="" -->e_ACCEPT_FAILED</em>&nbsp;</td><td>
<p>accept failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aa90e0e7c16736e45cc5933aa0db047c2d"></a><!-- doxytag: member="e_CONNECT_ATTEMPT_FAILED" ref="a4471b4199deb1c044105be42448ed89aa90e0e7c16736e45cc5933aa0db047c2d" args="" -->e_CONNECT_ATTEMPT_FAILED</em>&nbsp;</td><td>
<p>a connection attempt failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aabcf72de265b16a1952d8dd712db68f23"></a><!-- doxytag: member="e_CONNECT_FAILED" ref="a4471b4199deb1c044105be42448ed89aabcf72de265b16a1952d8dd712db68f23" args="" -->e_CONNECT_FAILED</em>&nbsp;</td><td>
<p>the connection initiation failed </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4471b4199deb1c044105be42448ed89aac2170049d69c3384f29ded6ce1102bd9"></a><!-- doxytag: member="e_CONNECT_ABORTED" ref="a4471b4199deb1c044105be42448ed89aac2170049d69c3384f29ded6ce1102bd9" args="" -->e_CONNECT_ABORTED</em>&nbsp;</td><td>
<p>session was shutdown before the </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a95872d425443f4b788fabb5a4f39856e"></a><!-- doxytag: member="btlmt::SessionPool::ConnectResolutionMode" ref="a95872d425443f4b788fabb5a4f39856e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1SessionPool.html#a95872d425443f4b788fabb5a4f39856e">btlmt::SessionPool::ConnectResolutionMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mode indicating whether to perform name resolution at each connect attempt in <code>connect</code>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a95872d425443f4b788fabb5a4f39856ead655346629a27a9625ae74c9749e52bd"></a><!-- doxytag: member="e_RESOLVE_ONCE" ref="a95872d425443f4b788fabb5a4f39856ead655346629a27a9625ae74c9749e52bd" args="" -->e_RESOLVE_ONCE</em>&nbsp;</td><td>
<p>perform resolution once prior to the first connect attempt </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a95872d425443f4b788fabb5a4f39856ea7356291cb014ac3784cec7067e2a7b54"></a><!-- doxytag: member="e_RESOLVE_AT_EACH_ATTEMPT" ref="a95872d425443f4b788fabb5a4f39856ea7356291cb014ac3784cec7067e2a7b54" args="" -->e_RESOLVE_AT_EACH_ATTEMPT</em>&nbsp;</td><td>
<p>perform resolution prior to each connect attempt </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad12993100d93a1269a3da642f4b981d9"></a><!-- doxytag: member="btlmt::SessionPool::PoolState" ref="ad12993100d93a1269a3da642f4b981d9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1SessionPool.html#ad12993100d93a1269a3da642f4b981d9">btlmt::SessionPool::PoolState</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Result code passed to the pool callback. Note that <code>e_CONNECT_ABORTED</code>, <code>e_CONNECT_ATTEMPT_FAILED</code>, <code>e_CONNECT_FAILED</code>, <code>e_ACCEPT_FAILED</code> are passed to both the session and the pool callbacks. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad12993100d93a1269a3da642f4b981d9a95865851c2caddc7405ea0a3f5c48a6b"></a><!-- doxytag: member="e_SESSION_LIMIT_REACHED" ref="ad12993100d93a1269a3da642f4b981d9a95865851c2caddc7405ea0a3f5c48a6b" args="" -->e_SESSION_LIMIT_REACHED</em>&nbsp;</td><td>
<p>cannot create more sessions </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acb8fe5673aa8bf8f36bdcae9eac13f8e"></a><!-- doxytag: member="btlmt::SessionPool::SessionPool" ref="acb8fe5673aa8bf8f36bdcae9eac13f8e" args="(const ChannelPoolConfiguration &amp;config, const SessionPoolStateCallback &amp;poolStateCallback, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::SessionPool::SessionPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a99f7e1aac1e835c18b1ad25682c6ec75">SessionPoolStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>poolStateCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a87c1949ab308025f3e497e623230558d"></a><!-- doxytag: member="btlmt::SessionPool::SessionPool" ref="a87c1949ab308025f3e497e623230558d" args="(btlb::BlobBufferFactory *blobBufferFactory, const ChannelPoolConfiguration &amp;config, const SessionPoolStateCallback &amp;poolStateCallback, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::SessionPool::SessionPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>blobBufferFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>config</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a99f7e1aac1e835c18b1ad25682c6ec75">SessionPoolStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>poolStateCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a new session pool according to the specified <code>config</code> that uses <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code>s for reading data and invokes the specified <code>poolStateCallback</code> when the pool state changes. Use the specified <code>blobBufferFactory</code> to supply buffers for the blobs used for reading data. Optionally specify <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. If <code>config.readTimeout()</code> is the default configured read-timeout value, then this session pool will disable the underlying channel pool's read-timeout event (i.e., this session pool will set the configured read timeout to 0.0s). Note that read timeout events generated by the underlying channel pool are ignored by this session pool (so there is no benefit to enabling them). </p>

</div>
</div>
<a class="anchor" id="a0d2199a5367c7970d96bdb2923f44d5e"></a><!-- doxytag: member="btlmt::SessionPool::~SessionPool" ref="a0d2199a5367c7970d96bdb2923f44d5e" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::SessionPool::~SessionPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this session pool. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af4ce1563fcbd9f36e2361467025d9724"></a><!-- doxytag: member="btlmt::SessionPool::BSLMF_NESTED_TRAIT_DECLARATION" ref="af4ce1563fcbd9f36e2361467025d9724" args="(SessionPool, bslma::UsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::SessionPool::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionPool.html">SessionPool</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a37c0bb356461c9be423ae0d15209bbf6"></a><!-- doxytag: member="btlmt::SessionPool::start" ref="a37c0bb356461c9be423ae0d15209bbf6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Begin the asynchronous operation of the session pool. Return zero on success, and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="ac241af61891949226cff10fa52be0837"></a><!-- doxytag: member="btlmt::SessionPool::stop" ref="ac241af61891949226cff10fa52be0837" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the asynchronous operation of the session pool and gracefully terminate all active connection and listeners; return 0 on success and a non-zero value otherwise. If all attempts to terminate the sessions "gracefully" fail, a negative value is returned and the sessions are destroyed anyway. </p>

</div>
</div>
<a class="anchor" id="a0b4111d1d3a671e2a6b73ef6435a942c"></a><!-- doxytag: member="btlmt::SessionPool::stopAndRemoveAllSessions" ref="a0b4111d1d3a671e2a6b73ef6435a942c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::stopAndRemoveAllSessions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop the asynchronous operation of this session pool, gracefully terminate all active connectors and listeners, and remove all those communication sessions from this session pool. Return 0 on success, and a non-zero value otherwise. If all attempts to terminate the sessions "gracefully" fail, a negative value is returned and the sessions are destroyed anyway. Note that shutting down a session will deallocate all system resources associated with that session. </p>

</div>
</div>
<a class="anchor" id="a18935f6ec09bac9a714db7d865ced9ae"></a><!-- doxytag: member="btlmt::SessionPool::listen" ref="a18935f6ec09bac9a714db7d865ced9ae" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, int portNumber, int backlog, SessionFactory *factory, void *userData=0, const btlso::SocketOptions *socketOptions=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::listen </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>portNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5bb11ad0bf1039d222ea1455e0854e97"></a><!-- doxytag: member="btlmt::SessionPool::listen" ref="a5bb11ad0bf1039d222ea1455e0854e97" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, int portNumber, int backlog, int reuseAddress, SessionFactory *factory, void *userData=0, const btlso::SocketOptions *socketOptions=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::listen </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>portNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reuseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa65ea6eec1c14ffa7824a79e73df4052"></a><!-- doxytag: member="btlmt::SessionPool::listen" ref="aa65ea6eec1c14ffa7824a79e73df4052" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, const btlso::IPv4Address &amp;endpoint, int backlog, SessionFactory *factory, void *userData=0, const btlso::SocketOptions *socketOptions=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::listen </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a11e8c6d26c840a409ed0d39effeeb0ac"></a><!-- doxytag: member="btlmt::SessionPool::listen" ref="a11e8c6d26c840a409ed0d39effeeb0ac" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, const btlso::IPv4Address &amp;endpoint, int backlog, int reuseAddress, SessionFactory *factory, void *userData=0, const btlso::SocketOptions *socketOptions=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::listen </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reuseAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously listen for connection requests on the specified <code>portNumber</code> on all local interfaces or the specified <code>endpoint</code>, depending on which overload of listen is used, with up to a maximum of <code>backlog</code> concurrent connection requests. Once a connection is successfully accepted, this session pool will allocate and start a session for the connection using the specified <code>factory</code>. Load a handle for the listening connection into <code>handleBuffer</code>. Optionally specify a <code>reuseAddress</code> value to be used in setting <code>REUSEADDRESS</code> socket option. If <code>reuseAddress</code> is not specified, 1 (i.e., <code>REUSEADDRESS</code> is enabled) is used. Optionally specify <code>socketOptions</code> that will be used to specify what options should be set on the listening socket. Return 0 on success, and a non-zero value otherwise. Every time a connection is accepted by this pool on this (newly-established) listening socket, the newly allocated session is passed to the specified <code>callback</code> along with the optionally specified <code>userData</code>. The behavior is undefined unless <code>0 &lt; backlog</code>. </p>

</div>
</div>
<a class="anchor" id="a810c4f39e806cd44790e8347b17b99c4"></a><!-- doxytag: member="btlmt::SessionPool::closeHandle" ref="a810c4f39e806cd44790e8347b17b99c4" args="(int handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::closeHandle </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the listener or the connection represented by the specified <code>handle</code>. Return 0 on success, or a non-zero value if the specified <code>handle</code> does not match any currently allocation session handle. </p>

</div>
</div>
<a class="anchor" id="ad0bae03a026012c5d07ea7e1973abae5"></a><!-- doxytag: member="btlmt::SessionPool::connect" ref="ad0bae03a026012c5d07ea7e1973abae5" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, const char *hostname, int port, int numAttempts, const bsls::TimeInterval &amp;interval, bslma::ManagedPtr&lt; btlso::StreamSocket&lt; btlso::IPv4Address &gt; &gt; *socket, SessionFactory *factory, void *userData=0, ConnectResolutionMode resolutionMode=e_RESOLVE_ONCE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::connect </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionPool.html#a95872d425443f4b788fabb5a4f39856e">ConnectResolutionMode</a>&nbsp;</td>
          <td class="paramname"> <em>resolutionMode</em> = <code>e_RESOLVE_ONCE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac821ba154510168bc6c04e0fced36ca3"></a><!-- doxytag: member="btlmt::SessionPool::connect" ref="ac821ba154510168bc6c04e0fced36ca3" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, const char *hostname, int port, int numAttempts, const bsls::TimeInterval &amp;interval, SessionFactory *factory, void *userData=0, ConnectResolutionMode resolutionMode=e_RESOLVE_ONCE, const btlso::SocketOptions *socketOptions=0, const btlso::IPv4Address *localAddress=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::connect </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionPool.html#a95872d425443f4b788fabb5a4f39856e">ConnectResolutionMode</a>&nbsp;</td>
          <td class="paramname"> <em>resolutionMode</em> = <code>e_RESOLVE_ONCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>localAddress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously attempt to connect to the specified <code>hostname</code> on the specified <code>port</code> up to the specified <code>numAttempts</code> delaying for the specified <code>interval</code> between each attempt. Optionally specify a <code>resolutionMode</code> to indicate whether the name resolution is performed once (if <code>resolutionMode</code> is <code>RESOLVE_ONCE</code>), or performed anew prior to each attempt (if <code>resolutionMode</code> is <code>RESOLVE_AT_EACH_ATTEMPT</code>); if 'resolutionMode is not specified, <code>RESOLVE_ONCE</code> is used. Once a connection is successfully established, allocate and start a session using the specified <code>factory</code> and load a handle for the initiated connection into <code>handleBuffer</code>. Whenever this session state changes (i.e., is established), the specified <code>callback</code> will be invoked along with a pointer to newly created <code><a class="el" href="classbtlmt_1_1Session.html">Session</a></code> and the optionally specified <code>userData</code>. Optionally specify either <code>socketOptions</code> that will be used to specify what options should be set on the connecting socket and/or the specified <code>localAddress</code> to be used as the source address, or specify <code>socket</code> to use as the connecting socket (with any desired options and/or source address already set). If <code>socket</code> is specified, this pool will assume its ownership, if this function returns successfully, and will be left unchanged if an error is returned. Return 0 on successful initiation, and a non-zero value otherwise. The behavior is undefined unless <code>0 &lt; numAttempts</code>, and <code>0 &lt; interval || 1 == numAttempts</code>. </p>

</div>
</div>
<a class="anchor" id="af514d80e40a7a57c95607b19d785f0d7"></a><!-- doxytag: member="btlmt::SessionPool::connect" ref="af514d80e40a7a57c95607b19d785f0d7" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, btlso::IPv4Address const &amp;endpoint, int numAttempts, const bsls::TimeInterval &amp;interval, bslma::ManagedPtr&lt; btlso::StreamSocket&lt; btlso::IPv4Address &gt; &gt; *socket, SessionFactory *factory, void *userData=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::connect </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ad1a3553cec19e154309f651e44a715"></a><!-- doxytag: member="btlmt::SessionPool::connect" ref="a5ad1a3553cec19e154309f651e44a715" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, btlso::IPv4Address const &amp;endpoint, int numAttempts, const bsls::TimeInterval &amp;interval, SessionFactory *factory, void *userData=0, const btlso::SocketOptions *socketOptions=0, const btlso::IPv4Address *localAddress=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::connect </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> const &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>localAddress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously attempt to connect to the specified <code>endpoint</code> up to the specified <code>numAttempts</code> delaying for the specified <code>interval</code> between each attempt; once a connection is successfully established, allocate and start a session using the specified <code>factory</code> and load a handle for the initiated connection into <code>handleBuffer</code>. Whenever this session state changes (i.e., is established), the specified <code>callback</code> will be invoked along with a pointer to newly created <code><a class="el" href="classbtlmt_1_1Session.html">Session</a></code> and the optionally specified <code>userData</code>. Optionally specify either <code>socketOptions</code> that will be used to specify what options should be set on the connecting socket and/or <code>localAddress</code> to be used as the source address, or <code>socket</code> to use as the connecting socket (with any desired options and/or source address already set). If <code>socket</code> is specified, ownership will be transferred from it if this function returns successfully, and will be left unchanged if an error is returned. Return 0 on successful initiation, and a non-zero value otherwise. The behavior is undefined unless <code>0 &lt; numAttempts</code>, and <code>0 &lt; interval</code> or <code>1 == numAttempts</code>. </p>

</div>
</div>
<a class="anchor" id="ae52dbcbd92671559fb4a7a7fd0ddfe9d"></a><!-- doxytag: member="btlmt::SessionPool::import" ref="ae52dbcbd92671559fb4a7a7fd0ddfe9d" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, btlso::StreamSocket&lt; btlso::IPv4Address &gt; *streamSocket, btlso::StreamSocketFactory&lt; btlso::IPv4Address &gt; *socketFactory, SessionFactory *sessionFactory, void *userData=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::import </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>streamSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>socketFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>sessionFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9363f920d26e30dc692e8a1522f72d1a"></a><!-- doxytag: member="btlmt::SessionPool::import" ref="a9363f920d26e30dc692e8a1522f72d1a" args="(int *handleBuffer, const SessionPool::SessionStateCallback &amp;callback, bslma::ManagedPtr&lt; btlso::StreamSocket&lt; btlso::IPv4Address &gt; &gt; *streamSocket, SessionFactory *sessionFactory, void *userData=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::import </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>handleBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1SessionPool.html#a2175efd4427f49e1e5f2c70346e7a60b">SessionPool::SessionStateCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>streamSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1SessionFactory.html">SessionFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>sessionFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously import the specified <code>streamSocket</code> into this session pool. Load into the specified <code>handleBuffer</code> the handle to the corresponding internally-allocated session through the specified <code>sessionFactory</code>. If <code>streamSocket</code> is a <code><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a></code>, then ownership is transferred from it if this function returns successfully, and will be left unchanged if an error is returned; otherwise, upon destruction of this session pool, <code>streamSocket</code> is destroyed via the specified <code>socketFactory</code>. When the session state changes (i.e., is established), the specified <code>callback</code> will be invoked along with the allocated <code><a class="el" href="classbtlmt_1_1Session.html">Session</a></code> and the optionally specified <code>userData</code>. Return 0 on success, and a non-zero value with no effect on the session pool otherwise. </p>

</div>
</div>
<a class="anchor" id="a99d3efee5dbf196d4660d0ac081a3587"></a><!-- doxytag: member="btlmt::SessionPool::setWriteQueueWatermarks" ref="a99d3efee5dbf196d4660d0ac081a3587" args="(int handleId, int lowWatermark, int highWatermark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::setWriteQueueWatermarks </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>handleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lowWatermark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>highWatermark</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the write queue low- and high-water marks for the session associated with the specified <code>handleId</code> to the specified <code>lowWatermark</code> and <code>highWatermark</code> values, respectively; return 0 on success, and a non-zero value otherwise. A <code>e_WRITE_QUEUE_LOWWATER</code> alert is provided (via the channel state callback) if <code>lowWatermark</code> is greater than or equal to the current size of the write queue, and a <code>e_WRITE_QUEUE_HIGHWATER</code> alert is provided if <code>highWatermark</code> is less than or equal to the current size of the write queue. (See the component-level documentation of <code>btlmt_channelpool</code> for details on <code>e_WRITE_QUEUE_HIGHWATER</code> and <code>e_WRITE_QUEUE_LOWWATER</code> alerts.) The behavior is undefined unless <code>0 &lt;= lowWatermark</code> and <code>0 &lt;= highWatermark</code>. Note that this method overrides the values configured (for all channels) by the <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a></code> supplied at construction. </p>

</div>
</div>
<a class="anchor" id="afafeeac972b76eb93c6ae841590cc30b"></a><!-- doxytag: member="btlmt::SessionPool::config" ref="afafeeac972b76eb93c6ae841590cc30b" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a>&amp; btlmt::SessionPool::config </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-modifiable reference to the configuration used during the construction of this session pool. </p>

</div>
</div>
<a class="anchor" id="aaeca7d07e73ae6a8f56447e63bf83827"></a><!-- doxytag: member="btlmt::SessionPool::getChannelHandleStatistics" ref="aaeca7d07e73ae6a8f56447e63bf83827" args="(bsl::vector&lt; ChannelPool::HandleInfo &gt; *handleInfo) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::SessionPool::getChannelHandleStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="structbtlmt_1_1ChannelPool_1_1HandleInfo.html">ChannelPool::HandleInfo</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>handleInfo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>handleInfo</code> array a snapshot of the information per socket handle currently in use by this channel pool. </p>

</div>
</div>
<a class="anchor" id="a345736669f5c424c92a51732a609fe33"></a><!-- doxytag: member="btlmt::SessionPool::numSessions" ref="a345736669f5c424c92a51732a609fe33" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::numSessions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <em>snapshot</em> of the current number of sessions managed by this session pool. </p>

</div>
</div>
<a class="anchor" id="af037d29b86280afe9d750b1e39c48148"></a><!-- doxytag: member="btlmt::SessionPool::portNumber" ref="af037d29b86280afe9d750b1e39c48148" args="(int handle) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::SessionPool::portNumber </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the port number on which the session with the specified <code>handle</code> is listening, or a negative value if <code>handle</code> does not refer to an active listening session obtained from a successful call to <code>listen</code> on this session pool. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a9759a4b9555db39882e10988c1e00f23"></a><!-- doxytag: member="btlmt::SessionPool::SessionPoolSessionIterator" ref="a9759a4b9555db39882e10988c1e00f23" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbtlmt_1_1SessionPoolSessionIterator.html">SessionPoolSessionIterator</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlmt__sessionpool_8h_source.html">btlmt_sessionpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
