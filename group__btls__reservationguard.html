<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btls_reservationguard Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btls_reservationguard<br/>
<small>
[<a class="el" href="group__btls.html">Package btls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a generic proctor for rate controlling objects.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtls.html">btls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> </li>
<li>
<a href="#3.2">Example 1: Guarding units reservation in operations with btls::LeakyBucket</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a generic proctor for rate controlling objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtls_1_1ReservationGuard.html">btls::ReservationGuard</a> </td><td>a guard for reserving resources from rate limiters.  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btls__leakybucket.html" title="Provide a mechanism to monitor the consumption rate of a resource.">Component btls_leakybucket</a>, <a class="el" href="group__btls__ratelimiter.html" title="Provide a mechanism to limit peak and sustained consumption rates.">Component btls_ratelimiter</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides generic proctor to automatically reserve and release units from a rate controlling object. The rate controlling object can be of any type (typically either a <code><a class="el" href="classbtls_1_1RateLimiter.html">btls::RateLimiter</a></code> or <code><a class="el" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a></code>) that provides the following methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> reserve(<a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> numOfUnits);
  <span class="keywordtype">void</span> submitReserved(<a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> numOfUnits);
  <span class="keywordtype">void</span> cancelReserved(<a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> numOfUnits);
</pre></div><br/>
<br/>
 Use <code><a class="el" href="classbtls_1_1ReservationGuard.html">btls::ReservationGuard</a></code> to ensure that reserved units will be correctly returned to a rate controlling object in a programming scope. Note that <code><a class="el" href="classbtls_1_1ReservationGuard.html">btls::ReservationGuard</a></code> does not assume ownership of the rate controlling object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates the intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_guarding_units_reservation_in_operations_with_btls~3A~3Aleakybucket"></a> <a class="anchor" id="description.example_1~3A_guarding_units_reservation_in_operations_with_btls~3A~3Aleakybucket"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="description.example_1"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Guarding units reservation in operations with btls::LeakyBucket: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we are limiting the rate of network traffic generation using a <code><a class="el" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a></code> object. We send data buffer over a network interface using the <code>mySendData</code> function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> mySendData(<span class="keywordtype">size_t</span> dataSize)
      <span class="comment">// Send a specified &#39;dataSize&#39; amount of data over the network.  Return</span>
      <span class="comment">// the amount of data actually sent.  Throw an exception if a network</span>
      <span class="comment">// failure is detected.</span>
  {
      <span class="comment">// In our example we don`t deal with actual data sending, so we assume</span>
      <span class="comment">// that the function has sent certain amount of data (3/4 of the</span>
      <span class="comment">// requested amount) successfully.</span>
      <span class="keywordflow">return</span> (dataSize * 3) &gt;&gt; 2;
  }
</pre></div><br/>
<br/>
 Notice that the <code>mySendData</code> function may throw an exception; therefore, we should wait until <code>mySendData</code> returns before indicating the amount of data sent to the leaky bucket. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Further suppose that multiple threads are sending network data and sharing the same leaky bucket. If every thread simply checks for overflowing of the leaky bucket, send data, and then submit to the leaky bucket, then the rate of data usage may exceed the limits imposed by the leaky bucket due to race conditions. We can avoid the this issue by reserving the amount of data immediately after checking whether the leaky bucket has overflown and submit the reserved amount after the data has been sent. However, this process could lead to the loss of the reserved units (effectively decreasing the leaky bucket's capacity) if <code>mySendData</code> throws an exception. <code><a class="el" href="classbtls_1_1ReservationGuard.html">btls::ReservationGuard</a></code> is designed to resolve this issue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define the size of each data chunk and the total size of the data to send: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  CHUNK_SIZE = 256;
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> bytesSent  = 0;
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> totalSize  = 10 * 1024; <span class="comment">// in bytes</span>
</pre></div><br/>
<br/>
 Then, we create a <code><a class="el" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a></code> object to limit the rate of data transmission: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> rate     = 512;
  <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> capacity = 1536;
  <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a>  now      = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();
  <a class="code" href="classbtls_1_1LeakyBucket.html">btls::LeakyBucket</a>   bucket(rate, capacity, now);
</pre></div><br/>
<br/>
 Next, we send the chunks of data using a loop. For each iteration, we check whether submitting another byte would cause the leaky bucket to overflow: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">while</span> (bytesSent &lt; totalSize) {
      now = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>();
      <span class="keywordflow">if</span> (!bucket.wouldOverflow(now)) {
</pre></div><br/>
<br/>
 Now, if the leaky bucket would not overflow, we create a <code><a class="el" href="classbtls_1_1ReservationGuard.html">btls::ReservationGuard</a></code> object to reserve the amount of data to be sent: <br/>
<br/>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbtls_1_1ReservationGuard.html">btls::ReservationGuard&lt;btls::LeakyBucket&gt;</a> guard(&amp;bucket,
                                                          CHUNK_SIZE);
</pre></div><br/>
<br/>
 Then, we use the <code>mySendData</code> function to send the data chunk over the network. After the data had been sent, we submit the amount of reserved data that was actually sent: <br/>
<br/>
<div class="fragment"><pre class="fragment">          <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> result;
          result = mySendData(CHUNK_SIZE);
          bytesSent += result;
          guard.submitReserved(result);
</pre></div><br/>
<br/>
 Note that we do not have manually cancel any remaining units reserved by the <code><a class="el" href="classbtls_1_1ReservationGuard.html">btls::ReservationGuard</a></code> object either because <code>mySendData</code> threw an exception, or the data was only partially sent, because when the guard object goes out of scope, all remaining reserved units will be automatically cancelled. <br/>
<br/>
<div class="fragment"><pre class="fragment">      }
</pre></div><br/>
<br/>
 Finally, if submitting another byte will cause the leaky bucket to overflow, then we wait until the submission will be allowed by waiting for an amount time returned by the <code>calculateTimeToSubmit</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">else</span> {
          <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> timeToSubmit =
                                           bucket.calculateTimeToSubmit(now);
          <a class="code" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> uS = timeToSubmit.<a class="code" href="classbsls_1_1TimeInterval.html#ac444ef74eebd36b28c6eabd8ee1d75cb">totalMicroseconds</a>() +
                                 (timeToSubmit.<a class="code" href="classbsls_1_1TimeInterval.html#a6a37e5f3c58f4e02724d5fc6321d4d08">nanoseconds</a>() % 1000) ? 1 : 0;
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(static_cast&lt;int&gt;(uS));
      }
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
