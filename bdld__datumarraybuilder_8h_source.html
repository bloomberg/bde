<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdld_datumarraybuilder.h                                           -*-C++-*-
#ifndef INCLUDED_BDLD_DATUMARRAYBUILDER
#define INCLUDED_BDLD_DATUMARRAYBUILDER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide a utility to build a &#39;Datum&#39; object holding an array.
//
//@CLASSES:
//  bdld::DatumArrayBuilder: utility to build a &#39;Datum&#39; object holding an array
//
//@SEE ALSO: bdld_datum
//
//@DESCRIPTION: This component defines a mechanism, &#39;bdld::DatumArrayBuilder&#39;,
// used to populate a &#39;Datum&#39; array value in an exception-safe manner.  In
// addition to providing exception safety, a &#39;DatumArrayBuilder&#39; is
// particularly useful when the length of the array to be constructed is not
// known in advance.  The user can append elements to the datum array as
// needed, and when there are no more elements to append the user calls
// &#39;commit&#39; and ownership of the populated &#39;Datum&#39; object is transferred to the
// caller.  After the call to &#39;commit&#39;, no additional elements can be appended
// to the &#39;Datum&#39; array value.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Using a &#39;DatumArrayBuilder&#39; to Create a &#39;Datum&#39; array.
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we receive a string that is constructed by streaming a bunch of
// values together in the format shown below:
//..
//  &quot;2.34,4,hi there,true&quot;
//..
// Notice that the values are separated by a &#39;,&#39;.  Also note that a &#39;,&#39; is not
// allowed to be part of a string value to simplify the implementation of the
// utility that parses this string.  The following code snippets illustrate how
// to create a &#39;Datum&#39; object that holds an array of &#39;Datum&#39; objects
// constructed using the streamed values.
//
// First we define a function &#39;nextValue&#39; that we will use to tokenize the
// input string:
//..
//  bsl::size_t nextValue(bsl::string *value, const bsl::string&amp; input)
//      // Extract the next value from a list of comma separated values in the
//      // specified &#39;input&#39; string and load it in the specified &#39;value&#39;.
//      // Return the index of the next value within &#39;input&#39;.
//  {
//      if (input.empty()) {
//          return bsl::string::npos;
//      }
//      int start = 0;
//      bsl::size_t nextIndex = input.find(&#39;,&#39;, start);
//      if (bsl::string::npos != nextIndex) {
//          *value = input.substr(start, nextIndex - start);
//      }
//      else {
//          *value = input.substr(start);
//      }
//      return nextIndex;
//  }
//..
// Next, we define a function &#39;convertToDatum&#39; that will convert a string
// token into a &#39;Datum&#39; scalar value:
//..
//  bdld::Datum convertToDatum(const bsl::string&amp;  token,
//                             bslma::Allocator   *basicAllocator)
//      // Convert the specified &#39;token&#39; into the appropriate type of scalar
//      // value and then create and return a &#39;Datum&#39; object using that value.
//      // Use the specified &#39;basicAllocator&#39; to allocate memory.
//  {
//      bool isInteger = true;
//      bool isDouble = false;
//      bool isBoolean = false;
//      for (bsl::size_t i = 0; i &lt; token.size(); ++i) {
//          if (!isdigit(token[i])) {
//              if (&#39;.&#39; == token[i] &amp;&amp; !isDouble) {
//                  isDouble = true;
//                  isInteger = false;
//                  continue;
//              }
//              isInteger = false;
//              isDouble = false;
//              break;
//          }
//      }
//
//      if (!isInteger &amp;&amp; !isDouble) {
//          if (&quot;true&quot; == token || &quot;false&quot; == token) {
//              isBoolean = true;
//          }
//      }
//
//      if (isInteger) { // integer token
//          return bdld::Datum::createInteger(atoi(token.c_str()));
//      }
//      else if (isDouble) { // double token
//          return bdld::Datum::createDouble(atof(token.c_str()));
//      }
//      else if (isBoolean) { // boolean token
//          return bdld::Datum::createBoolean(&quot;true&quot; == token ? true : false);
//      }
//      else { // string value
//          return bdld::Datum::copyString(token, basicAllocator);
//      }
//  }
//..
// Now, in our example main, we tokenize an input string &quot;2.34,4,hi there,true&quot;
// to populate a &#39;Datum&#39; array containing the values &#39;[2.34, 4, &quot;hi there&quot;,
// true]&#39;:
//..
//  void exampleMain() {
//      bslma::TestAllocator allocator;
//      const bsl::string    input(&quot;2.34,4,hi there,true&quot;, &amp;allocator);
//..
// Here, we create a &#39;DatumArrayBuilder&#39;, and iterate over the parsed tokens
// from &#39;input&#39;, using &#39;pushBack&#39; on the array builder to add the tokens to a
// &#39;Datum&#39; array value:
//..
//      bdld::DatumArrayBuilder builder(0, &amp;allocator);
//
//      bsl::string str(input, &amp;allocator);
//
//      bsl::string value;
//      bsl::size_t nextIndex;
//      do {
//          nextIndex = nextValue(&amp;value, str);
//          builder.pushBack(convertToDatum(value, &amp;allocator));
//          if (bsl::string::npos == nextIndex) {
//              break;
//          }
//          str = str.substr(nextIndex + 1);
//      } while (bsl::string::npos != nextIndex);
//
//      bdld::Datum result = builder.commit();
//..
// Notice that calling &#39;commit&#39; on the &#39;DatumArrayBuilder&#39; adopts ownership
// for the returned &#39;Datum&#39; object, and that the behavior is undefined if
// &#39;pushBack&#39; is called after &#39;commit&#39;.
//
// Finally, we verify that &#39;result&#39; has the expected array value, and destroy
// the created &#39;Datum&#39; value:
//..
//      assert(true       == result.isArray());
//      assert(4          == result.theArray().length());
//      assert(true       == result.theArray()[0].isDouble());
//      assert(2.34       == result.theArray()[0].theDouble());
//      assert(true       == result.theArray()[1].isInteger());
//      assert(4          == result.theArray()[1].theInteger());
//      assert(true       == result.theArray()[2].isString());
//      assert(&quot;hi there&quot; == result.theArray()[2].theString());
//      assert(true       == result.theArray()[3].isBoolean());
//      assert(true       == result.theArray()[3].theBoolean());
//
//      // Destroy the &#39;Datum&#39; object.
//      bdld::Datum::destroy(result, &amp;allocator);
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLD_DATUM
#include &lt;bdld_datum.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

namespace BloombergLP {

namespace bslma { class Allocator; }

namespace bdld {

                          // =======================
                          // class DatumArrayBuilder
                          // =======================

class DatumArrayBuilder {
    // This &#39;class&#39; provides a mechanism to build a &#39;Datum&#39; object having an
    // array value in an exception-safe manner.

  public:
    // TYPES
    typedef bsls::Types::size_type SizeType;
        // &#39;SizeType&#39; is an alias for an unsigned integral value, representing
        // the capacity or length of a datum array.

  private:
    // DATA
    DatumMutableArrayRef  d_array;        // mutable access to the datum array
    SizeType              d_capacity;     // capacity of the datum array
    bslma::Allocator     *d_allocator_p;  // allocator for memory

  private:
    // NOT IMPLEMENTED
    DatumArrayBuilder(const DatumArrayBuilder&amp;);
    DatumArrayBuilder&amp; operator=(const DatumArrayBuilder&amp;);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(DatumArrayBuilder,
                                   bslma::UsesBslmaAllocator);

    // CREATORS
    explicit DatumArrayBuilder(SizeType          initialCapacity = 0,
                               bslma::Allocator *basicAllocator  = 0);
        // Create a &#39;DatumArrayBuilder&#39; object that will administer the process
        // of building a &#39;Datum&#39; array.  Optionally specify an
        // &#39;initialCapacity&#39; for the array.  If &#39;initialCapacity&#39; is not
        // supplied, the initial capacity of the array is 0.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    ~DatumArrayBuilder();
        // Destroy this object.  If this object is holding a &#39;Datum&#39; array that
        // has not been adopted, then the &#39;Datum&#39; array is disposed after
        // destroying each of its elements.

    // MANIPULATORS
    void append(const Datum *values, SizeType length);
        // Append the specified array &#39;values&#39; having the specified &#39;length&#39; to
        // the &#39;Datum&#39; array being built by this object.  The behavior is
        // undefined unless &#39;0 != length&#39; and &#39;0 != values&#39; and each element in
        // &#39;values&#39; that needs dynamic memory, is allocated with the same
        // allocator that was used to construct this object.  The behavior is
        // also undefined if &#39;commit&#39; has already been called on this object.

    Datum commit();
        // Return a &#39;Datum&#39; array value holding the elements supplied to
        // &#39;pushBack&#39; or &#39;append&#39;.  The caller is responsible for releasing the
        // resources of the returned &#39;Datum&#39; object.  Calling this method
        // indicates that the caller is finished building the datum array and
        // no further values shall be appended.  It is undefined behavior to
        // call any method of this object, other than the destructor, after
        // &#39;commit&#39; has been called.

    void pushBack(const Datum&amp; value);
        // Append the specified &#39;value&#39; to the &#39;Datum&#39; array being built by
        // this object.  The behavior is undefined if &#39;value&#39; needs dynamic
        // memory and was allocated using a different allocator than the one
        // used to construct this object.  The behavior is also undefined if
        // &#39;commit&#39; has already been called on this object.

    // ACCESSORS
    SizeType capacity() const;
        // Return the capacity of the held &#39;Datum&#39; array.  The behavior is
        // undefined if &#39;commit&#39; has already been called on this object.  Note
        // that similar to the capacity of a &#39;vector&#39;, the returned capacity
        // has no bearing on the value of the &#39;Datum&#39; array being constructed,
        // but does indicate at which point additional memory will be required
        // to grow the &#39;Datum&#39; array being built.

    SizeType size() const;
        // Return the size of the held &#39;Datum&#39; array.  The behavior is
        // undefined if &#39;commit&#39; has already been called on this object.
};

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
