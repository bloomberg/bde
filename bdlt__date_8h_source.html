<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlt_date.h                                                        -*-C++-*-
#ifndef INCLUDED_BDLT_DATE
#define INCLUDED_BDLT_DATE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a value-semantic type to represent dates.
//
//@CLASSES:
//  bdlt::Date: value-semantic date type using the proleptic Gregorian calendar
//
//@SEE_ALSO: bdlt_dayofweek, bdlt_serialdateimputil
//
//@DESCRIPTION: This component defines a value-semantic class, &#39;bdlt::Date&#39;,
// capable of representing any valid date that is consistent with the proleptic
// Gregorian calendar restricted to the years 1 through 9999 (inclusive):
//..
//  http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar
//..
// &quot;Actual&quot; (i.e., natural) day and date calculations are supported directly by
// &#39;bdlt::Date&#39; and its associated free operators.  Calculations involving
// business days (or holidays), and day-count conventions (e.g., &quot;ISMA30360&quot;),
// can be found elsewhere.
//
///Valid Date Values and Their Representations
///-------------------------------------------
// A &#39;bdlt::Date&#39; object *always* represents a valid date value as defined by
// the proleptic Gregorian calendar.  The value of a &#39;bdlt::Date&#39; object can be
// expressed in the interface as either &#39;(year, month, day)&#39;, the canonical
// representation of dates, or &#39;(year, dayOfYear)&#39;.  For example,
// &#39;(1959, 3, 8)&#39; represents the same valid &#39;bdlt::Date&#39; value as &#39;(1959, 67)&#39;
// because the 8th day of the 3rd month of the year 1959 is also the 67th day
// of the year 1959.
//
// Of course, not all combinations of &#39;(year, month, day)&#39; and
// &#39;(year, dayOfYear)&#39; constitute valid values for &#39;bdlt::Date&#39; objects.  A
// &#39;(year, dayOfYear)&#39; pair does *not* represent a valid &#39;bdlt::Date&#39; value
// unless &#39;1 &lt;= year &lt;= 9999&#39; and &#39;1 &lt;= dayOfYear &lt;= 366&#39;.  Additionally, if
// &#39;year&#39; is not a leap year, then the representation is not valid unless
// &#39;1 &lt;= dayOfYear &lt;= 365&#39;.
//
// Note that, in a leap year, February has 29 days instead of the usual 28.
// (Thus, leap years have 366 days instead of the usual 365.)  The proleptic
// Gregorian calendar retroactively applies the leap year rules instituted by
// the Gregorian Reformation to *all* years.  In particular, a year in the
// range &#39;[1 .. 9999]&#39; is a leap year if it is divisible by 4, but *not*
// divisible by 100, *unless* it is *also* divisible by 400.
//
// A &#39;(year, month, day)&#39; triple does *not* represent a valid &#39;bdlt::Date&#39;
// value unless &#39;1 &lt;= year &lt;= 9999&#39;, &#39;1 &lt;= month &lt;= 12&#39;, and &#39;1 &lt;= day &lt;= 31&#39;.
// Also, when &#39;month&#39; is 4, 6, 9, or 11 (April, June, September, or November),
// the representation is not valid unless &#39;1 &lt;= day &lt;= 30&#39;, and, when &#39;month&#39;
// is 2 (February), unless &#39;1 &lt;= day &lt;= 29&#39;.  Finally, when &#39;month&#39; is 2 and
// &#39;year&#39; is not a leap year, then the representation is not valid unless
// &#39;1 &lt;= day &lt;= 28&#39;.
//
// Note that two &#39;static&#39; (class) methods:
//..
//  bool isValidYearDay(int year, int dayOfYear);
//  bool isValidYearMonthDay(int year, int month, int day);
//..
// are provided within &#39;bdlt::Date&#39; to indicate whether the given pair or
// triple of integers would represent a valid &#39;bdlt::Date&#39; value (e.g., prior
// to using them to construct a &#39;bdlt::Date&#39; object).
//
///Ensuring &#39;bdlt::Date&#39; Validity
///------------------------------
// Note that it is incumbent on the client of a &#39;bdlt::Date&#39; object never to
// cause it, directly or indirectly, to hold an invalid value, which can occur
// only by violating explicitly stated preconditions.  For example, invoking
// &#39;operator++&#39; on a date object that represents the valid &#39;bdlt::Date&#39; value
// 9999/12/31 (December 31, 9999) is a contract violation that can lead to
// undefined behavior.  Similarly, attempting to set the value of an existing
// date using the &#39;setYearMonthDay&#39; manipulator such that invoking
// &#39;isValidYearMonthDay&#39; would return &#39;false&#39; on the same &#39;(year, month, day)&#39;
// arguments is another contract violation.
//
// When setting a &#39;bdlt::Date&#39; object to a particular value, there are two
// forms of methods provided for both of the &#39;(year, month, day)&#39; and
// &#39;(year, dayOfYear)&#39; representations of date values.  When you are *certain*
// that the value you are trying to set is valid, either of the following two
// runtime-efficient methods can be used safely:
//..
//  void setYearDay(int year, int dayOfYear);
//  void setYearMonthDay(int year, int month, int day);
//..
// If, however, the integral date attributes at hand are not known to represent
// a valid date, they must first be validated, e.g., by calling one of the two
// &#39;static&#39; &#39;isValid*&#39; methods, or by calling the appropriate set method having
// the &#39;IfValid&#39; suffix, which will always verify validity before either
// setting the value and returning 0, or returning a non-zero status with no
// effect on the object:
//..
//  int setYearDayIfValid(int year, int dayOfYear);
//  int setYearMonthDayIfValid(int year, int month, int day);
//..
// Note that if the value is &quot;known&quot; to be valid, and these latter &#39;IfValid&#39;
// variants are called without checking their return status, we run the risk of
// a &quot;double fault&quot; in that if the value is not actually valid, there is no way
// for a robust implementation (such as this one) to check for the error in a
// defensive (e.g., &quot;DEBUG&quot; or &quot;SAFE&quot;) build mode.
//
///BDEX Compatibility with Legacy POSIX-Based Date
///-----------------------------------------------
// The version 1 format supported by &#39;bdlt::Date&#39; for BDEX streaming is
// expressly intended for maintaining some degree of &quot;compatibility&quot; with a
// legacy date class that uses a (non-proleptic) Gregorian calendar matching
// the POSIX &#39;cal&#39; command.  Over the range of dates supported by &#39;bdlt::Date&#39;
// (&#39;[0001JAN01 .. 9999DEC31&#39;]), the proleptic Gregorian calendar (used by
// &#39;bdlt::Date&#39;) has two fewer days than &#39;cal&#39;, and some dates that exist in
// one calendar do not exist in the other; therefore, true compatibility is not
// possible.  The compatibility guaranteed by BDEX streaming version 1 is such
// that all dates in the range &#39;[1752SEP14 .. 9999DEC31]&#39;, as well as the
// default value (&#39;0001JAN01&#39;), can be successfully exchanged, via BDEX,
// between &#39;bdlt::Date&#39; and the legacy date class.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Use of &#39;bdlt::Date&#39;
/// - - - - - - - - - - - - - - - - - -
// The following snippets of code illustrate how to create and use a
// &#39;bdlt::Date&#39; object.
//
// First, we create a default date &#39;d1&#39;:
//..
//  bdlt::Date d1;           assert(   1 == d1.year());
//                           assert(   1 == d1.month());
//                           assert(   1 == d1.day());
//..
// Next, we set &#39;d1&#39; to July 4, 1776:
//..
//  d1.setYearMonthDay(1776, 7, 4);
//                           assert(1776 == d1.year());
//                           assert(   7 == d1.month());
//                           assert(   4 == d1.day());
//..
// We can also use &#39;setYearMonthDayIfValid&#39; if we are not sure whether a
// particular year/month/day combination constitutes a valid &#39;bdlt::Date&#39;.  For
// example, if we want to set &#39;d1&#39; to &#39;1900/02/29&#39;, and it turns out that year
// 1900 was not a leap year (it wasn&#39;t), there will be no effect on the current
// value of the object:
//..
//  int ret = d1.setYearMonthDayIfValid(1900, 2, 29);
//                           assert(   0 != ret);         // 1900 not leap year
//                           assert(1776 == d1.year());   // no effect on &#39;d1&#39;
//                           assert(   7 == d1.month());
//                           assert(   4 == d1.day());
//..
// Then, from &#39;d1&#39;, we can determine the day of the year, and the day of the
// week, of July 4, 1776:
//..
//  int dayOfYear = d1.dayOfYear();
//                           assert( 186 == dayOfYear);
//
//  bdlt::DayOfWeek::Enum dayOfWeek = d1.dayOfWeek();
//                           assert(bdlt::DayOfWeek::e_THU == dayOfWeek);
//..
// Next, we create a &#39;bdlt::Date&#39; object, &#39;d2&#39;, using the year/day-of-year
// representation for dates:
//..
//  bdlt::Date d2(1776, dayOfYear);
//                           assert(1776 == d2.year());
//                           assert( 186 == d2.dayOfYear());
//                           assert(   7 == d2.month());
//                           assert(   4 == d2.day());
//                           assert(  d1 == d2);
//..
// Then, we add six days to the value of &#39;d2&#39;:
//..
//  d2 += 6;                 assert(1776 == d2.year());
//                           assert(   7 == d2.month());
//                           assert(  10 == d2.day());
//..
// Now, we subtract &#39;d1&#39; from &#39;d2&#39;, storing the (signed) difference in days
// (a.k.a. *Actual* difference) in &#39;daysDiff&#39;:
//..
//  int daysDiff = d2 - d1;  assert(   6 == daysDiff);
//..
// Finally, we stream the value of &#39;d2&#39; to &#39;stdout&#39;:
//..
//  bsl::cout &lt;&lt; d2 &lt;&lt; bsl::endl;
//..
// The streaming operator produces:
//..
//  10JUL1776
//..
// on &#39;stdout&#39;.

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLT_DAYOFWEEK
#include &lt;bdlt_dayofweek.h&gt;
#endif

#ifndef INCLUDED_BDLT_MONTHOFYEAR
#include &lt;bdlt_monthofyear.h&gt;
#endif

#ifndef INCLUDED_BDLT_SERIALDATEIMPUTIL
#include &lt;bdlt_serialdateimputil.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLH_HASH
#include &lt;bslh_hash.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace bdlt {

                                  // ==========
                                  // class Date
                                  // ==========

class Date {
    // This class implements a complex-constrained, value-semantic type for
    // representing dates according to the proleptic Gregorian calendar.  Each
    // object of this class *always* represents a *valid* date value in the
    // range &#39;[0001JAN01 .. 9999DEC31]&#39; inclusive.  The interface of this class
    // supports &#39;Date&#39; values expressed in terms of either year/month/day (the
    // canonical representation) or year/day-of-year (an alternate
    // representation).  See {Valid Date Values and Their Representations} for
    // details.


    // DATA
    int d_serialDate;  // absolute serial date (1 == 1/1/1, 2 == 1/1/2, ...)

    // FRIENDS
    friend bool operator==(const Date&amp;, const Date&amp;);
    friend bool operator!=(const Date&amp;, const Date&amp;);
    friend bool operator&lt; (const Date&amp;, const Date&amp;);
    friend bool operator&lt;=(const Date&amp;, const Date&amp;);
    friend bool operator&gt;=(const Date&amp;, const Date&amp;);
    friend bool operator&gt; (const Date&amp;, const Date&amp;);
    friend Date operator+(const Date&amp;, int);
    friend Date operator+(int, const Date&amp;);
    friend Date operator-(const Date&amp;, int);
    friend int  operator-(const Date&amp;, const Date&amp;);
    template &lt;class HASHALG&gt;
    friend void hashAppend(HASHALG&amp; hashAlg, const Date&amp;);

  private:
    // PRIVATE CLASS METHODS
    static bool isValidSerial(int serialDate);
        // Return &#39;true&#39; if the specified &#39;serialDate&#39; represents a valid value
        // for a &#39;Date&#39; object, and &#39;false&#39; otherwise.  &#39;serialDate&#39; represents
        // a valid &#39;Date&#39; value if it corresponds to a valid date as defined by
        // the proleptic Gregorian calendar confined to the year range
        // &#39;[1 .. 9999]&#39; inclusive, where serial date 1 corresponds to
        // &#39;0001/01/01&#39; and each successive day has a serial date value that is
        // 1 greater than that of the previous day.  See {Valid Date Values and
        // Their Representations} for details.


    // PRIVATE CREATORS
    explicit Date(int serialDate);
        // Create a date initialized with the value indicated by the specified
        // &#39;serialDate&#39;.  The behavior is undefined unless &#39;serialDate&#39;
        // represents a valid &#39;Date&#39; value.

  public:
    // CLASS METHODS
    static bool isValidYearDay(int year, int dayOfYear);
        // Return &#39;true&#39; if the specified &#39;year&#39; and &#39;dayOfYear&#39; represent a
        // valid value for a &#39;Date&#39; object, and &#39;false&#39; otherwise.  &#39;year&#39; and
        // &#39;dayOfYear&#39; represent a valid &#39;Date&#39; value if they correspond to a
        // valid date as defined by the proleptic Gregorian calendar confined
        // to the year range &#39;[1 .. 9999]&#39; inclusive.  See {Valid Date Values
        // and Their Representations} for details.

    static bool isValidYearMonthDay(int year, int month, int day);
        // Return &#39;true&#39; if the specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; represent
        // a valid value for a &#39;Date&#39; object, and &#39;false&#39; otherwise.  &#39;year&#39;,
        // &#39;month&#39;, and &#39;day&#39; represent a valid &#39;Date&#39; value if they correspond
        // to a valid date as defined by the proleptic Gregorian calendar
        // confined to the year range &#39;[1 .. 9999]&#39; inclusive.  See {Valid Date
        // Values and Their Representations} for details.

                                  // Aspects

    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    // CREATORS
    Date();
        // Create a &#39;Date&#39; object having the earliest supported date value,
        // i.e., having a year/month/day representation of &#39;0001/01/01&#39;.

    Date(int year, int dayOfYear);
        // Create a &#39;Date&#39; object having the value represented by the specified
        // &#39;year&#39; and &#39;dayOfYear&#39;.  The behavior is undefined unless &#39;year&#39; and
        // &#39;dayOfYear&#39; represent a valid &#39;Date&#39; value (see &#39;isValidYearDay&#39;).

    Date(int year, int month, int day);
        // Create a &#39;Date&#39; object having the value represented by the specified
        // &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;.  The behavior is undefined unless
        // &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; represent a valid &#39;Date&#39; value (see
        // &#39;isValidYearMonthDay&#39;).

    Date(const Date&amp; original);
        // Create a &#39;Date&#39; object having the value of the specified &#39;original&#39;
        // date.

    ~Date();
        // Destroy this object.

    // MANIPULATORS
    Date&amp; operator=(const Date&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; date, and
        // return a reference providing modifiable access to this object.

    Date&amp; operator+=(int numDays);
        // Assign to this object the value that is later by the specified
        // (signed) &#39;numDays&#39; from its current value, and return a reference
        // providing modifiable access to this object.  The behavior is
        // undefined unless the resulting value falls within the range of dates
        // supported by this class (see &#39;isValidYearMonthDay&#39;).  Note that
        // &#39;numDays&#39; may be negative.

    Date&amp; operator-=(int numDays);
        // Assign to this object the value that is earlier by the specified
        // (signed) &#39;numDays&#39; from its current value, and return a reference
        // providing modifiable access to this object.  The behavior is
        // undefined unless the resulting value falls within the range of dates
        // supported by this class (see &#39;isValidYearMonthDay&#39;).  Note that
        // &#39;numDays&#39; may be negative.

    Date&amp; operator++();
        // Set this object to have the value that is one day later than its
        // current value, and return a reference providing modifiable access to
        // this object.  The behavior is undefined if the year/month/day
        // representation of the current value is &#39;9999/12/31&#39;.

    Date&amp; operator--();
        // Set this object to have the value that is one day earlier than its
        // current value, and return a reference providing modifiable access to
        // this object.  The behavior is undefined if the year/month/day
        // representation of the current value is &#39;0001/01/01&#39;.

    int addDaysIfValid(int numDays);
        // Set this object to have the value that is later by the specified
        // (signed) &#39;numDays&#39; from its current value, if the resulting value
        // falls within the range of dates supported by this class (see
        // &#39;isValidYearMonthDay&#39;).  Return 0 on success, and a non-zero value
        // (with no effect) otherwise.  Note that &#39;numDays&#39; may be negative.

    void setYearDay(int year, int dayOfYear);
        // Set this object to have the value represented by the specified
        // &#39;year&#39; and &#39;dayOfYear&#39;.  The behavior is undefined unless &#39;year&#39; and
        // &#39;dayOfYear&#39; represent a valid &#39;Date&#39; value (see &#39;isValidYearDay&#39;).

    int setYearDayIfValid(int year, int dayOfYear);
        // Set this object to have the value represented by the specified
        // &#39;year&#39; and &#39;dayOfYear&#39; if they comprise a valid &#39;Date&#39; value (see
        // &#39;isValidYearDay&#39;).  Return 0 on success, and a non-zero value (with
        // no effect) otherwise.

    void setYearMonthDay(int year, int month, int day);
        // Set this object to have the value represented by the specified
        // &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;.  The behavior is undefined unless
        // &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; represent a valid &#39;Date&#39; value (see
        // &#39;isValidYearMonthDay&#39;).

    int setYearMonthDayIfValid(int year, int month, int day);
        // Set this object to have the value represented by the specified
        // &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; if they comprise a valid &#39;Date&#39; value
        // (see &#39;isValidYearMonthDay&#39;).  Return 0 on success, and a non-zero
        // value (with no effect) otherwise.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ATTRIBUTE ACCESSORS
    int day() const;
        // Return the day of the month in the range &#39;[1 .. 31]&#39; of this date.

    int dayOfYear() const;
        // Return the day of the year in the range &#39;[1 .. 366]&#39; of this date.

    int month() const;
        // Return the month of the year in the range &#39;[1 .. 12]&#39; of this date.

    int year() const;
        // Return the year in the range &#39;[1 .. 9999]&#39; of this date.

    // ACCESSORS
    DayOfWeek::Enum dayOfWeek() const;
        // Return the day of the week in the range
        // &#39;[DayOfWeek::e_SUN .. DayOfWeek::e_SAT]&#39; of this date.

    void getYearDay(int *year, int *dayOfYear) const;
        // Load, into the specified &#39;year&#39; and &#39;dayOfYear&#39;, the respective
        // &#39;year&#39; and &#39;dayOfYear&#39; attribute values of this date.

    void getYearMonthDay(int *year, int *month, int *day) const;
        // Load, into the specified &#39;year&#39;, &#39;month&#39;, and &#39;day&#39;, the respective
        // &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; attribute values of this date.

    MonthOfYear::Enum monthOfYear() const;
        // Return the month of the year in the range
        // &#39;[MonthOfYear::e_JAN .. MonthOfYear::e_DEC]&#39; of this date.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level = 0,
                        int           spacesPerLevel = 4) const;
        // Write the value of this object to the specified output &#39;stream&#39; in a
        // human-readable format, and return a reference to &#39;stream&#39;.
        // Optionally specify an initial indentation &#39;level&#39;, whose absolute
        // value is incremented recursively for nested objects.  If &#39;level&#39; is
        // specified, optionally specify &#39;spacesPerLevel&#39;, whose absolute value
        // indicates the number of spaces per indentation level for this and
        // all of its nested objects.  If &#39;level&#39; is negative, suppress
        // indentation of the first line.  If &#39;spacesPerLevel&#39; is negative,
        // format the entire output on one line, suppressing all but the
        // initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is not
        // valid on entry, this operation has no effect.  Note that this
        // human-readable format is not fully specified, and can change without
        // notice.


};

// FREE OPERATORS
bool operator==(const Date&amp; lhs, const Date&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;Date&#39; objects have the same value if
    // each of their &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; attributes (respectively) have
    // the same value.

bool operator!=(const Date&amp; lhs, const Date&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;Date&#39; objects do not have the
    // same value if any of their &#39;year&#39;, &#39;month&#39;, and &#39;day&#39; attributes
    // (respectively) do not have the same value.

bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp; stream, const Date&amp; date);
    // Write the value of the specified &#39;date&#39; object to the specified output
    // &#39;stream&#39; in a single-line format, and return a reference to &#39;stream&#39;.
    // If &#39;stream&#39; is not valid on entry, this operation has no effect.  Note
    // that this human-readable format is not fully specified, can change
    // without notice, and is logically equivalent to:
    //..
    //  print(stream, 0, -1);
    //..

bool operator&lt;(const Date&amp; lhs, const Date&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; date is earlier than the specified
    // &#39;rhs&#39; date, and &#39;false&#39; otherwise.

bool operator&lt;=(const Date&amp; lhs, const Date&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; date is earlier than or the same as
    // the specified &#39;rhs&#39; date, and &#39;false&#39; otherwise.

bool operator&gt;(const Date&amp; lhs, const Date&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; date is later than the specified
    // &#39;rhs&#39; date, and &#39;false&#39; otherwise.

bool operator&gt;=(const Date&amp; lhs, const Date&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; date is later than or the same as
    // the specified &#39;rhs&#39; date, and &#39;false&#39; otherwise.

Date operator++(Date&amp; date, int);
    // Set the specified &#39;date&#39; object to have the value that is one day later
    // than its current value, and return the value of &#39;date&#39; on entry.  The
    // behavior is undefined if the value of &#39;date&#39; on entry is &#39;9999/12/31&#39;.

Date operator--(Date&amp; date, int);
    // Set the specified &#39;date&#39; object to have the value that is one day
    // earlier than its current value, and return the value of &#39;date&#39; on entry.
    // The behavior is undefined if the value of &#39;date&#39; on entry is
    // &#39;0001/01/01&#39;.

Date operator+(const Date&amp; date,    int         numDays);
Date operator+(int         numDays, const Date&amp; date);
    // Return the date value that is later by the specified (signed) &#39;numDays&#39;
    // from the specified &#39;date&#39;.  The behavior is undefined unless the
    // resulting value falls within the range of dates supported by this class
    // (see &#39;isValidYearMonthDay&#39;).  Note that &#39;numDays&#39; may be negative.

Date operator-(const Date&amp; date, int numDays);
    // Return the date value that is earlier by the specified (signed)
    // &#39;numDays&#39; from the specified &#39;date&#39;.  The behavior is undefined unless
    // the resulting value falls within the range of dates supported by this
    // class (see &#39;isValidYearMonthDay&#39;).  Note that &#39;numDays&#39; may be negative.

int operator-(const Date&amp; lhs, const Date&amp; rhs);
    // Return the (signed) number of days between the specified &#39;lhs&#39; and &#39;rhs&#39;
    // dates.  Note that if &#39;lhs &lt; rhs&#39; the result will be negative.

template &lt;class HASHALG&gt;
void hashAppend(HASHALG&amp; hashAlg, const Date&amp; date);
    // Pass the specified &#39;date&#39; to the specified &#39;hashAlg&#39;.  Note that this
    // function is intended to integrate with the &#39;bslh&#39; modular hashing
    // system, and effectively provides a &#39;bsl::hash&#39; specialization for
    // &#39;date&#39;.

// ============================================================================
//                              INLINE DEFINITIONS
// ============================================================================

                                  // ----------
                                  // class Date
                                  // ----------

// PRIVATE CLASS METHODS
inline
bool Date::isValidSerial(int serialDate)
{
    return SerialDateImpUtil::isValidSerial(serialDate);
}

// PRIVATE CREATORS
inline
Date::Date(int serialDate)
: d_serialDate(serialDate)
{
    BSLS_ASSERT_SAFE(Date::isValidSerial(d_serialDate));
}

// CLASS METHODS
inline
bool Date::isValidYearDay(int year, int dayOfYear)
{
    return SerialDateImpUtil::isValidYearDay(year, dayOfYear);
}

inline
bool Date::isValidYearMonthDay(int year, int month, int day)
{
    return SerialDateImpUtil::isValidYearMonthDay(year, month, day);
}

                                  // Aspects

inline
int Date::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

// CREATORS
inline
Date::Date()
: d_serialDate(1)
{
}

inline
Date::Date(int year, int dayOfYear)
: d_serialDate(SerialDateImpUtil::ydToSerial(year, dayOfYear))
{
    BSLS_ASSERT_SAFE(isValidYearDay(year, dayOfYear));

}

inline
Date::Date(int year, int month, int day)
: d_serialDate(SerialDateImpUtil::ymdToSerial(year, month, day))
{
    BSLS_ASSERT_SAFE(isValidYearMonthDay(year, month, day));

}

inline
Date::Date(const Date&amp; original)
: d_serialDate(original.d_serialDate)
{
}

inline
Date::~Date()
{
    BSLS_ASSERT_SAFE(Date::isValidSerial(d_serialDate));
}

// MANIPULATORS
inline
Date&amp; Date::operator=(const Date&amp; rhs)
{
    d_serialDate = rhs.d_serialDate;
    return *this;
}

inline
Date&amp; Date::operator+=(int numDays)
{
    BSLS_ASSERT_SAFE(Date::isValidSerial(d_serialDate + numDays));


    d_serialDate += numDays;
    return *this;
}

inline
Date&amp; Date::operator-=(int numDays)
{
    BSLS_ASSERT_SAFE(Date::isValidSerial(d_serialDate - numDays));


    d_serialDate -= numDays;
    return *this;
}

inline
Date&amp; Date::operator++()
{
    BSLS_ASSERT_SAFE(*this != Date(9999, 12, 31));


    ++d_serialDate;
    return *this;
}

inline
Date&amp; Date::operator--()
{
    BSLS_ASSERT_SAFE(*this != Date(1, 1, 1));


    --d_serialDate;
    return *this;
}

inline
void Date::setYearDay(int year, int dayOfYear)
{
    BSLS_ASSERT_SAFE(isValidYearDay(year, dayOfYear));

    d_serialDate = SerialDateImpUtil::ydToSerial(year, dayOfYear);
}

inline
int Date::setYearDayIfValid(int year, int dayOfYear)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    if (isValidYearDay(year, dayOfYear)) {
        setYearDay(year, dayOfYear);
        return k_SUCCESS;                                             // RETURN
    }

    return k_FAILURE;
}

inline
void Date::setYearMonthDay(int year, int month, int day)
{
    BSLS_ASSERT_SAFE(isValidYearMonthDay(year, month, day));

    d_serialDate = SerialDateImpUtil::ymdToSerial(year, month, day);
}

inline
int Date::setYearMonthDayIfValid(int year, int month, int day)
{
    enum { k_SUCCESS = 0, k_FAILURE = -1 };

    if (isValidYearMonthDay(year, month, day)) {
        setYearMonthDay(year, month, day);
        return k_SUCCESS;                                             // RETURN
    }

    return k_FAILURE;
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; Date::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            int tmpSerialDate = 0;

            stream.getInt24(tmpSerialDate);

            // See {BDEX Compatibility with Legacy POSIX-Based &#39;Date&#39;} in the
            // component-level documentation.

            if (tmpSerialDate &gt; 3) {
                tmpSerialDate -= 2;  // ensure that serial values for 1752SEP14
                                     // and later dates &quot;align&quot;
            }
            else if (tmpSerialDate &gt; 0) {
                tmpSerialDate = 1;   // &quot;fuzzy&quot; default value &#39;[1 .. 3]&#39;
            }

            if (stream &amp;&amp; Date::isValidSerial(tmpSerialDate)) {
                d_serialDate = tmpSerialDate;

            }
            else {
                stream.invalidate();
            }
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }

    return stream;
}

// ATTRIBUTE ACCESSORS
inline
int Date::day() const
{
    return SerialDateImpUtil::serialToDay(d_serialDate);
}

inline
int Date::dayOfYear() const
{
    return SerialDateImpUtil::serialToDayOfYear(d_serialDate);
}

inline
int Date::month() const
{
    return SerialDateImpUtil::serialToMonth(d_serialDate);
}

inline
int Date::year() const
{
    return SerialDateImpUtil::serialToYear(d_serialDate);
}

// ACCESSORS
inline
DayOfWeek::Enum Date::dayOfWeek() const
{
    return static_cast&lt;DayOfWeek::Enum&gt;(
                           SerialDateImpUtil::serialToDayOfWeek(d_serialDate));
}

inline
void Date::getYearDay(int *year, int *dayOfYear) const
{
    BSLS_ASSERT_SAFE(year);
    BSLS_ASSERT_SAFE(dayOfYear);

    SerialDateImpUtil::serialToYd(year, dayOfYear, d_serialDate);
}

inline
void Date::getYearMonthDay(int *year, int *month, int *day) const
{
    BSLS_ASSERT_SAFE(year);
    BSLS_ASSERT_SAFE(month);
    BSLS_ASSERT_SAFE(day);

    SerialDateImpUtil::serialToYmd(year, month, day, d_serialDate);
}

inline
MonthOfYear::Enum Date::monthOfYear() const
{
    return static_cast&lt;MonthOfYear::Enum&gt;(month());
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; Date::bdexStreamOut(STREAM&amp; stream, int version) const
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {

            // See {BDEX Compatibility with Legacy POSIX-Based &#39;Date&#39;} in the
            // component-level documentation.

            if (1 == d_serialDate) {  // preserve default value
                stream.putInt24(d_serialDate);
            }
            else {
                stream.putInt24(d_serialDate + 2);
                                      // ensure that serial values for
                                      // 1752SEP14 and later dates &quot;align&quot;
            }
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }
    return stream;
}


}  // close package namespace

// FREE OPERATORS
inline
bool bdlt::operator==(const Date&amp; lhs, const Date&amp; rhs)
{
    return lhs.d_serialDate == rhs.d_serialDate;
}

inline
bool bdlt::operator!=(const Date&amp; lhs, const Date&amp; rhs)
{
    return lhs.d_serialDate != rhs.d_serialDate;
}

inline
bsl::ostream&amp; bdlt::operator&lt;&lt;(bsl::ostream&amp; stream, const Date&amp; date)
{
    return date.print(stream, 0, -1);
}

inline
bool bdlt::operator&lt;(const Date&amp; lhs, const Date&amp; rhs)
{
    return lhs.d_serialDate &lt; rhs.d_serialDate;
}

inline
bool bdlt::operator&lt;=(const Date&amp; lhs, const Date&amp; rhs)
{
    return lhs.d_serialDate &lt;= rhs.d_serialDate;
}

inline
bool bdlt::operator&gt;(const Date&amp; lhs, const Date&amp; rhs)
{
    return lhs.d_serialDate &gt; rhs.d_serialDate;
}

inline
bool bdlt::operator&gt;=(const Date&amp; lhs, const Date&amp; rhs)
{
    return lhs.d_serialDate &gt;= rhs.d_serialDate;
}

inline
bdlt::Date bdlt::operator++(Date&amp; date, int)
{
    BSLS_ASSERT_SAFE(date != Date(9999, 12, 31));

    Date tmp(date);
    ++date;
    return tmp;
}

inline
bdlt::Date bdlt::operator--(Date&amp; date, int)
{
    BSLS_ASSERT_SAFE(date != Date(1, 1, 1));

    Date tmp(date);
    --date;
    return tmp;
}

inline
bdlt::Date bdlt::operator+(const Date&amp; date, int numDays)
{
    BSLS_ASSERT_SAFE(Date::isValidSerial(date.d_serialDate + numDays));


    return Date(date.d_serialDate + numDays);
}

inline
bdlt::Date bdlt::operator+(int numDays, const Date&amp; date)
{
    BSLS_ASSERT_SAFE(Date::isValidSerial(numDays + date.d_serialDate));


    return Date(numDays + date.d_serialDate);
}

inline
bdlt::Date bdlt::operator-(const Date&amp; date, int numDays)
{
    BSLS_ASSERT_SAFE(Date::isValidSerial(date.d_serialDate - numDays));


    return Date(date.d_serialDate - numDays);
}

inline
int bdlt::operator-(const Date&amp; lhs, const Date&amp; rhs)
{

    return lhs.d_serialDate - rhs.d_serialDate;
}

// ASPECTS
template &lt;class HASHALG&gt;
void bdlt::hashAppend(HASHALG&amp; hashAlg, const Date&amp; date)
{
    using ::BloombergLP::bslh::hashAppend;
    hashAppend(hashAlg, date.d_serialDate);
}

}  // close enterprise namespace

namespace bsl {

template &lt;&gt;
struct is_trivially_copyable&lt;BloombergLP::bdlt::Date&gt; : bsl::true_type {
    // This template specialization for &#39;is_trivially_copyable&#39; indicates that
    // &#39;Date&#39; is a trivially copyable type.
};

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
