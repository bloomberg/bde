<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmt_mutexassert.h                                                -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BSLMT_MUTEXASSERT
#define INCLUDED_BSLMT_MUTEXASSERT

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an assert macro for verifying that a mutex is locked.
//
//@CLASSES:
//
//@MACROS:
//  BSLMT_MUTEXASSERT_IS_LOCKED: verify a mutex is locked in non-opt modes
//  BSLMT_MUTEXASSERT_IS_LOCKED_SAFE: verify a mutex is locked in safe mode
//  BSLMT_MUTEXASSERT_IS_LOCKED_OPT: verify a mutex is locked in all modes
//
//@SEE_ALSO: bslmt_mutex
//
//@DESCRIPTION: This component provides macros for asserting that a mutex is
// locked.  It does not distinguish between locks held by the current thread or
// other threads.  If the macro is active in the current build mode, when the
// macro is called, if the supplied mutex is unlocked, the assert handler
// installed for &#39;BSLS_ASSERT&#39; will be called.  The assert handler installed by
// default will report an error and abort the task.
//
// The three macros defined by the component are analogous to the macros
// defined by &#39;BSLS_ASSERT&#39;:
//
//: o &#39;BSLMT_MUTEXASSERT_IS_LOCKED&#39;: active when &#39;BSLS_ASSERT&#39; is active
//:
//: o &#39;BSLMT_MUTEXASSERT_IS_LOCKED_SAFE&#39;: active when &#39;BSLS_ASSERT_SAFE&#39; is
//:   active
//:
//: o &#39;BSLMT_MUTEXASSERT_IS_LOCKED_OPT&#39;: active when &#39;BSLS_ASSERT_OPT&#39; is
//:   active
//
// In build modes where any one of these macros is not active, calling it will
// have no effect.
//
// If any of these asserts are in effect and fail (because the mutex in
// question was unlocked), the behavior parallels the behavior of the assertion
// macros defined in &#39;bsls_assert.h&#39; -- &#39;bsls::Assert::invokeHandler&#39; is
// called, with a source code expression, the name of the source file, and the
// line number in the source file where the macro was called.  If the default
// handler is installed, this will result in an error message and an abort.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Checking Consistency Within a Private Method
///- - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Sometimes multithreaded code is written such that the author of a function
// requires that a caller has already acquired a mutex.  The
// &#39;BSLMT_MUTEXASSERT_IS_LOCKED*&#39; family of assertions allows the programmers
// to verify, using defensive programming techniques, that the mutex in
// question is indeed locked.
//
// Suppose we have a fully thread-safe queue that contains &#39;int&#39; values, and is
// guarded by an internal mutex.  We can use &#39;BSLMT_MUTEXASSERT_IS_LOCKED_SAFE&#39;
// to ensure (in appropriate build modes) that proper internal locking of the
// mutex is taking place.
//
// First, we define the container:
//..
//  class MyThreadSafeQueue {
//      // This &#39;class&#39; provides a fully *thread-safe* unidirectional queue of
//      // &#39;int&#39; values.  See {&#39;bsls_glossary&#39;|Fully Thread-Safe}.  All public
//      // manipulators operate as single, atomic actions.
//
//      // DATA
//      bsl::deque&lt;int&gt;      d_deque;    // underlying non-*thread-safe*
//                                       // standard container
//
//      mutable bslmt::Mutex  d_mutex;    // mutex to provide thread safety
//
//      // PRIVATE MANIPULATOR
//      int popImp(int *result);
//          // Assign the value at the front of the queue to the specified
//          // &#39;*result&#39;, and remove the value at the front of the queue;
//          // return 0 if the queue was not initially empty, and a non-zero
//          // value (with no effect) otherwise.  The behavior is undefined
//          // unless &#39;d_mutex&#39; is locked.
//
//    public:
//      // ...
//
//      // MANIPULATORS
//      int pop(int *result);
//          // Assign the value at the front of the queue to the specified
//          // &#39;*result&#39;, and remove the value at the front of the queue;
//          // return 0 if the queue was not initially empty, and a non-zero
//          // value (with no effect) otherwise.
//
//      void popAll(bsl::vector&lt;int&gt; *result);
//          // Assign the values of all the elements from this queue, in order,
//          // to the specified &#39;*result&#39;, and remove them from this queue.
//          // Any previous contents of &#39;*result&#39; are discarded.  Note that, as
//          // with the other public manipulators, this entire operation occurs
//          // as a single, atomic action.
//
//      void push(int value);
//          // ...
//
//      template &lt;class INPUT_ITER&gt;
//      void pushRange(const INPUT_ITER&amp; first, const INPUT_ITER&amp; last);
//          // ...
//  };
//..
// Notice that our public manipulators have two forms: push/pop a single
// element, and push/pop a collection of elements.  Popping even a single
// element is non-trivial, so we factor this operation into a non-*thread-safe*
// private manipulator that performs the pop, and is used in both public &#39;pop&#39;
// methods.  This private manipulator requires that the mutex be locked, but
// cannot lock the mutex itself, since the correctness of &#39;popAll&#39; demands that
// all of the pops be collectively performed using a single mutex lock/unlock.
//
// Then, we define the private manipulator:
//..
//  // PRIVATE MANIPULATOR
//  int MyThreadSafeQueue::popImp(int *result)
//  {
//      BSLMT_MUTEXASSERT_IS_LOCKED_SAFE(&amp;d_mutex);
//
//      if (d_deque.empty()) {
//          return -1;                                                // RETURN
//      }
//      else {
//          *result = d_deque.front();
//          d_deque.pop_front();
//          return 0;                                                 // RETURN
//      }
//  }
//..
// Notice that, on the very first line, the private manipulator verifies, as a
// precondition check, that the mutex has been acquired, using one of the
// &#39;BSLMT_MUTEXASSERT_IS_LOCKED*&#39; macros.  We use the &#39;...IS_LOCKED_SAFE...&#39;
// version of the macro so that the check, which on some platforms is as
// expensive as locking the mutex, is performed in only the safe build mode.
//
// Next, we define the public manipulators; each of which must acquire a lock
// on the mutex (note that there is a bug in &#39;popAll&#39;):
//..
//  // MANIPULATORS
//  int MyThreadSafeQueue::pop(int *result)
//  {
//      BSLS_ASSERT(result);
//
//      d_mutex.lock();
//      int rc = popImp(result);
//      d_mutex.unlock();
//      return rc;
//  }
//
//  void MyThreadSafeQueue::popAll(bsl::vector&lt;int&gt; *result)
//  {
//      BSLS_ASSERT(result);
//
//      const int size = static_cast&lt;int&gt;(d_deque.size());
//      result-&gt;resize(size);
//      int *begin = result-&gt;begin();
//      for (int index = 0; index &lt; size; ++index) {
//          int rc = popImp(&amp;begin[index]);
//          BSLS_ASSERT(0 == rc);
//      }
//  }
//
//  void MyThreadSafeQueue::push(int value)
//  {
//      d_mutex.lock();
//      d_deque.push_back(value);
//      d_mutex.unlock();
//  }
//
//  template &lt;class INPUT_ITER&gt;
//  void MyThreadSafeQueue::pushRange(const INPUT_ITER&amp; first,
//                                    const INPUT_ITER&amp; last)
//  {
//      d_mutex.lock();
//      d_deque.insert(d_deque.begin(), first, last);
//      d_mutex.unlock();
//  }
//..
// Notice that, in &#39;popAll&#39;, we forgot to lock/unlock the mutex!
//
// Then, in our function &#39;example2Function&#39;, we make use of our class to create
// and exercise a &#39;MyThreadSafeQueue&#39; object:
//..
//  void testThreadSafeQueue(bsl::ostream&amp; stream)
//  {
//      MyThreadSafeQueue queue;
//..
// Next, we populate the queue using &#39;pushRange&#39;:
//..
//      const int rawData[] = { 17, 3, 21, -19, 4, 87, 29, 3, 101, 31, 36 };
//      enum { k_RAW_DATA_LENGTH = sizeof rawData / sizeof *rawData };
//
//      queue.pushRange(rawData + 0, rawData + k_RAW_DATA_LENGTH);
//..
// Then, we pop a few items off the front of the queue and verify their values:
//..
//      int value = -1;
//
//      assert(0 == queue.pop(&amp;value));    assert(17 == value);
//      assert(0 == queue.pop(&amp;value));    assert( 3 == value);
//      assert(0 == queue.pop(&amp;value));    assert(21 == value);
//..
// Next, we attempt to empty the queue with &#39;popAll&#39;, which, if built in safe
// mode, would fail because it neglects to lock the mutex:
//..
//      bsl::vector&lt;int&gt; v;
//      queue.popAll(&amp;v);
//
//      stream &lt;&lt; &quot;Remaining raw numbers: &quot;;
//      for (bsl::size_t ti = 0; ti &lt; v.size(); ++ti) {
//          stream &lt;&lt; (ti ? &quot;, &quot; : &quot;&quot;) &lt;&lt; v[ti];
//      }
//      stream &lt;&lt; bsl::endl;
//  }
//..
// Then, we build in non-safe mode and run:
//..
//  Remaining raw numbers: -19, 4, 87, 29, 3, 101, 31, 36
//..
// Notice that, since the test case is being run in a single thread and our
// check is disabled, the bug where the mutex was not acquired does not
// manifest itself in a visible error, and we observe the seemingly correct
// output.
//
// Now, we build in safe mode (which enables our check), run the program (which
// calls &#39;example2Function&#39;), and observe that, when we call &#39;popAll&#39;, the
// &#39;BSLMT_MUTEXASSERT_IS_LOCKED_SAFE(&amp;d_mutex)&#39; macro issues an error message
// and aborts:
//..
//  Assertion failed: BSLMT_MUTEXASSERT_IS_LOCKED_SAFE(&amp;d_mutex), file /bb/big
//  storn/dev_framework/bchapman/git/bde-core/groups/bce/bslmt/unix-Linux-x86_6
//  4-2.6.18-gcc-4.6.1/bslmt_mutexassertislocked.t.cpp, line 137
//  Aborted (core dumped)
//..
// Finally, note that the message printed above and the subsequent aborting of
// the program were the result of a call to &#39;bsls::Assert::invokeHandler&#39;,
// which in this case was configured (by default) to call
// &#39;bsls::Assert::failAbort&#39;.  Other handlers may be installed that produce
// different results, but in all cases should prevent the program from
// proceeding normally.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#if defined(BSLS_ASSERT_IS_ACTIVE)
    #define BSLMT_MUTEXASSERT_IS_LOCKED(mutex_p) do {                         \
        bslmt::MutexAssert_Imp::assertIsLockedImpl(                           \
                           (mutex_p),                                         \
                           &quot;BSLMT_MUTEXASSERT_IS_LOCKED(&quot; #mutex_p &quot;)&quot;,       \
                           __FILE__,                                          \
                           __LINE__); } while (false)
#else
    #define BSLMT_MUTEXASSERT_IS_LOCKED(mutex_p) ((void) 0)
#endif

#if defined(BSLS_ASSERT_SAFE_IS_ACTIVE)
    #define BSLMT_MUTEXASSERT_IS_LOCKED_SAFE(mutex_p) do {                    \
        bslmt::MutexAssert_Imp::assertIsLockedImpl(                           \
                           (mutex_p),                                         \
                           &quot;BSLMT_MUTEXASSERT_IS_LOCKED_SAFE(&quot; #mutex_p &quot;)&quot;,  \
                           __FILE__,                                          \
                           __LINE__); } while (false)
#else
    #define BSLMT_MUTEXASSERT_IS_LOCKED_SAFE(mutex_p) ((void) 0)
#endif

#if defined(BSLS_ASSERT_OPT_IS_ACTIVE)
    #define BSLMT_MUTEXASSERT_IS_LOCKED_OPT(mutex_p) do {                     \
        bslmt::MutexAssert_Imp::assertIsLockedImpl(                           \
                           (mutex_p),                                         \
                           &quot;BSLMT_MUTEXASSERT_IS_LOCKED_OPT(&quot; #mutex_p &quot;)&quot;,   \
                           __FILE__,                                          \
                           __LINE__); } while (false)
#else
    #define BSLMT_MUTEXASSERT_IS_LOCKED_OPT(mutex_p) ((void) 0)
#endif

namespace BloombergLP {
namespace bslmt {

class Mutex;

                          // =====================
                          // class MutexAssert_Imp
                          // =====================

struct MutexAssert_Imp {
    // This &#39;struct&#39; provides a (component private) namespace for
    // implementation functions of the assert macros defined in this component.
    // This class should *not* be used directly in client code.

    // CLASS METHODS
    static void assertIsLockedImpl(Mutex      *mutex,
                                   const char *text,
                                   const char *file,
                                   int         line);
        // If the specified &#39;mutex&#39; is not locked, call
        // &#39;bsls::Assert::invokeHandler&#39; with the specified &#39;text&#39;, &#39;file&#39;, and
        // &#39;line&#39;, where &#39;text&#39; is text describing the assertion being
        // performed, &#39;file&#39; is the name of the source file that called the
        // macro, and &#39;line&#39; is the line number in the file where the macro was
        // called.  This function is intended to implement
        // &#39;BSLMT_MUTEXASSERT_IS_LOCKED&#39;, &#39;BSLMT_MUTEXASSERT_IS_LOCKED_SAFE&#39;,
        // and &#39;BSLMT_MUTEXASSERT_IS_LOCKED_OPT&#39; and should not otherwise be
        // called directly.
};
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
