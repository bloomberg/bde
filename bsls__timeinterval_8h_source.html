<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bsls_timeinterval.h                                                -*-C++-*-
#ifndef INCLUDED_BSLS_TIMEINTERVAL
#define INCLUDED_BSLS_TIMEINTERVAL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a representation of a time interval.
//
//@CLASSES:
//   bsls::TimeInterval: time interval with nanosecond resolution
//
//@SEE_ALSO: bdlt_time, bdlt_datetimeinterval
//
//@DESCRIPTION: This component provides a value-semantic type,
// &#39;bsls::TimeInterval&#39;, that is capable of representing a signed time
// interval with nanosecond resolution.
//
///Representation
///--------------
// A time interval has a value that is independent of its representation.
// Conceptually, a time interval may be thought of as a signed,
// arbitrary-precision floating-point number denominated in seconds (or in
// days, or in fortnights, if one prefers).  A &#39;bsls::TimeInterval&#39; represents
// this value as two fields: seconds and nanoseconds.  In the &quot;canonical
// representation&quot; of a time interval, the &#39;seconds&#39; field may have any 64-bit
// signed integer value, with the &#39;nanoseconds&#39; field limited to the range
// &#39;[ -999999999..999999999 ]&#39;, and with the additional constraint that the two
// fields are either both non-negative or both non-positive.  When setting the
// value of a time interval via its two-field representation, any integer value
// may be used in either field, with the constraint that the resulting number
// of seconds be representable as a 64-bit signed integer.  Similarly, the two
// field values may be accessed in the canonical representation using the
// &#39;seconds&#39; and &#39;nanoseconds&#39; methods.
//
// Binary arithmetic and relational operators taking two &#39;bsls::TimeInterval&#39;
// objects, or a &#39;bsls::TimeInterval&#39; object and a &#39;double&#39;, are provided.  A
// &#39;double&#39; operand, representing a real number of seconds, is first converted
// to a &#39;bsls::TimeInterval&#39; object before performing the operation.  Under
// such circumstances, the fractional part of the &#39;double&#39;, if any, is rounded
// to the nearest whole number of nanoseconds.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Creating and Modifying a &#39;bsls::TimeInterval&#39;
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// The following example demonstrates how to create and manipulate a
// &#39;bsls::TimeInterval&#39; object.
//
// First, we default construct a &#39;TimeInterval&#39; object, &#39;interval&#39;:
//..
//  bsls::TimeInterval interval;
//
//  assert(0 == interval.seconds());
//  assert(0 == interval.nanoseconds());
//..
// Next, we set the value of &#39;interval&#39; to 1 second and 10 nanoseconds (a time
// interval of 1000000010 nanoseconds):
//..
//  interval.setInterval(1, 10);
//
//  assert( 1 == interval.seconds());
//  assert(10 == interval.nanoseconds());
//..
// Then, we add 3 seconds to &#39;interval&#39;:
//..
//  interval.addInterval(3, 0);
//
//  assert( 4 == interval.seconds());
//  assert(10 == interval.nanoseconds());
//..
// Next, we create a copy of &#39;interval&#39;, &#39;intervalPrime&#39;:
//..
//  bsls::TimeInterval intervalPrime(interval);
//
//  assert(intervalPrime == interval);
//..
// Finally, we assign 3.14 seconds to &#39;intervalPrime&#39;, and then add 2.73
// seconds more:
//..
//  intervalPrime =  3.14;
//  intervalPrime += 2.73;
//
//  assert(        5 == intervalPrime.seconds());
//  assert(870000000 == intervalPrime.nanoseconds());
//..

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_LIMITS_H
#include &lt;limits.h&gt;  // &#39;LLONG_MIN&#39;, &#39;LLONG_MAX&#39;
#define INCLUDED_LIMITS_H
#endif

// BDE_VERIFY pragma: push
// BDE_VERIFY pragma: -FABC01  // &#39;add*&#39; operations are ordered by time unit

namespace BloombergLP {
namespace bsls {

                        // ==================
                        // class TimeInterval
                        // ==================

class TimeInterval {
    // Each instance of this value-semantic type represents a time interval
    // with nanosecond resolution.  In the &quot;canonical representation&quot; of a time
    // interval, the &#39;seconds&#39; field may have any 64-bit signed integer value,
    // with the &#39;nanoseconds&#39; field limited to the range
    // &#39;[ -999999999..999999999 ]&#39;, and with the additional constraint that the
    // two fields are either both non-negative or both non-positive.

    // PRIVATE TYPES
    enum {
        k_MILLISECS_PER_SEC     = 1000,        // one thousand

        k_MICROSECS_PER_SEC     = 1000000,     // one million

        k_NANOSECS_PER_MICROSEC = 1000,        // one thousand

        k_NANOSECS_PER_MILLISEC = 1000000,     // one million

        k_NANOSECS_PER_SEC      = 1000000000,  // one billion

        k_SECONDS_PER_MINUTE    = 60,

        k_SECONDS_PER_HOUR      = 60 * k_SECONDS_PER_MINUTE,

        k_SECONDS_PER_DAY       = 24 * k_SECONDS_PER_HOUR
    };

    // DATA
    bsls::Types::Int64 d_seconds;      // field for seconds
    int                d_nanoseconds;  // field for nanoseconds

    // PRIVATE CLASS METHODS
    static bool isSumValidInt64(bsls::Types::Int64 lhs,
                                bsls::Types::Int64 rhs);
        // Return &#39;true&#39; if the sum of the specified &#39;lhs&#39; and &#39;rhs&#39; can be
        // represented using a 64-bit signed integer, and &#39;false&#39; otherwise.

  public:
    // CLASS METHODS
    static bool isValid(bsls::Types::Int64 seconds,
                        int                nanoseconds);
        // Return &#39;true&#39; if a valid &#39;TimeInterval&#39; can be constructed from the
        // specified &#39;seconds&#39; and &#39;nanoseconds&#39;, and &#39;false&#39; otherwise.  A
        // valid time interval can be constructed from &#39;seconds&#39; and
        // &#39;nanoseconds&#39; if their sum results in a time interval whose total
        // number of seconds can be represented with a 64-bit signed integer.

                                  // Aspects

    static int maxSupportedBdexVersion(int versionSelector);
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    // CREATORS
    TimeInterval();
        // Create a time interval having the value of 0 seconds and 0
        // nanoseconds.

    TimeInterval(bsls::Types::Int64 seconds, int nanoseconds);
        // Create a time interval having the value given by the sum of the
        // specified integral number of &#39;seconds&#39; and &#39;nanoseconds&#39;.  The
        // behavior is undefined unless the total number of seconds in the
        // resulting time interval can be represented with a 64-bit signed
        // integer (see &#39;isValid&#39;).  Note that there is no restriction on the
        // sign or magnitude of either argument except that they must not
        // violate the method&#39;s preconditions.

    explicit TimeInterval(double seconds);
        // Create a time interval having the value represented by the specified
        // real number of &#39;seconds&#39;.  The fractional part of &#39;seconds&#39;, if any,
        // is rounded to the nearest whole number of nanoseconds.  The
        // behavior is undefined unless the total number of seconds in the
        // resulting time interval can be represented with a 64-bit signed
        // integer.

    // TimeInterval(const TimeInterval&amp; original) = default;
        // Create a time interval having the value of the specified &#39;original&#39;
        // time interval.  Note that this trivial copy constructor is
        // generated by the compiler.

    // ~TimeInterval() = default;
        // Destroy this time interval object.  Note that this trivial
        // destructor is generated by the compiler.

    // MANIPULATORS

                                  // Operator Overloads

    // TimeInterval&amp; operator=(const TimeInterval&amp; rhs) = default;
        // Assign to this time interval the value of the specified &#39;rhs&#39; time
        // interval, and return a reference providing modifiable access to this
        // object.  Note that this trivial assignment operation is generated by
        // the compiler.


    TimeInterval&amp; operator=(double rhs);
        // Assign to this time interval the value of the specified &#39;rhs&#39; real
        // number of seconds, and return a reference providing modifiable
        // access to this object.  The fractional part of &#39;rhs&#39;, if any, is
        // rounded to the nearest whole number of nanoseconds.  The behavior
        // is undefined unless &#39;rhs&#39; can be converted to a valid
        // &#39;TimeInterval&#39; object.

    TimeInterval&amp; operator+=(const TimeInterval&amp; rhs);
        // Add to this time interval the value of the specified &#39;rhs&#39; time
        // interval, and return a reference providing modifiable access to
        // this object.  The behavior is undefined unless the total number of
        // seconds in the resulting time interval can be represented with a
        // 64-bit signed integer.

    TimeInterval&amp; operator+=(double rhs);
        // Add to this time interval the value of the specified &#39;rhs&#39; real
        // number of seconds, and return a reference providing modifiable
        // access to this object.  The fractional part of &#39;rhs&#39;, if any, is
        // rounded to the nearest whole number of nanoseconds before being
        // added to this object.  The behavior is undefined unless &#39;rhs&#39; can
        // be converted to a valid &#39;TimeInterval&#39; object, and the total number
        // of seconds in the resulting time interval can be represented with a
        // 64-bit signed integer.

    TimeInterval&amp; operator-=(const TimeInterval&amp; rhs);
        // Subtract from this time interval the value of the specified &#39;rhs&#39;
        // time interval, and return a reference providing modifiable access to
        // this object.  The behavior is undefined unless
        // &#39;LLONG_MIN != rhs.seconds()&#39;, and the total number of seconds in the
        // resulting time interval can be represented with a 64-bit signed
        // integer.

    TimeInterval&amp; operator-=(double rhs);
        // Subtract from this time interval the value of the specified &#39;rhs&#39;
        // real number of seconds, and return a reference providing modifiable
        // access to this object.  The fractional part of &#39;rhs&#39;, if any, is
        // rounded to the nearest whole number of nanoseconds before being
        // subtracted from this object.  The behavior is undefined unless
        // &#39;rhs&#39; can be converted to a valid &#39;TimeInterval&#39; object whose
        // &#39;seconds&#39; field is greater than &#39;LLONG_MIN&#39;, and the total number of
        // seconds in the resulting time interval can be represented with a
        // 64-bit signed integer.

                                  // Add Operations

    TimeInterval&amp; addDays(bsls::Types::Int64 days);
        // Add to this time interval the number of seconds represented by the
        // specified integral number of &#39;days&#39;, and return a reference
        // providing modifiable access to this object.  The behavior is
        // undefined unless the number of seconds in &#39;days&#39;, and the total
        // number of seconds in the resulting time interval, can both be
        // represented with 64-bit signed integers.  Note that &#39;days&#39; may be
        // negative.

    TimeInterval&amp; addHours(bsls::Types::Int64 hours);
        // Add to this time interval the number of seconds represented by the
        // specified integral number of &#39;hours&#39;, and return a reference
        // providing modifiable access to this object.  The behavior is
        // undefined unless the number of seconds in &#39;hours&#39;, and the total
        // number of seconds in the resulting time interval, can both be
        // represented with 64-bit signed integers.  Note that &#39;hours&#39; may be
        // negative.

    TimeInterval&amp; addMinutes(bsls::Types::Int64 minutes);
        // Add to this time interval the number of seconds represented by the
        // specified integral number of &#39;minutes&#39;, and return a reference
        // providing modifiable access to this object.  The behavior is
        // undefined unless the number of seconds in &#39;minutes&#39;, and the total
        // number of seconds in the resulting time interval, can both be
        // represented with 64-bit signed integers.  Note that &#39;minutes&#39; may be
        // negative.

    TimeInterval&amp; addSeconds(bsls::Types::Int64 seconds);
        // Add to this time interval the specified integral number of
        // &#39;seconds&#39;, and return a reference providing modifiable access to
        // this object.  The behavior is undefined unless the total number of
        // seconds in the resulting time interval can be represented with a
        // 64-bit signed integer.  Note that &#39;seconds&#39; may be negative.

    TimeInterval&amp; addMilliseconds(bsls::Types::Int64 milliseconds);
        // Add to this time interval the specified integral number of
        // &#39;milliseconds&#39;, and return a reference providing modifiable access
        // to this object.  The behavior is undefined unless the total number
        // of seconds in the resulting time interval can be represented with a
        // 64-bit signed integer.  Note that &#39;milliseconds&#39; may be negative.

    TimeInterval&amp; addMicroseconds(bsls::Types::Int64 microseconds);
        // Add to this time interval the specified integral number of
        // &#39;microseconds&#39;, and return a reference providing modifiable access
        // to this object.  The behavior is undefined unless the total number
        // of seconds in the resulting time interval can be represented with a
        // 64-bit signed integer.  Note that &#39;microseconds&#39; may be negative.

    TimeInterval&amp; addNanoseconds(bsls::Types::Int64 nanoseconds);
        // Add to this time interval the specified integral number of
        // &#39;nanoseconds&#39;, and return a reference providing modifiable access to
        // this object.  The behavior is undefined unless the total number of
        // seconds in the resulting time interval can be represented with a
        // 64-bit signed integer.  Note that &#39;nanoseconds&#39; may be negative.

                                  // Set Operations

    void setTotalDays(bsls::Types::Int64 days);
        // Set the overall value of this object to indicate the specified
        // integral number of &#39;days&#39;.  The behavior is undefined unless the
        // number of seconds in &#39;days&#39; can be represented with a 64-bit signed
        // integer.  Note that &#39;days&#39; may be negative.

    void setTotalHours(bsls::Types::Int64 hours);
        // Set the overall value of this object to indicate the specified
        // integral number of &#39;hours&#39;.  The behavior is undefined unless the
        // number of seconds in &#39;hours&#39; can be represented with a 64-bit signed
        // integer.  Note that &#39;hours&#39; may be negative.

    void setTotalMinutes(bsls::Types::Int64 minutes);
        // Set the overall value of this object to indicate the specified
        // integral number of &#39;minutes&#39;.  The behavior is undefined unless the
        // number of seconds in &#39;minutes&#39; can be represented with a 64-bit
        // signed integer.  Note that &#39;minutes&#39; may be negative.

    void setTotalSeconds(bsls::Types::Int64 seconds);
        // Set the overall value of this object to indicate the specified
        // integral number of &#39;seconds&#39;.  Note that &#39;seconds&#39; may be negative.

    void setTotalMilliseconds(bsls::Types::Int64 milliseconds);
        // Set the overall value of this object to indicate the specified
        // integral number of &#39;milliseconds&#39;.  Note that &#39;milliseconds&#39; may be
        // negative.

    void setTotalMicroseconds(bsls::Types::Int64 microseconds);
        // Set the overall value of this object to indicate the specified
        // integral number of &#39;microseconds&#39;.  Note that &#39;microseconds&#39; may be
        // negative.

    void setTotalNanoseconds(bsls::Types::Int64 nanoseconds);
        // Set the overall value of this object to indicate the specified
        // integral number of &#39;nanoseconds&#39;.  Note that &#39;nanoseconds&#39; may be
        // negative.

                                  // Time-Interval-Based Manipulators

    void addInterval(bsls::Types::Int64 seconds, int nanoseconds = 0);
        // Add to this time interval the specified integral number of
        // &#39;seconds&#39;, and the optionally specified integral number of
        // &#39;nanoseconds&#39;.  If unspecified, &#39;nanoseconds&#39; is 0.  The behavior is
        // undefined unless &#39;this-&gt;seconds() + seconds&#39;, and the total number
        // of seconds in the resulting time interval, can both be represented
        // with 64-bit signed integers.

    void setInterval(bsls::Types::Int64 seconds, int nanoseconds = 0);
        // Set this time interval to have the value given by the sum of the
        // specified integral number of &#39;seconds&#39;, and the optionally specified
        // integral number of &#39;nanoseconds&#39;.  If unspecified, &#39;nanoseconds&#39; is
        // 0.  The behavior is undefined unless the total number of seconds in
        // the resulting time interval can be represented with a 64-bit signed
        // integer (see &#39;isValid&#39;).  Note that there is no restriction on the
        // sign or magnitude of either argument except that they must not
        // violate the method&#39;s preconditions.

    void setIntervalRaw(bsls::Types::Int64 seconds, int nanoseconds = 0);
        // Set this time interval to have the value given by the sum of the
        // specified integral number of &#39;seconds&#39;, and the optionally specified
        // integral number of &#39;nanoseconds&#39;, where &#39;seconds&#39; and &#39;nanoseconds&#39;
        // form a canonical representation of a time interval (see
        // {Representation}).  If unspecified, &#39;nanoseconds&#39; is 0.  The
        // behavior is undefined unless
        // &#39;-999999999 &lt;= nanoseconds &lt;= 999999999&#39; and &#39;seconds&#39; and
        // &#39;nanoseconds&#39; are either both non-negative or both non-positive.
        // Note that this function provides a subset of the defined behavior of
        // &#39;setInterval&#39; chosen to minimize runtime performance cost.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    // ACCESSORS
    int nanoseconds() const;
        // Return the nanoseconds field in the canonical representation of the
        // value of this time interval.

    bsls::Types::Int64 seconds() const;
        // Return the seconds field in the canonical representation of the
        // value of this time interval.

    bsls::Types::Int64 totalDays() const;
        // Return the value of this time interval as an integral number of
        // days, rounded towards zero.  Note that the return value may be
        // negative.

    bsls::Types::Int64 totalHours() const;
        // Return the value of this time interval as an integral number of
        // hours, rounded towards zero.  Note that the return value may be
        // negative.

    bsls::Types::Int64 totalMinutes() const;
        // Return the value of this time interval as an integral number of
        // minutes, rounded towards zero.  Note that the return value may be
        // negative.

    bsls::Types::Int64 totalSeconds() const;
        // Return the value of this time interval as an integral number of
        // seconds, rounded towards zero.  Note that the return value may be
        // negative.  Also note that this method returns the same value as
        // &#39;seconds&#39;.

    bsls::Types::Int64 totalMilliseconds() const;
        // Return the value of this time interval as an integral number of
        // milliseconds, rounded towards zero.  The behavior is undefined
        // unless the number of milliseconds can be represented with a 64-bit
        // signed integer.  Note that the return value may be negative.

    bsls::Types::Int64 totalMicroseconds() const;
        // Return the value of this time interval as an integral number of
        // microseconds, rounded towards zero.  The behavior is undefined
        // unless the number of microseconds can be represented with a 64-bit
        // signed integer.  Note that the return value may be negative.

    bsls::Types::Int64 totalNanoseconds() const;
        // Return the value of this time interval as an integral number of
        // nanoseconds.  The behavior is undefined unless the number of
        // nanoseconds can be represented using a 64-bit signed integer.  Note
        // that the return value may be negative.

    double totalSecondsAsDouble() const;
        // Return the value of this time interval as a real number of seconds.
        // Note that the return value may be negative and may have a fractional
        // part (representing the nanosecond field of this object).  Also note
        // that the conversion from the internal representation to a &#39;double&#39;
        // may *lose* precision.

                                  // Aspects

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    template &lt;class STREAM&gt;
    STREAM&amp; print(STREAM&amp; stream,
                  int     level          = 0,
                  int     spacesPerLevel = 4) const;
        // Write the value of this object to the specified output &#39;stream&#39; in a
        // human-readable format, and return a reference providing modifiable
        // access to &#39;stream&#39;.  Optionally specify an initial indentation
        // &#39;level&#39;, whose absolute value is incremented recursively for nested
        // objects.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, whose absolute value indicates the number of
        // spaces per indentation level for this and all of its nested objects.
        // If &#39;level&#39; is negative, suppress indentation of the first line.  If
        // &#39;spacesPerLevel&#39; is negative, format the entire output on one line,
        // suppressing all but the initial indentation (as governed by
        // &#39;level&#39;).  If &#39;stream&#39; is not valid on entry, this operation has no
        // effect.  Note that the format is not fully specified, and can change
        // without notice.


};

// FREE OPERATORS
TimeInterval operator+(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs);
TimeInterval operator+(const TimeInterval&amp; lhs, double rhs);
TimeInterval operator+(double lhs, const TimeInterval&amp; rhs);
    // Return a &#39;TimeInterval&#39; value that is the sum of the specified &#39;lhs&#39; and
    // &#39;rhs&#39; time intervals.  The behavior is undefined unless (1) operands of
    // type &#39;double&#39; can be converted to valid &#39;TimeInterval&#39; objects, and (2)
    // the resulting time interval can be represented with a 64-bit signed
    // integer.

TimeInterval operator-(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs);
TimeInterval operator-(const TimeInterval&amp; lhs, double rhs);
TimeInterval operator-(double lhs, const TimeInterval&amp; rhs);
    // Return a &#39;TimeInterval&#39; value that is the difference between the
    // specified &#39;lhs&#39; and &#39;rhs&#39; time intervals.  The behavior is undefined
    // unless (1) operands of type &#39;double&#39; can be converted to valid
    // &#39;TimeInterval&#39; objects, (2) the value on the right-hand side
    // (potentially after conversion to a &#39;TimeInterval&#39;) has a number of
    // seconds that is not &#39;LLONG_MIN&#39;, and (3) the resulting time interval can
    // be represented with a 64-bit signed integer.

TimeInterval operator-(const TimeInterval&amp; rhs);
    // Return a &#39;TimeInterval&#39; value that is the negative of the specified
    // &#39;rhs&#39; time interval.  The behavior is undefined unless
    // &#39;LLONG_MIN != rhs.seconds()&#39;.

bool operator==(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs);
bool operator==(const TimeInterval&amp; lhs, double rhs);
bool operator==(double lhs, const TimeInterval&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; time intervals have the
    // same value, and &#39;false&#39; otherwise.  Two time intervals have the same
    // value if their respective second and nanosecond fields have the same
    // value.  The behavior is undefined unless operands of type &#39;double&#39; can
    // be converted to valid &#39;TimeInterval&#39; objects.

bool operator!=(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs);
bool operator!=(const TimeInterval&amp; lhs, double rhs);
bool operator!=(double lhs, const TimeInterval&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; time intervals do not
    // have the same value, and &#39;false&#39; otherwise.  Two time intervals do not
    // have the same value if their respective second or nanosecond fields
    // differ in value.  The behavior is undefined unless operands of type
    // &#39;double&#39; can be converted to valid &#39;TimeInterval&#39; objects.

bool operator&lt; (const TimeInterval&amp; lhs, const TimeInterval&amp; rhs);
bool operator&lt; (const TimeInterval&amp; lhs, double rhs);
bool operator&lt; (double lhs, const TimeInterval&amp; rhs);
bool operator&lt;=(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs);
bool operator&lt;=(const TimeInterval&amp; lhs, double rhs);
bool operator&lt;=(double lhs, const TimeInterval&amp; rhs);
bool operator&gt; (const TimeInterval&amp; lhs, const TimeInterval&amp; rhs);
bool operator&gt; (const TimeInterval&amp; lhs, double rhs);
bool operator&gt; (double lhs, const TimeInterval&amp; rhs);
bool operator&gt;=(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs);
bool operator&gt;=(const TimeInterval&amp; lhs, double rhs);
bool operator&gt;=(double lhs, const TimeInterval&amp; rhs);
    // Return &#39;true&#39; if the nominal relation between the specified &#39;lhs&#39; and
    // &#39;rhs&#39; time interval values holds, and &#39;false&#39; otherwise.  The behavior
    // is undefined unless operands of type &#39;double&#39; can be converted to valid
    // &#39;TimeInterval&#39; objects.

template &lt;class STREAM&gt;
STREAM&amp; operator&lt;&lt;(STREAM&amp;             stream,
                   const TimeInterval&amp; timeInterval);
    // Write the value of the specified &#39;timeInterval&#39; to the specified output
    // &#39;stream&#39; in a single-line format, and return a reference providing
    // modifiable access to &#39;stream&#39;.  If &#39;stream&#39; is not valid on entry, this
    // operation has no effect.  Note that this human-readable format is not
    // fully specified and can change without notice.  Also note that this
    // method has the same behavior as &#39;object.print(stream, 0, -1)&#39;.

// ============================================================================
//                         INLINE DEFINITIONS
// ============================================================================

                        // ------------------
                        // class TimeInterval
                        // ------------------

// CLASS METHODS
inline
int TimeInterval::maxSupportedBdexVersion(int /* versionSelector */)
{
    return 1;
}

inline
bool TimeInterval::isValid(bsls::Types::Int64 seconds,
                           int                nanoseconds)
{
    return isSumValidInt64(seconds, nanoseconds / k_NANOSECS_PER_SEC);
}

// CREATORS
inline
TimeInterval::TimeInterval()
: d_seconds(0)
, d_nanoseconds(0)
{
}

inline
TimeInterval::TimeInterval(bsls::Types::Int64 seconds,
                           int                nanoseconds)
{
    setInterval(seconds, nanoseconds);
}

// MANIPULATORS
inline
TimeInterval&amp; TimeInterval::operator=(double rhs)
{
    *this = TimeInterval(rhs);
    return *this;
}

inline
TimeInterval&amp; TimeInterval::operator+=(const TimeInterval&amp; rhs)
{
    addInterval(rhs.d_seconds, rhs.d_nanoseconds);
    return *this;
}

inline
TimeInterval&amp; TimeInterval::operator+=(double rhs)
{
    *this += TimeInterval(rhs);
    return *this;
}


inline
TimeInterval&amp; TimeInterval::operator-=(const TimeInterval&amp; rhs)
{
    BSLS_ASSERT_SAFE(LLONG_MIN &lt; rhs.seconds());

    addInterval(-rhs.d_seconds, -rhs.d_nanoseconds);
    return *this;
}

inline
TimeInterval&amp; TimeInterval::operator-=(double rhs)
{
    *this -= TimeInterval(rhs);
    return *this;
}

                                  // Add Operations

inline
TimeInterval&amp; TimeInterval::addDays(bsls::Types::Int64 days)
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_SECONDS_PER_DAY &gt;= days &amp;&amp;
                     LLONG_MIN / k_SECONDS_PER_DAY &lt;= days);

    return addSeconds(days * k_SECONDS_PER_DAY);
}

inline
TimeInterval&amp; TimeInterval::addHours(bsls::Types::Int64 hours)
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_SECONDS_PER_HOUR &gt;= hours &amp;&amp;
                     LLONG_MIN / k_SECONDS_PER_HOUR &lt;= hours);

    return addSeconds(hours * k_SECONDS_PER_HOUR);
}

inline
TimeInterval&amp; TimeInterval::addMinutes(bsls::Types::Int64 minutes)
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_SECONDS_PER_MINUTE &gt;= minutes &amp;&amp;
                     LLONG_MIN / k_SECONDS_PER_MINUTE &lt;= minutes);

    return addSeconds(minutes * k_SECONDS_PER_MINUTE);
}

inline
TimeInterval&amp; TimeInterval::addMilliseconds(bsls::Types::Int64 milliseconds)
{
    addInterval(          milliseconds / k_MILLISECS_PER_SEC,
        static_cast&lt;int&gt;((milliseconds % k_MILLISECS_PER_SEC) *
                                                     k_NANOSECS_PER_MILLISEC));
    return *this;
}

inline
TimeInterval&amp; TimeInterval::addMicroseconds(bsls::Types::Int64 microseconds)
{
    addInterval(          microseconds / k_MICROSECS_PER_SEC,
        static_cast&lt;int&gt;((microseconds % k_MICROSECS_PER_SEC) *
                                                     k_NANOSECS_PER_MICROSEC));
    return *this;

}

inline
TimeInterval&amp; TimeInterval::addNanoseconds(bsls::Types::Int64 nanoseconds)
{
    addInterval(                 nanoseconds / k_NANOSECS_PER_SEC,
                static_cast&lt;int&gt;(nanoseconds % k_NANOSECS_PER_SEC));
    return *this;
}

                                  // Set Operations

inline
void TimeInterval::setTotalDays(bsls::Types::Int64 days)
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_SECONDS_PER_DAY &gt;= days &amp;&amp;
                     LLONG_MIN / k_SECONDS_PER_DAY &lt;= days);

    return setTotalSeconds(days * k_SECONDS_PER_DAY);
}

inline
void TimeInterval::setTotalHours(bsls::Types::Int64 hours)
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_SECONDS_PER_HOUR &gt;= hours &amp;&amp;
                     LLONG_MIN / k_SECONDS_PER_HOUR &lt;= hours);

    return setTotalSeconds(hours * k_SECONDS_PER_HOUR);
}

inline
void TimeInterval::setTotalMinutes(bsls::Types::Int64 minutes)
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_SECONDS_PER_MINUTE &gt;= minutes &amp;&amp;
                     LLONG_MIN / k_SECONDS_PER_MINUTE &lt;= minutes);

    return setTotalSeconds(minutes * k_SECONDS_PER_MINUTE);
}

inline
void TimeInterval::setTotalSeconds(bsls::Types::Int64 seconds)
{
    d_seconds     = seconds;
    d_nanoseconds = 0;
}

inline
void TimeInterval::setTotalMilliseconds(bsls::Types::Int64 milliseconds)
{
    setInterval(                  milliseconds / k_MILLISECS_PER_SEC,
                static_cast&lt;int&gt;((milliseconds % k_MILLISECS_PER_SEC) *
                                                     k_NANOSECS_PER_MILLISEC));
}

inline
void TimeInterval::setTotalMicroseconds(bsls::Types::Int64 microseconds)
{
    setInterval(                  microseconds / k_MICROSECS_PER_SEC,
                static_cast&lt;int&gt;((microseconds % k_MICROSECS_PER_SEC) *
                                                     k_NANOSECS_PER_MICROSEC));

}

inline
void TimeInterval::setTotalNanoseconds(bsls::Types::Int64 nanoseconds)
{
    setInterval(                 nanoseconds / k_NANOSECS_PER_SEC,
                static_cast&lt;int&gt;(nanoseconds % k_NANOSECS_PER_SEC));
}

inline
void TimeInterval::setIntervalRaw(bsls::Types::Int64 seconds,
                                  int                nanoseconds)
{
    BSLS_ASSERT_SAFE(-k_NANOSECS_PER_SEC &lt; nanoseconds &amp;&amp;
                      k_NANOSECS_PER_SEC &gt; nanoseconds);
    BSLS_ASSERT_SAFE((seconds &gt;= 0 &amp;&amp; nanoseconds &gt;= 0) ||
                     (seconds &lt;= 0 &amp;&amp; nanoseconds &lt;= 0));

    d_seconds     = seconds;
    d_nanoseconds = nanoseconds;
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; TimeInterval::bdexStreamIn(STREAM&amp; stream, int version)
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            bsls::Types::Int64 seconds;
            int                nanoseconds;
            stream.getInt64(seconds);
            stream.getInt32(nanoseconds);

            if (stream &amp;&amp; (   (seconds &gt;= 0 &amp;&amp; nanoseconds &gt;= 0)
                           || (seconds &lt;= 0 &amp;&amp; nanoseconds &lt;= 0))
                       &amp;&amp; nanoseconds &gt; -k_NANOSECS_PER_SEC
                       &amp;&amp; nanoseconds &lt;  k_NANOSECS_PER_SEC) {
                d_seconds     = seconds;
                d_nanoseconds = nanoseconds;
            }
            else {
                stream.invalidate();
            }
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }
    return stream;
}

// ACCESSORS
inline
int TimeInterval::nanoseconds() const
{
    return d_nanoseconds;
}

inline
bsls::Types::Int64 TimeInterval::seconds() const
{
    return d_seconds;
}

inline
bsls::Types::Int64 TimeInterval::totalDays() const
{
    return d_seconds / k_SECONDS_PER_DAY;
}

inline
bsls::Types::Int64 TimeInterval::totalHours() const
{
    return d_seconds / k_SECONDS_PER_HOUR;
}

inline
bsls::Types::Int64 TimeInterval::totalMinutes() const
{
    return d_seconds / k_SECONDS_PER_MINUTE;
}

inline
bsls::Types::Int64 TimeInterval::totalSeconds() const
{
    return d_seconds;
}

inline
bsls::Types::Int64 TimeInterval::totalMilliseconds() const
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_MILLISECS_PER_SEC &gt;= d_seconds &amp;&amp;
                     LLONG_MIN / k_MILLISECS_PER_SEC &lt;= d_seconds);
    BSLS_ASSERT_SAFE(isSumValidInt64(d_seconds * k_MILLISECS_PER_SEC,
                                     d_nanoseconds / k_NANOSECS_PER_MILLISEC));


    return d_seconds     * k_MILLISECS_PER_SEC
         + d_nanoseconds / k_NANOSECS_PER_MILLISEC;
}

inline
bsls::Types::Int64 TimeInterval::totalMicroseconds() const
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_MICROSECS_PER_SEC &gt;= d_seconds &amp;&amp;
                     LLONG_MIN / k_MICROSECS_PER_SEC &lt;= d_seconds);
    BSLS_ASSERT_SAFE(isSumValidInt64(d_seconds     * k_MICROSECS_PER_SEC,
                                     d_nanoseconds / k_NANOSECS_PER_MICROSEC));

    return d_seconds     * k_MICROSECS_PER_SEC
         + d_nanoseconds / k_NANOSECS_PER_MICROSEC;
}

inline
bsls::Types::Int64 TimeInterval::totalNanoseconds() const
{
    BSLS_ASSERT_SAFE(LLONG_MAX / k_NANOSECS_PER_SEC &gt;= d_seconds &amp;&amp;
                     LLONG_MIN / k_NANOSECS_PER_SEC &lt;= d_seconds);
    BSLS_ASSERT_SAFE(isSumValidInt64(d_seconds * k_NANOSECS_PER_SEC,
                                     d_nanoseconds));

    return d_seconds * k_NANOSECS_PER_SEC + d_nanoseconds;
}

inline
double TimeInterval::totalSecondsAsDouble() const
{
    return static_cast&lt;double&gt;(d_seconds) + d_nanoseconds /
                                                    (1.0 * k_NANOSECS_PER_SEC);
}

                                  // Aspects

template &lt;class STREAM&gt;
STREAM&amp; TimeInterval::bdexStreamOut(STREAM&amp; stream, int version) const
{
    if (stream) {
        switch (version) { // switch on the schema version
          case 1: {
            stream.putInt64(d_seconds);
            stream.putInt32(d_nanoseconds);
          } break;
          default: {
            stream.invalidate();  // unrecognized version number
          }
        }
    }
    return stream;
}

template &lt;class STREAM&gt;
STREAM&amp; TimeInterval::print(STREAM&amp; stream,
                            int     level,
                            int     spacesPerLevel) const
{
    if (level &gt; 0 &amp;&amp; spacesPerLevel != 0) {
        // If &#39;level &lt;= 0&#39; the value will not be indented, otherwise the
        // indentation is &#39;level * abs(spacesPerLevel)&#39;.

        // Use &#39;unsigned&#39; to suppress gcc compiler warning.

        unsigned int indentation = level *
                      (spacesPerLevel &lt; 0 ? -spacesPerLevel : spacesPerLevel);
        for (unsigned int i = 0; i &lt; indentation; ++i) {
            stream &lt;&lt; &#39; &#39;;
        }
    }

    stream &lt;&lt; &#39;(&#39; &lt;&lt; d_seconds     &lt;&lt; &quot;, &quot;
                  &lt;&lt; d_nanoseconds &lt;&lt; &#39;)&#39;;

    // We suppress the trailing end-of-line if &#39;spacesPerLevel &lt; 0&#39;.

    if (spacesPerLevel &gt;= 0) {
        stream &lt;&lt; &#39;\n&#39;;
    }
    return stream;
}


}  // close package namespace

// FREE OPERATORS
inline
bsls::TimeInterval bsls::operator+(const TimeInterval&amp; lhs,
                                   const TimeInterval&amp; rhs)
{
    TimeInterval result(lhs);
    result.addInterval(rhs.seconds(), rhs.nanoseconds());
    return result;
}

inline
bsls::TimeInterval bsls::operator+(const TimeInterval&amp; lhs, double rhs)
{
    return lhs + TimeInterval(rhs);
}

inline
bsls::TimeInterval bsls::operator+(double lhs, const TimeInterval&amp; rhs)
{
    return TimeInterval(lhs) + rhs;
}

inline
bsls::TimeInterval bsls::operator-(const TimeInterval&amp; lhs,
                                   const TimeInterval&amp; rhs)

{
    BSLS_ASSERT_SAFE(LLONG_MIN != rhs.seconds());

    TimeInterval result(lhs);
    result.addInterval(-rhs.seconds(), -rhs.nanoseconds());
    return result;
}

inline
bsls::TimeInterval bsls::operator-(const TimeInterval&amp; lhs, double rhs)
{
    return lhs - TimeInterval(rhs);
}

inline
bsls::TimeInterval bsls::operator-(double lhs, const TimeInterval&amp; rhs)
{
    return TimeInterval(lhs) - rhs;
}

inline
bsls::TimeInterval bsls::operator-(const TimeInterval&amp; rhs)
{
    BSLS_ASSERT_SAFE(LLONG_MIN != rhs.seconds());

    return TimeInterval(-rhs.seconds(), -rhs.nanoseconds());
}

inline
bool bsls::operator==(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs)
{
    return lhs.seconds()     == rhs.seconds()
        &amp;&amp; lhs.nanoseconds() == rhs.nanoseconds();
}

inline
bool bsls::operator==(const TimeInterval&amp; lhs, double rhs)
{
    return lhs == TimeInterval(rhs);
}

inline
bool bsls::operator==(double lhs, const TimeInterval&amp; rhs)
{
    return TimeInterval(lhs) == rhs;
}

inline
bool bsls::operator!=(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs)
{
    return lhs.seconds()     != rhs.seconds()
        || lhs.nanoseconds() != rhs.nanoseconds();
}

inline
bool bsls::operator!=(const TimeInterval&amp; lhs, double rhs)
{
    return lhs != TimeInterval(rhs);
}

inline
bool bsls::operator!=(double lhs, const TimeInterval&amp; rhs)
{
    return TimeInterval(lhs) != rhs;
}

inline
bool bsls::operator&lt; (const TimeInterval&amp; lhs, const TimeInterval&amp; rhs)
{
    return lhs.seconds() &lt; rhs.seconds()
        || (lhs.seconds() == rhs.seconds()
            &amp;&amp; lhs.nanoseconds() &lt; rhs.nanoseconds());
}

inline
bool bsls::operator&lt; (const TimeInterval&amp; lhs, double rhs)
{
    return lhs &lt; TimeInterval(rhs);
}

inline
bool bsls::operator&lt; (double lhs, const TimeInterval&amp; rhs)
{
    return TimeInterval(lhs) &lt; rhs;
}

inline
bool bsls::operator&lt;=(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs)
{
    return lhs.seconds() &lt; rhs.seconds()
        || (lhs.seconds() == rhs.seconds()
            &amp;&amp; lhs.nanoseconds() &lt;= rhs.nanoseconds());
}

inline
bool bsls::operator&lt;=(const TimeInterval&amp; lhs, double rhs)
{
    return lhs &lt;= TimeInterval(rhs);
}

inline
bool bsls::operator&lt;=(double lhs, const TimeInterval&amp; rhs)
{
    return TimeInterval(lhs) &lt;= rhs;
}

inline
bool bsls::operator&gt; (const TimeInterval&amp; lhs, const TimeInterval&amp; rhs)
{
    return lhs.seconds() &gt; rhs.seconds()
        || (lhs.seconds() == rhs.seconds()
            &amp;&amp; lhs.nanoseconds() &gt; rhs.nanoseconds());
}

inline
bool bsls::operator&gt; (const TimeInterval&amp; lhs, double rhs)
{
    return lhs &gt; TimeInterval(rhs);
}

inline
bool bsls::operator&gt; (double lhs, const TimeInterval&amp; rhs)
{
    return TimeInterval(lhs) &gt; rhs;
}

inline
bool bsls::operator&gt;=(const TimeInterval&amp; lhs, const TimeInterval&amp; rhs)
{
    return lhs.seconds() &gt; rhs.seconds()
        || (lhs.seconds() == rhs.seconds()
            &amp;&amp; lhs.nanoseconds() &gt;= rhs.nanoseconds());
}

inline
bool bsls::operator&gt;=(const TimeInterval&amp; lhs, double rhs)
{
    return lhs &gt;= TimeInterval(rhs);
}

inline
bool bsls::operator&gt;=(double lhs, const TimeInterval&amp; rhs)
{
    return TimeInterval(lhs) &gt;= rhs;
}

template &lt;class STREAM&gt;
inline
STREAM&amp; bsls::operator&lt;&lt;(STREAM&amp;             stream,
                         const TimeInterval&amp; timeInterval)
{
    return timeInterval.print(stream, 0, -1);
}

// BDE_VERIFY pragma: pop

}  // close enterprise namespace

// BDE_VERIFY pragma: push
// BDE_VERIFY pragma: -UC01
// BDE_VERIFY pragma: -CD01
// BDE_VERIFY pragma: -CB01
// BDE_VERIFY pragma: -CP01
// BDE_VERIFY pragma: -TR04

namespace bsl {

// IMPLEMENTATION NOTE: The following declaration of the
// &#39;is_trivially_copyable&#39; meta-function (and &#39;integral_constant&#39;) is
// unfortunate, but necessary as the &#39;is_trivially_copyable&#39; trait is defined
// in &#39;bslmf&#39;.

template &lt;class TYPE&gt;
struct is_trivially_copyable;

template &lt;class TYPE, TYPE VAL&gt;
struct integral_constant;

template &lt;&gt;
struct is_trivially_copyable&lt;BloombergLP::bsls::TimeInterval&gt;  {
    // This template specialization for &#39;is_trivially_copyable&#39; indicates that
    // &#39;TimeInterval&#39; is a trivially copyable type.  Note that we replicate the
    // properties of &#39;bsl::true_type&#39; to avoid a circular dependency.

    // PUBLIC TYPES
    typedef bool                          value_type;
    typedef integral_constant&lt;bool, true&gt; type;

    // PUBLIC CLASS DATA
    static const bool value = true;

    // ACCESSORS
    operator value_type() const { return true; }
        // Return &#39;true&#39;.

    // COMPATIBILITY MEMBERS
    static const bool VALUE = value;
};
// BDE_VERIFY pragma: pop

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
