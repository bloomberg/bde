<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdls_fdstreambuf.h                                                 -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLS_FDSTREAMBUF
#define INCLUDED_BDLS_FDSTREAMBUF

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a stream buffer initialized with a file descriptor.
//
//@CLASSES:
//   bdls::FdStreamBuf: stream buffer constructed with file descriptor
//
//@SEE_ALSO: &lt;bsl::streambuf&gt;
//
//@DESCRIPTION: This component implements a class, &#39;bdls::FdStreamBuf&#39;, derived
// from the C++ standard library&#39;s &#39;bsl::streambuf&#39; that can be associated with
// a file descriptor.  Except for the &#39;pubimbue&#39; function, all of the actions
// that can be performed on an &#39;bsl::streambuf&#39; can be performed on a
// &#39;bdls::FdStreamBuf&#39;.  An &#39;bsl::streambuf&#39; provides public methods for
// reading from and writing to a stream of data, which are implemented in terms
// of protected virtual functions.  A &#39;bdls::FdStreamBuf&#39; provides an
// implementation of these protected virtual members such that they operate on
// a given file descriptor.  The file descriptor can represent a file, a pipe,
// or other device, and it can be associated with the &#39;bdls::FdStreamBuf&#39; at
// construction, or by calling the &#39;reset&#39; method.  Note that a &#39;bsl::stream&#39;
// can be initialized with a &#39;bdls::FdStreamBuf&#39;, making it possible to
// associate the stream with a file descriptor.
//
// Note that the &#39;pubimbue&#39; function may be called, but not with any value
// other than &#39;bsl::locale()&#39;.  Furthermore, when called with this value, it
// has no effect.
//
// The file descriptor type &#39;bdls::FilesystemUtil::FileDescriptor&#39; used in this
// component is, on Unix, an &#39;int&#39; type returned by &#39;open&#39;, and on Windows, a
// &#39;HANDLE&#39; type returned by &#39;CreateFile&#39;.  Ideally, a user would open the file
// and obtain the platform-independent &#39;bdls::FilesystemUtil::FileDescriptor&#39;
// by calling &#39;bdls::FilesystemUtil::open&#39;, which will call the appropriate
// routine for the platform and return a
// &#39;bdls::FilesystemUtil::FileDescriptor&#39;.  A value of
// &#39;bdls::FilesystemUtil::k_INVALID_FD&#39; is used to represent an invalid file
// handle on both platforms.
//
// On Windows for a file in text mode, the byte &#39;0x1a&#39; (ctrl-Z) is recognized
// as an end of file marker.  If it is encountered, it is not returned in the
// buffer and subsequent reads will indicate that no more input is available.
// The behavior is undefined if it is not the last byte in the file.  Other
// types of files are not required to end with &#39;0x1a&#39;.  For files on Unix and
// files opened in binary mode on Windows, &#39;0x1a&#39; is treated like any other
// byte.
//
// Note that the public methods of the &#39;bsl::streambuf&#39; class used in the usage
// example are not described here.  See documentation in
// &quot;The C++ Programming Language, Third Edition&quot;, by Bjarne Stroustrup,
// Section 21.6.4, and on the web at:
//..
// http://www.cplusplus.com/reference/iostream/streambuf
//..
// Note that the &#39;bdls::FdStreamBuf&#39; and &#39;bdls::FdStreamBuf_FileHandler&#39;
// classes here are based on STLPort&#39;s implementation of &#39;filebuf&#39; and
// &#39;_Filebuf_Base&#39; respectively, with copyright notice as follows:
//..
// ----------------------------------------------------------------------------
// Copyright (c) 1999
// Silicon Graphics Computer Systems, Inc.
//
// Copyright (c) 1999
// Boris Fomitchev
//
// This material is provided &quot;as is&quot;, with absolutely no warranty expressed
// or implied.  Any use is at your own risk.
//
// Permission to use or copy this software for any purpose is hereby granted
// without fee, provided the above notices are retained on all copies.
// Permission to modify the code and to distribute modified code is granted,
// provided the above notices are retained, and a notice that the code was
// modified is included with the above copyright notice.
// ----------------------------------------------------------------------------
//..
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Stream Initializaton
///- - - - - - - - - - - - - - - -
// The most common usage of this component is to initialize a stream.  In this
// case, the &#39;bdls::FdStreamBuf&#39; will be used for either input or output, but
// not both.
//
// First we create a suitable file name, and make sure that no file of that
// name already exists:
//..
//  char fileNameBuffer[100];
//  bsl::sprintf(fileNameBuffer,
//#ifdef BSLS_PLATFORM_OS_UNIX
//               &quot;/tmp/bdls_FdStreamBuf.usage.1.%d.txt&quot;,
//#else // windows
//               &quot;C:\\TEMP\\bdls_FdStreamBuf.usage.1.%d.txt&quot;;
//#endif
//               bdls::ProcessUtil::getProcessId());
//
//  bdls::FilesystemUtil::remove(fileNameBuffer);
//  assert(0 == bdls::FilesystemUtil::exists(fileNameBuffer));
//..
// Then we create the file and open a file descriptor to it; the boolean
// flags indicate that the file is to be writable, and not previously existing
// (and therefore must be created):
//..
//  typedef bdls::FilesystemUtil::FileDescriptor FdType;
//
//  FdType fd = bdls::FilesystemUtil::open(fileNameBuffer,
//                                         bdls::FilesystemUtil::e_CREATE,
//                                         bdls::FilesystemUtil::e_READ_WRITE);
//  assert(bdls::FilesystemUtil::k_INVALID_FD != fd);
//..
// Next we create a &#39;bdls::FdStreamBuf&#39; associated with file descriptor
// &#39;fd&#39;; the &#39;false&#39; argument indicates that &#39;streamBuffer&#39; will not assume
// ownership of &#39;fd&#39;, meaning that when &#39;streamBuffer&#39; is destroyed &#39;fd&#39; will
// remain open:
//
// Note also that the stream buffer defaults to being in text mode on Windows,
// and binary mode on Unix.
//..
//  {
//      bdls::FdStreamBuf streamBuffer(fd,
//                                     true,    // writable
//                                     false);  // &#39;fd&#39; won&#39;t be closed
//                                              // when &#39;streamBuffer&#39; is
//                                              // destroyed
//
//      bsl::ostream os(&amp;streamBuffer);
//
//      os &lt;&lt; &quot;Five times nine point five = &quot; &lt;&lt; 5 * 9.5 &lt;&lt; bsl::endl;
//  }
//..
// Note also that the stream buffer defaults to being in text mode on
// Windows, and binary mode on Unix.
//
// Now create a new stream buffer to read the file back, in this case
// using binary mode so we can see exactly what was written.  The new
// stream buf is used to initialize an input stream.
//..
//  {
//      // read it in binary mode
//
//      bdls::FdStreamBuf streamBuffer(fd,
//                                     false,  // not writable
//                                     false,  // &#39;streamBuffer&#39; does not
//                                             // own &#39;fd&#39;
//                                     true);  // binary mode
//
//      streamBuffer.pubseekpos(0);
//
//      char buf[100];
//      bsl::memset(buf, 0, sizeof(buf));
//
//      bsl::istream is(&amp;streamBuffer);
//      char *pc = buf;
//      do {
//          is &gt;&gt; bsl::noskipws &gt;&gt; *pc++;
//      } while (&#39;\n&#39; != pc[-1]);
//
//#ifdef BSLS_PLATFORM_OS_UNIX
//      assert(!bsl::strcmp(&quot;Five times nine point five = 47.5\n&quot;, buf));
//#else
//      //On Windows we see a CRLF (&#39;\r\n&#39;) instead of a simple LF &#39;\n&#39;
//      assert(!bsl::strcmp(&quot;Five times nine point five = 47.5\r\n&quot;, buf));
//#endif
//  }
//..
// Finally, read the file back a second time, this time in text mode.  Note
// how, on Windows, the &#39;\r\n&#39; is translated back to &#39;\n&#39;
//..
//  {
//      // read it back in text mode
//
//      bdls::FdStreamBuf streamBuffer(fd,
//                                     false);  // not writable
//                                              // &#39;fd&#39; will be closed when
//                                              // streamBuffer is destroyed.
//                                              // Mode will be binary on
//                                              // Unix, text on Dos.
//      streamBuffer.pubseekpos(0);
//
//      char buf[100];
//      bsl::memset(buf, 0, sizeof(buf));
//
//      bsl::istream is(&amp;streamBuffer);
//      char *pc = buf;
//      do {
//          is &gt;&gt; bsl::noskipws &gt;&gt; *pc++;
//      } while (&#39;\n&#39; != pc[-1]);
//
//      assert(!bsl::strcmp(&quot;Five times nine point five = 47.5\n&quot;, buf));
//  }
//..
// And finally, we clean up:
//..
//  bdls::FilesystemUtil::remove(fileNameBuffer);
//..
//
///Example 2: Streambuf
/// - - - - - - - - - -
// For our second example we will create a &#39;bdls::FdStreamBuf&#39; associated with
// a temporary file, and then use the public methods of the base class
// interface, including &#39;sputn&#39;, &#39;sgetn&#39; and &#39;pubseekpos&#39;, to do some I/O and
// seeking on it.
//..
//  const char line1[] = &quot;To be or not to be, that is the question.\n&quot;;
//  const char line2[] =
//                     &quot;There are more things in heaven and earth,\n&quot;
//                     &quot;Horatio, than are dreamt of in your philosophy.\n&quot;;
//  const char line3[] = &quot;Wherever you go, there you are.  B Banzai\n&quot;;
//
//  const int lengthLine1 = sizeof(line1) - 1;
//  const int lengthLine2 = sizeof(line2) - 1;
//  const int lengthLine3 = sizeof(line3) - 1;
//..
// We start by selecting a file name for our (temporary) file.
//..
//  char fileNameBuffer[100];
//  bsl::sprintf(fileNameBuffer,
//#ifdef BSLS_PLATFORM_OS_UNIX
//               &quot;/tmp/bdls_FdStreamBuf.usage.2.%d.txt&quot;,
//#else // windows
//               &quot;C:\\TEMP\\bdls_FdStreamBuf.usage.2.%d.txt&quot;,
//#endif
//               bdls::ProcessUtil::getProcessId());
//..
// Then, make sure the file does not already exist:
//..
//  bdls::FilesystemUtil::remove(fileNameBuffer);
//  assert(false == bdls::FilesystemUtil::exists(fileNameBuffer));
//..
// Next, Create the file and open a file descriptor to it.  The boolean
// flags indicate that the file is writable, and not previously
// existing (and therefore must be created):
//..
//  typedef bdls::FilesystemUtil::FileDescriptor FdType;
//
//  FdType fd = bdls::FilesystemUtil::open(fileNameBuffer,
//                                         bdls::FilesystemUtil::e_CREATE,
//                                         bdls::FilesystemUtil::e_READ_WRITE);
//  assert(bdls::FilesystemUtil::k_INVALID_FD != fd);
//..
// Now, we create a &#39;bdls::FdStreamBuf&#39; object named &#39;streamBuffer&#39;
// associated with the file descriptor &#39;fd&#39;.  Note that &#39;streamBuffer&#39;
// defaults to assuming ownership of &#39;fd&#39;, meaning that when
// &#39;streamBuffer&#39; is cleared, reset, or destroyed, &#39;fd&#39; will be closed.
// Note that &#39;FdStreamBuf&#39; implements &#39;streambuf&#39;, which provides the
// public methods used in this example:
//..
//  bdls::FdStreamBuf streamBuffer(fd, true);
//
//  assert(streamBuffer.fileDescriptor() == fd);
//  assert(streamBuffer.isOpened());
//..
// Next we use the &#39;sputn&#39; method to write two lines to the file:
//..
//  streamBuffer.sputn(line1, lengthLine1);
//  streamBuffer.sputn(line2, lengthLine2);
//..
// Then we seek back to the start of the file.
//..
//  bsl::streamoff status = streamBuffer.pubseekpos(0);
//  assert(0 == status);
//..
// Next, we read the first &#39;lengthLine1&#39; characters of the file
// into &#39;buf&#39;, with the method &#39;sgetn&#39;.
//..
//  char buf[1000];
//  bsl::memset(buf, 0, sizeof(buf));
//  status = streamBuffer.sgetn(buf, lengthLine1);
//  assert(lengthLine1 == status);
//  assert(!bsl::strcmp(line1, buf));
//..
// Next we try to read &#39;2 * lengthLine2&#39; characters when only
// &#39;lengthLine2&#39; characters are available in the file to read, so
// the &#39;sgetn&#39; method will stop after reading &#39;lengthLine2&#39; characters.
// The &#39;sgetn&#39; method will return the number of chars successfully
// read:
//..
//  bsl::memset(buf, 0, sizeof(buf));
//  status =  streamBuffer.sgetn(buf, 2 * lengthLine2);
//  assert(lengthLine2 == status);
//  assert(!bsl::strcmp(line2, buf));
//..
// Trying to read past the end of the file invalidated the current
// cursor position in the file, so we must seek from the end or the
// beginning of the file in order to establish a new cursor position.
// Note the &#39;pubseekpos&#39; method always seeks relative to the beginning.
// We seek back to the start of the file:
//..
//  status = streamBuffer.pubseekpos(0);
//  assert(0 == status);
//..
// Note that line1 and line3 are the same length:
//..
//  assert(lengthLine1 == lengthLine3);
//..
// Then we write, replacing &#39;line1&#39; in the file with &#39;line3&#39;:
//..
//  status = streamBuffer.sputn(line3, lengthLine3);
//  assert(lengthLine3 == status);
//..
// Now we seek back to the beginning of the file:
//..
//  status = streamBuffer.pubseekpos(0);
//..
// Next we verify we were returned to the start of the file:
//..
//  assert(0 == status);
//..
// Then we read and verify the first line, which now contains the text
// of &#39;line3&#39;:
//..
//  bsl::memset(buf, 0, sizeof(buf));
//  status = streamBuffer.sgetn(buf, lengthLine3);
//  assert(lengthLine3 == status);
//  assert(!bsl::strcmp(line3, buf));
//..
// Now we read and verify the second line, still &#39;line2&#39;:
//..
//  bsl::memset(buf, 0, sizeof(buf));
//  status = streamBuffer.sgetn(buf, lengthLine2);
//  assert(lengthLine2 == status);
//  assert(!bsl::strcmp(line2, buf));
//..
// Next we close &#39;fd&#39; and disconnect &#39;streamBuffer&#39; from &#39;fd&#39;:
//..
//  status = streamBuffer.clear();
//  assert(0 == status);
//..
// Note that &#39;streamBuffer&#39; is now no longer open, and is not
// associated with a file descriptor:
//..
//  assert(!streamBuffer.isOpened());
//  assert(bdls::FilesystemUtil::k_INVALID_FD ==
//         streamBuffer.fileDescriptor());
//..
// Finally, we clean up the file:
//..
//  bdls::FilesystemUtil::remove(fileNameBuffer);
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLS_FILESYSTEMUTIL
#include &lt;bdls_filesystemutil.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_ATOMICOPERATIONS
#include &lt;bsls_atomicoperations.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;
#endif

#ifndef INCLUDED_BSL_IOS
#include &lt;bsl_ios.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

#ifndef INCLUDED_BSL_LOCALE
#include &lt;bsl_locale.h&gt;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;  // char_type, int_type, pos_type, off_type,
                            // traits_type are within the &#39;bsl::streambuf&#39;
                            // class
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;          // size_t
#endif

namespace BloombergLP {

namespace bdls {
                    // ====================================
                    // helper class FdStreamBuf_FileHandler
                    // ====================================

class FdStreamBuf_FileHandler {
    // This private helper class isolates direct operations on files from the
    // &#39;FdStreamBuf&#39; class; it is a thin wrapper around &#39;FilesystemUtil&#39;.  One
    // service this class provides is converting between an in-process &#39;\n&#39; and
    // its corresponding on-file &#39;\r\n&#39; when writing to or reading from a
    // Windows text file.  On &#39;reset&#39; an object of this type is associated with
    // a supplied file descriptor, after which it can do simple operations on
    // that file descriptor in the service of a &#39;FdStreamBuf&#39;.

  private:
    // CLASS DATA
    static bsls::AtomicOperations::AtomicTypes::Int
           s_pageSize;             // page size associated with this operating
                                   // system

    // DATA
    FilesystemUtil::FileDescriptor
           d_fileId;               // file descriptor, which is owned if
                                   // &#39;d_willCloseOnResetFlag&#39; is &#39;true&#39;,
                                   // otherwise not owned

    bool   d_openedFlag;           // &#39;true&#39; if this object is associated with
                                   // a valid file descriptor, and &#39;false&#39;
                                   // otherwise

    bool   d_regularFileFlag;      // &#39;true&#39; if the file descriptor represents
                                   // a plain file (and not a directory or
                                   // other device), and &#39;false&#39; otherwise

    bsl::ios_base::openmode
           d_openModeFlags;        // &#39;ios_base&#39;-style flags with which the
                                   // file or device was opened

    bool   d_willCloseOnResetFlag; // &#39;true&#39; if the file descriptor should be
                                   // closed when this file handler is reset,
                                   // cleared or destroyed, and &#39;false&#39;
                                   // otherwise

    char   d_peekBuffer;           // buffer used when looking one byte ahead
                                   // to complete a &#39;\r\n&#39; in text mode

    bool   d_peekBufferFlag;       // &#39;true&#39; if peek buffer contains a
                                   // character, &#39;false&#39; otherwise.  Note this
                                   // is never true on Unix or in binary mode
                                   // on Windows.

  private:
    // PRIVATE MANIPULATORS
#ifdef BSLS_PLATFORM_OS_WINDOWS
    int windowsWriteText(const char *buffer, int numChars);
        // Write the specified &#39;numChars&#39; characters from the specified
        // &#39;buffer&#39; to this object&#39;s file descriptor.  Return the number of
        // characters successfully written on success, and a negative value
        // otherwise.  Note that &#39;\n&#39;s in the specified &#39;buffer&#39; will be
        // translated to &#39;\r\n&#39; sequences on output.  Also note that this
        // method does not exist and is not called except on Windows.
#endif

  private:
    // NOT IMPLEMENTED
    FdStreamBuf_FileHandler(const FdStreamBuf_FileHandler &amp;);
    FdStreamBuf_FileHandler &amp;operator=(const FdStreamBuf_FileHandler &amp;);

  public:
    // CLASS METHODS
    static bsl::size_t pageSize();
        // Return the operating system&#39;s page size.

    // CREATORS
    FdStreamBuf_FileHandler();
        // Create a file handler that is not associated with any file
        // descriptor.  Note that &#39;isOpened&#39; will be &#39;false&#39; on the newly
        // created object.

    ~FdStreamBuf_FileHandler();
        // Destroy this file handler.  If &#39;willCloseOnReset&#39; is &#39;true&#39;, close
        // any file descriptor associated with this object.

    // MANIPULATORS
    int reset(FilesystemUtil::FileDescriptor fileDescriptor,
              bool                           writableFlag,
              bool                           willCloseOnResetFlag = true,
              bool                           binaryModeFlag = false);
        // Associate this object with the specified &#39;fileDescriptor&#39;, and
        // record the state of the specified &#39;writableFlag&#39; which, if &#39;true&#39;,
        // indicates that the &#39;fileDescriptor&#39; is writable, otherwise it is
        // not.  Before making this association, if, prior to this call,
        // &#39;willCloseOnReset&#39; is true, close any file descriptor previously
        // associated with this object, otherwise leave it open but
        // disassociate this object from it.  The optionally specified
        // &#39;willCloseOnResetFlag&#39; will set &#39;willCloseOnReset&#39;, which, if
        // &#39;true&#39;, indicates that &#39;fileDescriptor&#39; is to be closed when this
        // object is cleared, reset, or destroyed, otherwise no action will be
        // taken on &#39;fileDescriptor&#39; at that time.  Optionally specify a
        // &#39;binaryModeFlag&#39;, which is ignored on Unix; if &#39;false&#39; on Windows,
        // it indicates that &#39;\n&#39;s internally are to be translated to and from
        // &#39;\r\n&#39; sequences on the device; on Unix or if &#39;binaryModeFlag&#39; is
        // &#39;true&#39; no such translation is to occur.  Return 0 on success, and a
        // non-zero value otherwise.  Note that if
        // &#39;FilesystemUtil::k_INVALID_FD&#39; is passed as &#39;fileDescriptor&#39;, no
        // file descriptor is to be associated with this object.  Also note
        // that the state of &#39;fileDescriptor&#39; is unchanged by this call, there
        // is no implicit seek.

    void release();
        // Disassociate this file handler from any file descriptor with which
        // it may be associated without closing that file descriptor.  This
        // method succeeds with no effect if &#39;isOpened&#39; was &#39;false&#39;.  Note that
        // &#39;fileDescriptor&#39; is &#39;FilesystemUtil::k_INVALID_FD&#39; after this call.

    int clear();
        // Release any file descriptor that may be associated with this file
        // handler.  If &#39;isOpened&#39; and &#39;willCloseOnReset&#39; are both &#39;true&#39;, the
        // file descriptor will be closed, otherwise it will be left unchanged.
        // Return 0 on success and a non-zero value if the close fails.  This
        // method succeeds with no effect if &#39;isOpened&#39; was &#39;false&#39;.  Note that
        // &#39;fileDescriptor&#39; is always &#39;FilesystemUtil::k_INVALID_FD&#39; after this
        // call.

    int read(char *buffer, int numBytes);
        // Read the specified &#39;numBytes&#39; bytes from the current position of the
        // file descriptor into the specified &#39;buffer&#39;.  Return the number of
        // characters successfully read.  The behavior is undefined unless
        // &#39;0 &lt;= numBytes&#39; and &#39;buffer&#39; is at least &#39;numBytes&#39; long.  Note that
        // on Windows in text mode, &#39;\r\n&#39; is read as a single character and
        // stored in the buffer as &#39;\n&#39;.

    int write(const char *buffer, int numBytes);
        // Write the specified &#39;buffer&#39;, containing the specified &#39;numBytes&#39;,
        // to the file descriptor starting at the current position.  Return 0
        // on success, and a non-zero value otherwise.  The behavior is
        // undefined unless &#39;0 &lt;= numBytes&#39;.  Note that on Windows in text
        // mode, a &#39;\n&#39; is written as &#39;\r\n&#39; and counts as one character.

    bsl::streampos seek(bsl::streamoff offset, FilesystemUtil::Whence dir);
        // Set the file position associated with this object according to the
        // specified &#39;offset&#39; and &#39;dir&#39; behavior.
        //..
        //   * If &#39;dir&#39; is &#39;FilesystemUtil::e_SEEK_FROM_BEGINNING&#39;, set the
        //     position to &#39;offset&#39; bytes from the beginning of the file.
        //   * If &#39;dir&#39; is &#39;FilesystemUtil::e_SEEK_FROM_CURRENT&#39;, advance the
        //     position by &#39;offset&#39; bytes
        //   * If &#39;dir&#39; is &#39;FilesystemUtil::e_SEEK_FROM_END&#39;, set the position
        //     to &#39;offset&#39; bytes beyond the end of the file.
        //..
        // Return the new location of the file position, in bytes from the
        // beginning of the file on success; and &#39;FilesystemUtil::k_INVALID_FD&#39;
        // otherwise.  The effect on the file position is undefined unless the
        // file descriptor represents a device capable of seeking.  Note that
        // &#39;seek&#39; does not change the size of the file if the position advances
        // beyond the end of the file; instead, the next write at the pointer
        // will increase the file size.  Also note that on Windows in text
        // mode, &#39;offset&#39; will be the number of bytes on disk passed over,
        // including &#39;\r&#39;s in &#39;\r\n&#39; sequences.

    void *mmap(bsl::streamoff offset, bsl::streamoff length);
        // Map to memory a section of the file starting at the specified
        // &#39;offset&#39; from the start of the file and return a pointer to that
        // memory.  The section mapped is to be of the specified &#39;length&#39;.
        // The behavior is undefined unless &#39;offset&#39; is a multiple of
        // &#39;pageSize&#39;.  Note that the memory is mapped for readonly access.

    void unmap(void *mappedMemory, bsl::streamoff length);
        // Unmap the section of memory beginning at the specified
        // &#39;mappedMemory&#39;, having the specified &#39;length&#39;.  The behavior is
        // undefined unless &#39;mappedMemory&#39; is an address returned by a previous
        // call to the &#39;mmap&#39; method and &#39;length&#39; was the &#39;length&#39; specified in
        // that call.

    void setWillCloseOnReset(bool booleanValue);
        // Set &#39;willCloseOnReset&#39; (the flag determining whether this file
        // handler will close the file descriptor on the the next reset, clear,
        // or destruction) to the specified &#39;booleanValue&#39;.  If
        // &#39;willCloseOnReset&#39; is &#39;true&#39;, the next reset, clear, or destruction
        // will result in the file descriptor being closed, otherwise, it will
        // remain open.

    // ACCESSORS
    FilesystemUtil::FileDescriptor fileDescriptor() const;
        // Return the file descriptor associated with this object, if
        // &#39;isOpened&#39; is &#39;true&#39;, and -1 otherwise.

    bsl::streamoff fileSize() const;
        // Return the size of the file associated with this file handler, or
        // 0 if it is associated with a device other than a regular file (e.g.,
        // a device or directory).

    bsl::streamoff getOffset(char *first, char *last) const;
        // Return the number of bytes that the data in the range specified by
        // &#39;[first, last)&#39; will fill when written to the file descriptor.  Note
        // that on Unix, or for a binary file on Windows, this value will be
        // &#39;last - first&#39;, but for on Windows in text mode, extra bytes are
        // added when &#39;\n&#39; would be written to the file descriptor as &#39;\r\n&#39;.

    bool isInBinaryMode() const;
        // Return &#39;false&#39; if on Windows and the file is opened in text mode,
        // and &#39;true&#39; otherwise.

    bool isOpened() const;
        // Return &#39;true&#39; if this file handler is currently associated with a
        // file descriptor, and &#39;false&#39; otherwise.

    bool isRegularFile() const;
        // Return &#39;true&#39; if the file descriptor associated with this file
        // handler is associated with a regular file and &#39;false&#39; otherwise.
        // Note that directories and pipes are not regular files.

    int openMode() const;
        // Return the &#39;bsl::ios_base&#39; mode bits corresponding to this file
        // handler.  Note that this will be a union (bitwise-OR) of a subset of
        // the &#39;bsl::ios_base&#39; constants &#39;in&#39;, &#39;out&#39;, and &#39;binary&#39;.

    bool willCloseOnReset() const;
        // Return &#39;true&#39; if the associated file descriptor will be closed the
        // next time this file handler is reset, cleared, or destroyed, and
        // &#39;false&#39; otherwise.  Note that this value is determined by the value
        // of &#39;willCloseOnResetFlag&#39; that was passed to the most recent call to
        // &#39;reset&#39; or &#39;setWillCloseOnReset&#39;.
};

                             // =================
                             // class FdStreamBuf
                             // =================

class FdStreamBuf : public bsl::streambuf {
    // This class, derived from the C++ standard library class
    // &#39;bsl::streambuf&#39;, is a mechanism that can be associated with an opened
    // file descriptor, and, except for changing the locale, enables the caller
    // to invoke all the standard &#39;bsl::streambuf&#39; operations on that file
    // descriptor.  Note that objects of this class are always in exactly one
    // of the 5 modes outlined in the enum &#39;FdStreamBuf::FdStreamBufMode&#39;.

  private:
    // PRIVATE TYPES
    enum { k_PBACK_BUF_SIZE = 8 }; // size of d_pBackBuf

    enum FdStreamBufMode  {
        e_NULL_MODE          = 0,  // empty state, when not in any other mode;
                                   // the object is constructed in this state

        e_INPUT_MODE         = 1,  // doing input

        e_INPUT_PUTBACK_MODE = 2,  // input putback mode is a form of input
                                   // mode where chars that have been stuffed
                                   // back into the input buffer are kept in
                                   // &#39;d_pBackBuf&#39;.

        e_OUTPUT_MODE        = 3,  // doing output

        e_ERROR_MODE         = 4   // An error has occured.  Note that error
                                   // mode is sticky -- subsequent I/O won&#39;t
                                   // work until error mode is cleared by a
                                   // &#39;reset&#39; or a seek.
    };

  private:
    // DATA
                        // data members used in all modes

    FdStreamBuf_FileHandler
                      d_fileHandler;      // file handler, holds the file
                                          // descriptor, used for doing low
                                          // level operations on the file
                                          // descriptor

                        // mode information

    FdStreamBufMode   d_mode;

    bool              d_dynamicBufferFlag;// &#39;true&#39; if the buffer &#39;d_buf_p&#39; is
                                          // heap allocated, &#39;false&#39; if it was
                                          // supplied by the user.

                        // putback buffer

    char              d_pBackBuf[k_PBACK_BUF_SIZE];
                                          // for putback mode (see above)

                        // input/output buffer

    char             *d_buf_p;            // buffer
    char             *d_bufEOS_p;         // end of buffer space, allocated or
                                          // otherwise
    char             *d_bufEnd_p;         // end of data that&#39;s been read in
                                          // input mode, not used in output
                                          // mode.

                        // data members saved when entering putback mode --
                        // these elements are for for saving fields from the
                        // base class while we are in putback mode

    char             *d_savedEback_p;     // saved value of &#39;eback&#39;
    char             *d_savedGptr_p;      // saved value of &#39;gptr&#39;
    char             *d_savedEgptr_p;     // saved value of &#39;egptr&#39;

                        // fields relevant to mapping the file while in input
                        // mode

    char             *d_mmapBase_p;       // pointer to the &#39;mmap&#39;ed input
                                          // area, 0 if we are not in &#39;mmap&#39;
                                          // input mode

    bsl::streamoff    d_mmapLen;          // length of mapped area

                        // memory allocator

    bslma::Allocator *d_allocator_p;      // allocator (held, not owned)

  private:
    // PRIVATE MANIPULATORS
    void exitPutbackMode();
        // Exit putback mode (leaving this object in input mode) and restore
        // the get buffer to the state it was in just prior to entering putback
        // mode.  The behavior is undefined unless this object is in putback
        // mode.

    int switchToInputMode();
        // Switch this object to input mode.  Return 0 on success, and a
        // non-zero value otherwise.  If this method is called while in input
        // putback mode, exit input putback mode.  Note that this function is
        // called when doing the first input, after a seek, or after writing.
        // Also note that this method has no effect if called when this object
        // is in input mode.

    int exitInputMode(bool correctSeek);
        // Change from input mode to null mode.  If the specified &#39;correctSeek&#39;
        // is &#39;true&#39;, seek to position the file pointer at the point from
        // which the next input would have come; otherwise don&#39;t do the seek.
        // If the input file is currently mapped, unmap it.  Return 0 on
        // success, and non-zero otherwise.  The behavior is undefined unless
        // this object is in input or input_putback mode.  Note that
        // performing a corrective seek corrects the discrepancy between the
        // client&#39;s perception of the file pointer location and the actual
        // file pointer location, caused by buffering.

    int switchToOutputMode();
        // Switch this object to output mode.  Return 0 on success, and a
        // non-zero value otherwise.  Note that this method has no effect if
        // this object is already in output mode.  Also note that this method
        // is called when performing the first output, or when performing the
        // first output after a seek or read.

    int underflowRead();
        // Use &#39;read&#39; to get some data from the file descriptor, and add it to
        // the input buffer.  Return the first character of input.  Note that
        // this method is called only by &#39;underflow&#39;, and only as a last
        // resort, when additional data can&#39;t be provided by mapping.

    int inputError();
        // Put this object into error mode, clearing the get area.  Always
        // return &#39;traits_type::eof()&#39;.  Note that error mode is sticky and is
        // cleared only by a &#39;reset&#39;, &#39;clear&#39; or seek.

    int outputError();
        // Put this object into error mode, clearing the put area.  Always
        // return &#39;traits_type::eof()&#39;.  Note that error mode is sticky and is
        // cleared only by a &#39;reset&#39;, &#39;clear&#39;, &#39;seekoff&#39;, or &#39;seekpos&#39;.

    int allocateBuffer(char *buffer, int numBytes);
        // Set the buffer to be used by this object.  If the specified &#39;buffer&#39;
        // is 0, dynamically allocate a buffer of specified &#39;numBytes&#39; length,
        // or if &#39;buffer&#39; is a non-zero value, use the first &#39;numBytes&#39; bytes
        // of &#39;buffer&#39;.  Return 0 on success, and a non-zero value otherwise.
        // The behavior is undefined unless &#39;1 &lt;= numBytes&#39;, &#39;buffer&#39; (if
        // non-zero) is at least &#39;numBytes&#39; long, a buffer has not previously
        // been allocated or provided, and no I/O has occurred prior to this
        // call.

    int allocateBuffer();
        // Dynamically allocate an input/output buffer of a default size.
        // Return 0 on success, and a non-zero value otherwise.  The behavior
        // is undefined unless no buffer has previously been allocated or
        // provided, and no I/O has occurred prior to this call.

    void deallocateBuffer();
        // If the buffer is dynamically allocated by &#39;allocateBuffer&#39;, free
        // it.  The behavior is undefined unless the buffer was previously
        // allocated or provided.

    int seekInit();
        // Prepare this &#39;FdStreamBuf&#39; for a subsequent seek operation by
        // setting various mode information into an appropriate state.  If in
        // output mode, flush the buffer.  If in putback input mode or error
        // mode, exit that mode.  If in regular input mode, leave that mode
        // unaffected.  Return 0 on success, and a non-zero value otherwise.

    pos_type seekReturn(pos_type offset);
        // Finish a seek by putting this object into null mode and nulling out
        // pointers to the buffer to reflect the fact that a seek has occurred.
        // Return the specified &#39;offset&#39; on success, and a negative value
        // otherwise.

    int flush();
        // Flush any output data to the file descriptor, and reset the state of
        // this object.  Return 0 on success, and a non-zero value otherwise.

  protected:
    // PROTECTED MEMBER FUNCTIONS

    // The following member functions override protected virtual functions
    // inherited from the base class, and are specified to be protected as part
    // of the standard library &#39;bsl::streambuf&#39; interface.

    // PROTECTED MANIPULATORS
    virtual int_type underflow();
        // Replenish the input buffer with data obtained from the file
        // descriptor, and return the next character of input (or eof if no
        // input is available).  Note that in windows text mode, &#39;\r\n&#39;
        // sequences on the device will be translated to &#39;\n&#39;s.

    virtual int_type pbackfail(int_type c = traits_type::eof());
        // If the optionally specified &#39;c&#39; is not given, move the current input
        // position back one character and return the character at that
        // position.  Otherwise specify a value for &#39;c&#39; other than
        // &#39;traits_type::eof&#39;.  If &#39;c&#39; is equal to the previous character in
        // the read buffer, the behavior is the same as if &#39;eof()&#39; was passed.
        // If &#39;c&#39; is not eof and is not equal to the previous character in the
        // putback buffer push the character &#39;c&#39; is back into the input buffer,
        // if possible.  Return the backed up character on success and
        // &#39;traits_type::eof()&#39; otherwise.  If the input buffer is readonly, or
        // &#39;gptr()&#39; is already at the beginning of the input buffer, this
        // object enters &#39;INPUT_PUTBACK_MODE&#39; and &#39;c&#39; is stuffed back into the
        // putback buffer.  Note that only &#39;PBACK_BUF_SIZE&#39; characters can be
        // backed up into the putback buffer, if this limit is exceeded,
        // &#39;traits_type::eof()&#39; will be returned.  Also note that this method
        // is called by public methods &#39;sputbackc&#39; or &#39;sungetc&#39; in the base
        // class, and only when simply decrementing the current position in the
        // input buffer won&#39;t satisfy the request, either because &#39;c&#39; doesn&#39;t
        // match the previously input character, or because the input position
        // is already at the beginning of the input buffer.

    virtual int_type overflow(int_type c = traits_type::eof());
        // If in output mode, write the contents of the buffer to output.
        // Return &#39;traits_type::eof()&#39; on failure, and any other value on
        // success.  Optionally specify a character &#39;c&#39; to be appended to the
        // buffer prior to the flush.  If no character is specified, no
        // character is appended to the buffer.  If not in output mode, switch
        // to output mode.  Note that the write will translate &#39;\n&#39;s to
        // &#39;\r\n&#39;s.

    virtual FdStreamBuf *setbuf(char_type *buffer, bsl::streamsize numBytes);
        // Use the specified &#39;buffer&#39; of the specified &#39;numBytes&#39; capacity as
        // the input/output buffer for this &#39;streambuf&#39;.  If &#39;buffer == 0&#39;, the
        // buffer is dynamically allocated with a default size.  If both
        // &#39;buffer&#39; and &#39;numBytes&#39; are zero a 1-byte buffer is dynamically
        // allocated.  The behavior is undefined if any I/O has preceded this
        // call, and unless the buffer is uninitialized before this call.

    virtual pos_type seekoff(
        off_type                offset,
        bsl::ios_base::seekdir  whence,
        bsl::ios_base::openmode mode = bsl::ios_base::in | bsl::ios_base::out);
        // Set the file pointer associated with the file descriptor according
        // to the specified &#39;offset&#39; and &#39;whence&#39;:
        //..
        // * If &#39;whence&#39; is &#39;bsl::ios_base::beg&#39;, set the pointer to &#39;offset&#39;
        //   bytes from the beginning of the file.
        // * If &#39;whence&#39; is &#39;bsl::ios_base::cur&#39;, advance the pointer by
        //   &#39;offset&#39; bytes
        // * If &#39;whence&#39; is &#39;bsl::ios_base::end&#39;, set the pointer to &#39;offset&#39;
        //   bytes beyond the end of the file.
        //..
        // Optionally specify &#39;mode&#39;, which is ignored.  Return the new
        // location of the file position, in bytes from the beginning of the
        // file, on success, and -1 otherwise.  The behavior is undefined
        // unless the file descriptor is on a device capable of seeking.  Note
        // that seeking does not change the size of the file if the pointer
        // advances beyond the end of the file; instead, the next write at the
        // pointer will increase the file size.  Also note that seeks are
        // always in terms of bytes on the device, meaning that in Windows
        // text mode, seeking past a &#39;\n&#39; perceived by the caller will count as
        // 2 bytes since it has to seek over a &#39;\r\n&#39; sequence on the device.

    virtual pos_type seekpos(
        pos_type                offset,
        bsl::ios_base::openmode mode = bsl::ios_base::in | bsl::ios_base::out);
        // Seek to the specified &#39;offset&#39; relative to the beginning of the
        // file.  Return the resulting absolute position in the file relative
        // to the beginning.  Optionally specify &#39;mode&#39; which is ignored.  Also
        // note that seeks are always in terms of bytes on the device, meaning
        // that on a Windows text file, seeking past a &#39;\r\n&#39; sequence on the
        // disk will count as two bytes, though if it is read in it will be a
        // single &#39;\n&#39; byte.

    virtual int sync();
        // If in output mode, flush the buffer to the associated file
        // descriptor; otherwise do nothing.  Return 0 on success, -1
        // otherwise.

    virtual void imbue(const bsl::locale&amp; locale);
        // Set the locale for this object.  This method has no effect.  The
        // behavior is undefined unless the specified &#39;locale&#39; is the same as
        // &#39;bsl::locale()&#39;.

    virtual bsl::streamsize showmanyc();
        // If this object is in putback mode, return the number of characters
        // remaining to be read in the putback buffer, and otherwise the
        // number of characters remaining in the file to be read.  Return a
        // non-negative number of characters on success and a negative value
        // otherwise.  The behavior is undefined unless this object is in input
        // mode and the file descriptor is associated with a regular file.

    virtual bsl::streamsize xsgetn(char *buffer, bsl::streamsize numBytes);
        // Read up to the specified &#39;numBytes&#39; characters from the file
        // descriptor into the specified &#39;buffer&#39; and return the number of
        // characters successfully read.  The behavior is undefined unless
        // &#39;buffer&#39; is at least &#39;numBytes&#39; bytes long.  Note that on a Windows
        // text file, a &#39;\r\n&#39; in the file will be read as &#39;\n&#39; (counting as a
        // single character).

    virtual bsl::streamsize xsputn(const char      *buffer,
                                   bsl::streamsize  numBytes);
        // Write up to the specified &#39;numBytes&#39; characters from the specified
        // &#39;buffer&#39; and return the number of characters successfully written.
        // Note that this method does not necessarily modify the file: this
        // method may simply write the characters to a buffer to be flushed to
        // the file at a later time.  Also note that on a Windows text file, a
        // &#39;\n&#39; will be written to the file as &#39;\r\n&#39; (counted as a single
        // character).

  private:
    // NOT IMPLEMENTED
    FdStreamBuf(           const FdStreamBuf&amp;);
    FdStreamBuf&amp; operator=(const FdStreamBuf&amp;);

  public:
    // CREATORS
    explicit FdStreamBuf(
                   FilesystemUtil::FileDescriptor  fileDescriptor,
                   bool                            writableFlag,
                   bool                            willCloseOnResetFlag = true,
                   bool                            binaryModeFlag = false,
                   bslma::Allocator               *basicAllocator = 0);
        // Create a &#39;FdStreamBuf&#39; associated with the specified
        // &#39;fileDescriptor&#39; that refers to an already opened file or device,
        // and specify &#39;writableFlag&#39; which, if &#39;true&#39;, indicates that
        // &#39;fileDescriptor&#39; is writable, otherwise it is not.  The optionally
        // specified &#39;willCloseOnResetFlag&#39;, if &#39;true&#39;, indicates that
        // &#39;fileDescriptor&#39; is to be closed the next time this object is reset,
        // cleared or destroyed, or if &#39;false&#39; the file descriptor is to be
        // left open.  Optionally specify a &#39;binaryModeFlag&#39; which is ignored
        // on Unix; if &#39;false&#39; on Windows, it indicates that &#39;\n&#39;s are to be
        // translated to and from &#39;\r\n&#39; sequences on the device.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.  Note that if &#39;FilesystemUtil::k_INVALID_FD&#39; is passed to
        // &#39;fileDescriptor&#39;, no file descriptor is to be associated with this
        // object.  Also note that the state of the &#39;fileDescriptor&#39; is
        // unchanged by this call (i.e., there is no implicit seek).

    ~FdStreamBuf();
        // Destroy this object and, if &#39;willCloseOnReset&#39; is &#39;true&#39;, close the
        // file descriptor associated with this object, if any.

    // MANIPULATORS
    int reset(FilesystemUtil::FileDescriptor fileDescriptor,
              bool                           writableFlag,
              bool                           willCloseOnResetFlag = true,
              bool                           binaryModeFlag = false);
        // Associate this object with the specified &#39;fileDescriptor&#39;, and
        // record the state of the specified &#39;writableFlag&#39; which, if &#39;true&#39;,
        // indicates that &#39;fileDescriptor&#39; is writable, otherwise it is not.
        // Before making this association, if, prior to this call,
        // &#39;willCloseOnReset&#39; is true, close any file descriptor previously
        // associated with this object, otherwise leave it open but
        // disassociate this object from it.  The Optionally specified
        // &#39;willCloseOnResetFlag&#39; which will set &#39;willCloseOnReset&#39;, which, if
        // &#39;true&#39;, indicates that the specified file descriptor is to be closed
        // when this object is cleared, reset, or destroyed, otherwise no
        // action will be taken on &#39;fileDescriptor&#39; at that time.  Optionally
        // specify a &#39;binaryModeFlag&#39;, which is ignored on Unix; if &#39;false&#39; on
        // Windows, it indicates that &#39;\n&#39;s internally are to be translated to
        // and from &#39;\r\n&#39; sequences on the device; on Unix or if
        // &#39;binaryModeFlag&#39; is &#39;true&#39; no such translation is to occur.  Return
        // 0 on success, and a non-zero value otherwise.  Note that if
        // &#39;FilesystemUtil::k_INVALID_FD&#39; is passed as &#39;fileDescriptor&#39;, no
        // file descriptor is to be associated with this object.  Also note
        // that the state of the &#39;fileDescriptor&#39; is unchanged by this call,
        // there is no implicit seek.

    void release();
        // Disassociate this file handler from any file descriptor with which
        // it may be associated without closing that file descriptor.  This
        // method succeeds with no effect is &#39;isOpened&#39; was false.  Note that
        // &#39;fileDescriptor&#39; is &#39;FilesystemUtil::k_INVALID_FD&#39; after this call.

    int clear();
        // Release any file descriptor that may be associated with this file
        // handler.  If &#39;isOpened&#39; and &#39;willCloseOnReset&#39; are both &#39;true&#39;, the
        // file descriptor will be closed, otherwise it will not.  Return 0 on
        // success, and a non-zero value if the close fails.  This method
        // succeeds with no effect if &#39;isOpened&#39; was false.  Note that
        // &#39;fileDescriptor&#39; is &#39;FilesystemUtil::k_INVALID_FD&#39; after this call.

    // ACCESSORS
    FilesystemUtil::FileDescriptor fileDescriptor() const;
        // Return the file descriptor associated with this object, or
        // &#39;FilesystemUtil::k_INVALID_FD&#39; if this object is not currently
        // associated with a file descriptor.

    bool isOpened() const;
        // Return &#39;true&#39; if this object is currently associated with a file
        // descriptor, and &#39;false&#39; otherwise.

    bool willCloseOnReset() const;
        // Return &#39;true&#39; if this object will close the associated file
        // descriptor the next time it is reset, cleared, or destroyed, and
        // &#39;false&#39; otherwise.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                       // -----------------------------
                       // class FdStreamBuf_FileHandler
                       // -----------------------------

// CLASS METHODS
inline
size_t FdStreamBuf_FileHandler::pageSize()
{
    return bsls::AtomicOperations::getIntRelaxed(&amp;s_pageSize);
}

// MANIPULATORS
inline
void FdStreamBuf_FileHandler::release()
{
    d_willCloseOnResetFlag = false;
    reset(FilesystemUtil::k_INVALID_FD, false);
}

inline
int FdStreamBuf_FileHandler::clear()
{
    return reset(FilesystemUtil::k_INVALID_FD, false);
}

inline
void FdStreamBuf_FileHandler::setWillCloseOnReset(bool booleanValue)
{
    d_willCloseOnResetFlag = booleanValue;
}

inline
bsl::streamoff
FdStreamBuf_FileHandler::getOffset(char *first, char *last) const
{
    BSLS_ASSERT_SAFE(first &lt;= last);

    return d_openModeFlags &amp; bsl::ios_base::binary
           ? last - first
           : bsl::count(first, last, &#39;\n&#39;) + last - first;
}

inline
bool FdStreamBuf_FileHandler::isInBinaryMode() const
{
#if defined(BSLS_PLATFORM_OS_UNIX)
    return true;
# else
    // Windows

    return (d_openModeFlags &amp; bsl::ios_base::binary) != 0;
# endif
}

inline
bool FdStreamBuf_FileHandler::isOpened() const
{
    return d_openedFlag;
}

inline
bool FdStreamBuf_FileHandler::isRegularFile() const
{
    return d_regularFileFlag;
}

inline
int FdStreamBuf_FileHandler::openMode() const
{
    return (int) d_openModeFlags;
}

inline
bool FdStreamBuf_FileHandler::willCloseOnReset() const
{
    return d_willCloseOnResetFlag;
}

inline
FilesystemUtil::FileDescriptor
FdStreamBuf_FileHandler::fileDescriptor() const
{
    return d_fileId;
}

                             // -----------------
                             // class FdStreamBuf
                             // -----------------

// PRIVATE MANIPULATORS
inline
void FdStreamBuf::exitPutbackMode()
{
    setg(d_savedEback_p, d_savedGptr_p, d_savedEgptr_p);
    d_mode = e_INPUT_MODE;
}

inline
FdStreamBuf::pos_type
FdStreamBuf::seekReturn(pos_type offset)
    // Only called by &#39;seekoff&#39; and &#39;seekpos&#39;, returns the value about to be
    // returned by the calling routine.
{
    if (e_INPUT_MODE == d_mode || e_INPUT_PUTBACK_MODE == d_mode) {
        if (0 != exitInputMode(false)) {
            // error

            return (pos_type) - 1;                                    // RETURN
        }
    }
    setg(0, 0, 0);
    setp(0, 0);

    d_mode = e_NULL_MODE;

    return offset;
}

// MANIPULATORS
inline
int FdStreamBuf::reset(FilesystemUtil::FileDescriptor fileDescriptor,
                       bool                           writableFlag,
                       bool                           willCloseOnResetFlag,
                       bool                           binaryModeFlag)
{
    bool ok = 0 == flush();

    if (ok || FilesystemUtil::k_INVALID_FD == fileDescriptor) {
        // note we reset() whether flush succeeded or not

        ok &amp;= (0 == d_fileHandler.reset(fileDescriptor,
                                        writableFlag,
                                        willCloseOnResetFlag,
                                        binaryModeFlag));
    }

    return ok ? 0 : -1;
}

inline
void FdStreamBuf::release()
{
    d_fileHandler.setWillCloseOnReset(false);
    reset(FilesystemUtil::k_INVALID_FD, false);
}

inline
int FdStreamBuf::clear()
{
    return reset(FilesystemUtil::k_INVALID_FD, false);
}

// ACCESSORS
inline
FilesystemUtil::FileDescriptor FdStreamBuf::fileDescriptor() const
{
    return d_fileHandler.fileDescriptor();
}

inline
bool FdStreamBuf::isOpened() const
{
    return d_fileHandler.isOpened();
}

inline
bool FdStreamBuf::willCloseOnReset() const
{
    return d_fileHandler.willCloseOnReset();
}
}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
