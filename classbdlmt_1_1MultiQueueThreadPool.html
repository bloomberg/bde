<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlmt::MultiQueueThreadPool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlmt.html">bdlmt</a>      </li>
      <li><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">bdlmt::MultiQueueThreadPool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlmt::MultiQueueThreadPool Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlmt::MultiQueueThreadPool" -->
<p><code>#include &lt;<a class="el" href="bdlmt__multiqueuethreadpool_8h_source.html">bdlmt_multiqueuethreadpool.h</a>&gt;</code></p>

<p><a href="classbdlmt_1_1MultiQueueThreadPool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a2adde577c62b578518393f9a487a8a6e">Job</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void()&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#af4cc057e4e922cf8bcf5e23dcd12f661">CleanupFunctor</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a5bdf34b0738e952f7c6bfb8fb119d1c6">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">MultiQueueThreadPool</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a0f24750c3963000b70de8f231b6c60fa">MultiQueueThreadPool</a> (const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;threadAttributes, int minThreads, int maxThreads, int maxIdleTime, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#aea23c8db3e1ea946411eb8d3de1f3ee9">MultiQueueThreadPool</a> (<a class="el" href="classbdlmt_1_1ThreadPool.html">ThreadPool</a> *threadPool, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a4be887b8850b01a4f11391da2e9f6766">~MultiQueueThreadPool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a12bd44efc3cc2327bed255cbb674d0bb">createQueue</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a9dac19a8ab1e12eb7672aaf3a9253e94">deleteQueue</a> (int id, const <a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#af4cc057e4e922cf8bcf5e23dcd12f661">CleanupFunctor</a> &amp;cleanupFunctor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a33b44f0f470894c05e205d4a4923ef47">deleteQueue</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a700f94a765e5da95c576da918e027db2">disableQueue</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a5edb34beeb44db9f35830838a6c99958">drainQueue</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a4ab30cbb5a252c1df29367c5f01f1be6">enqueueJob</a> (int id, const <a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a2adde577c62b578518393f9a487a8a6e">Job</a> &amp;functor)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#ac979feab04751d7638b0ce3807c70a72">enableQueue</a> (int id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#ae464a473cb2f0fc9bad62af7d223660a">numProcessedReset</a> (int *numDequeued, int *numEnqueued)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#abc213e4e66106548e2dd357cd551bee5">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#af0591d71cd6a4670f0c8765215def6a0">drain</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a5197a5f82c41cc3836515a633452f8e1">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a2ae519a37dc0dfc7eb7e55eef411f7ba">shutdown</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#ac36c595a2950a19fe75a350b9d4f76e2">numQueues</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a954f135242ddc1b7f39675dd4331d0c1">numElements</a> (int id) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#acca92a215254ad0b9c9bbbc37d460270">numProcessed</a> (int *numDequeued, int *numEnqueued) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbdlmt_1_1ThreadPool.html">ThreadPool</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a6964a7f20de60d2c5c1a8d0736cf73a7">threadPool</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a dynamic, configurable pool of queues, each of which is processed serially by a thread pool. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a2adde577c62b578518393f9a487a8a6e"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::Job" ref="a2adde577c62b578518393f9a487a8a6e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void()&gt; <a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a2adde577c62b578518393f9a487a8a6e">bdlmt::MultiQueueThreadPool::Job</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af4cc057e4e922cf8bcf5e23dcd12f661"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::CleanupFunctor" ref="af4cc057e4e922cf8bcf5e23dcd12f661" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void()&gt; <a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#af4cc057e4e922cf8bcf5e23dcd12f661">bdlmt::MultiQueueThreadPool::CleanupFunctor</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a0f24750c3963000b70de8f231b6c60fa"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::MultiQueueThreadPool" ref="a0f24750c3963000b70de8f231b6c60fa" args="(const bslmt::ThreadAttributes &amp;threadAttributes, int minThreads, int maxThreads, int maxIdleTime, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::MultiQueueThreadPool::MultiQueueThreadPool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>threadAttributes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>minThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>maxIdleTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">MultiQueueThreadPool</a></code> with the specified <code>threadAttributes</code>, <code>minThread</code> and <code>maxThreads</code> minimum and maximum number of threads respectively, and the specified <code>maxIdleTime</code> maximum idle time (in milliseconds). Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the default memory allocator is used. Note that the <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">MultiQueueThreadPool</a></code> is created without any queues. Although queues may be created, <code>start</code> must be called before enqueuing jobs. </p>

</div>
</div>
<a class="anchor" id="aea23c8db3e1ea946411eb8d3de1f3ee9"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::MultiQueueThreadPool" ref="aea23c8db3e1ea946411eb8d3de1f3ee9" args="(ThreadPool *threadPool, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::MultiQueueThreadPool::MultiQueueThreadPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1ThreadPool.html">ThreadPool</a> *&nbsp;</td>
          <td class="paramname"> <em>threadPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct a <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">MultiQueueThreadPool</a></code> with the specified <code>threadPool</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the default memory allocator is used. The behavior is undefined if <code>threadPool</code> is 0. Note that the <code><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">MultiQueueThreadPool</a></code> is created without any queues. Although queues may be created, <code>start</code> must be called before enqueuing jobs. </p>

</div>
</div>
<a class="anchor" id="a4be887b8850b01a4f11391da2e9f6766"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::~MultiQueueThreadPool" ref="a4be887b8850b01a4f11391da2e9f6766" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::MultiQueueThreadPool::~MultiQueueThreadPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this multi-queue thread pool. Disable queuing on all queues, and wait until all queues are empty. Then, delete all queues, and shut down the thread pool if the thread pool is owned by this object. This method will block if any thread is executing <code>start</code> or <code>stop</code> at the time of the call. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a5bdf34b0738e952f7c6bfb8fb119d1c6"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::BSLALG_DECLARE_NESTED_TRAITS" ref="a5bdf34b0738e952f7c6bfb8fb119d1c6" args="(MultiQueueThreadPool, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlmt::MultiQueueThreadPool::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html">MultiQueueThreadPool</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a12bd44efc3cc2327bed255cbb674d0bb"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::createQueue" ref="a12bd44efc3cc2327bed255cbb674d0bb" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::createQueue </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a queue with unlimited capacity and a default number of initial elements. Return a non-zero queue ID on success, and 0 otherwise. The queue ID can be used to enqueue jobs to the queue, or to delete the queue. </p>

</div>
</div>
<a class="anchor" id="a9dac19a8ab1e12eb7672aaf3a9253e94"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::deleteQueue" ref="a9dac19a8ab1e12eb7672aaf3a9253e94" args="(int id, const CleanupFunctor &amp;cleanupFunctor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::deleteQueue </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#af4cc057e4e922cf8bcf5e23dcd12f661">CleanupFunctor</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>cleanupFunctor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable enqueuing to the queue associated with the specified <code>id</code>, and enqueue the specified <code>cleanupFunctor</code> to the <em>front</em> of the queue. The <code>cleanupFunctor</code> is guaranteed to be the last queue element processed, after which the queue is destroyed and removed from all internal registries. The caller will NOT be blocked until <code>cleanupFunctor</code> executes to completion. Return 0 on success, and a non-zero value otherwise. The behavior is undefined if this function is called simultaneously with <code>disableQueue</code>, <code>drainQueue</code>, <code>start</code>, <code>drain</code>, <code>stop</code>, or <code>shutdown</code>. Note that passing an unbound <code>cleanupFunctor</code> is equivalent to passing a <code>cleanupFunctor</code> bound with <code>makeNull</code>. Also note that this function will fail if called on a stopped multi queue thread pool. </p>

</div>
</div>
<a class="anchor" id="a33b44f0f470894c05e205d4a4923ef47"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::deleteQueue" ref="a33b44f0f470894c05e205d4a4923ef47" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::deleteQueue </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable enqueuing to the queue associated with the specified <code>id</code>, and block the calling thread until a currently-active callback, if any, is completed. Return 0 on success, and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a700f94a765e5da95c576da918e027db2"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::disableQueue" ref="a700f94a765e5da95c576da918e027db2" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::disableQueue </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable enqueuing to the queue associated with the specified <code>id</code>. Return 0 on success, and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a5edb34beeb44db9f35830838a6c99958"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::drainQueue" ref="a5edb34beeb44db9f35830838a6c99958" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::drainQueue </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait until all jobs in the queue indicated by the specified <code>id</code> are finished. This method simply blocks until that queue is empty, without disabling the queue. The queue may be enabled or disabled when this is called. Return 0 on success, and a non-zero value otherwise. The behavior is undefined if another thread deletes the queue before this method finishes. </p>

</div>
</div>
<a class="anchor" id="a4ab30cbb5a252c1df29367c5f01f1be6"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::enqueueJob" ref="a4ab30cbb5a252c1df29367c5f01f1be6" args="(int id, const Job &amp;functor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::enqueueJob </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbdlmt_1_1MultiQueueThreadPool.html#a2adde577c62b578518393f9a487a8a6e">Job</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>functor</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue the specified <code>functor</code> to the queue specified by <code>id</code>. Return 0 if enqueued successfully, and a non-zero value if queuing is otherwise. The behavior is undefined unless <code>functor</code> is bound. </p>

</div>
</div>
<a class="anchor" id="ac979feab04751d7638b0ce3807c70a72"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::enableQueue" ref="ac979feab04751d7638b0ce3807c70a72" args="(int id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::enableQueue </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable enqueuing to the queue associated with the specified <code>id</code>. Return 0 on success, and a non-zero value otherwise. It is an error to call <code>enableQueue</code> if a previous call to <code>stop</code> is being executed. </p>

</div>
</div>
<a class="anchor" id="ae464a473cb2f0fc9bad62af7d223660a"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::numProcessedReset" ref="ae464a473cb2f0fc9bad62af7d223660a" args="(int *numDequeued, int *numEnqueued)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::MultiQueueThreadPool::numProcessedReset </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numDequeued</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numEnqueued</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>numDequeued</code> and <code>numEnqueued</code> the number of items dequeued / enqueued (respectively) since the last time these values were reset and reset these values. </p>

</div>
</div>
<a class="anchor" id="abc213e4e66106548e2dd357cd551bee5"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::start" ref="abc213e4e66106548e2dd357cd551bee5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enable queuing on all queues, start the thread pool if the thread pool is owned by this object, and ensure that at least the minimum number of processing threads are started. Return 0 on success, and a non-zero value otherwise. This method will block if any thread is executing <code>drain</code>, <code>stop</code>, or <code>shutdown</code> at the time of the call. This method has no effect if this thread pool has already been started. </p>

</div>
</div>
<a class="anchor" id="af0591d71cd6a4670f0c8765215def6a0"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::drain" ref="af0591d71cd6a4670f0c8765215def6a0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::MultiQueueThreadPool::drain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Block until all queues are empty. This method waits until all queues are empty without disabling the queues. The queues and/or the thread pool may be either enabled or disabled when this method is called. This method may be called on a stopped or started thread pool. This method will block if any thread is executing <code>start</code>, <code>stop</code>, or <code>shutdown</code> at the time of the call. Note that <code>drain</code> does not attempt to delete queues directly. However as a side-effect of emptying all queues, any queue for which <code>deleteQueue</code> was called previously will be deleted before <code>drain</code> unblocks. </p>

</div>
</div>
<a class="anchor" id="a5197a5f82c41cc3836515a633452f8e1"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::stop" ref="a5197a5f82c41cc3836515a633452f8e1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::MultiQueueThreadPool::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable queuing on all queues, and wait until all queues are empty. Then, stop the thread pool if the thread pool is owned by this object. This method will block if any thread is executing <code>start</code> or <code>drain</code> or <code>shutdown</code> at the time of the call. Note that <code>stop</code> does not attempt to delete queues directly. However as a side-effect of emptying all queues, any queue for which <code>deleteQueue</code> was called previously will be deleted before <code>stop</code> unblocks. </p>

</div>
</div>
<a class="anchor" id="a2ae519a37dc0dfc7eb7e55eef411f7ba"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::shutdown" ref="a2ae519a37dc0dfc7eb7e55eef411f7ba" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::MultiQueueThreadPool::shutdown </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Disable queuing on all queues, and wait until all queues are empty. Then, delete all queues, and shut down the thread pool if the thread pool is owned by this object. This method will block if any thread is executing <code>start</code> or <code>drain</code> or <code>stop</code> at the time of the call. </p>

</div>
</div>
<a class="anchor" id="ac36c595a2950a19fe75a350b9d4f76e2"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::numQueues" ref="ac36c595a2950a19fe75a350b9d4f76e2" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::numQueues </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an instantaneous snapshot of the number of queues managed by this object. </p>

</div>
</div>
<a class="anchor" id="a954f135242ddc1b7f39675dd4331d0c1"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::numElements" ref="a954f135242ddc1b7f39675dd4331d0c1" args="(int id) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlmt::MultiQueueThreadPool::numElements </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>id</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an instantaneous snapshot of the number of elements enqueued in the queue associated with the specified <code>id</code> as a non-negative integer, or -1 if <code>id</code> does not specify a valid queue. </p>

</div>
</div>
<a class="anchor" id="acca92a215254ad0b9c9bbbc37d460270"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::numProcessed" ref="acca92a215254ad0b9c9bbbc37d460270" args="(int *numDequeued, int *numEnqueued) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlmt::MultiQueueThreadPool::numProcessed </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numDequeued</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numEnqueued</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>numDequeued</code> and <code>numEnqueued</code> the number of items dequeued / enqueued (respectively) since the last time these values were reset. </p>

</div>
</div>
<a class="anchor" id="a6964a7f20de60d2c5c1a8d0736cf73a7"></a><!-- doxytag: member="bdlmt::MultiQueueThreadPool::threadPool" ref="a6964a7f20de60d2c5c1a8d0736cf73a7" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbdlmt_1_1ThreadPool.html">ThreadPool</a>&amp; bdlmt::MultiQueueThreadPool::threadPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable thread pool owned by this object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlmt__multiqueuethreadpool_8h_source.html">bdlmt_multiqueuethreadpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
