<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslstl_unorderedmapkeyconfiguration.h                              -*-C++-*-
#ifndef INCLUDED_BSLSTL_UNORDEREDMAPKEYCONFIGURATION
#define INCLUDED_BSLSTL_UNORDEREDMAPKEYCONFIGURATION

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a class template to extract keys as the &#39;first&#39; attribute.
//
//@CLASSES:
//   bslalg::UnorderedMapKeyConfiguration : extracts &#39;key&#39; from &#39;value&#39; type
//
//@SEE_ALSO: bslalg_hashtableimputil
//
//@DESCRIPTION: This component will, given an object of a value type consisting
// of a key type and some other information, return a const reference to only
// the key type within that object.  The object passed will be of parametrized
// type &#39;VALUE_TYPE&#39;, for which a type &#39;VALUE_TYPE::first_type&#39; must be
// defined and be of the key type, and for which the operation &#39;.first&#39; must be
// defined and must yield the object of the key type.
//
// &#39;bslalg::HashTableImpUtil&#39; has a static &#39;extractKey&#39; function template that,
// given a &#39;value type&#39;, will represent objects stored in a data structure,
// will abstract out the &#39;key type&#39; portion of that object.  In the case of the
// &#39;unordered_map&#39; data structure, the &#39;value type&#39; will be &#39;bsl::pair&#39;, and
// the key type will &#39;bsl::pair::first_type&#39;.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Using Multiple Extractors to Sort an Array on Different Keys
///- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we want to define a &#39;sort&#39; function which will work on a variety
// of different object types.  The object has to have a &#39;key&#39; within it,
// possibly the whole object, which will compare with the &#39;key&#39; of other
// objects with a transitive &#39;&lt;&#39; operator.
//
// First, we define our function &#39;mySort&#39;, which takes two template args:
// &#39;VALUE_TYPE&#39;, the type of object being sorted, and &#39;KEY_EXTRACTOR&#39;, the
// utility class that will extra which part of the objects to be sorted is the
// key which will drive the sort:
//..
//  template &lt;class VALUE_TYPE, class KEY_EXTRACTOR&gt;
//  void mySort(VALUE_TYPE *begin, VALUE_TYPE *end, const KEY_EXTRACTOR&amp;)
//      // This function provides an order-preserving sort of the items in the
//      // range &#39;[ begin, end )&#39;, where &#39;KEY_EXTRACTOR::extractKey&#39; yields the
//      // key being sorted over.  We require that &#39;VALUE_TYPE&#39; support copy
//      // construction and assignment.
//  {
//      while (begin &lt; --end) {
//          for (VALUE_TYPE *it = begin; it &lt; end; ++it) {
//              if (KEY_EXTRACTOR::extractKey(it[1]) &lt;
//                                          KEY_EXTRACTOR::extractKey(it[0])) {
//                  // they&#39;re in the wrong order -- swap them
//
//                  VALUE_TYPE tmp(it[0]);
//                  it[0] = it[1];
//                  it[1] = tmp;
//              }
//          }
//
//          // &#39;*end&#39; is now the highest element in the range &#39;[ begin, end ]&#39;,
//          // so we only have to sort the elements before it in the next pass.
//      }
//  }
//..
// Then, we define &#39;StudentRecord&#39;, which keeps some vital statistics on
// students:
//..
//  struct StudentRecord {
//      const char *d_name;
//      double      d_gpa;
//      int         d_age;
//  };
//..
// Next, we define two extractors for &#39;StudentRecord&#39;, which will yield the
// &#39;GPA&#39; or &#39;Age&#39; fields:
//..
//  struct StudentRecordGPAExtractor {
//      static
//      const double&amp; extractKey(const StudentRecord&amp; record)
//      {
//          return record.d_gpa;
//      }
//  };
//
//  struct StudentRecordAgeExtractor {
//      static
//      const int&amp; extractKey(const StudentRecord&amp; record)
//      {
//          return record.d_age;
//      }
//  };
//..
// Then, in &#39;main&#39;, we create an array of &#39;StudentRecord&#39;s describing a set of
// students, with their names, GPA&#39;s, and ages.
//..
//  StudentRecord studentArray[] = {
//      { &quot;Phil&quot;,  3.4, 19 },
//      { &quot;Bob&quot;,   2.7, 20 },
//      { &quot;Bill&quot;,  4.2, 21 },
//      { &quot;Stan&quot;,  1.9, 18 },
//      { &quot;Ann&quot;,   2.3, 21 },
//      { &quot;Julie&quot;, 2.3, 20 } };
//  const int NUM_STUDENTS = sizeof studentArray / sizeof *studentArray;
//..
// Next, using our GPA extractor and our &#39;mySort&#39; function, we sort the
// students by GPA:
//..
//  StudentRecordGPAExtractor gpaExtractor;
//
//  mySort(studentArray + 0,
//         studentArray + NUM_STUDENTS,
//         gpaExtractor);
//..
// Then, we print out the sorted array of students:
//..
//  if (verbose) {
//      printf(&quot;\nList of students, lowest GPA first:\n&quot;);
//      printf(  &quot;===================================\n&quot;);
//
//      printf(&quot;Name   GPA  AGE\n&quot;
//             &quot;-----  ---  ---\n&quot;);
//      for (int i = 0; i &lt; NUM_STUDENTS; ++i) {
//          const StudentRecord&amp; record = studentArray[i];
//
//          printf(&quot;%-5s  %g  %3d\n&quot;, record.d_name,
//                                    record.d_gpa,
//                                    record.d_age);
//      }
//  }
//..
// The output produced is:
//..
//  List of students, lowest GPA first:
//  ===================================
//  Name   GPA  AGE
//  -----  ---  ---
//  Stan   1.9   18
//  Ann    2.3   21
//  Julie  2.3   20
//  Bob    2.7   20
//  Phil   3.4   19
//  Bill   4.2   21
//..
// Note that Ann and Julie, who have the same GPA, are still in the same order
// as they were before the sort, as &#39;mySort&#39; was an order-preserving sort:
//
// Next, we sort by age with our age extractor, and print out the results:
//..
//  StudentRecordAgeExtractor ageExtractor;
//
//  mySort(studentArray + 0,
//         studentArray + NUM_STUDENTS,
//         ageExtractor);
//
//  if (verbose) {
//      printf(&quot;\nList of students, youngest first:\n&quot;);
//      printf(  &quot;================================\n&quot;);
//
//      printf(&quot;Name   GPA  AGE\n&quot;
//             &quot;-----  ---  ---\n&quot;);
//      for (int i = 0; i &lt; NUM_STUDENTS; ++i) {
//          const StudentRecord&amp; record = studentArray[i];
//
//          printf(&quot;%-5s  %g  %3d\n&quot;, record.d_name,
//                                    record.d_gpa,
//                                    record.d_age);
//      }
//  }
//..
// The output is:
//..
//  List of students, youngest first:
//  ================================
//  Name   GPA  AGE
//  -----  ---  ---
//  Stan   1.9   18
//  Phil   3.4   19
//  Julie  2.3   20
//  Bob    2.7   20
//  Ann    2.3   21
//  Bill   4.2   21
//..
// Note again, the ordering of students with identical ages is preserved.
//
// Then, suppose we are storing information about employees in &#39;MyPair&#39;
// objects, where &#39;first&#39; is a double storing the employees hourly wage, and
// &#39;second&#39; in the employee&#39;s name.  Suppose we want to sort the employees by
// their hourly wages, which is the &#39;.first&#39; field of the pair.
//
// We declare our employee pair type:
//..
//  typedef MyPair&lt;double, const char *&gt; EmployeePair;
//..
// Next, we define an array of employee pairs for employees&#39; wages and names:
//..
//  EmployeePair employees[] = {
//      { 12.25, &quot;Kyle&quot; },
//      { 15.00, &quot;Eric&quot; },
//      { 12.25, &quot;Stan&quot; },
//      {  7.75, &quot;Kenny&quot; } };
//  const int NUM_EMPLOYEES = sizeof employees / sizeof *employees;
//..
// Then, we create an &#39;UnorderedMapKeyConfiguration&#39; type paramtrized on
// &#39;EmployeePair&#39;, which will extract the &#39;.first&#39; field, which is the wage,
// from an employee pair:
//..
//  bslstl::UnorderedMapKeyConfiguration&lt;EmployeePair&gt; wageExtractor;
//..
// Next, we sort:
//..
//  mySort(employees + 0, employees + NUM_EMPLOYEES, wageExtractor);
//..
// Now, we print out our results:
//..
//  if (verbose) {
//      printf(&quot;\nList of employees, cheapest first:\n&quot;
//               &quot;==================================\n&quot;);
//
//      printf(&quot;Name   Wage\n&quot;
//             &quot;-----  -----\n&quot;);
//
//      for (int i = 0; i &lt; NUM_EMPLOYEES; ++i) {
//          const EmployeePair&amp; employee = employees[i];
//
//          printf(&quot;%-5s  %5.2f\n&quot;, employee.second, employee.first);
//      }
//  }
//..
// Finally, we see our output.  Note that the ordering of Kyle and Stan, who
// are paid the same wage, is preserved.
//..
//  List of employees, cheapest first:
//  ==================================
//  Name   Wage
//  -----  -----
//  Kenny   7.75
//  Kyle   12.25
//  Stan   12.25
//  Eric   15.00
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

namespace BloombergLP {
namespace bslstl {

                      // ===================================
                      // struct UnorderedMapKeyConfiguration
                      // ===================================

template &lt;class VALUE_TYPE&gt;
struct UnorderedMapKeyConfiguration {
  public:
    typedef          VALUE_TYPE             ValueType;
    typedef typename ValueType::first_type  KeyType;

    // Choosing to implement for each configuration, to reduce the template
    // mess.  With only two policies, not much is saved using a shared
    // dependent base class to provide a common implementation.  This is the
    // key abstraction, turning &#39;bslalg::BidirectionalLink*&#39; into &#39;VALUE_TYPE&amp;&#39;

    // CLASS METHODS
    static const KeyType&amp; extractKey(const VALUE_TYPE&amp; obj);
        // Return the member &#39;first&#39; of the specified object &#39;obj&#39;.
        // &#39;obj.first&#39; must of of type &#39;VALUE_TYPE::first_type&#39;, which is the
        // &#39;key&#39; portion of &#39;obj&#39;.
};

// ===========================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ===========================================================================

                       //-----------------------------------
                       // class UnorderedMapKeyConfiguration
                       //-----------------------------------

// CLASS METHODS
template &lt;class VALUE_TYPE&gt;
inline
const typename UnorderedMapKeyConfiguration&lt;VALUE_TYPE&gt;::KeyType&amp;
UnorderedMapKeyConfiguration&lt;VALUE_TYPE&gt;::extractKey(const VALUE_TYPE&amp; obj)
{
    return obj.first;
}

}  // close namespace bslalg

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
