<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlc::HashTable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlc.html">bdlc</a>      </li>
      <li><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlc::HashTable&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlc::HashTable" -->
<p><code>#include &lt;<a class="el" href="bdlc__hashtable_8h_source.html">bdlc_hashtable.h</a>&gt;</code></p>

<p><a href="classbdlc_1_1HashTable-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#a9554bbac8a8c4b9987662811b478bdeb">BSLALG_DECLARE_NESTED_TRAITS</a> (<a class="el" href="classbdlc_1_1HashTable.html">HashTable</a>, <a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#acc2bc00e0ad3ff358d905259dea39593">HashTable</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> capacityHint, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#ab39b615680b6762e970603e041a56dac">HashTable</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> capacityHint, const HASH1 &amp;hashFunctor1, const HASH2 &amp;hashFunctor2, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#a3b4c13f73ef6d245065b69eec54840dc">~HashTable</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#a3efe2232f77bc0a5efa779980a2b32b7">insert</a> (<a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> *handle, const KEY &amp;key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#ad3ff8273a5c5fa60dc6539745f1899b1">insert</a> (<a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> *handle, const KEY &amp;key, const VALUE &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#adc508a418856d1fa0a6bc412cefdda8d">remove</a> (const <a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> &amp;handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#ac14b1ff42480d4bd8de6b6d3fd1b1c4b">value</a> (const <a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> &amp;handle)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#a57be18cf1bbe1fb4a0f04f4aebdda478">capacity</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#af36122cd777922594f32cf3398532846">capacityHint</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#aeed3e790d805ca969bcfa623682a9277">find</a> (<a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> *handle, const KEY &amp;key) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const KEY &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#a2eb0d8273cd56fa07668d7a51a82b43e">key</a> (const <a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> &amp;handle) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#ad4ac1af312fbafe8d07163a860fb128f">maxChain</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#aa6cc3bac22fc0dc1f0722657209e4f85">numCollisions</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#a99023aa3d0ed9f7009e67a490934e149">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#a7f3552bd54b57a29dbf20969ab9ed601">totalChain</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlc_1_1HashTable.html#a744792499211e6010e711a024c33c0d3">value</a> (const <a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> &amp;handle) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class KEY, class VALUE = bslmf::Nil, class TRAITS = HashTableDefaultTraits, class HASH1 = HashTableDefaultHash1, class HASH2 = HashTableDefaultHash2&gt;<br/>
 class bdlc::HashTable&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;</h3>

<p>This class is a double-hashed table. The <code>VALUE</code> template parameter is optional. The <code>capacityHint</code> specified at construction time will be used to compute the number of buckets (capacity) in this object. Also, two hash functions may optionally be specified at construction time. Elements can be inserted using the <code>insert</code> method. If the <code>VALUE</code> parameter is not <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>, then both key and value must be supplied to the <code>insert</code> method. Otherwise, only the key should be supplied. The <code>find</code> method can be used to lookup elements by a specified key. The optional <code>TRAITS</code> parameter can be used to classify "null" and "removed" values. See the component-level documentation for more details. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="abb73b231c2360c12be3a7c15466ab8a1"></a><!-- doxytag: member="bdlc::HashTable::Handle" ref="abb73b231c2360c12be3a7c15466ab8a1" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::<a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="acc2bc00e0ad3ff358d905259dea39593"></a><!-- doxytag: member="bdlc::HashTable::HashTable" ref="acc2bc00e0ad3ff358d905259dea39593" args="(bsls::Types::Int64 capacityHint, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::<a class="el" href="classbdlc_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>capacityHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a double-hash table using the specified <code>capacityHint</code>. Use the optionally specified <code>basicAllocator</code> to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 != capacityHint</code>. Note that <code>capacityHint</code> can be either a positive integer or a negative integer. If <code>capacityHint</code> is positive, then the capacity of the hash table will be the first available prime number larger than, or equal to, <code>capacityHint</code>. Otherwise, the capacity of the hash table will be the first available prime number smaller than, or equal to, <code>capacityHint</code>. Also note that <code>HASH1</code> will be used as the first hash function, and <code>HASH2</code> will be used as the second hash function. </p>

</div>
</div>
<a class="anchor" id="ab39b615680b6762e970603e041a56dac"></a><!-- doxytag: member="bdlc::HashTable::HashTable" ref="ab39b615680b6762e970603e041a56dac" args="(bsls::Types::Int64 capacityHint, const HASH1 &amp;hashFunctor1, const HASH2 &amp;hashFunctor2, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::<a class="el" href="classbdlc_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>capacityHint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HASH1 &amp;&nbsp;</td>
          <td class="paramname"> <em>hashFunctor1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const HASH2 &amp;&nbsp;</td>
          <td class="paramname"> <em>hashFunctor2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a double-hash table with the specified <code>capacityHint</code>. Use the specified <code>hashFunctor1</code> as the first hash function; use the specified <code>hashFunctor2</code> as the second hash function; use the optionally specified <code>basicAllocator</code> to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>0 != capacityHint</code>, and <code>hashFunction1</code> and <code>hashFunction2</code> are valid. Note that <code>capacityHint</code> can be either a positive integer or a negative integer. If <code>capacityHint</code> is positive, then the capacity of the hash table will be the first available prime number larger than, or equal to, <code>capacityHint</code>. Otherwise, the capacity of the hash table will be the first available prime number smaller than, or equal to, <code>capacityHint</code>. </p>

</div>
</div>
<a class="anchor" id="a3b4c13f73ef6d245065b69eec54840dc"></a><!-- doxytag: member="bdlc::HashTable::~HashTable" ref="a3b4c13f73ef6d245065b69eec54840dc" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::~<a class="el" href="classbdlc_1_1HashTable.html">HashTable</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9554bbac8a8c4b9987662811b478bdeb"></a><!-- doxytag: member="bdlc::HashTable::BSLALG_DECLARE_NESTED_TRAITS" ref="a9554bbac8a8c4b9987662811b478bdeb" args="(HashTable, bslalg::TypeTraitUsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::BSLALG_DECLARE_NESTED_TRAITS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlc_1_1HashTable.html">HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1TypeTraitUsesBslmaAllocator.html">bslalg::TypeTraitUsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3efe2232f77bc0a5efa779980a2b32b7"></a><!-- doxytag: member="bdlc::HashTable::insert" ref="a3efe2232f77bc0a5efa779980a2b32b7" args="(Handle *handle, const KEY &amp;key)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert an element with the specified <code>key</code> into this object; load a handle to the new element into the specified <code>handle</code>. Return true if successful, and false otherwise. The behavior is undefined unless <code>key</code> does not evaluate to a "null" or "removed" bucket, as defined by the parameterized <code>TRAITS</code> (see the component-level documentation for more details). Note that this method will fail to compile unless the <code>VALUE</code> parameter is <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>. </p>

</div>
</div>
<a class="anchor" id="ad3ff8273a5c5fa60dc6539745f1899b1"></a><!-- doxytag: member="bdlc::HashTable::insert" ref="ad3ff8273a5c5fa60dc6539745f1899b1" args="(Handle *handle, const KEY &amp;key, const VALUE &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VALUE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert an element with the specified <code>key</code> and the specified <code>value</code> into this object; load a handle to the new element into the specified <code>handle</code>. Return true if successful, and false otherwise. The behavior is undefined unless <code>key</code> and <code>value</code> do not evaluate to a "null" or "removed" bucket, as defined by the parameterized <code>TRAITS</code> (see the component-level documentation for more details). This method will fail to compile unless the <code>VALUE</code> parameter is not <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>. </p>

</div>
</div>
<a class="anchor" id="adc508a418856d1fa0a6bc412cefdda8d"></a><!-- doxytag: member="bdlc::HashTable::remove" ref="adc508a418856d1fa0a6bc412cefdda8d" args="(const Handle &amp;handle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the element identified by the specified <code>handle</code> from this object. The behavior is undefined unless <code>handle</code> is valid. Note that <code>handle</code> will become invalid when this method returns. </p>

</div>
</div>
<a class="anchor" id="ac14b1ff42480d4bd8de6b6d3fd1b1c4b"></a><!-- doxytag: member="bdlc::HashTable::value" ref="ac14b1ff42480d4bd8de6b6d3fd1b1c4b" args="(const Handle &amp;handle)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VALUE&amp; <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the reference to the modifiable value of the element identified by the specified <code>handle</code>. The behavior is undefined unless <code>handle</code> is valid. Note that this method will fail to compile unless the <code>VALUE</code> parameter is not <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>. </p>

</div>
</div>
<a class="anchor" id="a57be18cf1bbe1fb4a0f04f4aebdda478"></a><!-- doxytag: member="bdlc::HashTable::capacity" ref="a57be18cf1bbe1fb4a0f04f4aebdda478" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum number of elements that can be stored in this object. Note that this value is computed based on the capacity hint used upon construction. </p>

</div>
</div>
<a class="anchor" id="af36122cd777922594f32cf3398532846"></a><!-- doxytag: member="bdlc::HashTable::capacityHint" ref="af36122cd777922594f32cf3398532846" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::capacityHint </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the capacity hint that was used to determine the capacity of this object. </p>

</div>
</div>
<a class="anchor" id="aeed3e790d805ca969bcfa623682a9277"></a><!-- doxytag: member="bdlc::HashTable::find" ref="aeed3e790d805ca969bcfa623682a9277" args="(Handle *handle, const KEY &amp;key) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KEY &amp;&nbsp;</td>
          <td class="paramname"> <em>key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Find an element having the specified <code>key</code>; load a handle to the element into the specified <code>handle</code>. Return true if successful, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="a2eb0d8273cd56fa07668d7a51a82b43e"></a><!-- doxytag: member="bdlc::HashTable::key" ref="a2eb0d8273cd56fa07668d7a51a82b43e" args="(const Handle &amp;handle) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const KEY&amp; <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the reference to the non-modifiable key of the element identified by the specified <code>handle</code>. The behavior is undefined unless <code>handle</code> is valid. </p>

</div>
</div>
<a class="anchor" id="ad4ac1af312fbafe8d07163a860fb128f"></a><!-- doxytag: member="bdlc::HashTable::maxChain" ref="ad4ac1af312fbafe8d07163a860fb128f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::maxChain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum chain length encountered by this object. </p>

</div>
</div>
<a class="anchor" id="aa6cc3bac22fc0dc1f0722657209e4f85"></a><!-- doxytag: member="bdlc::HashTable::numCollisions" ref="aa6cc3bac22fc0dc1f0722657209e4f85" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::numCollisions </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of collisions encountered by this object. </p>

</div>
</div>
<a class="anchor" id="a99023aa3d0ed9f7009e67a490934e149"></a><!-- doxytag: member="bdlc::HashTable::size" ref="a99023aa3d0ed9f7009e67a490934e149" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements stored in this object. </p>

</div>
</div>
<a class="anchor" id="a7f3552bd54b57a29dbf20969ab9ed601"></a><!-- doxytag: member="bdlc::HashTable::totalChain" ref="a7f3552bd54b57a29dbf20969ab9ed601" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::totalChain </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total chain length encountered by this object. </p>

</div>
</div>
<a class="anchor" id="a744792499211e6010e711a024c33c0d3"></a><!-- doxytag: member="bdlc::HashTable::value" ref="a744792499211e6010e711a024c33c0d3" args="(const Handle &amp;handle) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class KEY , class VALUE  = bslmf::Nil, class TRAITS  = HashTableDefaultTraits, class HASH1  = HashTableDefaultHash1, class HASH2  = HashTableDefaultHash2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const VALUE&amp; <a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>&lt; KEY, VALUE, TRAITS, HASH1, HASH2 &gt;::value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbdlc_1_1HashTable.html#abb73b231c2360c12be3a7c15466ab8a1">Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>handle</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the reference to the non-modifiable value of the element identified by the specified <code>handle</code>. The behavior is undefined unless <code>handle</code> is valid. Note that this method will fail to compile unless the <code>VALUE</code> parameter is not <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlc__hashtable_8h_source.html">bdlc_hashtable.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
