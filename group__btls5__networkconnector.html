<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: btls5_networkconnector Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component btls5_networkconnector<br/>
<small>
[<a class="el" href="group__btls5.html">Package btls5</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mechanism to connect through SOCKS5 proxies.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebtls5.html">btls5</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslma.html">bslma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: Connect to a Server Through Two Proxy Levels</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mechanism to connect through SOCKS5 proxies. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbtls5_1_1NetworkConnector.html">btls5::NetworkConnector</a> </td><td>mechanism to connect via SOCKS5 hosts  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__btls5__negotiator.html" title="Provide a mechanism for SOCKS5 client-side handshake.">Component btls5_negotiator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism class, <code><a class="el" href="classbtls5_1_1NetworkConnector.html">btls5::NetworkConnector</a></code>, that establishes connections through proxy hosts using the SOCKS5 protocol. The connections are established asynchronously, with status reported to a client-supplied callback. Each connection attempt is identified by a <code>ConnectionAttemptHandle</code>, which can be used to start the attempt as well as cancel it. The client code should call <code>makeConnectionAttemptHandle</code>, which returns a <code>ConnectionAttemptHandle</code>, followed by <code>startConnectionAttempt</code> to initiate the connection attempt. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>After initiating the attempt the client can wait until the attempt is concluded and the callback is invoked, or cancel the attempt by calling <code>cancelConnectionAttempt</code>. Note that the callback may still be invoked after <code>cancelConnectionAttempt</code> is called. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that on MS Windows, <code><a class="el" href="structbtlso_1_1SocketImpUtil.html#ab899cc56fedaa558d3502e0351a8819f">btlso::SocketImpUtil::startup</a></code> must be called to initialize the socket environment before calling <code><a class="el" href="classbtls5_1_1NetworkConnector.html#ad6aa3bd1a5dda5d7eb876197b15e7fbb">btls5::NetworkConnector::startConnectionAttempt</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_connect_to_a_server_through_two_proxy_levels"></a> <a class="anchor" id="usage.example_1~3A_connect_to_a_server_through_two_proxy_levels"></a> <a class="anchor" id="description.usage.example_1~3A_connect_to_a_server_through_two_proxy_levels"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Connect to a Server Through Two Proxy Levels: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to connect to a server reachable through two levels of proxies: first through one of our corporate SOCKS5 servers, and then through one of the regional SOCKS5 servers. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define a callback function to process connection status, and if successful, perform useful work and finally deallocate the socket. After the work is done (or an error is reported) we signal the main thread with the status; this also signifies that we no longer need the stream factory passed to us: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> connectCb(
              <span class="keywordtype">int</span>                                             status,
              <a class="code" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket&lt; btlso::IPv4Address&gt;</a>       *socket,
              <a class="code" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory&lt;btlso::IPv4Address&gt;</a> *socketFactory,
              <span class="keyword">const</span> <a class="code" href="classbtls5_1_1DetailedStatus.html">btls5::DetailedStatus</a>&amp;                    detailedStatus,
              <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>                                   *stateLock,
              <a class="code" href="classbslmt_1_1Condition.html">bslmt::Condition</a>                               *stateChanged,
              <span class="keyword">volatile</span> <span class="keywordtype">int</span>                                   *state)
  {
      <span class="keywordflow">if</span> (0 == status) {
          <span class="comment">// Success: conduct I/O operations with &#39;socket&#39; ... and deallocate</span>

          socketFactory-&gt;<a class="code" href="classbtlso_1_1StreamSocketFactory.html#aa381703fd6fcd02a77cde8923260453e">deallocate</a>(socket);
      } <span class="keywordflow">else</span> {
          cout &lt;&lt; <span class="stringliteral">&quot;Connect failed &quot;</span> &lt;&lt; status &lt;&lt; <span class="stringliteral">&quot;: &quot;</span> &lt;&lt; detailedStatus
               &lt;&lt; endl;
      }
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> lock(stateLock);
      *state = status ? -1 : 1; <span class="comment">// 1 for success, -1 for failure</span>
      stateChanged-&gt;<a class="code" href="classbslmt_1_1Condition.html#a4a5eb7027abc969948ac9c61a00ee734">signal</a>();
  }
</pre></div><br/>
<br/>
 Then, we define the function that will set up the proxy network description and attempt to connect to a remote host. The first level of proxies should be reachable directly: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">int</span> connectThroughProxies(<span class="keyword">const</span> <a class="code" href="classbtlso_1_1Endpoint.html">btlso::Endpoint</a>&amp; corpProxy1,
                                   <span class="keyword">const</span> <a class="code" href="classbtlso_1_1Endpoint.html">btlso::Endpoint</a>&amp; corpProxy2)
  {
      <a class="code" href="classbtls5_1_1NetworkDescription.html">btls5::NetworkDescription</a> proxies;
      proxies.<a class="code" href="classbtls5_1_1NetworkDescription.html#a6cb93260d4b97e4ec2488783c7fed192">addProxy</a>(0, corpProxy1);
      proxies.<a class="code" href="classbtls5_1_1NetworkDescription.html#a6cb93260d4b97e4ec2488783c7fed192">addProxy</a>(0, corpProxy2);
</pre></div><br/>
<br/>
 Next, we add a level for regional proxies reachable from the corporate proxies. Note that <code>.tk</code> stands for Tokelau in the Pacific Ocean: <br/>
<br/>
<div class="fragment"><pre class="fragment">      proxies.<a class="code" href="classbtls5_1_1NetworkDescription.html#a6cb93260d4b97e4ec2488783c7fed192">addProxy</a>(1, <a class="code" href="classbtlso_1_1Endpoint.html">btlso::Endpoint</a>(<span class="stringliteral">&quot;proxy1.example.tk&quot;</span>, 1080));
      proxies.<a class="code" href="classbtls5_1_1NetworkDescription.html#a6cb93260d4b97e4ec2488783c7fed192">addProxy</a>(1, <a class="code" href="classbtlso_1_1Endpoint.html">btlso::Endpoint</a>(<span class="stringliteral">&quot;proxy2.example.tk&quot;</span>, 1080));
</pre></div><br/>
<br/>
 Then, we set the username and password, which will be used in case one of the proxies in the connection path requires that type of authentication: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbtls5_1_1Credentials.html">btls5::Credentials</a> credentials(<span class="stringliteral">&quot;John.smith&quot;</span>, <span class="stringliteral">&quot;pass1&quot;</span>);
      <a class="code" href="structbtls5_1_1NetworkDescriptionUtil.html#a165e9ef71fc7315e68ed23989d94303b">btls5::NetworkDescriptionUtil::setAllCredentials</a>(&amp;proxies,
                                                       credentials);
</pre></div><br/>
<br/>
 Now, we construct a <code><a class="el" href="classbtls5_1_1NetworkConnector.html">btls5::NetworkConnector</a></code> that will be used to connect to one or more destinations: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbtlso_1_1InetStreamSocketFactory.html">btlso::InetStreamSocketFactory&lt;btlso::IPv4Address&gt;</a> factory;
      <a class="code" href="classbtlmt_1_1TcpTimerEventManager.html">btlmt::TcpTimerEventManager</a> eventManager;
      eventManager.<a class="code" href="classbtlmt_1_1TcpTimerEventManager.html#af5aadadedc8858fc4f7594d66154c800">enable</a>();
      <a class="code" href="classbtls5_1_1NetworkConnector.html">btls5::NetworkConnector</a> connector(proxies, &amp;factory, &amp;eventManager);
</pre></div><br/>
<br/>
 Finally, we attempt to connect to the destination. Input, output, and eventual closing of the connection will be handled from <code>connectCb</code>, which will signal by changing <code>state</code>, with the access protected by a mutex and condition variable: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> proxyTimeout(5.0);
      <span class="keyword">const</span> <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> totalTimeout(30.0);
      <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>     stateLock;
      <a class="code" href="classbslmt_1_1Condition.html">bslmt::Condition</a> stateChanged;
      <span class="keyword">volatile</span> <span class="keywordtype">int</span>     state = 0; <span class="comment">// value &gt; 0 is success and &lt; 0 is error</span>
      <span class="keyword">using namespace </span>bdlf::PlaceHolders;
      <a class="code" href="classbsl_1_1shared__ptr.html">btls5::NetworkConnector::ConnectionAttemptHandle</a> attempt =
         connector.makeConnectionAttemptHandle(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                                                            connectCb,
                                                            <a class="code" href="namespacebdlf_1_1PlaceHolders.html#a15d6194465744f5f4a1c9f98ca44ebca">_1</a>, _2, _3, _4,
                                                            &amp;stateLock,
                                                            &amp;stateChanged,
                                                            &amp;state),
                                               proxyTimeout,
                                               totalTimeout,
                                               <a class="code" href="classbtlso_1_1Endpoint.html">btlso::Endpoint</a>(
                                                   <span class="stringliteral">&quot;destination.example.com&quot;</span>,
                                                   8194));
      connector.startConnectionAttempt(attempt);
      <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> lock(&amp;stateLock);
      <span class="keywordflow">while</span> (!state) {
          stateChanged.<a class="code" href="classbslmt_1_1Condition.html#a06716e9924b9e439f75495f4035572ff">wait</a>(&amp;stateLock);
      }
      <span class="keywordflow">return</span> state;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
