<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Struct bslalg::ArrayPrimitives_Imp</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslalg.html">bslalg</a>      </li>
      <li><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html">bslalg::ArrayPrimitives_Imp</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslalg::ArrayPrimitives_Imp Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslalg::ArrayPrimitives_Imp" -->
<p><code>#include &lt;<a class="el" href="bslalg__arrayprimitives_8h_source.html">bslalg_arrayprimitives.h</a>&gt;</code></p>

<p><a href="structbslalg_1_1ArrayPrimitives__Imp-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <br/>
&nbsp;&nbsp;<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac0374b242b545f5ad166610ea016c31fadd0a27513b952faa72a5580477a6f27f">e_IS_ITERATOR_TO_FUNCTION_POINTER</a> =  6, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac0374b242b545f5ad166610ea016c31faee52d7e7bb114f7f79f19f3ddf79ffcc">e_IS_POINTER_TO_POINTER</a> =  5, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac0374b242b545f5ad166610ea016c31fada7a9ad5e5d26d868f6a70afcc14ef0d">e_IS_FUNDAMENTAL_OR_POINTER</a> =  4, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac0374b242b545f5ad166610ea016c31fa2a920d436e5b441d7663da75863450d3">e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac0374b242b545f5ad166610ea016c31fa94386f645130ef4be6ef153db6a43212">e_BITWISE_COPYABLE_TRAITS</a> =  2, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac0374b242b545f5ad166610ea016c31fa1e032ef439e56681a4c4588bef6f95bb">e_BITWISE_MOVEABLE_TRAITS</a> =  1, 
<a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac0374b242b545f5ad166610ea016c31fa47be6c16c995abea4b42ca4b7f12ea06">e_NIL_TRAITS</a> =  0
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a199421dc299938beb43f0e6a5d93ec76ac857bb68ed1443f754eeca31d5649ff4">k_INPLACE_BUFFER_SIZE</a> =  16 * bsls::AlignmentUtil::BSLS_MAX_ALIGNMENT
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">ArrayPrimitives::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structbslalg_1_1ArrayPrimitives.html#ac756e623500f4007bf4aac5ab654f487">ArrayPrimitives::difference_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8b51214119c3bc6ee5b5a7b89faf33e6">difference_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a4d63e544f8af2100c4b932b55a848eaf">bitwiseFillN</a> (char *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numBytesInitialized, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a03c62f25ac3b8f3b368712819f50bbcf">uninitializedFillN</a> (bool *begin, bool value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#adec60d318920092609c76d601ae79dc6">uninitializedFillN</a> (char *begin, char value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#af266e67774ff1d1c89df01dbb8118c98">uninitializedFillN</a> (unsigned char *begin, unsigned char value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ab7b3f14442a5877657377f0fe9e974d4">uninitializedFillN</a> (signed char *begin, signed char value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#af23d05910dd850f82414be04ed86bc4f">uninitializedFillN</a> (wchar_t *begin, wchar_t value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac4b0f0da4762e222b14b41bbf70b700b">uninitializedFillN</a> (short *begin, short value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a23469786042e0d20fb167426b9ed8add">uninitializedFillN</a> (unsigned short *begin, unsigned short value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a27d042c85bdb0076c4e3d6d216042af9">uninitializedFillN</a> (int *begin, int value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a9f4d768a7e2545a8fc7b32cdca5f2f35">uninitializedFillN</a> (unsigned int *begin, unsigned int value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aed4ff126de58808989dd6544387efd1c">uninitializedFillN</a> (long *begin, long value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa88b3d4517425578706653e9c91ef72e">uninitializedFillN</a> (unsigned long *begin, unsigned long value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aff2c2d4673a77d7447987e4f5540a7d3">uninitializedFillN</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *begin, <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ab4d93e0647185f557c08ad536cff79a7">uninitializedFillN</a> (<a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *begin, <a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a5077084438e6835f4ebbe91f048083b4">uninitializedFillN</a> (float *begin, float value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#adad605c4d7a605ff3922f77caadef2b8">uninitializedFillN</a> (double *begin, double value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8404457f4258ac2632bf443b2467b110">uninitializedFillN</a> (long double *begin, long double value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a1b52a7e1d5dcc115d76980dc1cea8c68">uninitializedFillN</a> (void **begin, void *value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a675ac70c91b5532bde5917de52c3f68d">uninitializedFillN</a> (const void **begin, const void *value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a032c0a27bce38daf5896b51f26716c0e">uninitializedFillN</a> (TARGET_TYPE **begin, TARGET_TYPE *value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ab77dc976caeca6a1b59b4ec35aa4de4d">uninitializedFillN</a> (const TARGET_TYPE **begin, const TARGET_TYPE *value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, void *=0, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a6b62a72a0c0b01a8ce2b9a13337f19b1">uninitializedFillN</a> (TARGET_TYPE *begin, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa8f6c304b69d42a3624659a2edf35ec0">uninitializedFillN</a> (TARGET_TYPE *begin, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#acfd7ceb935a75a2ad254c76edabf4b11">copyConstruct</a> (TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_POINTER_TO_POINTER &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a5931ba677b3fce413e776c018552c6cf">copyConstruct</a> (TARGET_TYPE *toBegin, const TARGET_TYPE *fromBegin, const TARGET_TYPE *fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a91b5d0afe84637f8237d003f8c29555e">copyConstruct</a> (TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a101cc9445b5095d921624b17600f6ba0">copyConstruct</a> (void **toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a16932c23bcdddfaed64f5346cc0ec7b7">copyConstruct</a> (TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a764f6bec1b4a863c9fcc8877350704ae">defaultConstruct</a> (TARGET_TYPE *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ac90c27f8506758b3a013b65bb190caad">defaultConstruct</a> (TARGET_TYPE *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ad19451853e18c853f751f178bb3b0bef">defaultConstruct</a> (TARGET_TYPE *begin, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ada0daab2e1c004f75dabda61ad27f298">destructiveMove</a> (TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aea1752b7424996096d32af939a0ff26f">destructiveMove</a> (TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR , class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ad40f5bc962d0c179849e5e18f1be7283">emplace</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *, Args &amp;&amp;...args)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR , class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a81c4a6f751c58fd0f1d940732cf19ace">emplace</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *, Args &amp;&amp;...args)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR , class... Args&gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a3028b52d484e85d81d5e19e852ee5586">emplace</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *, Args &amp;&amp;...args)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ad6338bad7a0f04bbf5ce6d362e5614a9">erase</a> (TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a65c3514ebd8660efefdd05e2ff3b102d">erase</a> (TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a5960c3173123aa7713cf333e581d0394">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a6a0f137cb13d976b3db86578dbc5ba82">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a4aa0445ab8ed7287b0ab1b7170232dd8">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aefbcccb52433f92ff67157d52445c51c">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_POINTER_TO_POINTER &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a23ffddc6b549acc810f5b7ad1bf31b2b">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE *fromBegin, const TARGET_TYPE *fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#ad7a722a92500754d68e409258068ee8b">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8f264026763bfa78c9741e34d97a58e1">insert</a> (void **toBegin, void **toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a69d589810a375fa3ba246c0042713897">insert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a46b66f47d3373fdf7c12287a19228fd9">moveInsert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **lastPtr, TARGET_TYPE *first, TARGET_TYPE *last, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8f0e74c670977196948a80b45b99c613">moveInsert</a> (TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **lastPtr, TARGET_TYPE *first, TARGET_TYPE *last, <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a> numElements, ALLOCATOR *allocator, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a5a72aa6b88982a74a3deabf28d4bb86f">rotate</a> (TARGET_TYPE *begin, TARGET_TYPE *middle, TARGET_TYPE *end, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8d4b954c886bcf26a4558a0b8425b536">rotate</a> (TARGET_TYPE *begin, TARGET_TYPE *middle, TARGET_TYPE *end, <a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a2b40fb18c00545727b37647ffb26530a">bitwiseRotate</a> (char *begin, char *middle, char *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a2688725ce6ac6998762609895e76785a">bitwiseRotateBackward</a> (char *begin, char *middle, char *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8fb32a2c58d13ee43448d1296d98b35d">bitwiseRotateForward</a> (char *begin, char *middle, char *end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a56a7c164ad1a06dc1393727680df2062">bitwiseSwapRanges</a> (char *begin, char *middle, char *end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class FORWARD_ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aee46e724062e785d68b04c901e37b420">isInvalidRange</a> (FORWARD_ITERATOR begin, FORWARD_ITERATOR end)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TARGET_TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a302ae10bbbda71b91c986ea83e31bd1b">isInvalidRange</a> (TARGET_TYPE *begin, TARGET_TYPE *end)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of independent utility functions that operate on arrays of elements of a parameterized <code>TARGET_TYPE</code>. These utility functions are only for the purpose of implementing those in the <code><a class="el" href="structbslalg_1_1ArrayPrimitives.html">ArrayPrimitives</a></code> utility. For brevity, we do not repeat the main contracts here, but instead refer to the corresponding contract in the <code>ArrayPrimitive</code> utility. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="aa3d2e68766698f07a79e998b29f2d1e7"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::size_type" ref="aa3d2e68766698f07a79e998b29f2d1e7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbslalg_1_1ArrayPrimitives.html#aee073b37feb7e3e840fa4c1a8bfa94be">ArrayPrimitives::size_type</a> <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">bslalg::ArrayPrimitives_Imp::size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b51214119c3bc6ee5b5a7b89faf33e6"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::difference_type" ref="a8b51214119c3bc6ee5b5a7b89faf33e6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbslalg_1_1ArrayPrimitives.html#ac756e623500f4007bf4aac5ab654f487">ArrayPrimitives::difference_type</a> <a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#a8b51214119c3bc6ee5b5a7b89faf33e6">bslalg::ArrayPrimitives_Imp::difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ac0374b242b545f5ad166610ea016c31f"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::@8" ref="ac0374b242b545f5ad166610ea016c31f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These constants are used in the overloads below, when the last argument is of type <code><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt;N&gt; *</code>, indicating that <code>TARGET_TYPE</code> has the traits for which the enumerator equal to <code>N</code> is named. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac0374b242b545f5ad166610ea016c31fadd0a27513b952faa72a5580477a6f27f"></a><!-- doxytag: member="e_IS_ITERATOR_TO_FUNCTION_POINTER" ref="ac0374b242b545f5ad166610ea016c31fadd0a27513b952faa72a5580477a6f27f" args="" -->e_IS_ITERATOR_TO_FUNCTION_POINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac0374b242b545f5ad166610ea016c31faee52d7e7bb114f7f79f19f3ddf79ffcc"></a><!-- doxytag: member="e_IS_POINTER_TO_POINTER" ref="ac0374b242b545f5ad166610ea016c31faee52d7e7bb114f7f79f19f3ddf79ffcc" args="" -->e_IS_POINTER_TO_POINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac0374b242b545f5ad166610ea016c31fada7a9ad5e5d26d868f6a70afcc14ef0d"></a><!-- doxytag: member="e_IS_FUNDAMENTAL_OR_POINTER" ref="ac0374b242b545f5ad166610ea016c31fada7a9ad5e5d26d868f6a70afcc14ef0d" args="" -->e_IS_FUNDAMENTAL_OR_POINTER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac0374b242b545f5ad166610ea016c31fa2a920d436e5b441d7663da75863450d3"></a><!-- doxytag: member="e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS" ref="ac0374b242b545f5ad166610ea016c31fa2a920d436e5b441d7663da75863450d3" args="" -->e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac0374b242b545f5ad166610ea016c31fa94386f645130ef4be6ef153db6a43212"></a><!-- doxytag: member="e_BITWISE_COPYABLE_TRAITS" ref="ac0374b242b545f5ad166610ea016c31fa94386f645130ef4be6ef153db6a43212" args="" -->e_BITWISE_COPYABLE_TRAITS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac0374b242b545f5ad166610ea016c31fa1e032ef439e56681a4c4588bef6f95bb"></a><!-- doxytag: member="e_BITWISE_MOVEABLE_TRAITS" ref="ac0374b242b545f5ad166610ea016c31fa1e032ef439e56681a4c4588bef6f95bb" args="" -->e_BITWISE_MOVEABLE_TRAITS</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ac0374b242b545f5ad166610ea016c31fa47be6c16c995abea4b42ca4b7f12ea06"></a><!-- doxytag: member="e_NIL_TRAITS" ref="ac0374b242b545f5ad166610ea016c31fa47be6c16c995abea4b42ca4b7f12ea06" args="" -->e_NIL_TRAITS</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a199421dc299938beb43f0e6a5d93ec76"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::@9" ref="a199421dc299938beb43f0e6a5d93ec76" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Number of bytes for which a stack-allocated buffer can be comfortably obtained to optimize bitwise moves. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a199421dc299938beb43f0e6a5d93ec76ac857bb68ed1443f754eeca31d5649ff4"></a><!-- doxytag: member="k_INPLACE_BUFFER_SIZE" ref="a199421dc299938beb43f0e6a5d93ec76ac857bb68ed1443f754eeca31d5649ff4" args="" -->k_INPLACE_BUFFER_SIZE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a4d63e544f8af2100c4b932b55a848eaf"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseFillN" ref="a4d63e544f8af2100c4b932b55a848eaf" args="(char *begin, size_type numBytesInitialized, size_type numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseFillN </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numBytesInitialized</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fill the specified <code>numBytes</code> in the array starting at the specified <code>begin</code> address, as if by bit-wise copying the specified <code>numBytesInitialized</code> at every offset that is a multiple of <code>numBytesInitialized</code> within the output array. The behavior is undefined unless <code>numBytesInitialized &lt;= numBytes</code>. Note that <code>numBytes</code> usually is, but does not have to be, a multiple of <code>numBytesInitialized</code>. </p>

</div>
</div>
<a class="anchor" id="a03c62f25ac3b8f3b368712819f50bbcf"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a03c62f25ac3b8f3b368712819f50bbcf" args="(bool *begin, bool value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">bool *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adec60d318920092609c76d601ae79dc6"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="adec60d318920092609c76d601ae79dc6" args="(char *begin, char value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af266e67774ff1d1c89df01dbb8118c98"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="af266e67774ff1d1c89df01dbb8118c98" args="(unsigned char *begin, unsigned char value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab7b3f14442a5877657377f0fe9e974d4"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="ab7b3f14442a5877657377f0fe9e974d4" args="(signed char *begin, signed char value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">signed char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed char&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af23d05910dd850f82414be04ed86bc4f"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="af23d05910dd850f82414be04ed86bc4f" args="(wchar_t *begin, wchar_t value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac4b0f0da4762e222b14b41bbf70b700b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="ac4b0f0da4762e222b14b41bbf70b700b" args="(short *begin, short value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">short *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a23469786042e0d20fb167426b9ed8add"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a23469786042e0d20fb167426b9ed8add" args="(unsigned short *begin, unsigned short value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a27d042c85bdb0076c4e3d6d216042af9"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a27d042c85bdb0076c4e3d6d216042af9" args="(int *begin, int value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9f4d768a7e2545a8fc7b32cdca5f2f35"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a9f4d768a7e2545a8fc7b32cdca5f2f35" args="(unsigned int *begin, unsigned int value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aed4ff126de58808989dd6544387efd1c"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="aed4ff126de58808989dd6544387efd1c" args="(long *begin, long value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa88b3d4517425578706653e9c91ef72e"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="aa88b3d4517425578706653e9c91ef72e" args="(unsigned long *begin, unsigned long value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">unsigned long *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aff2c2d4673a77d7447987e4f5540a7d3"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="aff2c2d4673a77d7447987e4f5540a7d3" args="(bsls::Types::Int64 *begin, bsls::Types::Int64 value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab4d93e0647185f557c08ad536cff79a7"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="ab4d93e0647185f557c08ad536cff79a7" args="(bsls::Types::Uint64 *begin, bsls::Types::Uint64 value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a> *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#a62cdf73ffc20667bc9de36b07c9c25f0">bsls::Types::Uint64</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5077084438e6835f4ebbe91f048083b4"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a5077084438e6835f4ebbe91f048083b4" args="(float *begin, float value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">float *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adad605c4d7a605ff3922f77caadef2b8"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="adad605c4d7a605ff3922f77caadef2b8" args="(double *begin, double value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">double *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8404457f4258ac2632bf443b2467b110"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a8404457f4258ac2632bf443b2467b110" args="(long double *begin, long double value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">long double *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b52a7e1d5dcc115d76980dc1cea8c68"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a1b52a7e1d5dcc115d76980dc1cea8c68" args="(void **begin, void *value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a675ac70c91b5532bde5917de52c3f68d"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a675ac70c91b5532bde5917de52c3f68d" args="(const void **begin, const void *value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">const void **&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a032c0a27bce38daf5896b51f26716c0e"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a032c0a27bce38daf5896b51f26716c0e" args="(TARGET_TYPE **begin, TARGET_TYPE *value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab77dc976caeca6a1b59b4ec35aa4de4d"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="ab77dc976caeca6a1b59b4ec35aa4de4d" args="(const TARGET_TYPE **begin, const TARGET_TYPE *value, size_type numElements, void *=0, bslmf::MetaInt&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">const TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_FUNDAMENTAL_OR_POINTER &gt; *&nbsp;</td>
          <td class="paramname"> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6b62a72a0c0b01a8ce2b9a13337f19b1"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="a6b62a72a0c0b01a8ce2b9a13337f19b1" args="(TARGET_TYPE *begin, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa8f6c304b69d42a3624659a2edf35ec0"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::uninitializedFillN" ref="aa8f6c304b69d42a3624659a2edf35ec0" args="(TARGET_TYPE *begin, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::uninitializedFillN </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy the specified <code>value</code> of the parameterized <code>TARGET_TYPE</code> into every of the specified <code>numElements</code> in the array starting at the specified <code>begin</code> address. Pass the specified <code>allocator</code> to the copy constructor if appropriate. Note that if <code>TARGET_TYPE</code> is bit-wise copyable or is not based on <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code>, <code>allocator</code> is ignored. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="acfd7ceb935a75a2ad254c76edabf4b11"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::copyConstruct" ref="acfd7ceb935a75a2ad254c76edabf4b11" args="(TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_IS_POINTER_TO_POINTER &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_POINTER_TO_POINTER &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a5931ba677b3fce413e776c018552c6cf"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::copyConstruct" ref="a5931ba677b3fce413e776c018552c6cf" args="(TARGET_TYPE *toBegin, const TARGET_TYPE *fromBegin, const TARGET_TYPE *fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a91b5d0afe84637f8237d003f8c29555e"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::copyConstruct" ref="a91b5d0afe84637f8237d003f8c29555e" args="(TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a101cc9445b5095d921624b17600f6ba0"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::copyConstruct" ref="a101cc9445b5095d921624b17600f6ba0" args="(void **toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a16932c23bcdddfaed64f5346cc0ec7b7"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::copyConstruct" ref="a16932c23bcdddfaed64f5346cc0ec7b7" args="(TARGET_TYPE *toBegin, FWD_ITER fromBegin, FWD_ITER fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::copyConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>copyConstruct</code> contract. If the (template parameter) <code>ALLOCATOR</code> type is based on <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> and the <code>TARGET_TYPE</code> constructors take an allocator argument, then pass the specified <code>allocator</code> to the copy constructor. The behavior is undefined unless the output array has length at least the distance from the specified <code>fromBegin</code> to the specified <code>fromEnd</code>. Note that if <code>FWD_ITER</code> is the <code>TARGET_TYPE *</code> pointer type and <code>TARGET_TYPE</code> is bit-wise copyable, then this operation is simply <code>memcpy</code>. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="a764f6bec1b4a863c9fcc8877350704ae"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::defaultConstruct" ref="a764f6bec1b4a863c9fcc8877350704ae" args="(TARGET_TYPE *begin, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::defaultConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_HAS_TRIVIAL_DEFAULT_CTOR_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac90c27f8506758b3a013b65bb190caad"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::defaultConstruct" ref="ac90c27f8506758b3a013b65bb190caad" args="(TARGET_TYPE *begin, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::defaultConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad19451853e18c853f751f178bb3b0bef"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::defaultConstruct" ref="ad19451853e18c853f751f178bb3b0bef" args="(TARGET_TYPE *begin, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::defaultConstruct </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Use the default constructor of the (template parameter) <code>TARGET_TYPE</code> (or <code>memset</code> to 0 if <code>TARGET_TYPE</code> has a trivial default constructor) on each element of the array starting at the specified <code>begin</code> address and ending immediately before the <code>end</code> address. Pass the specified <code>allocator</code> to the default constructor if appropriate. The last argument is for traits overloading resolution only and its value is ignored. </p>

</div>
</div>
<a class="anchor" id="ada0daab2e1c004f75dabda61ad27f298"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::destructiveMove" ref="ada0daab2e1c004f75dabda61ad27f298" args="(TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::destructiveMove </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aea1752b7424996096d32af939a0ff26f"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::destructiveMove" ref="aea1752b7424996096d32af939a0ff26f" args="(TARGET_TYPE *toBegin, TARGET_TYPE *fromBegin, TARGET_TYPE *fromEnd, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::destructiveMove </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>destructiveMove</code> contract. Note that both arrays cannot overlap (one contains only initialized elements and the other only uninitialized elements), and that if <code>TARGET_TYPE</code> is bit-wise moveable, then this operation is simply <code>memcpy</code>. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="ad40f5bc962d0c179849e5e18f1be7283"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::emplace" ref="ad40f5bc962d0c179849e5e18f1be7283" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_COPYABLE_TRAITS &gt; *, Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::emplace </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a81c4a6f751c58fd0f1d940732cf19ace"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::emplace" ref="a81c4a6f751c58fd0f1d940732cf19ace" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *, Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::emplace </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3028b52d484e85d81d5e19e852ee5586"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::emplace" ref="a3028b52d484e85d81d5e19e852ee5586" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *, Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR , class... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::emplace </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct <code>numElements</code> elements in-place using the specified <code>args</code> as the parameter passed to the constructor of the (template parameter) <code>TARGET_TYPE</code> into the array, starting at the <code>toBegin</code> address and ending immediately before the specified <code>toEnd</code> address, shifting the elements in the array by <code>numElements</code> positions towards larger addresses. Optionally specifiy an integral type to distinguish among various traits that the <code>TARGET_TYPE</code> has. The behavior is undefined unless the destination array contains at least <code>numElements</code> uninitialized elements after <code>toEnd</code>. If a copy constructor or assignment operator for <code>TARGET_TYPE</code> throws an exception, then any elements created after <code>toEnd</code> are destroyed and the elements in the range <code>[ toBegin, toEnd )</code> will have unspecified, but valid, values. </p>

</div>
</div>
<a class="anchor" id="ad6338bad7a0f04bbf5ce6d362e5614a9"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::erase" ref="ad6338bad7a0f04bbf5ce6d362e5614a9" args="(TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::erase </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a65c3514ebd8660efefdd05e2ff3b102d"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::erase" ref="a65c3514ebd8660efefdd05e2ff3b102d" args="(TARGET_TYPE *first, TARGET_TYPE *middle, TARGET_TYPE *last, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::erase </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>erase</code> contract. Note that if (template parameter) <code>TARGET_TYPE</code> is bit-wise moveable, then this operation can be implemented by first bit-wise moving the elements in <code>[middle, last)</code> towards first, and destroying <code>[ last - (middle - first), last)</code>; note that this cannot throw exceptions. </p>

</div>
</div>
<a class="anchor" id="a5960c3173123aa7713cf333e581d0394"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a5960c3173123aa7713cf333e581d0394" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6a0f137cb13d976b3db86578dbc5ba82"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a6a0f137cb13d976b3db86578dbc5ba82" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4aa0445ab8ed7287b0ab1b7170232dd8"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a4aa0445ab8ed7287b0ab1b7170232dd8" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE &amp;value, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>insert</code> contract. Note that if <code>TARGET_TYPE</code> is bit-wise copyable, then this operation is simply <code>memmove</code> followed by <code>bitwiseFillN</code>. If <code>TARGET_TYPE</code> is bit-wise moveable, then this operation can still be optimized using <code>memmove</code> followed by repeated assignments, but a guard needs to be set up. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="aefbcccb52433f92ff67157d52445c51c"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="aefbcccb52433f92ff67157d52445c51c" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_IS_POINTER_TO_POINTER &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_POINTER_TO_POINTER &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a23ffddc6b549acc810f5b7ad1bf31b2b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a23ffddc6b549acc810f5b7ad1bf31b2b" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, const TARGET_TYPE *fromBegin, const TARGET_TYPE *fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_COPYABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_COPYABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7a722a92500754d68e409258068ee8b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="ad7a722a92500754d68e409258068ee8b" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f264026763bfa78c9741e34d97a58e1"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a8f264026763bfa78c9741e34d97a58e1" args="(void **toBegin, void **toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_IS_ITERATOR_TO_FUNCTION_POINTER &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a69d589810a375fa3ba246c0042713897"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::insert" ref="a69d589810a375fa3ba246c0042713897" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, FWD_ITER fromBegin, FWD_ITER fromEnd, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class FWD_ITER , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::insert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FWD_ITER&nbsp;</td>
          <td class="paramname"> <em>fromEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>insert</code> contract. Note that if <code>TARGET_TYPE</code> is bit-wise copyable and <code>FWD_ITER</code> is convertible to <code>const TARGET_TYPE *</code>, then this operation is simply <code>memmove</code> followed by <code>memcopy</code>. If <code>TARGET_TYPE</code> is bit-wise moveable and <code>FWD_ITER</code> is convertible to <code>const TARGET_TYPE *</code>, then this operation can still be optimized using <code>memmove</code> followed by repeated copies. The last argument is for removing overload ambiguities and is not used. </p>

</div>
</div>
<a class="anchor" id="a46b66f47d3373fdf7c12287a19228fd9"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::moveInsert" ref="a46b66f47d3373fdf7c12287a19228fd9" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **lastPtr, TARGET_TYPE *first, TARGET_TYPE *last, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::moveInsert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>lastPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f0e74c670977196948a80b45b99c613"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::moveInsert" ref="a8f0e74c670977196948a80b45b99c613" args="(TARGET_TYPE *toBegin, TARGET_TYPE *toEnd, TARGET_TYPE **lastPtr, TARGET_TYPE *first, TARGET_TYPE *last, size_type numElements, ALLOCATOR *allocator, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::moveInsert </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toBegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>toEnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE **&nbsp;</td>
          <td class="paramname"> <em>lastPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslalg_1_1ArrayPrimitives__Imp.html#aa3d2e68766698f07a79e998b29f2d1e7">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ALLOCATOR *&nbsp;</td>
          <td class="paramname"> <em>allocator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>moveInsert</code> contract. Note that if <code>TARGET_TYPE</code> is at least bit-wise moveable, then this operation is simply <code>memmove</code> followed by <code>memcpy</code>. </p>

</div>
</div>
<a class="anchor" id="a5a72aa6b88982a74a3deabf28d4bb86f"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::rotate" ref="a5a72aa6b88982a74a3deabf28d4bb86f" args="(TARGET_TYPE *begin, TARGET_TYPE *middle, TARGET_TYPE *end, bslmf::MetaInt&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::rotate </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_BITWISE_MOVEABLE_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8d4b954c886bcf26a4558a0b8425b536"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::rotate" ref="a8d4b954c886bcf26a4558a0b8425b536" args="(TARGET_TYPE *begin, TARGET_TYPE *middle, TARGET_TYPE *end, bslmf::MetaInt&lt; e_NIL_TRAITS &gt; *)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::rotate </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslmf_1_1MetaInt.html">bslmf::MetaInt</a>&lt; e_NIL_TRAITS &gt; *&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>These functions follow the <code>rotate</code> contract, but the first overload is optimized when the parameterized <code>TARGET_TYPE</code> is bit-wise moveable. The last argument is for removing overload ambiguities and is not used. Note that if <code>TARGET_TYPE</code> is bit-wise moveable, the <code>rotate(char*, char*, char*)</code> can be used, enabling to take the whole implementation out-of-line. </p>

</div>
</div>
<a class="anchor" id="a2b40fb18c00545727b37647ffb26530a"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseRotate" ref="a2b40fb18c00545727b37647ffb26530a" args="(char *begin, char *middle, char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseRotate </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function follows the <code>rotate</code> contract, but by using bit-wise moves on the underlying <code>char</code> array. </p>

</div>
</div>
<a class="anchor" id="a2688725ce6ac6998762609895e76785a"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseRotateBackward" ref="a2688725ce6ac6998762609895e76785a" args="(char *begin, char *middle, char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseRotateBackward </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the characters in the array starting at the specified <code>first</code> address and ending immediately before the specified <code>middle</code> address to the array of the same length ending at the specified <code>last</code> address (and thus starting at the <code>last - (middle - first)</code> address), and move the elements previously in the array starting at <code>middle</code> and ending at <code>last</code> down to the <code>first</code> address. The behavior is undefined unless <code>middle - begin &lt;= k_INPLACE_BUFFER_SIZE</code>. </p>

</div>
</div>
<a class="anchor" id="a8fb32a2c58d13ee43448d1296d98b35d"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseRotateForward" ref="a8fb32a2c58d13ee43448d1296d98b35d" args="(char *begin, char *middle, char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseRotateForward </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move the characters in the array starting at the specified <code>first</code> address and ending immediately before the specified <code>middle</code> address to the array of the same length ending at the specified <code>last</code> address (and thus starting at the <code>last - (middle - first)</code> address), and move the elements previously in the array starting at <code>middle</code> and ending at <code>last</code> down to the <code>first</code> address. The behavior is undefined unless <code>end - middle &lt;= k_INPLACE_BUFFER_SIZE</code>. </p>

</div>
</div>
<a class="anchor" id="a56a7c164ad1a06dc1393727680df2062"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::bitwiseSwapRanges" ref="a56a7c164ad1a06dc1393727680df2062" args="(char *begin, char *middle, char *end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bslalg::ArrayPrimitives_Imp::bitwiseSwapRanges </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Swap the characters in the array starting at the specified <code>first</code> address and ending immediately before the specified <code>middle</code> address with the array of the same length starting at the <code>middle</code> address and ending at the specified <code>last</code> address. The behavior is undefined unless <code>middle - begin == end - middle</code>. </p>

</div>
</div>
<a class="anchor" id="aee46e724062e785d68b04c901e37b420"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::isInvalidRange" ref="aee46e724062e785d68b04c901e37b420" args="(FORWARD_ITERATOR begin, FORWARD_ITERATOR end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class FORWARD_ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::ArrayPrimitives_Imp::isInvalidRange </td>
          <td>(</td>
          <td class="paramtype">FORWARD_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FORWARD_ITERATOR&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a302ae10bbbda71b91c986ea83e31bd1b"></a><!-- doxytag: member="bslalg::ArrayPrimitives_Imp::isInvalidRange" ref="a302ae10bbbda71b91c986ea83e31bd1b" args="(TARGET_TYPE *begin, TARGET_TYPE *end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TARGET_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool bslalg::ArrayPrimitives_Imp::isInvalidRange </td>
          <td>(</td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TARGET_TYPE *&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>begin</code> and the specified <code>end</code> provably do not form a valid semi-open range, <code>[begin, end)</code>, and <code>false</code> otherwise. Note that <code>begin == null == end</code> produces a valid range, and any other use of the null pointer value will return <code>true</code>. Also note that this function is intended to support testing, primarily through assertions, so will return <code>true</code> unless it can <em>prove</em> that the passed range is invalid. Currently, this function can prove invalid ranges only for pointers, although should also encompass generic random access iterators in a future update, where iterator tag types are levelized below <code>bslalg</code>. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bslalg__arrayprimitives_8h_source.html">bslalg_arrayprimitives.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:33 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
