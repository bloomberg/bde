<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_exceptionguard.h                                             -*-C++-*-
#ifndef INCLUDED_BSLMA_EXCEPTIONGUARD
#define INCLUDED_BSLMA_EXCEPTIONGUARD

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a check that objects throwing exceptions do not change.
//
//@CLASSES:
//  bslma::ExceptionGuard: guard to check an object state has not changed
//
//@SEE_ALSO: bslma_testallocator
//
//@DESCRIPTION: This component provides a class that can be used to ASSERT if
// an object changes state when a method fails by throwing an exception.  This
// is often used to validate the strong exception safety guarantee in a test
// driver, usually with the test support macros provided by the component
// &#39;bslma_testallocator&#39;, such as &#39;BSLMA_TESTALLOCATOR_EXCEPTION_TEST_BEGIN&#39;.
// The object under test must be CopyConstructible, and support the extended
// copy constructor taking an allocator.  Note that this may be a generalised
// STL allocator, conforming to the Allocator requirements of the C++ standard,
// rather than just a &#39;bslma::Allocator&#39;.  This allows for testing standard
// library components such as those in &#39;bsl&#39;.
//
// As the constructor must make a copy of the object under test, this class
// should not be used in a test driver until after the extended copy
// constructor has been proven tested.  Similarly, the destructor asserts that
// the value has not changed using &#39;operator==&#39;, which should also be confirmed
// as correct before relying on this class in a test driver.  Finally, the
// &#39;resetvalue&#39; method should not be used prior to validating the copy-
// assignment operator.
//
///Usage
///-----
// TBD ...

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

class Allocator;

                            // ====================
                            // class ExceptionGuard
                            // ====================

template &lt;class OBJECT&gt;
class ExceptionGuard {
    // This class provide a mechanism to verify the strong exception guarantee
    // in exception-throwing code.  On construction, this class stores the
    // a copy of an object of the parameterized type &#39;OBJECT&#39; and the address
    // of that object.  On destruction, if &#39;release&#39; was not invoked, it will
    // verify the value of the object is the same as the value of the copy
    // create on construction.  This class requires the copy constructor and
    // &#39;operator ==&#39; to be tested before use.

    // DATA
    int           d_line;      // the line number at construction
    OBJECT        d_copy;      // copy of the object being tested
    const OBJECT *d_object_p;  // address of the original object

  public:
    // CREATORS
    ExceptionGuard(const OBJECT *object,
                   int           line,
                   Allocator    *basicAllocator = 0);
        // Create the exception guard for the specified &#39;object&#39; at the
        // specified &#39;line&#39; number.  Optionally, specify &#39;basicAllocator&#39; used
        // to supply memory.

    template &lt;class ALLOCATOR&gt;
    ExceptionGuard(const OBJECT     *object,
                   int               line,
                   const ALLOCATOR&amp;  basicAllocator);
        // Create the exception guard for the specified &#39;object&#39; at the
        // specified &#39;line&#39; number.  Optionally, specify &#39;basicAllocator&#39; used
        // to supply memory.

    ~ExceptionGuard();
        // Destroy the exception guard.  If the guard was not released, verify
        // that the state of the object supplied at construction has not
        // change.

    // MANIPULATORS
    void release();
        // Release the guard from verifying the state of the object.

    void resetValue(const OBJECT&amp; value, int line);
        // Reset the expected state of the guarded object, if an exception
        // should propagate past this guard, to the specified &#39;value&#39;, which is
        // set from the specified &#39;line&#39;.
};

// ============================================================================
//                      TEMPLATE FUNCTION DEFINITIONS
// ============================================================================


                       // --------------------
                       // class ExceptionGuard
                       // --------------------

// CREATORS
template &lt;class OBJECT&gt;
inline
ExceptionGuard&lt;OBJECT&gt;::ExceptionGuard(const OBJECT *object,
                                       int           line,
                                       Allocator    *basicAllocator)
: d_line(line)
, d_copy(*object, basicAllocator)
, d_object_p(object)
{
}

template &lt;class OBJECT&gt;
template &lt;class ALLOCATOR&gt;
inline
ExceptionGuard&lt;OBJECT&gt;::ExceptionGuard(const OBJECT     *object,
                                       int               line,
                                       const ALLOCATOR&amp;  basicAllocator)
: d_line(line)
, d_copy(*object, basicAllocator)
, d_object_p(object)
{
}

template &lt;class OBJECT&gt;
ExceptionGuard&lt;OBJECT&gt;::~ExceptionGuard()
{
    if (d_object_p) {
        // This test is tricky, as it is typically triggered while an exception
        // is active, and so should not have an assert handler that in turn
        // throws an exception.  Note that as this assertion is the whole
        // purpose of the class, we use &#39;BSLS_ASSERT_OPT&#39; so that it is active
        // in most build modes.
        BSLS_ASSERT_OPT(d_copy == *d_object_p);
    }
}

// MANIPULATORS
template &lt;class OBJECT&gt;
inline
void ExceptionGuard&lt;OBJECT&gt;::release()
{
    d_object_p = 0;
}

template &lt;class OBJECT&gt;
inline
void ExceptionGuard&lt;OBJECT&gt;::resetValue(const OBJECT&amp; value, int line)
{
    d_copy = value;
    d_line = line;
}

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
