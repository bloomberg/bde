<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_atomicoperations Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_atomicoperations<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide platform-independent atomic operations.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Memory Order and Consistency Guarantees of Atomic Operations</a> <ul>
<li>
<a href="#3.1.1">Acquire and Release Memory Consistency Guarantees</a> </li>
<li>
<a href="#3.1.2">Sequential Consistency Memory Consistency Guarantee</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Atomic Integer Operations</a> </li>
<li>
<a href="#3.3">Atomic Pointer Operations</a> </li>
<li>
<a href="#3.4">Usage</a> <ul>
<li>
<a href="#3.4.1">Example 1: Usage Statistics on a Thread Pool</a> </li>
<li>
<a href="#3.4.2">Example 2: Thread-safe Counted Handle</a> <ul>
<li>
<a href="#3.4.2.1">Class <code>my_CountedHandleRep</code></a> </li>
<li>
<a href="#3.4.2.2">Class <code>my_CountedHandle</code></a> </li>
<li>
<a href="#3.4.2.3">Function Definitions for <code>my_CountedHandleRep</code></a> </li>
<li>
<a href="#3.4.2.4">Function Definitions for <code>my_CountedHandle</code></a> </li>
</ul>
</li>
<li>
<a href="#3.4.3">Example 3: Thread-Safe Lock-Free Singly-Linked List</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide platform-independent atomic operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="structbsls_1_1AtomicOperations.html">bsls::AtomicOperations</a> </td><td>namespace for atomic operations  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This utility provides a set of platform-independent atomic operations for fundamental data types, such as 32-bit and 64-bit integer and pointer. The examples of provided atomic operations include loading, storing, exchanging, incrementing and decrementing the data of fundamental types. Atomic operations are useful for manipulating certain types of shared data without the need for high level synchronization mechanisms (e.g., "mutexes" or "critical sections"). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Integer atomic operations allow for thread-safe manipulation of a single 32 or 64-bit integer value, without the use of other synchronization mechanisms. Even the most basic operations on data that is shared among multiple threads must use some form of synchronization to ensure proper results. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Consider the prefix increment from the following snippet of C code: <br/>
<br/>
<div class="fragment"><pre class="fragment">    <span class="keyword">static</span> <span class="keywordtype">int</span> x;
    ++x;
</pre></div><br/>
<br/>
 Although the increment statement looks very simple, it may result in several machine instructions. Depending on the architecture and compiler optimization options, the statement might result in the following pseudo machine instructions: <br/>
<br/>
<div class="fragment"><pre class="fragment">     LOAD <span class="charliteral">&#39;x&#39;</span> to <span class="keyword">register</span>
     ADD 1 to <span class="keyword">register</span>
     STORE <span class="keyword">register</span> to <span class="charliteral">&#39;x&#39;</span>
</pre></div><br/>
<br/>
 Consider the situation when the above statements were executed simultaneously by two threads. Thread A could load <code>x</code> to a register, and then be interrupted by the operating system. Thread B could then begin to execute, and complete all three instructions, loading, incrementing, and storing the variable <code>x</code>. When thread A resumes, it would increment the value that it loaded, and store the result. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Thus, it is possible that both threads load the same value of x to the register, add one, and store their individual but equal results, incorrectly incrementing <code>x</code> by only 1 instead of the correct value 2. One could correct this problem by using a high level synchronization mechanisms (e.g., "mutex"), but these mechanisms are generally very expensive for such a small fragment of code, and could result in a large number of unnecessary context switches, for instance, if the increment statement occurs within a loop. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Instead, an atomic operation (in this case, <code><a class="el" href="structbsls_1_1AtomicOperations.html#a51f23edd44c7c3a9968dba19eae5d0b3">bsls::AtomicOperations::incrementInt</a></code>) can be used to manipulate the value; use of this operation will ensure that, when executed simultaneously by multiple threads, the threads will increment the value serially, without interrupting one another. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Special data types are provided to represent these values. Atomic data types are generally the same as their corresponding primitive data types, and therefore typically do not incur any additional memory overhead. However, on some platforms, it may be necessary to use larger, more complex types to represent these values; therefore they must always be accessed or manipulated using their accessors or manipulators, respectively. Not doing so may result in incorrect results and/or non-portable code. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Atomic operations should not be used in situations where behavior is inherently thread safe and no synchronization is required; although they are typically much faster than using high-level synchronization mechanisms to accomplish the same results, atomic operations are typically more expensive (in both speed and code size) than their non-atomic equivalents. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_order_and_consistency_guarantees_of_atomic_operations"></a> <a class="anchor" id="description.memory_order_and_consistency_guarantees_of_atomic_operations"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Memory Order and Consistency Guarantees of Atomic Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Atomic operations provided by this component ensure various memory ordering consistency guarantees. Memory ordering guarantees of atomic operations are designed to ensure visibility and synchronization order of memory reads and writes between threads that perform atomic operations. The operations on objects of the provided classes ensure the most strict consistency guarantee, sequential consistency (described below), unless explicitly qualified with a less strict consistency guarantee (i.e., Acquire, Release, Acquire/Release or Relaxed). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component implements memory order and consistency guarantees as defined in the C++ 2011 Standard (sections: [intro.multithreaded], [atomics.order]). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following memory ordering guarantees are supported: <ul>
<li>
relaxed - the operation does not provide any memory consistency guarantee  </li>
<li>
release - the operation performs a release operation on the affected memory location, thus making preceding regular memory writes of the calling thread visible to other threads through the atomic variable to which it is applied (generally available for operations that write to a memory location).  </li>
<li>
acquire - the operation performs an acquire operation on the affected memory location, thus making regular memory writes in other threads released through the atomic variable to which it is applied visible to the current thread (generally available for operations that read from a memory location).  </li>
<li>
acquire/release - the operation has both acquire and release semantics (generally available for operations that both read and write a memory location).  </li>
<li>
sequential consistency - the operation has both acquire and release guarantees, and further guarantees that all sequentially consistent operations performed by the process will be observed to occur in a single global total order (regardless of the thread from which they are observed).  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="acquire_and_release_memory_consistency_guarantees"></a> <a class="anchor" id="memory_order_and_consistency_guarantees_of_atomic_operations.acquire_and_release_memory_consistency_guarantees"></a> <a class="anchor" id="description.memory_order_and_consistency_guarantees_of_atomic_operations.acquire_and_release_memory_consistency_guarantees"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Acquire and Release Memory Consistency Guarantees: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Operations providing acquire and release guarantees are essential to synchronizing the memory state between multiple threads. For example, consider two threads, A and B, that perform store and load operations to shared memory locations. Without any synchronization, store operations in thread A can be freely reordered with load operations in thread B, i.e, thread A can perform two store operations to two memory locations in a certain order and thread B can see those operations done in a different order due to such effects as: compiler or processor optimizations of store and load operations, and cache synchronization between processors and cores. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>However, stores in thread A can be ordered with loads in thread B using a combination of store-release and load-acquire operations. A store-release operations in thread A followed by a load-acquire operation in thread B to <em>the</em> <em>same</em> <em>memory</em> <em>location</em> guarantees that thread B sees all other stores done in thread A prior to the store-release operation. The store-release in thread A effectively synchronizes the memory state with the load-acquire in thread A. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An acquire-release operation is a load-modify-store operation that, if performed in both threads A and B on the same memory location, synchronizes stores and loads between threads A and B in both directions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="sequential_consistency_memory_consistency_guarantee"></a> <a class="anchor" id="memory_order_and_consistency_guarantees_of_atomic_operations.sequential_consistency_memory_consistency_guarantee"></a> <a class="anchor" id="description.memory_order_and_consistency_guarantees_of_atomic_operations.sequential_consistency_memory_consistency_guarantee"></a> <a class="anchor" id="3.1.2"></a> </dd></dl>
<dl class="user"><dt><b>Sequential Consistency Memory Consistency Guarantee: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, load and store operations with sequential consistency are guaranteed to performed in a global total order among all threads in the process. To illustrate the total order, let's consider the so-called "independent reads of independent writes" example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> x(0);
  <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> y(0);
  <span class="keywordtype">int</span> r1, r2, r3, r4;

  <span class="keywordtype">void</span> thread1() {
      x = 1;  <span class="comment">// sequential consistency store</span>
  }

  <span class="keywordtype">void</span> thread2() {
      y = 1;  <span class="comment">// sequential consistency store</span>
  }

  <span class="keywordtype">void</span> thread3() {
      r1 = x;  <span class="comment">// sequential consistency load</span>
      r2 = y;  <span class="comment">// sequential consistency load</span>
  }

  <span class="keywordtype">void</span> thread4() {
      r3 = y;  <span class="comment">// sequential consistency load</span>
      r4 = x;  <span class="comment">// sequential consistency load</span>
  }
</pre></div><br/>
<br/>
 Where <code>threadN</code> functions are executed concurrently by different threads (note that values <code>x</code> and <code>y</code> are written by independent threads). Sequential consistency guarantees that if <code>thread3</code> observes values <code>x</code> and <code>y</code> as <code>r1 == 1 &amp;&amp; r2 == 0</code>, then <code>thread4</code> can't observe values <code>x</code> and <code>y</code> in a different order, i.e., <code>r3 == 1 &amp;&amp; r4 == 0</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="atomic_integer_operations"></a> <a class="anchor" id="description.atomic_integer_operations"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Atomic Integer Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The atomic integer operations provide thread-safe access for 32 or 64-bit signed integer numbers without the use of higher level synchronization mechanisms. Atomic integers are most commonly used to manipulate shared counters and indices. Five types of operations are provided; get/set, increment/decrement, add, swap, and test and swap. Two sub-types of manipulators are provided for increment/decrement and addition operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="structbsls_1_1AtomicOperations.html">bsls::AtomicOperations</a></code> functions whose names end in "Nv" (stands for "new
 value"; e.g., <code>addIntNv</code>, <code>incrementInt64Nv</code>) return the resulting value of the operations; those without the suffix do not return a value. If an application does not require the resulting value of an operation, it should not use the "Nv" manipulator. On some platforms, it may be less efficient to determine the resulting value of an operation than to simply perform the operation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="atomic_pointer_operations"></a> <a class="anchor" id="description.atomic_pointer_operations"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Atomic Pointer Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The atomic pointer operations provide thread-safe access to pointer values without the use of higher level synchronization mechanisms. They are commonly used to create fast thread safe singly-linked lists. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Usage Statistics on a Thread Pool: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates a common use of atomic integer types for statistics counters. The program creates a series of threads to process transactions. As each thread completes a transaction, it atomically increments the transaction counters. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For this example, we assume the existence of the functions <code>processNextTransaction</code>, <code>createWorkerThread</code>, and <code>waitAllThreads</code>. The function <code>createWorkerThread</code> spawns a new thread, which executes the <code>workerThread</code> function. <code>waitAllThreads</code> blocks until all the worker thread complete. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we declare the shared counters: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">static</span> bsls::AtomicOperations::AtomicTypes::Int64 transactionCount;
 <span class="keyword">static</span> bsls::AtomicOperations::AtomicTypes::Int64 successCount;
 <span class="keyword">static</span> bsls::AtomicOperations::AtomicTypes::Int64 failureCount;
</pre></div><br/>
<br/>
 Next, for each transaction processed, we atomically increment either the success or the failure counter as well as the total transaction count: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">void</span> workerThread(<span class="keywordtype">int</span> *stop)
  {
      <span class="keywordflow">while</span> (!(*stop)) {
          <span class="keywordflow">if</span> (processNextTransaction()) {
              <a class="code" href="structbsls_1_1AtomicOperations.html#ac15a1fbc60d4493294cadfa58a5bf227">bsls::AtomicOperations::incrementInt64</a>(&amp;failureCount);
          }
          <span class="keywordflow">else</span> {
              <a class="code" href="structbsls_1_1AtomicOperations.html#ac15a1fbc60d4493294cadfa58a5bf227">bsls::AtomicOperations::incrementInt64</a>(&amp;successCount);
          }
          <a class="code" href="structbsls_1_1AtomicOperations.html#ac15a1fbc60d4493294cadfa58a5bf227">bsls::AtomicOperations::incrementInt64</a>(&amp;transactionCount);
      }
  }
</pre></div><br/>
<br/>
 Finally, we write function, <code>serverMain</code>, that provides the overall control logic for the server. This function spawns the threads and then waits for all work to be completed; when all of the threads have finished, this function returns normally: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> serverMain()
  {
      <span class="keyword">const</span> <span class="keywordtype">int</span> numThreads = 10;
</pre></div><br/>
<br/>
 Before any of the counters is used, they must be initialized. <code>initInt64</code> is called to initialize each value to 0: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="structbsls_1_1AtomicOperations.html#a69c4b3a276a4153de3c051a411541809">bsls::AtomicOperations::initInt64</a>(&amp;transactionCount, 0);
      <a class="code" href="structbsls_1_1AtomicOperations.html#a69c4b3a276a4153de3c051a411541809">bsls::AtomicOperations::initInt64</a>(&amp;successCount, 0);
      <a class="code" href="structbsls_1_1AtomicOperations.html#a69c4b3a276a4153de3c051a411541809">bsls::AtomicOperations::initInt64</a>(&amp;failureCount, 0);
</pre></div><br/>
<br/>
 Spawn the threads to process the transactions concurrently: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numThreads; ++i) {
          createWorkerThread();
      }
</pre></div><br/>
<br/>
 Wait for all the threads to complete: <br/>
<br/>
<div class="fragment"><pre class="fragment">      waitAllThreads();
  }
</pre></div><br/>
<br/>
 Note that functions <code>createWorkerThread</code> and <code>waitAllThreads</code> can be implemented using any thread-support package. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Thread-safe Counted Handle: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates the use of atomic integer operations to implement a thread-safe ref-counted handle similar to a shared pointer. Each handle (of type <code>my_CountedHandle</code>) maintains a pointer to a representation object, <code>my_CountedHandleRep</code>, which in turn, stores both a pointer to the managed object and a reference counter. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Both the handle class and the representation class are template classes with two template parameters. The template parameter, <code>INSTANCE</code>, represents the type of the "instance", or managed object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A representation object can be shared by several handle objects. When a handle object is assigned to a second handle object, the address of the representation is copied to the second handle, and the reference count on the representation is atomically incremented. When a handle releases its reference to the representation, it atomically decrements the reference count. If the resulting reference count becomes 0 (and there are no more references to the object), the handle deletes the representation object and the representation object, in turn, deletes the managed object (<code>INSTANCE</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="class_my_countedhandlerep"></a> <a class="anchor" id="example_2.class_my_countedhandlerep"></a> <a class="anchor" id="usage.example_2.class_my_countedhandlerep"></a> <a class="anchor" id="description.usage.example_2.class_my_countedhandlerep"></a> <a class="anchor" id="3.4.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Class my_CountedHandleRep: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define class <code>my_CountedHandleRep</code>. This class manages a single <code>INSTANCE</code> object on behalf of multiple "handle" objects; since different "handle" objects may be active in different threads, class <code>my_CountedHandleRep</code> must be (fully) thread-safe. Specifically, methods <code>increment</code> and <code>decrement</code> must work atomically. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that, this rep class is intended to be used only by class <code>my_CountedHandle</code>, and thus all methods of class <code>my_CountedHandleRep</code> are declared private, and <code>friend</code> status is granted to class <code>my_CountedHandle</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// =========================</span>
                          <span class="comment">// class my_CountedHandleRep</span>
                          <span class="comment">// =========================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">class </span>my_CountedHandle;

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">class </span>my_CountedHandleRep {

      <span class="comment">// DATA</span>
      bsls::AtomicOperations::AtomicTypes::Int
                           d_count;        <span class="comment">// number of active references</span>
      INSTANCE            *d_instance_p;   <span class="comment">// address of managed instance</span>

      <span class="comment">// FRIENDS</span>
      <span class="keyword">friend</span> <span class="keyword">class </span>my_CountedHandle&lt;INSTANCE&gt;;

    <span class="keyword">private</span>: <span class="comment">// not implemented</span>
      my_CountedHandleRep(<span class="keyword">const</span> my_CountedHandleRep&amp;);
      my_CountedHandleRep&amp; operator=(<span class="keyword">const</span> my_CountedHandleRep&amp;);

    <span class="keyword">public</span>:
      <span class="comment">// CLASS METHODS</span>
      <span class="keyword">static</span> <span class="keywordtype">void</span>
      deleteObject(my_CountedHandleRep&lt;INSTANCE&gt; *<span class="keywordtype">object</span>);

      <span class="comment">// CREATORS</span>
      my_CountedHandleRep(INSTANCE *instance);
      ~my_CountedHandleRep();

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> increment();
      <span class="keywordtype">int</span> decrement();
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="class_my_countedhandle"></a> <a class="anchor" id="example_2.class_my_countedhandle"></a> <a class="anchor" id="usage.example_2.class_my_countedhandle"></a> <a class="anchor" id="description.usage.example_2.class_my_countedhandle"></a> <a class="anchor" id="3.4.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Class my_CountedHandle: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Then, we create class <code>my_CountedHandle</code> that provides an individual handle to the shared, reference-counted object. Each <code>my_CountedHandle</code> object acts as a smart pointer, supplying an overloaded <code>operator-&gt;</code> that provides access to the underlying <code>INSTANCE</code> object via pointer semantics. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>my_CountedHandle</code> can also be copied freely; the copy constructor will use the <code>increment</code> method from <code>my_CountedHandleRep</code> to note the extra copy. Similarly, the destructor will call <code>my_CountedHandleRep::decrement</code> to note that there is one fewer handle the underlying <code>INSTANCE</code> has, and delete the "rep" object when its reference count is reduced to zero: <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ======================</span>
                          <span class="comment">// class my_CountedHandle</span>
                          <span class="comment">// ======================</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">class </span>my_CountedHandle {

      <span class="comment">// DATA</span>
      my_CountedHandleRep&lt;INSTANCE&gt; *d_rep_p;  <span class="comment">// shared rep.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_CountedHandle(INSTANCE *instance);

      my_CountedHandle(<span class="keyword">const</span> my_CountedHandle&lt;INSTANCE&gt;&amp; other);

      ~my_CountedHandle();

      <span class="comment">// ACCESSORS</span>
      INSTANCE *operator-&gt;() <span class="keyword">const</span>;
      <span class="keywordtype">int</span> numReferences() <span class="keyword">const</span>;
  };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="function_definitions_for_my_countedhandlerep"></a> <a class="anchor" id="example_2.function_definitions_for_my_countedhandlerep"></a> <a class="anchor" id="usage.example_2.function_definitions_for_my_countedhandlerep"></a> <a class="anchor" id="description.usage.example_2.function_definitions_for_my_countedhandlerep"></a> <a class="anchor" id="3.4.2.3"></a> </dd></dl>
<dl class="user"><dt><b>Function Definitions for my_CountedHandleRep: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we provide a definition for the <code>static</code> <code>deleteObject</code> method, which is called by the destructor for class <code>my_CountedHandle</code> for the last instance of <code>my_CountedHandle</code> using the given "rep" object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_CountedHandleRep&lt;INSTANCE&gt;::deleteObject(
                               my_CountedHandleRep&lt;INSTANCE&gt; *<span class="keywordtype">object</span>)
  {
      <span class="keyword">delete</span> object;
  }
</pre></div><br/>
<br/>
 Then, we write the constructor for the <code>my_CountedHandleRep&lt;INSTANCE&gt;</code> class. We initialize the atomic reference counter to one reference using <code><a class="el" href="structbsls_1_1AtomicOperations.html#a8eaf108e2401275703e30e8682d8d8b7">bsls::AtomicOperations::initInt</a></code>. This reflects the fact that this constructor will be called by a new instance of <code>my_CountedHandle</code>. That instance is our first and only handle when this constructor is called: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandleRep&lt;INSTANCE&gt;::
                          my_CountedHandleRep(INSTANCE        *instance)
  : d_instance_p(instance)
  {
      <a class="code" href="structbsls_1_1AtomicOperations.html#a8eaf108e2401275703e30e8682d8d8b7">bsls::AtomicOperations::initInt</a>(&amp;d_count, 1);
  }
</pre></div><br/>
<br/>
 Then, we define the destructor, which just deletes <code>my_CountedHandle</code> <code>d_instance_p</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandleRep&lt;INSTANCE&gt;::~my_CountedHandleRep()
  {
      <span class="keyword">delete</span> d_instance_p;
  }
</pre></div><br/>
<br/>
 Next, we define method <code>increment</code>, which atomically increments the number of references to this <code>my_CountedHandleRep</code>. Since our caller is not interested in the result (and our return type is thus <code>void</code>), we use <code>incrementInt</code> instead of <code>incrementIntNv</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> my_CountedHandleRep&lt;INSTANCE&gt;::increment()
  {
      <a class="code" href="structbsls_1_1AtomicOperations.html#a51f23edd44c7c3a9968dba19eae5d0b3">bsls::AtomicOperations::incrementInt</a>(&amp;d_count);
  }
</pre></div><br/>
<br/>
 Then, we implement method <code>decrement</code>, which atomically decrements the reference count; since our caller will need to check the resulting value to determine whether the <code>INSTANCE</code> should be deleted, we use <code>decrementIntNv</code> rather than <code>decrementInt</code>, and return the new number of references: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_CountedHandleRep&lt;INSTANCE&gt;::decrement()
  {
      <span class="keywordflow">return</span> <a class="code" href="structbsls_1_1AtomicOperations.html#afb5da6a33f36646c03c5ead2d108460f">bsls::AtomicOperations::decrementIntNv</a>(&amp;d_count);
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="function_definitions_for_my_countedhandle"></a> <a class="anchor" id="example_2.function_definitions_for_my_countedhandle"></a> <a class="anchor" id="usage.example_2.function_definitions_for_my_countedhandle"></a> <a class="anchor" id="description.usage.example_2.function_definitions_for_my_countedhandle"></a> <a class="anchor" id="3.4.2.4"></a> </dd></dl>
<dl class="user"><dt><b>Function Definitions for my_CountedHandle: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Next, we define the first constructor for <code>my_CountedHandle</code>, which is used when creating a handle for a new <code>INSTANCE</code>; note that the <code>INSTANCE</code> is constructed separately, and a pointer to that object is passed as the first argument (<code>object</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">                          <span class="comment">// ----------------------</span>
                          <span class="comment">// class my_CountedHandle</span>
                          <span class="comment">// ----------------------</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandle&lt;INSTANCE&gt;::my_CountedHandle(INSTANCE *instance)
  {
      d_rep_p = <span class="keyword">new</span> my_CountedHandleRep&lt;INSTANCE&gt;(instance);
  }
</pre></div><br/>
<br/>
 Then, we define the copy constructor; the new object copies the underlying <code>my_CountedHandleRep</code> and then increments its counter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandle&lt;INSTANCE&gt;::my_CountedHandle(
                                     <span class="keyword">const</span> my_CountedHandle&lt;INSTANCE&gt;&amp; other)
  : d_rep_p(other.d_rep_p)
  {
      <span class="keywordflow">if</span> (d_rep_p) {
          d_rep_p-&gt;increment();
      }
  }
</pre></div><br/>
<br/>
 Next, we define the destructor which decrements the "rep" object's reference count using the <code>decrement</code> method. The <code>decrement</code> method returns the object's reference count after the decrement is completed, and <code>my_CountedHandle</code> uses this value to determine whether the "rep" object should be deleted: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  my_CountedHandle&lt;INSTANCE&gt;::~my_CountedHandle()
  {
      <span class="keywordflow">if</span> (d_rep_p &amp;&amp; 0 == d_rep_p-&gt;decrement()) {
          my_CountedHandleRep&lt;INSTANCE&gt;::deleteObject(d_rep_p);
      }
  }
</pre></div><br/>
<br/>
 Now, we define member <code>operator-&gt;()</code>, which provides basic pointer semantics for <code>my_CountedHandle</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  INSTANCE *my_CountedHandle&lt;INSTANCE&gt;::operator-&gt;()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_rep_p-&gt;d_instance_p;
  }
</pre></div><br/>
<br/>
 Finally, we define method <code>numReferences</code>, which returns the value of the reference counter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> INSTANCE&gt;
  <span class="keyword">inline</span>
  <span class="keywordtype">int</span> my_CountedHandle&lt;INSTANCE&gt;::numReferences()<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <span class="keywordflow">return</span> d_rep_p ? <a class="code" href="structbsls_1_1AtomicOperations.html#ac81bd17e4c9ce322ee1639f0eda17415">bsls::AtomicOperations::getInt</a>(d_rep_p-&gt;d_count) : 0;
  }
</pre></div><br/>
<br/>
 Note that, while class <code>my_CountedHandleRep</code> is itself fully thread-safe, it does not guarantee thread safety for the <code>INSTANCE</code> object. In order to provide thread safety for the <code>INSTANCE</code> in the general case, the "rep" would need to use a more general concurrency mechanism such as a mutex. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Thread-Safe Lock-Free Singly-Linked List: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates the use of atomic pointers to implement a fast and thread-aware, yet fast single-linked list. The example class, <code>my_PtrStack</code>, is a templatized pointer stack, supporting <code>push</code> and <code>pop</code> methods. The class is implemented using a single-linked list. Nodes in the list are linked together using atomic operations. Instance of this structure are allocated using the provided allocator. When nodes are freed, they are cached on a free list. This free list is also implemented as a single-linked list, using atomic pointer operations. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create class template, <code>my_PtrStack</code>, parameterized by <code>TYPE</code>. Instances of this template maintain a list of nodes and a free-node list. Each node has a pointer to a data item, <code>d_item_p</code>, a link to the next node in the list, <code>d_next_p</code>. The definition of the <code>my_PtrStack</code> class is provided below: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>my_PtrStack {
      <span class="comment">// TYPES</span>
      <span class="keyword">struct </span>Node {
          TYPE *d_item_p;
          Node *d_next_p;
      };

      <span class="comment">// DATA</span>
      bsls::AtomicOperations::AtomicTypes::Pointer  d_list_p;
      bsls::AtomicOperations::AtomicTypes::Pointer  d_freeList_p;

      <span class="comment">// PRIVATE MANIPULATORS</span>
      Node *allocateNode();
      <span class="keywordtype">void</span> freeNode(Node *node);
      <span class="keywordtype">void</span> deleteNodes(Node *node);

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      my_PtrStack();
     ~my_PtrStack();

      <span class="comment">// MANIPULATORS</span>
      <span class="keywordtype">void</span> push(TYPE *item);
      TYPE *pop();
  };
</pre></div><br/>
<br/>
 Then, we write the constructor that initializes the pointers for the node list and the free list: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// CREATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> my_PtrStack&lt;TYPE&gt;::my_PtrStack()
  {
      <a class="code" href="structbsls_1_1AtomicOperations.html#a5f516afc24f0de04e928c68cb8e901db">bsls::AtomicOperations::initPointer</a>(&amp;d_freeList_p, 0);
      <a class="code" href="structbsls_1_1AtomicOperations.html#a5f516afc24f0de04e928c68cb8e901db">bsls::AtomicOperations::initPointer</a>(&amp;d_list_p, 0);
  }
</pre></div><br/>
<br/>
 Next, we define the <code>deleteNodes</code> and the destructor function to delete nodes that the <code>my_PtrStack</code> object owns. Note that we don't need to worry about the concurrent access to node lists in the destructor, as destructor can be executed in only a single thread: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> <span class="keywordtype">void</span> my_PtrStack&lt;TYPE&gt;::deleteNodes(Node *node)
  {
      <span class="keywordflow">while</span> (node) {
          Node *next = node-&gt;d_next_p;
          <span class="keyword">delete</span> node;
          node = next;
      }
  }

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> my_PtrStack&lt;TYPE&gt;::~my_PtrStack()
  {
      deleteNodes(
         (Node *) <a class="code" href="structbsls_1_1AtomicOperations.html#aaa69768e2e24b6668af4c946abab4113">bsls::AtomicOperations::getPtrRelaxed</a>(&amp;d_list_p));
      deleteNodes(
         (Node *) <a class="code" href="structbsls_1_1AtomicOperations.html#aaa69768e2e24b6668af4c946abab4113">bsls::AtomicOperations::getPtrRelaxed</a>(&amp;d_freeList_p));
  }
</pre></div><br/>
<br/>
 Then, we define method <code>allocateNode</code> to get a node from the free list in the thread-safe manner by leveraging atomic operations to ensure proper thread synchronization: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// PRIVATE MANIPULATORS</span>
  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> <span class="keyword">typename</span> my_PtrStack&lt;TYPE&gt;::Node *my_PtrStack&lt;TYPE&gt;::allocateNode()
  {
      Node *node;
</pre></div><br/>
<br/>
 To remove an item from this list, get the current list head using <code>getPtr</code>. Then, test and swap it with the next node. <code>testAndSwapPtr</code> compares <code>d_freeList_p</code> to <code>node</code>, replacing it with <code>node-&gt;d_next_p</code> only if it matches. If <code>d_freeList_p</code> did not match <code>node</code>, then the free list has been changed on another thread, between the calls to <code>getPtr</code> and <code>testAndSwapPtr</code>. If the list head has changed, then try again: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">do</span> {
          node = (Node*) <a class="code" href="structbsls_1_1AtomicOperations.html#a787df526b06976e2037524e3886e6852">bsls::AtomicOperations::getPtr</a>(&amp;d_freeList_p);
          <span class="keywordflow">if</span> (!node) <span class="keywordflow">break</span>;
      } <span class="keywordflow">while</span> (<a class="code" href="structbsls_1_1AtomicOperations.html#aea3a5972ba601e155eefc03a19f35cba">bsls::AtomicOperations::testAndSwapPtr</a>(
                                                    &amp;d_freeList_p,
                                                    node,
                                                    node-&gt;d_next_p) != node);
</pre></div><br/>
<br/>
 Next, we allocate a new node if there are no nodes in the free node list: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (!node) {
          node = <span class="keyword">new</span> Node();
      }
      <span class="keywordflow">return</span> node;
  }
</pre></div><br/>
<br/>
 Then, we provide the <code>freeNode</code> method to add a given <code>node</code> to the free list. To add the node to the list, we set the next pointer of the new node to the current value of the list head, and atomically test and swap the head of the list with the new node. If the list head has been changed (by another thread), we try again: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> <span class="keywordtype">void</span> my_PtrStack&lt;TYPE&gt;::freeNode(Node *node)
  {
      <span class="keywordflow">do</span> {
        node-&gt;d_next_p = (Node*) <a class="code" href="structbsls_1_1AtomicOperations.html#a787df526b06976e2037524e3886e6852">bsls::AtomicOperations::getPtr</a>(
                                                              &amp;d_freeList_p);
      } <span class="keywordflow">while</span> (<a class="code" href="structbsls_1_1AtomicOperations.html#aea3a5972ba601e155eefc03a19f35cba">bsls::AtomicOperations::testAndSwapPtr</a>(
                                                    &amp;d_freeList_p,
                                                    node-&gt;d_next_p,
                                                    node) != node-&gt;d_next_p);
  }
</pre></div><br/>
<br/>
 Now, we begin to define the public "stack-like" interface for <code>my_PtrStack</code>. Note that the <code>push</code> method is similar to <code>freeNode</code>, except that it assigns an item value and operates on <code>d_list_p</code>, which maintains the list of active nodes: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> <span class="keywordtype">void</span> my_PtrStack&lt;TYPE&gt;::push(TYPE *item)
  {
      Node *node = allocateNode();
      node-&gt;d_item_p = item;
      <span class="keywordflow">do</span> {
          node-&gt;d_next_p = (Node*) <a class="code" href="structbsls_1_1AtomicOperations.html#a787df526b06976e2037524e3886e6852">bsls::AtomicOperations::getPtr</a>(&amp;d_list_p);
      } <span class="keywordflow">while</span> (<a class="code" href="structbsls_1_1AtomicOperations.html#aea3a5972ba601e155eefc03a19f35cba">bsls::AtomicOperations::testAndSwapPtr</a>(
                                                    &amp;d_list_p,
                                                    node-&gt;d_next_p,
                                                    node)!= node-&gt;d_next_p);
  }
</pre></div><br/>
<br/>
 Finally, we define the <code>pop</code> method which removes the node from the top of active node list, <code>d_list_p</code>, adds it to the free-node list, and returns the data item contained in the node to the caller: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">inline</span> TYPE *my_PtrStack&lt;TYPE&gt;::pop()
  {
      Node *node;
      <span class="keywordflow">do</span> {
          node = (Node*) <a class="code" href="structbsls_1_1AtomicOperations.html#a787df526b06976e2037524e3886e6852">bsls::AtomicOperations::getPtr</a>(&amp;d_list_p);
          <span class="keywordflow">if</span> (!node) <span class="keywordflow">break</span>;
      } <span class="keywordflow">while</span> (<a class="code" href="structbsls_1_1AtomicOperations.html#aea3a5972ba601e155eefc03a19f35cba">bsls::AtomicOperations::testAndSwapPtr</a>(
                                                     &amp;d_freeList_p,
                                                     node,
                                                     node-&gt;d_next_p)!= node);
      TYPE *item = node ? node-&gt;d_item_p : 0;
      <span class="keywordflow">if</span> (node)
          freeNode(node);
      <span class="keywordflow">return</span> item;
  }
</pre></div><br/>
<br/>
 Notice that if the stack was empty, a NULL pointer is returned. </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
