<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlmt_multiprioritythreadpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlmt_multiprioritythreadpool<br/>
<small>
[<a class="el" href="group__bdlmt.html">Package bdlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mechanism to parallelize a prioritized sequence of jobs.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlmt.html">bdlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: The <code>void function</code>/<code>void pointer</code> Interface</a> </li>
<li>
<a href="#3.2.2">Example 2: The Functor-Based Interface</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mechanism to parallelize a prioritized sequence of jobs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlmt_1_1MultipriorityThreadPool.html">bdlmt::MultipriorityThreadPool</a> </td><td>mechanism to parallelize prioritized jobs  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmt__threadutil.html" title="Provide platform-independent utilities related to threading.">Component bslmt_threadutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines an implementation of a thread pool in which work items ("jobs") are associated with a limited number of integer priorities that determine the sequence in which enqueued jobs are executed. (See the package-level documentation for general information on thread pools.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This flavor of our generalized thread pool model associates an integral priority with each work item. For efficiency of implementation, these priorities are limited, as indicated at construction, to a relatively small number <code>N</code> of contiguous integers <code>[ 0 .. N - 1 ]</code>, 0 being the most urgent. For this implementation, the maximum number of priorities <code>N</code> is 32. A fixed number of worker threads is also specified at construction. Finally, this thread pool takes an optional allocator supplied at construction. Once configured, these instance parameters remain unchanged for the lifetime of each multi-priority thread pool object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The associated priority of a job is relevant only while that job is pending; once a job has begun executing, it will not be interrupted or suspended to make way for a another job regardless of their relative priorities. While processing jobs, worker threads will always choose a more urgent job (lower integer value for priority) over a less urgent one. Given two jobs having the same priority value, the one that has been in the thread pool's queue the longest is selected (FIFO order). Note that the number of active worker threads does not increase or decrease depending on load. If no jobs remain to be executed, surplus threads will block until work arrives. If there are more jobs than threads, excess jobs wait in the queue until previous jobs finish. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlmt_1_1MultipriorityThreadPool.html">bdlmt::MultipriorityThreadPool</a></code> provides two interfaces for specifying jobs: the traditional <code>void function</code>/<code>void pointer</code> interface and the more versatile functor-based interface. The <code>void function</code>/<code>void pointer</code> interface allows callers to use a C-style function to be executed as a job. The application need specify only the address of the function, and a single <code>void *</code> argument to be passed to the function. The specified function will be invoked with the specified argument by the processing (worker) thread. The functor-based interface allows for flexible job execution by copying the passed functor and executing its (invokable) <code>operator()</code> method. Note that the functor gets copied twice before it is executed, once when pushed into the queue, and once when popped out of it, something to keep in mind if the object is going to be expensive to copy. (See the <code>bdef</code> package-level documentation for more information on functors and their use.) </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that except in the case where <code>numThreads() == 1</code>, we cannot guarantee the exact order of the execution of the jobs in the queue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally an application can specify the attributes of the worker threads in a thread pool (e.g., guard size or stack size), by optionally supplying an appropriately configured <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a></code> object. (See the <code>bslmt_threadutil</code> component-level documentation for a description of the <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a></code> class.) Note that the field pertaining to whether the worker threads should be detached or joinable is ignored. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlmt_1_1MultipriorityThreadPool.html">bdlmt::MultipriorityThreadPool</a></code> class is both <em>fully thread-safe</em> (i.e., all non-creator methods can correctly execute concurrently), and is <em>thread-enabled</em> (i.e., the classes does not function correctly in a non-multi-threading environment). See <code>bsldoc_glossary</code> for complete definitions of <em>fully thread-safe</em> and <em>thread-enabled</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Be aware that the behavior is undefined if any of the following methods are called on a threadpool from any of the threads belonging to that thread pool. <ul>
<li>
<code>stopThreads</code>  </li>
<li>
<code>suspendProcessing</code>  </li>
<li>
<code>drainJobs</code>  </li>
</ul>
Note that, in these cases, such undefined behavior may include deadlock. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following two examples illustrate use of the multi-priority thread pool provided in this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_the_void_function~2Fvoid_pointer_interface"></a> <a class="anchor" id="usage.example_1~3A_the_void_function~2Fvoid_pointer_interface"></a> <a class="anchor" id="description.usage.example_1~3A_the_void_function~2Fvoid_pointer_interface"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: The void function/void pointer Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It is possible to enqueue a job to a multi-priority thread pool as a pointer to a function that takes a single <code>void *</code> argument. This first usage example will demonstrate that high-priority traffic through a thread pool is unimpeded by a much greater quantity of low-priority traffic. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The idea here is we have a large number of jobs submitted in too little time for all of them to be completed. All jobs take the same amount of time to complete, but there are two different priorities of jobs. There are 100 times more jobs of less urgent priority than of the more urgent priority, and there is more than enough time for the jobs of more urgent priority to be completed. We want to verify that all the jobs of more urgent priority get completed while most of the jobs of less urgent priority do not. This will demonstrate that we can construct an arrangement where traffic of low priority, while massively more numerous, does not impede the progress of higher-priority jobs: <br/>
<br/>
<div class="fragment"><pre class="fragment">   <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a>     urgentJobsDone;
   <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> lessUrgentJobsDone;

   <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *urgentJob(<span class="keywordtype">void</span> *)
   {
       <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(10000);          <span class="comment">// 10 mSec</span>

       ++urgentJobsDone;

       <span class="keywordflow">return</span> 0;
   }

   <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *lessUrgentJob(<span class="keywordtype">void</span> *)
   {
       <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(10000);          <span class="comment">// 10 mSec</span>

       ++lessUrgentJobsDone;

       <span class="keywordflow">return</span> 0;
   }
</pre></div><br/>
<br/>
 The main program (below) enqueues 100 times as many low-priority jobs as high priority ones. 10,100 jobs are submitted, each taking at least 0.01 seconds, for a total cpu time of 101 seconds. We use 20 threads, so that is about 5 seconds. But we shut down the run after only 0.5 seconds, so that means at least 90% of the jobs will not complete. When run, typical output of this program is: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Jobs done: urgent: 100, less urgent: 507
</pre></div><br/>
<br/>
 meaning <em>all</em> of the urgent jobs completed, while approximately 95% of the less urgent jobs did not: <br/>
<br/>
<div class="fragment"><pre class="fragment">       <a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html">bdlmt::MultipriorityThreadPool</a> pool(20,  <span class="comment">// # of threads</span>
                                         2);  <span class="comment">// # of priorities</span>

       <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> finishTime = <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() + 0.5;
       pool.startThreads();
</pre></div><br/>
<br/>
 We use 1 as our less urgent priority, leaving 0 as our urgent priority: <br/>
<br/>
<div class="fragment"><pre class="fragment">       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 100; ++i) {
           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 100; ++j) {
               pool.enqueueJob(&amp;lessUrgentJob, (<span class="keywordtype">void</span> *) 0, 1); <span class="comment">// less urgent</span>
           }
           pool.enqueueJob(&amp;urgentJob, (<span class="keywordtype">void</span> *) 0, 0);         <span class="comment">// urgent</span>
       }

       <a class="code" href="structbslmt_1_1ThreadUtil.html#a667b0f54d6c038c8ecb851ca66dc0529">bslmt::ThreadUtil::sleep</a>(finishTime - <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>());
       pool.shutdown();

       bsl::cout &lt;&lt; <span class="stringliteral">&quot;Jobs done: urgent: &quot;</span> &lt;&lt; urgentJobsDone &lt;&lt;
                    <span class="stringliteral">&quot;, less urgent: &quot;</span>     &lt;&lt; lessUrgentJobsDone &lt;&lt; bsl::endl;
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_the_functor-based_interface"></a> <a class="anchor" id="usage.example_2~3A_the_functor-based_interface"></a> <a class="anchor" id="description.usage.example_2~3A_the_functor-based_interface"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: The Functor-Based Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In this second example we present a multi-threaded algorithm for calculating prime numbers. This is just to serve as an illustration; although it works, it is not really any faster than doing it with a single thread. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For every prime number <code>P</code>, we have to mark all multiples of it in two ranges, <code>[ P .. P ** 2 ]</code> and <code>[ P ** 2 .. TOP_NUMBER ]</code>, as non-prime, where we use 2000 for <code>TOP_NUMBER</code> in this example. For any <code>P ** 2</code>, if we can determine that all primes below <code>P</code> have marked all their multiples up to <code>P ** 2</code>, then we can scan that range and any unmarked values in it will be a new prime. The we can start out with our first prime, 2, and mark all primes between it and <code>2 ** 2 == 4</code>, thus discovering 3 is prime. Once we have marked all multiples of 2 and 3 below <code>3 * 3 == 9</code>, we can then scan that range and discover 5 and 7 are primes, and repeat the process to discover bigger and bigger primes until we have covered an entire range (in this example all ints below TOP_NUMBER == 2000): <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keyword">enum</span> {
       TOP_NUMBER     = 2000,
       NUM_PRIORITIES = 32
   };

   <span class="keywordtype">bool</span> isStillPrime[TOP_NUMBER];
   <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> scannedTo[TOP_NUMBER];  <span class="comment">// if &#39;P&#39; is a prime, what is the</span>
                                           <span class="comment">// highest multiple of &#39;P&#39; that</span>
                                           <span class="comment">// we have marked</span>
                                           <span class="comment">// &#39;isStillPrime[P] = false&#39;</span>

   <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> maxPrimeFound;          <span class="comment">// maximum prime identified so far</span>
   <span class="keywordtype">int</span> primeNumbers[TOP_NUMBER];           <span class="comment">// elements in the range</span>
                                           <span class="comment">// &#39;0 .. numPrimeNumbers - 1&#39; are</span>
                                           <span class="comment">// the prime numbers we have found</span>
                                           <span class="comment">// so far</span>
   <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a> numPrimeNumbers;

   <a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html">bdlmt::MultipriorityThreadPool</a> *threadPool;

   <span class="keywordtype">bool</span>          doneFlag;                 <span class="comment">// set this flag to signal</span>
                                           <span class="comment">// other jobs that we&#39;re done</span>
   <a class="code" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a> doneBarrier(2);           <span class="comment">// we wait on this barrier</span>
                                           <span class="comment">// to signal the main thread</span>
                                           <span class="comment">// that we&#39;re done</span>

   <span class="keyword">struct </span>Functor {
       <span class="keyword">static</span> <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a> s_mutex;
       <span class="keywordtype">int</span>                d_numToScan;
       <span class="keywordtype">int</span>                d_priority;
       <span class="keywordtype">int</span>                d_limit;

       Functor(<span class="keywordtype">int</span> numToScan)
       : d_numToScan(numToScan)
       , d_priority(0)
       {
           d_limit = bsl::min((<span class="keywordtype">double</span>) numToScan * numToScan,
                              (<span class="keywordtype">double</span>) TOP_NUMBER);
       }

       <span class="keywordtype">void</span> setNewPrime(<span class="keywordtype">int</span> newPrime) {
           maxPrimeFound = newPrime;
           primeNumbers[numPrimeNumbers] = newPrime;
           ++numPrimeNumbers;

           <span class="keywordflow">if</span> (2 * newPrime &lt; TOP_NUMBER) {
               Functor f(newPrime);

               threadPool-&gt;<a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html#a8c2b353155b2d3ec3b4800f5bb8a8686">enqueueJob</a>(f, 0);
           }
       }

       <span class="keywordtype">void</span> evaluateCandidatesForPrime() {
           <span class="keywordflow">if</span> (maxPrimeFound &gt; d_limit) {
               <span class="keywordflow">return</span>;
           }

           <span class="keywordtype">int</span> numToScanI;
           <span class="keywordflow">for</span> (numToScanI = numPrimeNumbers - 1; numToScanI &gt; 0;
                                                           --numToScanI) {
               <span class="keywordflow">if</span> (primeNumbers[numToScanI] == d_numToScan) {
                   <span class="keywordflow">break</span>;
               }
           }
           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = numToScanI - 1; i &lt; 0; --i) {
               <span class="keywordflow">if</span> (TOP_NUMBER &lt; scannedTo[primeNumbers[i]]) {
                   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = i + 1; j &lt; numPrimeNumbers; ++j) {
                       <span class="keywordflow">if</span> (TOP_NUMBER == scannedTo[primeNumbers[j]]) {
                           scannedTo[primeNumbers[j]] = TOP_NUMBER + 1;
                       }
                       <span class="keywordflow">else</span> {
                           <span class="keywordflow">break</span>;
                       }
                   }
                   <span class="keywordflow">break</span>;
               }

               <span class="keywordflow">if</span> (scannedTo[primeNumbers[i]] &lt; d_limit) {
                   <span class="comment">// Not all multiples of all prime numbers below</span>
                   <span class="comment">// us have been adequately marked as non-prime.  We</span>
                   <span class="comment">// cannot yet draw any new conclusions about what</span>
                   <span class="comment">// is and what is not prime in this range.</span>

                   <span class="comment">// Resubmit ourselves to the back of the priority queue</span>
                   <span class="comment">// so that we&#39;ll get re-evaluated when previous prime</span>
                   <span class="comment">// numbers are done scanning.  Note that we could get</span>
                   <span class="comment">// reenqueued several times.</span>

                   <span class="comment">// Note that jobs marking the &#39;isStillPrime&#39; array are</span>
                   <span class="comment">// at priority 0, while later incarnations that can</span>
                   <span class="comment">// only set new primes are at priority 1 and keep</span>
                   <span class="comment">// getting resubmitted at less and less urgent</span>
                   <span class="comment">// priorities until all their prerequisites (which</span>
                   <span class="comment">// are at priority 0) are done.</span>

                   d_priority = bsl::min(NUM_PRIORITIES - 2,
                                         d_priority + 1);
                   threadPool-&gt;<a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html#a8c2b353155b2d3ec3b4800f5bb8a8686">enqueueJob</a>(*<span class="keyword">this</span>, d_priority);

                   <span class="keywordflow">return</span>;
               }
           }

           <span class="comment">// Everything up to &#39;d_limit&#39; that has not been marked</span>
           <span class="comment">// non-prime is prime.</span>

           <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> guard(&amp;s_mutex);

           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = maxPrimeFound + 1; d_limit &gt; i; ++i) {
               <span class="keywordflow">if</span> (isStillPrime[i]) {
                   setNewPrime(i);
               }
           }

           <span class="keywordflow">if</span> (TOP_NUMBER == d_limit &amp;&amp; !doneFlag) {
               <span class="comment">// We have successfully listed all primes below &#39;TOP_NUMBER&#39;.</span>
               <span class="comment">// Touch the done barrier and our caller will then know that</span>
               <span class="comment">// we are done and shut down the queue.</span>

               doneFlag = <span class="keyword">true</span>;
               doneBarrier.wait();
           }
       }

       <span class="keywordtype">void</span> operator()() {
           <span class="keywordflow">if</span> (0 == d_priority) {
               <a class="code" href="classbsls_1_1AtomicInt.html">bsls::AtomicInt</a>&amp; rScannedTo = scannedTo[d_numToScan];

               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = d_numToScan; i &lt; d_limit; i += d_numToScan) {
                   isStillPrime[i] = <span class="keyword">false</span>;
                   rScannedTo = i;
               }

               d_priority = 1;
               threadPool-&gt;<a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html#a8c2b353155b2d3ec3b4800f5bb8a8686">enqueueJob</a>(*<span class="keyword">this</span>, d_priority);

               <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = d_limit; i &lt; TOP_NUMBER; i += d_numToScan) {
                   isStillPrime[i] = <span class="keyword">false</span>;
                   rScannedTo = i;
               }
               rScannedTo = TOP_NUMBER;
           }
           <span class="keywordflow">else</span> {
               evaluateCandidatesForPrime();
           }
       }
   };
   <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a> Functor::s_mutex;
</pre></div><br/>
<br/>
 and in the main program: <br/>
<br/>
<div class="fragment"><pre class="fragment">         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; TOP_NUMBER &gt; i; ++i) {
             isStillPrime[i] = <span class="keyword">true</span>;
             scannedTo[i] = 0;
         }

         scannedTo[0] = TOP_NUMBER + 1;
         scannedTo[1] = TOP_NUMBER + 1;

         maxPrimeFound = 2;
         primeNumbers[0] = 2;
         numPrimeNumbers = 1;
         doneFlag = <span class="keyword">false</span>;

         <a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html">bdlmt::MultipriorityThreadPool</a> threadPool(20, NUM_PRIORITIES);
         threadPool.<a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html#a2e25032848b7cd2137a23ad67f924d59">startThreads</a>();

         Functor f(2);
         threadPool.<a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html#a8c2b353155b2d3ec3b4800f5bb8a8686">enqueueJob</a>(f, 0);

         doneBarrier.wait();

         threadPool.<a class="code" href="classbdlmt_1_1MultipriorityThreadPool.html#add80fee30a6f85c3d05a4b6369f868c9">shutdown</a>();

         <span class="keywordflow">if</span> (verbose) {
             printf(<span class="stringliteral">&quot;%d prime numbers below %d:&quot;</span>, (<span class="keywordtype">int</span>) numPrimeNumbers,
                                                  TOP_NUMBER);

             <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; numPrimeNumbers &gt; i; ++i) {
                 printf(<span class="stringliteral">&quot;%s%4d&quot;</span>, 0 == i % 10 ? <span class="stringliteral">&quot;\n    &quot;</span> : <span class="stringliteral">&quot;, &quot;</span>,
                                                          primeNumbers[i]);
             }
             printf(<span class="stringliteral">&quot;\n&quot;</span>);
         }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
