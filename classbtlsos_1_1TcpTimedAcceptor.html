<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlsos::TcpTimedAcceptor</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlsos.html">btlsos</a>      </li>
      <li><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html">btlsos::TcpTimedAcceptor</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlsos::TcpTimedAcceptor Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlsos::TcpTimedAcceptor" --><!-- doxytag: inherits="btlsc::TimedChannelAllocator" -->
<p><code>#include &lt;<a class="el" href="btlsos__tcptimedacceptor_8h_source.html">btlsos_tcptimedacceptor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlsos::TcpTimedAcceptor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlsos_1_1TcpTimedAcceptor.png" usemap="#btlsos::TcpTimedAcceptor_map" alt=""/>
  <map id="btlsos::TcpTimedAcceptor_map" name="btlsos::TcpTimedAcceptor_map">
<area href="classbtlsc_1_1TimedChannelAllocator.html" alt="btlsc::TimedChannelAllocator" shape="rect" coords="0,0,175,24"/>
</map>
</div>

<p><a href="classbtlsos_1_1TcpTimedAcceptor-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a7c8a369d28a343515787be8ccc552161">TcpTimedAcceptor</a> (<a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *factory, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a7bc6ce39d511aac60b7a8427b827c5f1">TcpTimedAcceptor</a> (<a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *factory, int initialCapacity, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a009325f659016fbb8f238c1a35f65d78">~TcpTimedAcceptor</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a66991439f7ac44475b53638d01ba904c">allocate</a> (int *status, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#ac8902bd09de7fd760e92dc2feaca813e">timedAllocate</a> (int *status, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#ac50c098f13c3c0e0996d613a1b16dbbf">allocateTimed</a> (int *status, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#ab79d991214a49708b958ff388710f26e">timedAllocateTimed</a> (int *status, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a9b21092eeb5680bc57556aca206cb665">close</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#aa135e1b7b25ed0499d1c88a08e199c15">deallocate</a> (<a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *channel)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#afb0c39ed3a83022ad9a3a1ec4f258852">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#ae4fc7b3cebe5e75eecc0a2b89ea459ea">open</a> (const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;endpoint, int queueSize, int reuseAddressFlag=1)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a64d78ba7b84bb13857fcd48f08a8c528">setOption</a> (int level, int option, int value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a><br class="typebreak"/>
&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a74f10728d218e8c27f4ac270402308dd">socket</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#af4cd554483182aca82d638eeba296770">address</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a4d3ee02d314bec707b845fa1c2af6ffe">getOption</a> (int *result, int level, int option) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#a0e885f9ba22265f03e15d1770165f5ae">isInvalid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpTimedAcceptor.html#af0465ff3f8e30e0dffb5e3366fbcb51f">numChannels</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a <code>btesc</code>-style timed channel allocator for a single, server-side (i.e., listening) socket. The allocations can be timed or not-timed and produce either timed or non-timed channels. The return status for an operation mandated by <code><a class="el" href="classbtlsc_1_1TimedChannelAllocator.html">btlsc::TimedChannelAllocator</a></code> protocol is negative for failure, 0 on timeout, and positive for a (restartable) interrupt on an underlying system call. The status value of -2 is reserved to indicate an allocation attempt on an uninitialized acceptor (i.e., no listening socket is established). The acceptor provides a "delayed open" (where a listening socket is established at some point after construction), and allows the listening socket to be closed (and opened again) with no effect on the state of any other channel currently managed by this acceptor. </p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7c8a369d28a343515787be8ccc552161"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::TcpTimedAcceptor" ref="a7c8a369d28a343515787be8ccc552161" args="(btlso::StreamSocketFactory&lt; btlso::IPv4Address &gt; *factory, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpTimedAcceptor::TcpTimedAcceptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a timed acceptor that uses the specified <code>factory</code> to create stream sockets. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>factory</code> is not 0. Note that the acceptor is created NOT in an invalid state (as reported by <code>isInvalid</code> method), though subsequent allocations will <em>fail</em> until a listening socket is created (using <code>open</code>). </p>

</div>
</div>
<a class="anchor" id="a7bc6ce39d511aac60b7a8427b827c5f1"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::TcpTimedAcceptor" ref="a7bc6ce39d511aac60b7a8427b827c5f1" args="(btlso::StreamSocketFactory&lt; btlso::IPv4Address &gt; *factory, int initialCapacity, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpTimedAcceptor::TcpTimedAcceptor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocketFactory.html">btlso::StreamSocketFactory</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>initialCapacity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a timed acceptor that uses the specified <code>factory</code> to create stream sockets with enough internal capacity to accommodate up to the specified <code>initialCapacity</code> channels without reallocation. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined if <code>factory</code> is 0 or unless <code>0 &lt; initialCapacity</code>. Note that the acceptor is created NOT in an invalid state (as reported by the <code>isInvalid</code> method), though the subsequent allocations will <em>fail</em> until a listening socket is created (using <code>open</code>). </p>

</div>
</div>
<a class="anchor" id="a009325f659016fbb8f238c1a35f65d78"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::~TcpTimedAcceptor" ref="a009325f659016fbb8f238c1a35f65d78" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpTimedAcceptor::~TcpTimedAcceptor </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this acceptor. The behavior is undefined unless all allocated channels are deallocated. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a66991439f7ac44475b53638d01ba904c"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::allocate" ref="a66991439f7ac44475b53638d01ba904c" args="(int *status, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a>* btlsos::TcpTimedAcceptor::allocate </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a stream-based channel. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Return the address of a channel on success, and 0 otherwise. On an unsuccessful allocation, load the specified <code>status</code> with a positive value if an asynchronous event interrupted the allocation, and a negative value (indicating an error) otherwise; <code>status</code> is not modified on success. A channel address will remain valid until deallocated explicitly (see <code>deallocate</code>). An allocation that fails with a positive status is likely to succeed if retried. An allocation error does not <em>necessarily</em> invalidate this allocator, and so subsequent allocations <em>may</em> succeed. Use the <code>isInvalid</code> method for more information on the state of this allocator. Note that -2 is loaded into <code>status</code> if a listening socket is not established (see <code>open</code>). </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannelAllocator.html#a65eec36ed2d23d575dc22ca2b0b12a22">btlsc::TimedChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="ac8902bd09de7fd760e92dc2feaca813e"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::timedAllocate" ref="ac8902bd09de7fd760e92dc2feaca813e" args="(int *status, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a>* btlsos::TcpTimedAcceptor::timedAllocate </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a stream-based channel or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Return the address of a callback channel on success, and 0 otherwise. On an unsuccessful allocation, load the specified <code>status</code> with 0 if <code>timeout</code> interrupted this operation, a positive value if the interruption is due to an asynchronous event, and a negative value (indicating an error) otherwise; <code>status</code> is not modified on success. A channel address will remain valid until deallocated explicitly (see <code>deallocate</code>). An allocation that fails with a non-negative status is likely to succeed if retried. An allocation error does not <em>necessarily</em> invalidate this allocator, and so subsequent allocations <em>may</em> succeed. Use the <code>isInvalid</code> method for more information on the state of this allocator. Note that if the <code>timeout</code> value has already passed, the allocation will still be attempted, but the attempt will not block. Also note that -2 is loaded into <code>status</code> if a listening socket is not established (see <code>open</code>). </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannelAllocator.html#abf59b4e1dda216de4e26db81bd15af38">btlsc::TimedChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="ac50c098f13c3c0e0996d613a1b16dbbf"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::allocateTimed" ref="ac50c098f13c3c0e0996d613a1b16dbbf" args="(int *status, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a>* btlsos::TcpTimedAcceptor::allocateTimed </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a stream-based timed channel. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous
         events" are permitted to interrupt this operation; by default, such events are ignored. Return the address of a timed callback channel on success, and 0 otherwise. On an unsuccessful allocation, load the specified <code>status</code> with a positive value if an asynchronous event interrupted the allocation, and a negative value (indicating an error) otherwise; <code>status</code> is not modified on success. A channel address will remain valid until deallocated explicitly (see <code>deallocate</code>). An allocation that fails with a positive status is likely to succeed if retried. An allocation error does not <em>necessarily</em> invalidate this allocator, and so subsequent allocations <em>may</em> succeed. Use the <code>isInvalid</code> method for more information on the state of this allocator. Note that -2 is loaded into <code>status</code> if a listening socket is not established (see <code>open</code>). </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannelAllocator.html#a5da376301cee7d0248da821716395c56">btlsc::TimedChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="ab79d991214a49708b958ff388710f26e"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::timedAllocateTimed" ref="ab79d991214a49708b958ff388710f26e" args="(int *status, const bsls::TimeInterval &amp;timeout, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlsc_1_1TimedChannel.html">btlsc::TimedChannel</a>* btlsos::TcpTimedAcceptor::timedAllocateTimed </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>status</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate a stream-based timed channel or interrupt after the specified absolute <code>timeout</code> time is reached. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return the address of a timed callback channel on success, and 0 otherwise. On an unsuccessful allocation, load the specified <code>status</code> with 0 if <code>timeout</code> interrupts this operation, a positive value if the interruption is due to an asynchronous event, and a negative value (indicating an error) otherwise; <code>status</code> is not modified on success. A non-null channel address will remain valid until deallocated explicitly (see <code>deallocate</code>). An allocation that fails with a non-negative status is likely to succeed if retried. An allocation error does not <em>necessarily</em> invalidate this allocator, and so subsequent allocations <em>may</em> succeed. Use the <code>isInvalid</code> method for more information on the state of this allocator. Note that if the <code>timeout</code> value has already passed, the allocation will still be attempted, but the attempt will not block. Also note that -2 is loaded into <code>status</code> if a listening socket is not established (see <code>open</code>). </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannelAllocator.html#a215cb680b27e50f0f811a8328df0bcbc">btlsc::TimedChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a9b21092eeb5680bc57556aca206cb665"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::close" ref="a9b21092eeb5680bc57556aca206cb665" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedAcceptor::close </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the listening socket; return 0 on success, and a non-zero value otherwise. A listening socket yields a non-zero server address (see <code>address</code>). The behavior is undefined unless the listening socket is successfully established. Note that closing a listening port has no effect on any other channels managed by this allocator. </p>

</div>
</div>
<a class="anchor" id="aa135e1b7b25ed0499d1c88a08e199c15"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::deallocate" ref="aa135e1b7b25ed0499d1c88a08e199c15" args="(btlsc::Channel *channel)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpTimedAcceptor::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlsc_1_1Channel.html">btlsc::Channel</a> *&nbsp;</td>
          <td class="paramname"> <em>channel</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reclaim all afforded services for the specified <code>channel</code>. The behavior is undefined unless <code>channel</code> is currently allocated from this allocator, (i.e., was previously obtained from this instance and has not subsequently been deallocated). </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannelAllocator.html#a963c9e7cc99cc44e242ae244b0019252">btlsc::TimedChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="afb0c39ed3a83022ad9a3a1ec4f258852"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::invalidate" ref="afb0c39ed3a83022ad9a3a1ec4f258852" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpTimedAcceptor::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Place this allocator in a permanently invalid state. No subsequent allocations will succeed. Note that invalidating the allocator has no effect on the state of any channel managed by it nor on the listening socket, which, if established, must be closed explicitly (using <code>close</code> method). </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannelAllocator.html#abf55a9bb900a019d387486c815204bed">btlsc::TimedChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="ae4fc7b3cebe5e75eecc0a2b89ea459ea"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::open" ref="ae4fc7b3cebe5e75eecc0a2b89ea459ea" args="(const btlso::IPv4Address &amp;endpoint, int queueSize, int reuseAddressFlag=1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedAcceptor::open </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>queueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reuseAddressFlag</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Establish a listening socket having the specified <code>queueSize</code> maximum number of pending connections on the specified <code>endpoint</code>. Optionally specify a <code>reuseAddressFlag</code> used to set <code>SO_REUSEADDRESS</code> option on a listening socket. If <code>reuseAddressFlag</code> is not specified, this option is enabled. Return 0 on success and a non-zero value otherwise. The behavior is undefined unless <code>0 &lt; queueSize</code> and this object is not invalidated. </p>

</div>
</div>
<a class="anchor" id="a64d78ba7b84bb13857fcd48f08a8c528"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::setOption" ref="a64d78ba7b84bb13857fcd48f08a8c528" args="(int level, int option, int value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedAcceptor::setOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified socket <code>option</code> of the specified <code>level</code> on the listening socket to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. (The list of commonly-supported options is available in <code>btlso_socketoptutil</code>.) The behavior is undefined unless the listening socket is established and this object is not invalidated. Note that all sockets allocated from this acceptor will inherit the options' values set on the listening socket. </p>

</div>
</div>
<a class="anchor" id="a74f10728d218e8c27f4ac270402308dd"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::socket" ref="a74f10728d218e8c27f4ac270402308dd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt;<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&gt;* btlsos::TcpTimedAcceptor::socket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the stream-socket used by this acceptor, or 0 if this acceptor is not opened to establish a listening socket yet. </p>

</div>
</div>
<a class="anchor" id="af4cd554483182aca82d638eeba296770"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::address" ref="af4cd554483182aca82d638eeba296770" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&amp; btlsos::TcpTimedAcceptor::address </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (fully qualified) address of the listening socket, or an invalid address of (ANY_ADDRESS, ANY_PORT) if the server is not established (see <code>btlso_ipv4address</code>). </p>

</div>
</div>
<a class="anchor" id="a4d3ee02d314bec707b845fa1c2af6ffe"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::getOption" ref="a4d3ee02d314bec707b845fa1c2af6ffe" args="(int *result, int level, int option) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedAcceptor::getOption </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the current value of the specified <code>option</code> of the specified <code>level</code> set on the listening socket. Return 0 on success and a non-zero value otherwise. The list of commonly-supported options (and levels) is enumerated in <code>btlso_socketoptutil</code>. The behavior is undefined if result is 0 or if the listening socket has not been established. </p>

</div>
</div>
<a class="anchor" id="a0e885f9ba22265f03e15d1770165f5ae"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::isInvalid" ref="a0e885f9ba22265f03e15d1770165f5ae" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedAcceptor::isInvalid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a non-zero value if this channel allocator is <em>permanently</em> invalid (i.e., no subsequent allocation requests will succeed), and 0 otherwise. </p>

<p>Implements <a class="el" href="classbtlsc_1_1TimedChannelAllocator.html#a0f69d056cb49159ed41750c7fa36fd40">btlsc::TimedChannelAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="af0465ff3f8e30e0dffb5e3366fbcb51f"></a><!-- doxytag: member="btlsos::TcpTimedAcceptor::numChannels" ref="af0465ff3f8e30e0dffb5e3366fbcb51f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpTimedAcceptor::numChannels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of channels currently allocated from this acceptor. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlsos__tcptimedacceptor_8h_source.html">btlsos_tcptimedacceptor.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:17 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
