<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_assert Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_assert<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide build-specific, runtime-configurable assertion macros.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Macros</a> </li>
<li>
<a href="#4">Description</a> <ul>
<li>
<a href="#4.1">Defensive Programming (DP)</a> </li>
<li>
<a href="#4.2">Assertion Semantics</a> <ul>
<li>
<a href="#4.2.1">Detailed Behavior</a> </li>
<li>
<a href="#4.2.2">Selecting Which of the Three ASSERT Macros to Use</a> </li>
</ul>
</li>
<li>
<a href="#4.3">Build Modes (Build Targets and Assertion-Level Flags)</a> <ul>
<li>
<a href="#4.3.1">Build Targets Only</a> </li>
<li>
<a href="#4.3.2">Assertion-Level Flags</a> </li>
</ul>
</li>
<li>
<a href="#4.4">Runtime-Configurable Assertion-Failure Behavior</a> <ul>
<li>
<a href="#4.4.1">Exception-Throwing Failure Handlers and <code>bsls::AssertFailureHandlerGuard</code></a> </li>
</ul>
</li>
<li>
<a href="#4.5">Assertions in Header Files (Mixing Build Options Across Translation Units)</a> </li>
<li>
<a href="#4.6">Conditional Compilation: <code>BDE_BUILD_TARGET_SAFE_2</code> and Assertion Predicates</a> </li>
<li>
<a href="#4.7">Usage Examples</a> <ul>
<li>
<a href="#4.7.1">1. Using <code>BSLS_ASSERT</code>, <code>BSLS_ASSERT_SAFE</code>, and <code>BSLS_ASSERT_OPT</code></a> </li>
<li>
<a href="#4.7.2">2. When and How to Call the <code>invokeHandler</code> Method Directly</a> </li>
<li>
<a href="#4.7.3">3. Runtime Configuration of the <code>bsls::Assert</code> Facility</a> </li>
<li>
<a href="#4.7.4">4. Creating a Custom Assertion Handler</a> </li>
<li>
<a href="#4.7.5">5. Using the <code>bsls::AssertFailureHandlerGuard</code></a> </li>
<li>
<a href="#4.7.6">6. Using (BSLS) "ASSERT" Macros in Conjunction w/ <code>BDE_BUILD_TARGET_SAFE_2</code></a> </li>
<li>
<a href="#4.7.7">7. Conditional Compilation Associated with Enabled Assertion Levels</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide build-specific, runtime-configurable assertion macros. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsls_1_1Assert.html">bsls::Assert</a> </td><td>namespace for "assert" management functions  </td></tr>
<tr>
<td><a class="el" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a> </td><td>scoped guard for changing handlers safely  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="macros"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Macros: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>BSLS_ASSERT </td><td>runtime check typically enabled in safe and non-opt build modes  </td></tr>
<tr>
<td>BSLS_ASSERT_SAFE </td><td>runtime check typically only enabled in safe build modes  </td></tr>
<tr>
<td>BSLS_ASSERT_OPT </td><td>runtime check typically enabled in all build modes  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bsls__buildtarget.html" title="Provide build-target information in the object file.">Component bsls_buildtarget</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="4"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides three "assert-like" macros, <code>BSLS_ASSERT</code>, <code>BSLS_ASSERT_SAFE</code>, and <code>BSLS_ASSERT_OPT</code>, which can be used to enable optional <em>redundant</em> runtime checks in corresponding build modes. If an assertion argument evaluates to 0, a runtime-configurable "handler" function is invoked with the current filename, line number, and (0-valued expression) argument text. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="defensive_programming_(dp)"></a> <a class="anchor" id="description.defensive_programming_(dp)"></a> <a class="anchor" id="4.1"></a> </dd></dl>
<dl class="user"><dt><b>Defensive Programming (DP): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Although there is no one agreed-upon definition, in this context we will use the term <em>Defensive</em> <em>Programming</em> (DP) to mean any attempt by the component author to provide (optional) runtime validation of the preconditions (or invariants) defined in the function-level documentation (contract) for that component. Note that DP is intended to help expose defects early in the development process, and <em>never</em> to mask or recover from them in production. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Calling a function without satisfying its preconditions results in <em>undefined</em> <em>behavior</em>. Detecting and reporting undefined behavior due to client misuse can sometimes be very helpful at identifying subtle errors. Additionally, we may choose to embed redundant (i.e., logically superfluous) runtime checks -- both as a form of active documentation, and also to help expose our own, latent coding errors that have escaped detection during testing. In either case, these <em>defensive</em> (and other) runtime checks can add significant overhead. Hence, this extra runtime overhead should not necessarily be incorporated for every build target and assertion mode (see "Build Modes" below). Moreover, the extent of these checks may change (i.e., for a particular build mode) from one release to the next. Therefore, any defensive (or other redundant) checks provided for a particular build mode are <em>NEVER</em> part of the function-level contract -- and remain solely what is known as a <em>Quality-of-Implementation</em> (QoI) issue. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="assertion_semantics"></a> <a class="anchor" id="description.assertion_semantics"></a> <a class="anchor" id="4.2"></a> </dd></dl>
<dl class="user"><dt><b>Assertion Semantics: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are three important aspects of assertions: (1) <b>Every</b> <b>assertion</b> <b>is</b> <b>redundant</b>; it is essential that if all assertions are compiled out of a program that is defect-free, apart from improved runtime performance, the program behaves identically. Hence, (2) <b>each</b> <b>boolean-valued</b> <b>assert</b> <b>argument</b> <b>must</b> <b>have</b> <b>no</b> <b>side-effects</b>. Finally, (3) <b>assertions</b> <b>do</b> <b>not</b> <b>affect</b> <b>binary</b> <b>compatibility</b>; hence, translation units with different assertion levels (but not necessarily build targets) can safely be combined into a single program (see "Build Modes" and "Assertions in Header
 Files" below). Note that the build target <code>BDE_BUILD_TARGET_SAFE_2</code> does permit binary incompatibility for conditionally compiled source code, but there is no corresponding <code>BSLS_ASSERT_SAFE_2</code> assertion macro (see "Usage
 Examples" below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="detailed_behavior"></a> <a class="anchor" id="assertion_semantics.detailed_behavior"></a> <a class="anchor" id="description.assertion_semantics.detailed_behavior"></a> <a class="anchor" id="4.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Detailed Behavior: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If an assertion fires (i.e., due to a 0-valued expression argument), there is either a contract violation or some other logic error; the program is now in an undefined state, and the goal of the assertion (if enabled) is to report the precise location and nature of the defect <em>quickly</em> and <em>loudly</em>. Assertions are enabled at compile time by the presence or absence of relevant <em>build</em> <em>targets</em> and <em>assertion-level</em> <em>flags</em> (see "Build Modes" below). When enabled, each of the three flavors of (BSLS) "ASSERT" macros provided in this component does the same thing: Each macro tests the predicate expression <code>X</code>, and, if <code>!(X)</code> is <code>true</code>, invokes the currently installed (<code>void</code>-valued) handler function having the signature <code>(const char *, const char *, int)</code>, passing the textual rendering of the predicate (<code>#X</code>), <code>__FILE__</code>, and <code>__LINE__</code>. Note that if an "ASSERT" macro is not enabled by the appropriate build flags, it is not instantiated (i.e., it expands to nothing in the preprocessor). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="selecting_which_of_the_three_assert_macros_to_use"></a> <a class="anchor" id="assertion_semantics.selecting_which_of_the_three_assert_macros_to_use"></a> <a class="anchor" id="description.assertion_semantics.selecting_which_of_the_three_assert_macros_to_use"></a> <a class="anchor" id="4.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Selecting Which of the Three ASSERT Macros to Use: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The choice of which specific macro to use is governed primarily by the relative runtime cost of (a) evaluating the expression needed to detect a potential defect (e.g., an out-of-range argument to a function) compared with (b) the useful productive work being done (e.g., by the function): <br/>
<br/>
<div class="fragment"><pre class="fragment">      Recommended    Relative overhead (a/b) of (a) evaluating the particular
    (BSLS) &quot;ASSERT&quot;   argument expression compared with (b) the runtime cost
   Macro to be used.   of performing concomitant useful (productive) work.
  --------------------  ---------------------------------------------------
   <span class="preprocessor">#       Macro Name         Rel.  Cost      Description of ratio (a/b)</span>
<span class="preprocessor"></span>  ---   ----------------     ------------    ----------------------------
  I.    <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>     Expensive       (order of magnitude overhead)

  II.   <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>          Inexpensive     (no more than 5-10% overhead)

  III.  <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>      Negligible      (no observable overhead)
</pre></div><br/>
<br/>
 The most typical asserts are <code>BSLS_ASSERT</code>, which may add some measurable overhead, compared to the runtime cost of a (non-'inline') function call, but not much. We would expect to incur this overhead in, say, a "debug
 mode" build, but not, for example, in an "opt mode" one. For inline functions with even simple defensive checks, the runtime cost of performing the check may be substantial (i.e., &gt; 10%) compared to that of the useful work being done. In such cases, we will prefer the <code>BSLS_ASSERT_SAFE</code> macro to ensure that instantiation occurs only in "safe mode", where the expensive extra check is presumably needed to help resolve a specific problem, and substantial extra overhead is a non-issue. Finally, in situations where the cost of the defensive check is truly negligible and failing to detect a defect or misuse could result in catastrophe, we may instead elect to use the <code>BSLS_ASSERT_OPT</code> macro, which instantiates even in "opt mode", where runtime performance is presumed to be at a premium. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="build_modes_(build_targets_and_assertion-level_flags)"></a> <a class="anchor" id="description.build_modes_(build_targets_and_assertion-level_flags)"></a> <a class="anchor" id="4.3"></a> </dd></dl>
<dl class="user"><dt><b>Build Modes (Build Targets and Assertion-Level Flags): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <em>build</em> <em>mode</em> for this component defines the amount of defensive checking that will be incorporated (at compile time) into the translation unit. For example, "safe mode" implies that all three of the (BSL) "ASSERT" macros above will instantiate, while "debug mode" implies that only <code>BSLS_ASSERT</code> and <code>BSLS_ASSERT_OPT</code> will do so. Building in "opt mode" implies that only <code>BSLS_ASSERT_OPT</code> instantiates, and "none mode" would mean that all "ASSERT" macros will be compiled out. Note that this final build mode is useful during testing to ensure, as required (see "Assertion
 Semantics" above), that defensive checks performed using the <code>BSLS_ASSERT_OPT</code> macro (1) incur no significant (observable) runtime overhead, (2) cause no change in behavior, and (3) do not affect binary compatibility. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>A particular build mode is implied by the relevant (BDE) build targets and (BSLS) assertion-level flags (i.e., preprocessor macros) that are defined at compilation (preprocessing) time -- e.g., by supplying one or more <code>-D</code> options, each followed immediately by the relevant macro name on the (Unix) command line. The presence (or absence) of definitions for the following build targets and (subsequently) assertion-level flags determine the build mode, and therefore whether the bodies of each of the three "ASSERT" macros (see previous section) are compiled into the translation unit. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>(BDE) build targets are defined by the development environment, and not by any component within the software repository. The following table shows the three (BDE) build targets that can affect which (BSLS) "ASSERT" macros instantiate. <br/>
<br/>
<div class="fragment"><pre class="fragment">        (BDE) Build Targets
      -----------------------
  (A) BDE_BUILD_TARGET_SAFE_2
  (B) BDE_BUILD_TARGET_SAFE
  (C) BDE_BUILD_TARGET_OPT
</pre></div><br/>
<br/>
 <em>Any</em> of the 8 possible combinations of the three build targets, e.g., <code>BDE_BUILD_TARGET_OPT</code> and <code>BDE_BUILD_TARGET_SAFE_2</code>, may be defined. By contrast, the four (BSLS) assertion-level flags, shown below (e.g., <code>BSLS_ASSERT_LEVEL_NONE</code>), are specific to this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following table shows the four mutually exclusive (BSLS) assertion-level flags. (Note that, by default, the <code>BSLS_ASSERT_SAFE</code> macro is disabled, and the <code>BSLS_ASSERT</code> and <code>BSLS_ASSERT_OPT</code> macros are enabled; the <code>BSLS_ASSERT</code> macro is disabled when the <code>BDE_BUILD_TARGET_OPT</code> flag is defined and not overruled by also defining the <code>BDE_BUILD_TARGET_SAFE</code> macro.) <br/>
<br/>
<div class="fragment"><pre class="fragment">       (BSLS) Assertion-Level Flags
      ------------------------------
  (1) BSLS_ASSERT_LEVEL_ASSERT_SAFE
  (2) BSLS_ASSERT_LEVEL_ASSERT
  (3) BSLS_ASSERT_LEVEL_ASSERT_OPT
  (4) BSLS_ASSERT_LEVEL_NONE
</pre></div><br/>
<br/>
 At most <em>one</em> of the above flags may be defined during the translation of any component that includes <code><a class="el" href="bsls__assert_8h.html" title="Provide build-specific, runtime-configurable assertion macros.">bsls_assert.h</a></code>, or that component will fail to compile (producing a useful diagnostic message). If an assertion-level flag is defined, it overrides the default instantiation behavior for every combination of build-target definitions. Note, however, that the precise behavior of each of the three (BSLS) "ASSERT" macros, when enabled, depends on the particular assert handler that is currently installed (see "Runtime-Configurable Assertion-Failure Behavior" below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="build_targets_only"></a> <a class="anchor" id="build_modes_(build_targets_and_assertion-level_flags).build_targets_only"></a> <a class="anchor" id="description.build_modes_(build_targets_and_assertion-level_flags).build_targets_only"></a> <a class="anchor" id="4.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Build Targets Only: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If no assertion-level flags are defined (see "Assertion-Level Flags" below), the presence or absence of the definitions of the three relevant build targets control the build mode, and, therefore, which of the (BSLS) "ASSERT" macros will be active (i.e., will instantiate): <br/>
<br/>
<div class="fragment"><pre class="fragment">  ===========================================================================
   <span class="stringliteral">&quot;ASSERT&quot;</span> Macro Instantiation Assuming NO Assertion-Level Flags are Defined
  ===========================================================================
  --- BDE_BUILD_TARGET ----   ------------ BSLS <span class="stringliteral">&quot;ASSERT&quot;</span> MACRO --------------
    (A)      (B)      (C)            I.            II.            III.
  _SAFE_2   _SAFE    _OPT     <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>  <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>   <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>
  -------  -------  -------   ----------------  ------------  ---------------
                                                INSTANTIATES   INSTANTIATES
                    DEFINED                                    INSTANTIATES
           DEFINED             INSTANTIATES     INSTANTIATES   INSTANTIATES
           DEFINED  DEFINED    INSTANTIATES     INSTANTIATES   INSTANTIATES
  DEFINED                      INSTANTIATES     INSTANTIATES   INSTANTIATES
  DEFINED           DEFINED    INSTANTIATES     INSTANTIATES   INSTANTIATES
  DEFINED  DEFINED             INSTANTIATES     INSTANTIATES   INSTANTIATES
  DEFINED  DEFINED  DEFINED    INSTANTIATES     INSTANTIATES   INSTANTIATES

  ==========================================================================
</pre></div><br/>
<br/>
 As the table above illustrates, if no build targets are defined, then both <code>BSLS_ASSERT</code> and <code>BSLS_ASSERT_OPT</code> instantiate. If <code>BDE_BUILD_TARGET_OPT</code> is defined and neither <code>BDE_BUILD_TARGET_SAFE</code> nor <code>BDE_BUILD_TARGET_SAFE_2</code> is defined, then only <code>BSLS_ASSERT_OPT</code> instantiates. If, however, either <code>BDE_BUILD_TARGET_SAFE</code> or <code>BDE_BUILD_TARGET_SAFE_2</code> is defined, then all three "ASSERT" macros, <code>BSLS_ASSERT_SAFE</code>, <code>BSLS_ASSERT</code>, and <code>BSLS_ASSERT_OPT</code>, instantiate (regardless of whether or not <code>BDE_BUILD_TARGET_OPT</code> happens to be defined). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="assertion-level_flags"></a> <a class="anchor" id="build_modes_(build_targets_and_assertion-level_flags).assertion-level_flags"></a> <a class="anchor" id="description.build_modes_(build_targets_and_assertion-level_flags).assertion-level_flags"></a> <a class="anchor" id="4.3.2"></a> </dd></dl>
<dl class="user"><dt><b>Assertion-Level Flags: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>With respect to the instantiation of the three (BSLS) "ASSERT" macros, if any one of the four assertion-level flags is defined, all definitions of <em>build</em> <em>targets</em> are ignored, and that flag alone controls which (BSLS) "ASSERT" macros will instantiate. (Multiple assertion-level flag definitions are reported as errors at compile time for every translation unit that includes <code><a class="el" href="bsls__assert_8h.html" title="Provide build-specific, runtime-configurable assertion macros.">bsls_assert.h</a></code>.) The following table indicates the effect of defining each of the four mutually exclusive (BSLS) assertion- level flags on the instantiation of each of the four (BSLS) "ASSERT" macros: <br/>
<br/>
<div class="fragment"><pre class="fragment">  ===========================================================================
  <span class="stringliteral">&quot;ASSERT&quot;</span> Macro Instantiation Assuming *ONE* Assertion-Level Flag is Defined
  ===========================================================================
   BSLS Assertion-Level Flag |~~~~~~~~~~~~ BSLS <span class="stringliteral">&quot;ASSERT&quot;</span> MACROS ~~~~~~~~~~~~|
                                    I.              II.            III.
         BSLS_ASSERT_...     <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>  <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>   <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>
      ---------------------  ----------------  ------------  ---------------
  (1) ..._LEVEL_ASSERT_SAFE    INSTANTIATES    INSTANTIATES    INSTANTIATES
  (2) ..._LEVEL_ASSERT                         INSTANTIATES    INSTANTIATES
  (3) ..._LEVEL_ASSERT_OPT                                     INSTANTIATES
  (4) ..._LEVEL_NONE

  ==========================================================================
</pre></div><br/>
<br/>
 As the table above illustrates, if the <code>BSLS_ASSERT_LEVEL_ASSERT_SAFE</code> assertion-level flag is defined, then all three macros, <code>BSLS_ASSERT_SAFE</code>, <code>BSLS_ASSERT</code>, and <code>BSLS_ASSERT_OPT</code>, instantiate. If instead the <code>BSLS_ASSERT_LEVEL_ASSERT</code> flag is defined, then only <code>BSLS_ASSERT</code> and <code>BSLS_ASSERT_OPT</code> instantiate. Otherwise, if <code>BSLS_ASSERT_LEVEL_ASSERT_OPT</code> is the only assertion-level flag defined, then just <code>BSLS_ASSERT_OPT</code> instantiates. Finally, if the <code>BSLS_ASSERT_LEVEL_NONE</code> flag is the one defined then none of the three "ASSERT" macros will instantiate. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="runtime-configurable_assertion-failure_behavior"></a> <a class="anchor" id="description.runtime-configurable_assertion-failure_behavior"></a> <a class="anchor" id="4.4"></a> </dd></dl>
<dl class="user"><dt><b>Runtime-Configurable Assertion-Failure Behavior: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In addition to the three (BSLS) "ASSERT" macros, <code>BSLS_ASSERT</code>, <code>BSLS_ASSERT_SAFE</code>, and <code>BSLS_ASSERT_OPT</code>, this component provides (1) an <code>invokeHandler</code> method used (primarily) to implement these three "ASSERT" macros and enable their runtime configuration, (2) administration methods to configure, at runtime, the behavior resulting from an assertion failure (i.e., by installing an appropriate assertion-failure handler function), and (3) a suite of standard ("off-the-shelf") assertion-failure handler functions, to be installed via the administrative methods (if desired), and invoked by the <code>invokeHandler</code> method on an assertion failure. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When an assertion fails, the currently installed <em>failure</em> <em>handler</em> ("callback") function is invoked. The default handler is the (<code>static</code>) <code><a class="el" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a></code> method; a user may replace this default handler by using the (<code>static</code>) <code><a class="el" href="classbsls_1_1Assert.html#a858135de85382a93ab42d8ef24b114cb">bsls::Assert::setFailureHandler</a></code> administrative method and passing it (the address of) a function whose signature conforms to the <code><a class="el" href="classbsls_1_1Assert.html#af88d17790bace0f850ae6f48faf63b02">bsls::Assert::Handler</a></code> <code>typedef</code>. This handler may be one of the other handler methods provided in <code><a class="el" href="classbsls_1_1Assert.html">bsls::Assert</a></code>, or a new "custom" function, written by the user (see "Usage Examples" below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception-throwing_failure_handlers_and_bsls~3A~3Aassertfailurehandlerguard"></a> <a class="anchor" id="runtime-configurable_assertion-failure_behavior.exception-throwing_failure_handlers_and_bsls~3A~3Aassertfailurehandlerguard"></a> <a class="anchor" id="description.runtime-configurable_assertion-failure_behavior.exception-throwing_failure_handlers_and_bsls~3A~3Aassertfailurehandlerguard"></a> <a class="anchor" id="4.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Exception-Throwing Failure Handlers and bsls::AssertFailureHandlerGuard: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Among the failure handlers provided is <code><a class="el" href="classbsls_1_1Assert.html#af7b3b9be1016c988537502f0b0a4e658">bsls::Assert::failThrow</a></code>, which throws an <code><a class="el" href="classbsls_1_1AssertTestException.html">bsls::AssertTestException</a></code> object. Throwing an exception, however, is not safe in all environments and deliberately aborting is more useful in a debugging context than throwing an unhandled exception. Hence, in order for an <code><a class="el" href="classbsls_1_1AssertTestException.html">bsls::AssertTestException</a></code> object to be thrown on an assertion failure, the user must first install the <code><a class="el" href="classbsls_1_1Assert.html#af7b3b9be1016c988537502f0b0a4e658">bsls::Assert::failThrow</a></code> handler (or another exception-throwing handler) explicitly. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that an object of type <code><a class="el" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a></code> can be used to temporarily set an exception-throwing handler within a <code>try</code> block, automatically restoring the previous handler when the <code>try</code> block exits (see "Usage Examples" below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="assertions_in_header_files_(mixing_build_options_across_translation_units)"></a> <a class="anchor" id="description.assertions_in_header_files_(mixing_build_options_across_translation_units)"></a> <a class="anchor" id="4.5"></a> </dd></dl>
<dl class="user"><dt><b>Assertions in Header Files (Mixing Build Options Across Translation Units): </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Mixing build modes across translation units, although not strictly conformant with the the C++ language standard, is permissible in practice; however, the defensive checks that are enabled may be unpredictable. The <em>one-definition</em> <em>rule</em> states that if there are multiple definitions of an object or function within a program, these definitions <em>must</em> be identical or else the program is <em>ill-formed</em>. Unfortunately, definitions in header files may not be identical across object (<code>.o</code>) files if the build targets or assertion-level flags defined during translation (preprocessing) are not the same. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, consider an <code>inline</code> function that sets the width of a <code>Square</code> and optionally checks for (defends against) a negative <code>width</code> argument: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// our_square.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">inline</span>
  <span class="keywordtype">void</span> Square::setWidth(<span class="keywordtype">int</span> width)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(width &gt;= 0);

      d_width = width;
  }
</pre></div><br/>
<br/>
 Now consider a client that uses this <code>setWidth</code> method: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_client.cpp</span>
  <span class="comment">// ...</span>
  <span class="keywordtype">void</span> f()
  {
      Square s;
      s.setWidth(-5);
  }
</pre></div><br/>
<br/>
 We can build the <code>our_square</code> component in "safe mode" -- e.g., by incorporating <code>-DBSLS_ASSERT_LEVEL_ASSERT_SAFE</code> on the (Unix) command line. Notice, however, that building client software against a version of <code>our_square.o</code> compiled in "safe mode" does <em>not</em> ensure that all of the <code>BSLS_ASSERT_SAFE</code> macros will be active (will instantiate); instead, the client's build mode will (most likely) govern those instantiations of the <code>BSLS_ASSERT_SAFE</code> macro located within the library. The only way to ensure that all of the <code>BSLS_ASSERT_SAFE</code> macros instantiate is to build the <em>client</em> as well as the library software in "safe mode". </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Inline functions are not the only source of multiple inconsistent definitions. Consider a non-'inline' method <code>reserveCapacity</code> on a <code>List</code> template, parameterized by element <code>TYPE</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// our_list.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> List&lt;TYPE&gt;::reserveCapacity(<span class="keywordtype">int</span> numElements)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(numElements &gt;= 0);
      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 Each different translation unit that invokes <code>reserveCapacity</code> potentially generates another instantiation of this function template. Those translation units that are compiled in "debug mode" (or "safe mode") -- e.g., with <code>BSLS_ASSERT_LEVEL_ASSERT</code> (or <code>BSLS_ASSERT_LEVEL_ASSERT_SAFE</code>) defined -- will incorporate code corresponding to each use of the <code>BSLS_ASSERT</code> macro therein; the rest will not. Which one of these template instantiations the linker uses in the final program is undefined and highly unpredictable. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The bottom line is that, unless clients of a library are compiled with (at least) the same level of assertion enabling as the library itself, not all of the library's defensive checking (for the assertion-level for which the library was compiled) will necessarily be incorporated into the client code. Similarly, compiling a client in a higher-level of defensive checking (e.g., "safe mode") than the library was compiled (e.g., "debug mode") may result in additional defensive checks beyond what the library author intended for the mode (e.g., "debug mode") in which the library was compiled. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that all build modes (except for when <code>BDE_BUILD_TARGET_SAFE_2</code> is defined, see below) are required to be binary compatible (e.g., fields cannot be added to the middle of a <code>struct</code>). Since a component's contract makes no explicit promise about what checking will occur, that contract is not violated when different parts of a program are compiled with different levels of assertion-enabling build options. The only consequence is that a smaller (or larger) number of defensive checks may be active than might otherwise be expected. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="conditional_compilation"></a> <a class="anchor" id="description.conditional_compilation"></a> <a class="anchor" id="4.6"></a> </dd></dl>
<dl class="user"><dt><b>Conditional Compilation: BDE_BUILD_TARGET_SAFE_2 and Assertion Predicates: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>To recap, there are three (mutually compatible) general <em>build</em> <em>targets</em> <ul>
<li>
<code>BDE_BUILD_TARGET_OPT</code>  </li>
<li>
<code>BDE_BUILD_TARGET_SAFE</code>  </li>
<li>
<code>BDE_BUILD_TARGET_SAFE_2</code>  </li>
</ul>
and four (mutually exclusive) component-specific <em>assertion</em> <em>levels</em> <ul>
<li>
<code>BSLS_ASSERT_LEVEL_ASSERT_SAFE</code>  </li>
<li>
<code>BSLS_ASSERT_LEVEL_ASSERT</code>  </li>
<li>
<code>BSLS_ASSERT_LEVEL_ASSERT_OPT</code>  </li>
<li>
<code>BSLS_ASSERT_LEVEL_NONE</code>  </li>
</ul>
that can be defined (externally) by the build environment to affect which of the three <em>assert</em> <em>macros</em> <ol>
<li>
<code>BSLS_ASSERT_SAFE(boolean-valued expression)</code>  </li>
<li>
<code>BSLS_ASSERT(boolean-valued expression)</code>  </li>
<li>
<code>BSLS_ASSERT_OPT(boolean-valued expression)</code>  </li>
</ol>
will be active (i.e., instantiate). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The public interface of this component also explicitly supports three additional, intermediate input macros, called <em>assertion</em> <em>predicates</em> <ol>
<li>
<code>BSLS_ASSERT_SAFE_IS_ACTIVE</code>  </li>
<li>
<code>BSLS_ASSERT_IS_ACTIVE</code>  </li>
<li>
<code>BSLS_ASSERT_OPT_IS_ACTIVE</code>  </li>
</ol>
that are derived from the various combinations of the external inputs, and indicate whether each respective kind of (BSLS) assertion macro is active. These additional "predicate" macros, along with <code>BDE_BUILD_TARGET_SAFE_2</code>, can be used directly by clients of this component to conditionally compile source code other than just (BSLS) assertions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, additional source code that would affect binary compatibility must be conditionally compiled using <code>BDE_BUILD_TARGET_SAFE_2</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #ifdef BDE_BUILD_TARGET_SAFE_2</span>
<span class="preprocessor"></span>
  <span class="comment">// additional (redundant) defensive code that breaks binary compatibility</span>

<span class="preprocessor">  #endif</span>
</pre></div><br/>
<br/>
 However, there may be times when we want to provide code that is binary compatible (and has no other undesirable side-effects) whenever, say, <code>BSLS_ASSERT</code> is active: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #ifdef BSLS_ASSERT_IS_ACTIVE</span>
<span class="preprocessor"></span>
  <span class="comment">// additional (redundant) defensive code that is binary compatible and</span>
  <span class="comment">// should exist whenever &#39;BSLS_ASSERT&#39; is active, but not otherwise</span>

<span class="preprocessor">  #endif</span>
</pre></div><br/>
<br/>
 Note that <code>BSLS_ASSERT_IS_ACTIVE</code> implies <code>BSLS_ASSERT_OPT_IS_ACTIVE</code>, but not <code>BSLS_ASSERT_SAFE_IS_ACTIVE</code>. Also note that (redundant) defensive code that is intended to be active in <em>all</em> build modes -- like <code>BSLS_ASSERT_OPT</code> -- should nonetheless be conditionally compiled (to enable verification that the runtime overhead is truly negligible): <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #ifdef BSLS_ASSERT_OPT_IS_ACTIVE</span>
<span class="preprocessor"></span>
  <span class="comment">// additional (redundant) defensive code that is binary compatible and</span>
  <span class="comment">// should exist even in an optimized build</span>

<span class="preprocessor">  #endif</span>
</pre></div><br/>
<br/>
 See "Usage Examples" 6 &amp; 7, respectively, for how <code>BDE_BUILD_TARGET_SAFE_2</code> and intermediate assertion predicate macros, such as <code>BSLS_ASSERT_SAFE_IS_ACTIVE</code> (and even <code>BSLS_ASSERT_OPT_IS_ACTIVE</code>), can be used profitably in practice. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage_examples"></a> <a class="anchor" id="description.usage_examples"></a> <a class="anchor" id="4.7"></a> </dd></dl>
<dl class="user"><dt><b>Usage Examples: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following examples illustrate (1) when to use each of the three kinds of (BSLS) "ASSERT" macros, (2) when and how to call the <code>invokeHandler</code> method directly, (3) how to configure, at runtime, the behavior resulting from an assertion failure using "off-the-shelf" handler methods, (4) how to create your own custom assertion-failure handler function, (5) proper use of <code><a class="el" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a></code> to install, temporarily, an exception-producing assert handler, (6) how "ASSERT" macros would be used in conjunction with portions of the source code (affecting binary compatibility) that are incorporated only when <code>BDE_BUILD_TARGET_SAFE_2</code> is defined, and (7) how assertion predicates (e.g., <code>BSLS_ASSERT_SAFE_IS_ACTIVE</code>) are used to conditionally compile additional (redundant) defensive source code (not affecting binary compatibility) precisely when the corresponding (BSLS) "ASSERT" macro (e.g., <code>BSLS_ASSERT_SAFE</code>) is active. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="1._using_bsls_assert,_bsls_assert_safe,_and_bsls_assert_opt"></a> <a class="anchor" id="usage_examples.1._using_bsls_assert,_bsls_assert_safe,_and_bsls_assert_opt"></a> <a class="anchor" id="description.usage_examples.1._using_bsls_assert,_bsls_assert_safe,_and_bsls_assert_opt"></a> <a class="anchor" id="4.7.1"></a> </dd></dl>
<dl class="user"><dt><b>1. Using BSLS_ASSERT, BSLS_ASSERT_SAFE, and BSLS_ASSERT_OPT: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides three different variants of (BSLS) "ASSERT" macros. This first usage example illustrates how one might select each of the particular variants, based on the runtime cost of the defensive check relative to that of the useful work being done. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Use of the <code>BSLS_ASSERT_SAFE</code> macro is often appropriate when the defensive check occurs within the body of an <code>inline</code> function. The <code>BSLS_ASSERT_SAFE</code> macro minimizes the impact on runtime performance as it is instantiated only when requested (i.e., by building in "safe mode"). For example, consider a light-weight point class <code>Kpoint</code> that maintains <code>x</code> and <code>y</code> coordinates in the range <code>[ -1000 .. 1000 ]</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_kpoint.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">class </span>Kpoint {
      <span class="keywordtype">short</span> <span class="keywordtype">int</span> d_x;
      <span class="keywordtype">short</span> <span class="keywordtype">int</span> d_y;
    <span class="keyword">public</span>:
      Kpoint(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y);
          <span class="comment">// ...</span>
          <span class="comment">// The behavior is undefined unless &#39;-1000 &lt;= x &lt;= 1000&#39;</span>
          <span class="comment">// and &#39;-1000 &lt;= y &lt;= 1000&#39;.</span>
      <span class="comment">// ...</span>
  };

  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Since the cost of validation here is significant compared with the useful work being done, we might choose to implement defensive checks using <code>BSLS_ASSERT_SAFE</code> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// ...</span>

  <span class="keyword">inline</span>
  Kpoint::Kpoint(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
  : d_x(x)
  , d_y(y)
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(-1000 &lt;= x); <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(x &lt;= 1000);
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(-1000 &lt;= y); <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(y &lt;= 1000);
  }
</pre></div><br/>
<br/>
 For more substantial (non-'inline') functions, we would be more likely to use the <code>BSLS_ASSERT</code> macro because the runtime overhead due to defensive checks is likely to be much less significant. For example, consider a hash-table class that allows the client to resize the underlying table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_hashtable.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">class </span>HashTable {
      <span class="comment">// ...</span>
    <span class="keyword">public</span>:
      <span class="comment">// ...</span>

      <span class="keywordtype">void</span> resize(<span class="keywordtype">double</span> loadFactor);
          <span class="comment">// Adjust the size of the underlying hash table to be</span>
          <span class="comment">// approximately the current number of elements divided</span>
          <span class="comment">// by the specified &#39;loadFactor&#39;.  The behavior is undefined</span>
          <span class="comment">// unless &#39;0 &lt; loadFactor&#39;.</span>
  };
</pre></div><br/>
<br/>
 Since the relative runtime cost of validating the input argument is quite small (e.g., less than 10%) compared to the typical work being done, we might choose to implement the defensive check using <code>BSLS_ASSERT</code> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_hashtable.cpp</span>
  <span class="comment">// ...</span>

  <span class="keywordtype">void</span> HashTable::resize(<span class="keywordtype">double</span> loadFactor)
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt; loadFactor);

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 In some cases, the runtime cost of checking is always negligible when compared with the runtime cost of performing the useful work; moreover, the consequences of continuing in an undefined state for certain applications could be catastrophic. Instead of using <code>BSLS_ASSERT</code> in such cases, we might consider using <code>BSLS_ASSERT_OPT</code>. For example, suppose we have a financial application class <code>TradingSystem</code> that performs trades: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_tradingsystem.h</span>
  <span class="comment">// ...</span>

  <span class="keyword">class </span>TradingSystem {
      <span class="comment">// ...</span>
    <span class="keyword">public</span>:
      <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 Further suppose that there is a particular method <code>executeTrade</code> that takes, as a scaling factor, an integer that must be a multiple of 100 or the behavior is undefined (and might actually execute a trade): <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordtype">void</span> executeTrade(<span class="keywordtype">int</span> scalingFactor);
          <span class="comment">// Execute the current trade using the specified &#39;scalingFactor&#39;.</span>
          <span class="comment">// The behavior is undefined unless &#39;0 &lt;= scalingFactor&#39; and</span>
          <span class="comment">// &#39;100&#39; evenly divides &#39;scalingFactor&#39;.</span>
      <span class="comment">// ...</span>
  };
</pre></div><br/>
<br/>
 Because the cost of the two checks is likely not even measurable compared to the overhead of accessing databases and executing the trade, and because the consequences of specifying a bad scaling factor are virtually unbounded, we might choose to implement these defensive checks using <code>BSLS_ASSERT_OPT</code> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// my_tradingsystem.cpp</span>
  <span class="comment">// ...</span>

  <span class="keywordtype">void</span> TradingSystem::executeTrade(<span class="keywordtype">int</span> scalingFactor)
  {
      <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>(0 &lt;= scalingFactor);
      <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>(0 == scalingFactor % 100);

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 Notice that in each case, the choice of which of the three (BSLS) "ASSERT" macros to use is governed primarily by the relative runtime cost compared with that of the useful work being done (and only secondarily by the potential consequences of continuing execution in an undefined state). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="2._when_and_how_to_call_the_invokehandler_method_directly"></a> <a class="anchor" id="usage_examples.2._when_and_how_to_call_the_invokehandler_method_directly"></a> <a class="anchor" id="description.usage_examples.2._when_and_how_to_call_the_invokehandler_method_directly"></a> <a class="anchor" id="4.7.2"></a> </dd></dl>
<dl class="user"><dt><b>2. When and How to Call the invokeHandler Method Directly: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There <em>may</em> be times (but this is yet to be demonstrated) when we might reasonably choose to invoke the currently installed assertion-failure handler directly -- i.e., instead of via one of the three (BSLS) "ASSERT" macros provided in this component. Suppose that we are currently in the body of some function <code>someFunc</code> and, for whatever reason, feel compelled to invoke the currently installed assertion-failure handler based on some criteria other than the current build mode. The call might look as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> someFunc(<span class="keywordtype">bool</span> a, <span class="keywordtype">bool</span> b, <span class="keywordtype">bool</span> c)
  {
      <span class="keywordtype">bool</span> someCondition = a &amp;&amp; b &amp;&amp; !c;

      <span class="keywordflow">if</span> (someCondition) {
          <a class="code" href="classbsls_1_1Assert.html#ac809c4c1ef9ec0e5616a2923f216957f">bsls::Assert::invokeHandler</a>(<span class="stringliteral">&quot;Bad News&quot;</span>, __FILE__, __LINE__);
      }
  }
</pre></div><br/>
<br/>
 If presented with invalid arguments, <code>someFunc</code> (above) will produce output similar to the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Assertion failed: Bad News, file bsls_assert.t.cpp, line 365
  Abort (core dumped)
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="3._runtime_configuration_of_the_bsls~3A~3Aassert_facility"></a> <a class="anchor" id="usage_examples.3._runtime_configuration_of_the_bsls~3A~3Aassert_facility"></a> <a class="anchor" id="description.usage_examples.3._runtime_configuration_of_the_bsls~3A~3Aassert_facility"></a> <a class="anchor" id="4.7.3"></a> </dd></dl>
<dl class="user"><dt><b>3. Runtime Configuration of the bsls::Assert Facility: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>By default, any assertion failure will result in the invocation of the <code><a class="el" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a></code> handler function. We can replace this behavior with that of one of the other static failure handler methods supplied in <code><a class="el" href="classbsls_1_1Assert.html">bsls::Assert</a></code> as follows. Let's assume we are at the top of our application called <code>myMain</code> (which would typically be <code>main</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> myMain()
  {
</pre></div><br/>
<br/>
 First observe that the default assertion-failure handler function is, in fact, <code><a class="el" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(&amp;<a class="code" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a> == <a class="code" href="classbsls_1_1Assert.html#a69345d2f503edb36027a3e5641b714f6">bsls::Assert::failureHandler</a>());
</pre></div><br/>
<br/>
 Next, we install a new assertion-failure handler function, <code><a class="el" href="classbsls_1_1Assert.html#a415c7cbe1f8010a13bc654a1b3f532d6">bsls::Assert::failSleep</a></code>, from the suite of "off-the-shelf" handlers provided as <code>static</code> methods of <code><a class="el" href="classbsls_1_1Assert.html">bsls::Assert</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsls_1_1Assert.html#a858135de85382a93ab42d8ef24b114cb">bsls::Assert::setFailureHandler</a>(&amp;<a class="code" href="classbsls_1_1Assert.html#a415c7cbe1f8010a13bc654a1b3f532d6">bsls::Assert::failSleep</a>);
</pre></div><br/>
<br/>
 Observe that <code><a class="el" href="classbsls_1_1Assert.html#a415c7cbe1f8010a13bc654a1b3f532d6">bsls::Assert::failSleep</a></code> is the new, currently-installed assertion-failure handler: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(&amp;<a class="code" href="classbsls_1_1Assert.html#a415c7cbe1f8010a13bc654a1b3f532d6">bsls::Assert::failSleep</a> == <a class="code" href="classbsls_1_1Assert.html#a69345d2f503edb36027a3e5641b714f6">bsls::Assert::failureHandler</a>());
</pre></div><br/>
<br/>
 Note that if we were to explicitly invoke the current assertion-failure handler as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsls_1_1Assert.html#ac809c4c1ef9ec0e5616a2923f216957f">bsls::Assert::invokeHandler</a>(<span class="stringliteral">&quot;message&quot;</span>, <span class="stringliteral">&quot;file&quot;</span>, 27);  <span class="comment">// This will hang!</span>
</pre></div><br/>
<br/>
 the program will hang since <code><a class="el" href="classbsls_1_1Assert.html#a415c7cbe1f8010a13bc654a1b3f532d6">bsls::Assert::failSleep</a></code> repeatedly sleeps for a period of time within an infinite loop. Thus, this assertion-failure handler is useful for hanging a process so that a debugger may be attached to it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We may now decide to disable the <code>setFailureHandler</code> method using the <code><a class="el" href="classbsls_1_1Assert.html#a4ba3635126eb08b5de58c75ece963dce">bsls::Assert::lockAssertAdministration()</a></code> method to ensure that no one else will override our decision globally. Note, however, that the <code><a class="el" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a></code> is not affected, and can still be used to supplant the currently installed handler (see below): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsls_1_1Assert.html#a4ba3635126eb08b5de58c75ece963dce">bsls::Assert::lockAssertAdministration</a>();
</pre></div><br/>
<br/>
 Attempting to change the currently installed handler now will fail: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsls_1_1Assert.html#a858135de85382a93ab42d8ef24b114cb">bsls::Assert::setFailureHandler</a>(&amp;<a class="code" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a>);

      assert(&amp;<a class="code" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a> != <a class="code" href="classbsls_1_1Assert.html#a69345d2f503edb36027a3e5641b714f6">bsls::Assert::failureHandler</a>());

      assert(&amp;<a class="code" href="classbsls_1_1Assert.html#a415c7cbe1f8010a13bc654a1b3f532d6">bsls::Assert::failSleep</a> == <a class="code" href="classbsls_1_1Assert.html#a69345d2f503edb36027a3e5641b714f6">bsls::Assert::failureHandler</a>());
  }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="4._creating_a_custom_assertion_handler"></a> <a class="anchor" id="usage_examples.4._creating_a_custom_assertion_handler"></a> <a class="anchor" id="description.usage_examples.4._creating_a_custom_assertion_handler"></a> <a class="anchor" id="4.7.4"></a> </dd></dl>
<dl class="user"><dt><b>4. Creating a Custom Assertion Handler: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Sometimes, especially during testing, we may need to write our own custom assertion-failure handler function. The only requirements are that the function have the same prototype (i.e., the same respective parameter and return types) as the <code>bsls::Assert::Handle</code> <code>typedef</code>, and that the function should not return (i.e., it must <code>abort</code>, <code>exit</code>, <code>terminate</code>, <code>throw</code>, or hang). To illustrate, we will create a <code>static</code> method at file scope that conforms to the required structure (notice the explicit use of <code>std::printf</code> from <code>&lt;cstdio&gt;</code> instead of <code>std::cout</code> from <code>&lt;iostream&gt;</code> to avoid interaction with the C++ memory allocation layer): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">static</span> <span class="keywordtype">bool</span> globalEnableOurPrintingFlag = <span class="keyword">true</span>;

  <span class="keyword">static</span>
  <span class="keywordtype">void</span> ourFailureHandler(<span class="keyword">const</span> <span class="keywordtype">char</span> *text, <span class="keyword">const</span> <span class="keywordtype">char</span> *file, <span class="keywordtype">int</span> line)
      <span class="comment">// Print the specified expression &#39;text&#39;, &#39;file&#39; name, and &#39;line&#39;</span>
      <span class="comment">// number to &#39;stdout&#39; as a comma-separated list, replacing null</span>
      <span class="comment">// string-argument values with empty strings (unless printing has been</span>
      <span class="comment">// disabled by the &#39;globalEnableOurPrintingFlag&#39; variable), then</span>
      <span class="comment">// unconditionally abort.</span>
  {
      <span class="keywordflow">if</span> (!text) {
          text = <span class="stringliteral">&quot;&quot;</span>;
      }
      <span class="keywordflow">if</span> (!file) {
          file = <span class="stringliteral">&quot;&quot;</span>;
      }
      <span class="keywordflow">if</span> (globalEnableOurPrintingFlag) {
          std::printf(<span class="stringliteral">&quot;%s, %s, %d\n&quot;</span>, text, file, line);
      }
      std::abort();
  }
</pre></div><br/>
<br/>
 At the top level of our application we have the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> ourMain()
  {
</pre></div><br/>
<br/>
 First, let's observe that we can assign this new function to a function pointer of type <code><a class="el" href="classbsls_1_1Assert.html#af88d17790bace0f850ae6f48faf63b02">bsls::Assert::Handler</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsls_1_1Assert.html#af88d17790bace0f850ae6f48faf63b02">bsls::Assert::Handler</a> f = &amp;::ourFailureHandler;
</pre></div><br/>
<br/>
 Now we can install it just as we would any other handler: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsls_1_1Assert.html#a858135de85382a93ab42d8ef24b114cb">bsls::Assert::setFailureHandler</a>(&amp;::ourFailureHandler);
</pre></div><br/>
<br/>
 We can now invoke the default handler directly: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsls_1_1Assert.html#ac809c4c1ef9ec0e5616a2923f216957f">bsls::Assert::invokeHandler</a>(<span class="stringliteral">&quot;str1&quot;</span>, <span class="stringliteral">&quot;str2&quot;</span>, 3);
  }
</pre></div><br/>
<br/>
 With the resulting output as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  str1, str2, 3
  Abort (core dumped)
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="5._using_the_bsls~3A~3Aassertfailurehandlerguard"></a> <a class="anchor" id="usage_examples.5._using_the_bsls~3A~3Aassertfailurehandlerguard"></a> <a class="anchor" id="description.usage_examples.5._using_the_bsls~3A~3Aassertfailurehandlerguard"></a> <a class="anchor" id="4.7.5"></a> </dd></dl>
<dl class="user"><dt><b>5. Using the bsls::AssertFailureHandlerGuard: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Sometimes we may want to replace, temporarily (i.e., within some local lexical scope), the currently installed assertion-failure handler function. In particular, we sometimes use the <code><a class="el" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a></code> class to replace the current handler with one that throws an exception (because we know that such an exception is safe in the local context). Let's start with the simple factorial function below, which validates, in "debug mode" (or "safe mode"), that its input is non-negative: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> fact(<span class="keywordtype">int</span> n)
      <span class="comment">// Return &#39;n!&#39;.  The behavior is undefined unless &#39;0 &lt;= n&#39;.</span>
  {
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(0 &lt;= n);

      <span class="keywordtype">double</span> result = 1.0;
      <span class="keywordflow">while</span> (n &gt; 1) {
          result *= n--;
      }
      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Now consider the following integer-valued <code>extern "C"</code> C++ function, <code>wrapperFunc</code>, which can be called from C and FORTRAN, as well as from C++: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">int</span> wrapperFunc(<span class="keywordtype">bool</span> verboseFlag)
  {
      <span class="keyword">enum</span> { GOOD = 0, BAD } result = GOOD;
</pre></div><br/>
<br/>
 The purpose of this function is to allow assertion failures in subroutine calls below this function to be handled by throwing an exception, which is then caught by the wrapper and reported to the caller as a "bad" status. Hence, when within the runtime scope of this function, we want to install, temporarily, the assertion-failure handler <code><a class="el" href="classbsls_1_1Assert.html#af7b3b9be1016c988537502f0b0a4e658">bsls::Assert::failThrow</a></code>, which, when invoked, causes an <code><a class="el" href="classbsls_1_1AssertTestException.html">bsls::AssertTestException</a></code> object to be thrown. (Note that we are not advocating this approach for "recovery", but rather for an orderly shut-down, or perhaps during testing.) The <code><a class="el" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a></code> class is provided for just this purpose: <br/>
<br/>
<div class="fragment"><pre class="fragment">      assert(&amp;<a class="code" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a> == <a class="code" href="classbsls_1_1Assert.html#a69345d2f503edb36027a3e5641b714f6">bsls::Assert::failureHandler</a>());

      <a class="code" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a> guard(&amp;<a class="code" href="classbsls_1_1Assert.html#af7b3b9be1016c988537502f0b0a4e658">bsls::Assert::failThrow</a>);

      assert(&amp;<a class="code" href="classbsls_1_1Assert.html#af7b3b9be1016c988537502f0b0a4e658">bsls::Assert::failThrow</a> == <a class="code" href="classbsls_1_1Assert.html#a69345d2f503edb36027a3e5641b714f6">bsls::Assert::failureHandler</a>());
</pre></div><br/>
<br/>
 Next we open up a <code>try</code> block, and somewhere within the <code>try</code> we "accidentally" invoke <code>fact</code> with an out-of-contract value (i.e., <code>-1</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #ifdef BDE_BUILD_TARGET_EXC</span>
<span class="preprocessor"></span>      <span class="keywordflow">try</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>          {

          <span class="comment">// ...</span>

          <span class="keywordtype">double</span> d = fact(-1);        <span class="comment">// Out-of-contract call to &#39;fact&#39;.</span>

          <span class="comment">// ...</span>
      }
<span class="preprocessor">  #ifdef BDE_BUILD_TARGET_EXC</span>
<span class="preprocessor"></span>      <span class="keywordflow">catch</span> (<span class="keyword">const</span> <a class="code" href="classbsls_1_1AssertTestException.html">bsls::AssertTestException</a>&amp; e) {
          result = BAD;
          <span class="keywordflow">if</span> (verboseFlag) {
              std::cout &lt;&lt; <span class="stringliteral">&quot;Internal Error: &quot;</span> &lt;&lt; e.what() &lt;&lt; std::endl;
          }
      }
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Assuming exceptions are enabled (i.e., <code>BDE_BUILD_TARGET_EXC</code> is defined), if an <code><a class="el" href="classbsls_1_1AssertTestException.html">bsls::AssertTestException</a></code> occurs below this wrapper function, the exception will be caught, a message will be printed to <code>stdout</code>, e.g., <br/>
<br/>
<div class="fragment"><pre class="fragment">  Internal Error: bsls_assert.t.cpp:500: 0 &lt;= n
</pre></div><br/>
<br/>
 and the <code>wrapperFunc</code> function will return a bad status (i.e., 1) to its caller. Note that if exceptions are not enabled, <code><a class="el" href="classbsls_1_1Assert.html#af7b3b9be1016c988537502f0b0a4e658">bsls::Assert::failThrow</a></code> will behave as <code><a class="el" href="classbsls_1_1Assert.html#a330f1589f484ad67d234454c1bc53966">bsls::Assert::failAbort</a></code>, and dump core immediately: <br/>
<br/>
<div class="fragment"><pre class="fragment"> Assertion failed: 0 &lt;= n, file bsls_assert.t.cpp, line 500
 Abort (core dumped)
</pre></div><br/>
<br/>
 Finally note that the <code><a class="el" href="classbsls_1_1AssertFailureHandlerGuard.html">bsls::AssertFailureHandlerGuard</a></code> is not thread-aware. In particular, a guard that is created in one thread will also affect the failure handlers that are used in other threads. Care should be taken when using this guard when more than a single thread is executing. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="6._using_(bsls)_~22assert~22_macros_in_conjunction_w~2F_bde_build_target_safe_2"></a> <a class="anchor" id="usage_examples.6._using_(bsls)_~22assert~22_macros_in_conjunction_w~2F_bde_build_target_safe_2"></a> <a class="anchor" id="description.usage_examples.6._using_(bsls)_~22assert~22_macros_in_conjunction_w~2F_bde_build_target_safe_2"></a> <a class="anchor" id="4.7.6"></a> </dd></dl>
<dl class="user"><dt><b>6. Using (BSLS) "ASSERT" Macros in Conjunction w/ BDE_BUILD_TARGET_SAFE_2: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Recall that assertions do not affect binary compatibility; however, software built with <code>BDE_BUILD_TARGET_SAFE_2</code> defined need not be binary compatible with software built otherwise. In this example, we look at how we might use the (BSLS) "ASSERT" family of macros in conjunction with code that is incorporated (at compile time) only when <code>BDE_BUILD_TARGET_SAFE_2</code> is defined. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As a simple example, let's consider an elided implementation of a singly-linked integer list and its iterator. Whenever <code>BDE_BUILD_TARGET_SAFE_2</code> is defined, we want to defend against the possibility that a client mistakenly passes a <code>ListIter</code> object into a <code>List</code> object method (e.g., <code>List::insert</code>) where that <code>ListIter</code> object did not originate from the same <code>List</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We'll start by defining a local helper <code>List_Link</code> <code>struct</code> as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>List_Link {
      List_Link *d_next_p;
      <span class="keywordtype">int</span>        d_data;
      List_Link(List_Link *next, <span class="keywordtype">int</span> data) : d_next_p(next), d_data(data) { }
  };
</pre></div><br/>
<br/>
 Next, we'll define <code>ListIter</code>, which always identifies the current position in a sequence of links, but whenever <code>BDE_BUILD_TARGET_SAFE_2</code> is defined, also maintains a pointer to its parent <code>List</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>List;                         <span class="comment">// Forward declaration.</span>

  <span class="keyword">class </span>ListIter {
<span class="preprocessor">  #ifdef BDE_BUILD_TARGET_SAFE_2</span>
<span class="preprocessor"></span>      List *d_parent_p;               <span class="comment">// Exists only in &quot;safe 2 mode&quot;.</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>      List_Link **d_current_p;
      <span class="keyword">friend</span> <span class="keyword">class </span>List;
      <span class="keyword">friend</span> <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> ListIter&amp;, <span class="keyword">const</span> ListIter&amp;);
    <span class="keyword">private</span>:
      ListIter(List_Link **current,
               List *
  #ifdef BDE_BUILD_TARGET_SAFE_2
                     parent           <span class="comment">// Not used unless in &quot;safe 2 mode&quot;.</span>
  #endif
              )
      : d_current_p(current)
  #ifdef BDE_BUILD_TARGET_SAFE_2
      , d_parent_p(parent)            <span class="comment">// Initialize only in &quot;safe 2 mode&quot;.</span>
  #endif
      { }
    <span class="keyword">public</span>:
      ListIter&amp; <a class="code" href="namespacebslstl.html#a00890c2044ab22c5074a3d85283319d0">operator++</a>() { <span class="comment">/* ... */</span> <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
      <span class="comment">// ...</span>
  };
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> ListIter&amp; lhs, <span class="keyword">const</span> ListIter&amp; rhs);
  <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#acf8107f12ec28380f11b968856544276">operator!=</a>(<span class="keyword">const</span> ListIter&amp; lhs, <span class="keyword">const</span> ListIter&amp; rhs);
</pre></div><br/>
<br/>
 Finally we define the <code>List</code> class itself with most of the operations elided; the methods of particular interest here are <code>begin</code> and <code>insert</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>List {
      List_Link *d_head_p;
    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      List() : d_head_p(0) { }
      List(<span class="keyword">const</span> List&amp; original) { <span class="comment">/* ... */</span> }
      ~List() { <span class="comment">/* ... */</span> }

      <span class="comment">// MANIPULATORS</span>
      List&amp; operator=(<span class="keyword">const</span> List&amp; rhs) { <span class="comment">/* ... */</span> <span class="keywordflow">return</span> *<span class="keyword">this</span>; }

      <span class="comment">//| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |</span>
      <span class="comment">//v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v</span>
      <span class="comment">//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span>
      ListIter begin()
          <span class="comment">// Return an iterator referring to the beginning of this list.</span>
      {
          <span class="keywordflow">return</span> ListIter(&amp;d_head_p, <span class="keyword">this</span>);
      }
      <span class="comment">//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span>

      <span class="comment">//| | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | | |</span>
      <span class="comment">//v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v v</span>
      <span class="comment">//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span>
      <span class="keywordtype">void</span> insert(<span class="keyword">const</span> ListIter&amp; position, <span class="keywordtype">int</span> data)
          <span class="comment">// Insert the specified &#39;data&#39; value into this list at the</span>
          <span class="comment">// specified &#39;position&#39;.</span>
      {
<span class="preprocessor">  #ifdef BDE_BUILD_TARGET_SAFE_2</span>
<span class="preprocessor"></span>          <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(<span class="keyword">this</span> == position.d_parent_p);  <span class="comment">// &quot;safe 2 mode&quot;</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>          *position.d_current_p = <span class="keyword">new</span> List_Link(*position.d_current_p, data);
      }
      <span class="comment">//:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">void</span> print(std::ostream&amp; stream)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          stream &lt;&lt; <span class="charliteral">&#39;[&#39;</span>;
          <span class="keywordflow">for</span> (List_Link *p = d_head_p; p; p = p-&gt;d_next_p) {
              stream &lt;&lt; <span class="charliteral">&#39; &#39;</span> &lt;&lt; p-&gt;d_data;
          }
          stream &lt;&lt; <span class="stringliteral">&quot; ]&quot;</span> &lt;&lt; std::endl;
      }
  };
</pre></div><br/>
<br/>
 Outside of "safe 2 mode", it is possible to pass an iterator object obtained from the <code>begin</code> method of one <code>List</code> object into the <code>insert</code> method of another, having, perhaps, unexpected results: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> sillyFunc(<span class="keywordtype">bool</span> printFlag)
  {
      List a;
      ListIter aIt = a.begin();
      a.insert(aIt, 1);
      a.insert(aIt, 2);
      a.insert(aIt, 3);

      <span class="keywordflow">if</span> (printFlag) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;a = &quot;</span>; a.print(std::cout);
      }

      List b;
      ListIter bIt = b.begin();
      a.insert(bIt, 4);       <span class="comment">// Oops!  Should have been: &#39;b.insert(bIt, 4);&#39;</span>
      a.insert(bIt, 5);       <span class="comment">// Oops!    &quot;     &quot;     &quot;   &#39;    &quot;     &quot;   5  &#39;</span>
      a.insert(bIt, 6);       <span class="comment">// Oops!    &quot;     &quot;     &quot;   &#39;    &quot;     &quot;   6  &#39;</span>

      <span class="keywordflow">if</span> (printFlag) {
          std::cout &lt;&lt; <span class="stringliteral">&quot;a = &quot;</span>; a.print(std::cout);
          std::cout &lt;&lt; <span class="stringliteral">&quot;b = &quot;</span>; b.print(std::cout);
      }
  }
</pre></div><br/>
<br/>
 In the example above, we have "accidentally" passed the iterator <code>bIt</code> obtained from <code>List</code> object <code>b</code> into the <code>insert</code> method for <code>List</code> object <code>a</code>. The resulting undefined behavior (in other than "safe 2 mode") might produce output that looks as follows: <br/>
<br/>
<div class="fragment"><pre class="fragment">  a = [ 3 2 1 ]
  a = [ 3 2 1 ]
  b = [ 6 5 4 ]
</pre></div><br/>
<br/>
 If the same <code>sillyFunc</code> were compiled in "safe 2 mode" (i.e., with <code>BDE_BUILD_TARGET_SAFE_2</code> defined) the undefined behavior would be detected and the output would, by default, look more like the following: <br/>
<br/>
<div class="fragment"><pre class="fragment">  a = [ 3 2 1 ]
  Assertion failed: <span class="keyword">this</span> == position.d_parent_p, file my_list.cpp, line 56
  Abort (core dumped)
</pre></div><br/>
<br/>
 thereby quickly exposing the misuse by the client. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="7._conditional_compilation_associated_with_enabled_assertion_levels"></a> <a class="anchor" id="usage_examples.7._conditional_compilation_associated_with_enabled_assertion_levels"></a> <a class="anchor" id="description.usage_examples.7._conditional_compilation_associated_with_enabled_assertion_levels"></a> <a class="anchor" id="4.7.7"></a> </dd></dl>
<dl class="user"><dt><b>7. Conditional Compilation Associated with Enabled Assertion Levels: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In cases where we want to tie code, other than just an assertion, to a specific level of enabled assertions, we will want to use the corresponding intermediate predicate that enables that level of assertions: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
For <code>BSLS_ASSERT_SAFE</code>, use <code>BSLS_ASSERT_SAFE_IS_ACTIVE</code>.  </li>
<li>
For <code>BSLS_ASSERT</code>, use <code>BSLS_ASSERT_IS_ACTIVE</code>.  </li>
<li>
For <code>BSLS_ASSERT_OPT</code>, use <code>BSLS_ASSERT_OPT_IS_ACTIVE</code>.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose that we have a class such as <code>MyDate</code> (below) that, except for checking its invariants, would have a trivial destructor. By not declaring a destructor at all, we are able to realize significant performance advantages, but then we lose the ability to validate our invariants in "debug" or "safe" mode. What we want to do is to declare (and later define) the destructor in precisely those build modes for which we would want to assert invariants. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An elided class <code>MyDate</code>, which is based on a serial-date implementation, is provided for reference: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>MyDate {
      <span class="comment">// This class implements a value-semantic &quot;date&quot; type representing</span>
      <span class="comment">// valid date values in the range &#39;[ 0001Jan01 .. 9999Dec31 ]&#39;.</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_serialDate;  <span class="comment">// sequential representation within a valid range</span>

    <span class="keyword">public</span>:
       <span class="comment">// CLASS METHODS</span>

       <span class="comment">// ...</span>

       <span class="comment">// CREATORS</span>
       MyDate();
           <span class="comment">// Create a &#39;MyDate&#39; object having the value &#39;0001Jan01&#39;.</span>

       <span class="comment">// ...</span>

       MyDate(<span class="keyword">const</span> MyDate&amp; original);
           <span class="comment">// Create a &#39;MyDate&#39; object having the same value as the</span>
           <span class="comment">// specified &#39;original&#39; object.</span>

<span class="preprocessor">  #if defined(BSLS_ASSERT_SAFE_IS_ACTIVE)</span>
<span class="preprocessor"></span>       ~MyDate();
           <span class="comment">// Destroy this object.  Note that in some build modes the</span>
           <span class="comment">// destructor generated by the compiler is trivial.</span>
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
      <span class="comment">// ...</span>
  };

  <span class="comment">// ...</span>

  <span class="comment">// =======================================================================</span>
  <span class="comment">//                      INLINE FUNCTION DEFINITIONS</span>
  <span class="comment">// =======================================================================</span>

  <span class="comment">// ...</span>

  <span class="comment">// CREATORS</span>
  <span class="keyword">inline</span>
  MyDate::MyDate()
  : d_serialDate(1)  <span class="comment">// 0001Jan01</span>
  {
  }

  <span class="keyword">inline</span>
  MyDate::MyDate(<span class="keyword">const</span> MyDate&amp; original)
  : d_serialDate(original.d_serialDate)
  {
  }

  <span class="comment">// ...</span>

<span class="preprocessor">  #if defined(BSLS_ASSERT_SAFE_IS_ACTIVE)</span>
<span class="preprocessor"></span>  <span class="keyword">inline</span>
  MyDate::~MyDate()
  {
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(1 &lt;= d_serialDate);             <span class="comment">// 0001Jan01</span>
      <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(     d_serialDate &lt;= 3652061);  <span class="comment">// 9999Dec31</span>
  }
<span class="preprocessor">  #endif</span>
<span class="preprocessor"></span>
  <span class="comment">// ...</span>
</pre></div><br/>
<br/>
 In practice, however, we would probably implement an <code>isValidSerialDate</code> method in a lower-level utility class, e.g., <code>MyDateImpUtil</code>, leading to code that is more fine-grained, modular, and hierarchically reusable: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">inline</span>
  <span class="keywordtype">bool</span> MyDateImpUtil::isValidSerialDate(<span class="keywordtype">int</span> d_date)
  {
      <span class="keywordflow">return</span> 1 &lt;= d_serialDate &amp;&amp; d_serialDate &lt;= 3652061;
  }
</pre></div><br/>
<br/>
 Like other aspects of <code>BSLS_ASSERT_SAFE</code>, the example above benignly violates the one-definition rule for mixed-mode builds. Note that all code conditionally compiled based on <code>BSLS_ASSERT_SAFE_IS_ACTIVE</code>, <code>BSLS_ASSERT_IS_ACTIVE</code>, and <code>BSLS_ASSERT_OPT_IS_ACTIVE</code> should be binary compatible for mixed-mode builds. If the conditionally-compiled code would not be binary compatible, use <code>BDE_BUILD_TARGET_SAFE_2</code> instead. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, in very rare cases, we may want to put in (redundant) defensive code (in the spirit of <code>BSLS_ASSERT_OPT</code>) that is not part of the component-level contract, yet (1) is known to have negligible runtime cost and (2) is deemed to be so important as to be necessary even for optimized builds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>For example, consider again the <code>MyDate</code> class above that now also declares a non-'inline' <code>print</code> method to format the current date value in some human-readable, but otherwise unspecified format: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// xyza_mydate.h</span>
  <span class="comment">// ...</span>
  <span class="keyword">class </span>MyDate {
      <span class="comment">// ...</span>

      <span class="comment">// DATA</span>
      <span class="keywordtype">int</span> d_serialDate;  <span class="comment">// sequential representation within a valid range</span>

    <span class="keyword">public</span>:
      <span class="comment">// ...</span>
      <span class="comment">// ACCESSORS</span>
      <span class="comment">// ...</span>

      std::ostream&amp; print(std::ostream&amp; stream, ...) <span class="keyword">const</span>;
          <span class="comment">// Write the value of this object to the specified output &#39;stream&#39;</span>
          <span class="comment">// in some human-readable format, and return a reference to</span>
          <span class="comment">// &#39;stream&#39;.  Optionally specify ...</span>

      <span class="comment">// ...</span>

  };
</pre></div><br/>
<br/>
 Successfully writing bad data is among the most insidious of bugs, because a latent error can persist and not be discovered until long after the program terminates. Writing the value of a corrupted <code>MyDate</code> object in a <em>machine-readable</em> (binary) format is an error so serious as to warrant invoking <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>(MyDateImpUtil::isValidSerialDate(d_serialDate));
</pre></div><br/>
<br/>
 each time we attempt the output operation; however, printing the value in a human-readable format intended primarily for debugging purposes is another matter. In anything other than a safe build (which in this case would enforce essentially all method preconditions), it would be unfortunate if a developer, knowing that there was a problem involving the use of <code>MyDate</code>, inserted print statements to identify that problem, only to have the <code>print</code> method itself ruthlessly invoke the assert handler, likely terminating the process). Moreover, it may also be unsafe even to attempt to format the value of a <code>MyDate</code> object whose <code>d_serialDate</code> value violates its invariants (e.g., due to a static table lookup). In such cases we may, as sympathetic library developers, choose to implement different undefined (undocumented) redundant defensive behaviors, depending on the desired level of assertions: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// xyza_mydate.cpp</span>
  <span class="comment">// ...</span>
<span class="preprocessor">  #include &lt;xyza_mydateimputil.h&gt;</span>
  <span class="comment">// ...</span>

  std::ostream&amp; MyDate::print(std::ostream&amp; stream, ...)<span class="keyword"> const</span>
<span class="keyword">  </span>{
      <a class="code" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>(<span class="comment">/* any *argument* preconditions for this function */</span>);

      <span class="comment">// Handle case where the invariants have been violated.</span>

<span class="preprocessor">  #ifdef BSLS_ASSERT_OPT_IS_ACTIVE</span>
<span class="preprocessor"></span>      <span class="comment">// Note that if &#39;BSLS_ASSERT_LEVEL_NONE&#39; has been set, this</span>
      <span class="comment">// code -- along with all &#39;BSLS_ASSERT_OPT&#39; macros -- will not</span>
      <span class="comment">// instantiate, enabling us to verify that the combined runtime</span>
      <span class="comment">// overhead of all such (redundant) defensive code is at worst</span>
      <span class="comment">// negligible, if not unmeasurable.</span>

      <span class="keywordflow">if</span> (!MyDateImpUtil::isValidSerialDate(d_serialDate)) {

          <span class="comment">// Our invariant is corrupted.</span>

<span class="preprocessor">  #ifdef BSLS_ASSERT_IS_ACTIVE</span>
<span class="preprocessor"></span>          <span class="comment">// Providing debugging information in this mode would be useful.</span>

          std::cerr &lt;&lt; <span class="stringliteral">&quot;\nxyza::MyDate: Invalid internal serial date value &quot;</span>
                    &lt;&lt; d_serialDate &lt;&lt; <span class="charliteral">&#39;.&#39;</span> &lt;&lt; std::endl;

<span class="preprocessor">  #endif // BSLS_ASSERT_IS_ACTIVE</span>
<span class="preprocessor"></span>
          <span class="comment">// In safe mode, each of the &#39;MyClass&#39; methods fully guards its</span>
          <span class="comment">// preconditions: There is simply no easy way to get here!</span>

          <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(<span class="stringliteral">&quot;Probable rogue memory overwrite!&quot;</span> &amp;&amp; 0);

          <span class="comment">// If we get here, we&#39;re corrupted, but not in safe mode!</span>

          <span class="keywordflow">return</span> stream &lt;&lt; <span class="stringliteral">&quot;(* Invalid &#39;MyDate&#39; State &quot;</span>
                        &lt;&lt; d_serialDate
                        &lt;&lt; <span class="stringliteral">&quot; *)&quot;</span> &lt;&lt; std::flush;                     <span class="comment">// RETURN</span>

<span class="preprocessor">  #endif // BSLS_ASSERT_OPT_IS_ACTIVE</span>
<span class="preprocessor"></span>
      }

      <span class="comment">// If we get here in a production build, this object is &quot;sane&quot;:</span>
      <span class="comment">// Do whatever this &#39;print&#39; method would normally do, assuming</span>
      <span class="comment">// that no method preconditions or object invariants are violated.</span>

      <span class="comment">// ...  &lt;*** Your (Normal-Case) Formatting Code Here! ***&gt;</span>
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:42 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
