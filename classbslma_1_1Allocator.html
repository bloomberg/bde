<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bslma::Allocator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslma.html">bslma</a>      </li>
      <li><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslma::Allocator Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslma::Allocator" -->
<p><code>#include &lt;<a class="el" href="bslma__allocator_8h_source.html">bslma_allocator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bslma::Allocator:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbslma_1_1Allocator.png" usemap="#bslma::Allocator_map" alt=""/>
  <map id="bslma::Allocator_map" name="bslma::Allocator_map">
<area href="classbdlma_1_1CountingAllocator.html" alt="bdlma::CountingAllocator" shape="rect" coords="0,56,253,80"/>
<area href="classbdlma_1_1GuardingAllocator.html" alt="bdlma::GuardingAllocator" shape="rect" coords="263,56,516,80"/>
<area href="classbdlma_1_1ManagedAllocator.html" alt="bdlma::ManagedAllocator" shape="rect" coords="526,56,779,80"/>
<area href="classbslma_1_1MallocFreeAllocator.html" alt="bslma::MallocFreeAllocator" shape="rect" coords="789,56,1042,80"/>
<area href="classbslma_1_1NewDeleteAllocator.html" alt="bslma::NewDeleteAllocator" shape="rect" coords="1052,56,1305,80"/>
<area href="classbslma_1_1TestAllocator.html" alt="bslma::TestAllocator" shape="rect" coords="1315,56,1568,80"/>
<area href="classbdlma_1_1BufferedSequentialAllocator.html" alt="bdlma::BufferedSequentialAllocator" shape="rect" coords="263,112,516,136"/>
<area href="classbdlma_1_1MultipoolAllocator.html" alt="bdlma::MultipoolAllocator" shape="rect" coords="526,112,779,136"/>
<area href="classbdlma_1_1SequentialAllocator.html" alt="bdlma::SequentialAllocator" shape="rect" coords="789,112,1042,136"/>
<area href="classbdlma_1_1LocalSequentialAllocator.html" alt="bdlma::LocalSequentialAllocator&lt; t_SIZE &gt;" shape="rect" coords="263,168,516,192"/>
</map>
</div>

<p><a href="classbslma_1_1Allocator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a9d59bbf24d35476520d29cc82b224221">~Allocator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#ad4499967960770d979508ef9df5544b9">allocate</a> (<a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a> size)=0</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a5ff7b0468394849d6824be024f272968">deallocate</a> (void *address)=0</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#a0e51fc2d107684523cc66bf65293dc37">deleteObject</a> (const TYPE *object)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class TYPE &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslma_1_1Allocator.html#abeccfe6cfd8205faf528a8e12f97aebe">deleteObjectRaw</a> (const TYPE *object)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This protocol class provides a pure abstract interface and contract for clients and suppliers of raw memory. If the requested memory cannot be returned; the contract requires that an <code>std::bad_alloc</code> exception be thrown. Note that memory is guaranteed to be sufficiently aligned for any object of the requested size on the current platform, which may be less than the maximal alignment guarantee afforded by global <code>operator new</code>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a07cd3ddf3fba145a0469a4e867047287"></a><!-- doxytag: member="bslma::Allocator::size_type" ref="a07cd3ddf3fba145a0469a4e867047287" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbsls_1_1Types.html#a34b68a3bcc9b5548299fcba31e9b31d9">bsls::Types::size_type</a> <a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">bslma::Allocator::size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9d59bbf24d35476520d29cc82b224221"></a><!-- doxytag: member="bslma::Allocator::~Allocator" ref="a9d59bbf24d35476520d29cc82b224221" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bslma::Allocator::~Allocator </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this allocator. Note that the behavior of destroying an allocator while memory is allocated from it is not specified. (Unless you <em>know</em> that it is valid to do so, don't!) </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad4499967960770d979508ef9df5544b9"></a><!-- doxytag: member="bslma::Allocator::allocate" ref="ad4499967960770d979508ef9df5544b9" args="(size_type size)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void* bslma::Allocator::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html#a07cd3ddf3fba145a0469a4e867047287">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a newly allocated block of memory of (at least) the specified positive <code>size</code> (in bytes). If <code>size</code> is 0, a null pointer is returned with no other effect. If this allocator cannot return the requested number of bytes, then it will throw a <code>std::bad_alloc</code> exception in an exception-enabled build, or else will abort the program in a non-exception build. The behavior is undefined unless <code>0 &lt;= size</code>. Note that the alignment of the address returned conforms to the platform requirement for any object of the specified <code>size</code>. </p>

<p>Implemented in <a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a1e3f353cc3248132d18c8b7e5cef9376">bdlma::BufferedSequentialAllocator</a>, <a class="el" href="classbdlma_1_1CountingAllocator.html#a6cf1e3a70ff483c2b9c4286b6b870420">bdlma::CountingAllocator</a>, <a class="el" href="classbdlma_1_1GuardingAllocator.html#a1b9eef0256af681e7de857367b73dcf4">bdlma::GuardingAllocator</a>, <a class="el" href="classbdlma_1_1MultipoolAllocator.html#a6d6e04e2bfb4d48c06051a1f30f7488b">bdlma::MultipoolAllocator</a>, <a class="el" href="classbdlma_1_1SequentialAllocator.html#a3696da7587a1c842d9430a960520af71">bdlma::SequentialAllocator</a>, <a class="el" href="classbslma_1_1MallocFreeAllocator.html#a325c3f98b1e7586f0564d4884e4d8611">bslma::MallocFreeAllocator</a>, <a class="el" href="classbslma_1_1NewDeleteAllocator.html#a4467a22d277e8c0454909d4aad3159af">bslma::NewDeleteAllocator</a>, and <a class="el" href="classbslma_1_1TestAllocator.html#adadeba443e1ea37730a9cf936a600e56">bslma::TestAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a5ff7b0468394849d6824be024f272968"></a><!-- doxytag: member="bslma::Allocator::deallocate" ref="a5ff7b0468394849d6824be024f272968" args="(void *address)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void bslma::Allocator::deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>address</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the memory block at the specified <code>address</code> back to this allocator. If <code>address</code> is 0, this function has no effect. The behavior is undefined unless <code>address</code> was allocated using this allocator object and has not already been deallocated. </p>

<p>Implemented in <a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html#a23ce15c3ede673b6c1da54850c6899b0">bdlma::BufferedSequentialAllocator</a>, <a class="el" href="classbdlma_1_1CountingAllocator.html#aa5e8299337deb9adbf0149350c0a9aba">bdlma::CountingAllocator</a>, <a class="el" href="classbdlma_1_1GuardingAllocator.html#ad25b41f61f97e3e28786d8f50555cf66">bdlma::GuardingAllocator</a>, <a class="el" href="classbdlma_1_1MultipoolAllocator.html#a6aa286e1880de3ae0cc8f1831a34daa5">bdlma::MultipoolAllocator</a>, <a class="el" href="classbdlma_1_1SequentialAllocator.html#a107050851e46527f4664869ec8a76f44">bdlma::SequentialAllocator</a>, <a class="el" href="classbslma_1_1MallocFreeAllocator.html#a08c03a4283be84a82d1b97bc17419dc6">bslma::MallocFreeAllocator</a>, <a class="el" href="classbslma_1_1NewDeleteAllocator.html#a481b3511a0cd4ae014c9d04b38b8e377">bslma::NewDeleteAllocator</a>, and <a class="el" href="classbslma_1_1TestAllocator.html#aa3d86f105cc1a797cfa5ad9e2bbf6825">bslma::TestAllocator</a>.</p>

</div>
</div>
<a class="anchor" id="a0e51fc2d107684523cc66bf65293dc37"></a><!-- doxytag: member="bslma::Allocator::deleteObject" ref="a0e51fc2d107684523cc66bf65293dc37" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObject </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> based on its dynamic type and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code>, when cast appropriately to <code>void *</code>, was allocated using this allocator and has not already been deallocated. Note that <code>dynamic_cast&lt;void *&gt;(object)</code> is applied if <code>TYPE</code> is polymorphic, and <code>static_cast&lt;void *&gt;(object)</code> is applied otherwise. </p>

</div>
</div>
<a class="anchor" id="abeccfe6cfd8205faf528a8e12f97aebe"></a><!-- doxytag: member="bslma::Allocator::deleteObjectRaw" ref="abeccfe6cfd8205faf528a8e12f97aebe" args="(const TYPE *object)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bslma::Allocator::deleteObjectRaw </td>
          <td>(</td>
          <td class="paramtype">const TYPE *&nbsp;</td>
          <td class="paramname"> <em>object</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy the specified <code>object</code> and then use this allocator to deallocate its memory footprint. Do nothing if <code>object</code> is a null pointer. The behavior is undefined unless <code>object</code> was allocated using this allocator, is <b>not</b> a secondary base class pointer -- i.e., the address is (numerically) the same as when it was originally dispensed by this allocator, and has not already been deallocated. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslma__allocator_8h_source.html">bslma_allocator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:34 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
