<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bdlpcre::RegEx</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlpcre.html">bdlpcre</a>      </li>
      <li><a class="el" href="classbdlpcre_1_1RegEx.html">bdlpcre::RegEx</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bdlpcre::RegEx Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlpcre::RegEx" -->
<p><code>#include &lt;<a class="el" href="bdlpcre__regex_8h_source.html">bdlpcre_regex.h</a>&gt;</code></p>

<p><a href="classbdlpcre_1_1RegEx-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a2cd19dd684db922f15a6b7972608f2e1">k_FLAG_CASELESS</a> =  PCRE2_CASELESS, 
<a class="el" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a9f1334e854f5b3fb1c9328c70c23ee64">k_FLAG_DOTMATCHESALL</a> =  PCRE2_DOTALL, 
<a class="el" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a8a8be75e1131edd126bf766182e53979">k_FLAG_MULTILINE</a> =  PCRE2_MULTILINE, 
<a class="el" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a8b56acb60ba66567374f10dd55ca5de1">k_FLAG_UTF8</a> =  PCRE2_UTF
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a6390998dceedd534d683015f8f1fa09a">BSLMF_NESTED_TRAIT_DECLARATION</a> (<a class="el" href="classbdlpcre_1_1RegEx.html">RegEx</a>, <a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a70c4632cd199c59c038c660cc776c688">RegEx</a> (<a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a78c7b069eb3a65fe5c72b316afe2341c">~RegEx</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#aeb4b1af38f8f1414d040abc72d8ddd38">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a7bdfc6923cee41c12f7c39879b4ff118">prepare</a> (<a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *errorMessage, size_t *errorOffset, const char *pattern, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a0c6eaff1deec6e06930f53b99e965c15">setDepthLimit</a> (int depthLimit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a528e3c16375b1505e20cd9408d9695fe">depthLimit</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a4c60626a9ec2755e8e17a07e48daceb1">flags</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a9afe579f21957d1fa532839a9e84cdc8">isPrepared</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a0a82d9668f8c0ae3f4e3e5514428facc">match</a> (const char *subject, size_t subjectLength, size_t subjectOffset=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a9b5e7df99a3aa22d3f87079df299f250">match</a> (<a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; size_t, size_t &gt; *result, const char *subject, size_t subjectLength, size_t subjectOffset=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a41a9fb681878e600b4d13a89535797dd">match</a> (<a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> *result, const char *subject, size_t subjectLength, size_t subjectOffset=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a6e63f49f7d5fb98cd39e54d7b2028ff3">match</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; size_t, size_t &gt; &gt; *result, const char *subject, size_t subjectLength, size_t subjectOffset=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#aaf4a9b151b40a1ab3cf1b3adca049c74">match</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &gt; *result, const char *subject, size_t subjectLength, size_t subjectOffset=0) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#aa6e2c856eee2275d64ad335efcf7bed0">numSubpatterns</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a7bccfda56a6f2201419993ba263a0c97">subpatternIndex</a> (const char *name) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a17de76aa45b10b61b3237edebaf57e2c">defaultDepthLimit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlpcre_1_1RegEx.html#a3d0c16b167d0bd6704b402c77da6f51c">setDefaultDepthLimit</a> (int depthLimit)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a mechanism for compiling and matching regular expressions. A regular expression approximately compatible with Perl 5.10 is compiled with the <code>prepare</code> method. Subsequently, strings are matched against the compiled (prepared) pattern using the overloaded <code>match</code> methods. Note that the underlying implementation uses the open-source Perl Compatible Regular Expressions (PCRE2) library that was developed at the University of Cambridge (<code><a href="http://www.pcre.org/">http://www.pcre.org/</a></code>). </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a826927503e25019333a9e0db982eeed7"></a><!-- doxytag: member="bdlpcre::RegEx::@210" ref="a826927503e25019333a9e0db982eeed7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a826927503e25019333a9e0db982eeed7a2cd19dd684db922f15a6b7972608f2e1"></a><!-- doxytag: member="k_FLAG_CASELESS" ref="a826927503e25019333a9e0db982eeed7a2cd19dd684db922f15a6b7972608f2e1" args="" -->k_FLAG_CASELESS</em>&nbsp;</td><td>
<p>case-insensitive matching </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a826927503e25019333a9e0db982eeed7a9f1334e854f5b3fb1c9328c70c23ee64"></a><!-- doxytag: member="k_FLAG_DOTMATCHESALL" ref="a826927503e25019333a9e0db982eeed7a9f1334e854f5b3fb1c9328c70c23ee64" args="" -->k_FLAG_DOTMATCHESALL</em>&nbsp;</td><td>
<p>dot metacharacter matches all chars (including newlines) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a826927503e25019333a9e0db982eeed7a8a8be75e1131edd126bf766182e53979"></a><!-- doxytag: member="k_FLAG_MULTILINE" ref="a826927503e25019333a9e0db982eeed7a8a8be75e1131edd126bf766182e53979" args="" -->k_FLAG_MULTILINE</em>&nbsp;</td><td>
<p>multi-line matching </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a826927503e25019333a9e0db982eeed7a8b56acb60ba66567374f10dd55ca5de1"></a><!-- doxytag: member="k_FLAG_UTF8" ref="a826927503e25019333a9e0db982eeed7a8b56acb60ba66567374f10dd55ca5de1" args="" -->k_FLAG_UTF8</em>&nbsp;</td><td>
<p>UTF-8 support. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a70c4632cd199c59c038c660cc776c688"></a><!-- doxytag: member="bdlpcre::RegEx::RegEx" ref="a70c4632cd199c59c038c660cc776c688" args="(bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlpcre::RegEx::RegEx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>IMPLICIT: Create a regular-expression object in the "unprepared" state. Optionally specify a <code>basicAllocator</code> used to supply memory. The alignment strategy of the allocator must be "maximum" or "natural". If <code>basicAllocator</code> is 0, the currently installed default allocator is used. </p>

</div>
</div>
<a class="anchor" id="a78c7b069eb3a65fe5c72b316afe2341c"></a><!-- doxytag: member="bdlpcre::RegEx::~RegEx" ref="a78c7b069eb3a65fe5c72b316afe2341c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlpcre::RegEx::~RegEx </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this regular-expression object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a6390998dceedd534d683015f8f1fa09a"></a><!-- doxytag: member="bdlpcre::RegEx::BSLMF_NESTED_TRAIT_DECLARATION" ref="a6390998dceedd534d683015f8f1fa09a" args="(RegEx, bslma::UsesBslmaAllocator)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdlpcre::RegEx::BSLMF_NESTED_TRAIT_DECLARATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbdlpcre_1_1RegEx.html">RegEx</a>&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbslma_1_1UsesBslmaAllocator.html">bslma::UsesBslmaAllocator</a>&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a17de76aa45b10b61b3237edebaf57e2c"></a><!-- doxytag: member="bdlpcre::RegEx::defaultDepthLimit" ref="a17de76aa45b10b61b3237edebaf57e2c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlpcre::RegEx::defaultDepthLimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the process-wide default evaluation recursion depth limit. </p>

</div>
</div>
<a class="anchor" id="a3d0c16b167d0bd6704b402c77da6f51c"></a><!-- doxytag: member="bdlpcre::RegEx::setDefaultDepthLimit" ref="a3d0c16b167d0bd6704b402c77da6f51c" args="(int depthLimit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int bdlpcre::RegEx::setDefaultDepthLimit </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depthLimit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the process-wide default evaluation recursion depth limit to the specified <code>depthLimit</code>. Returns the previous depth limit. </p>

</div>
</div>
<a class="anchor" id="aeb4b1af38f8f1414d040abc72d8ddd38"></a><!-- doxytag: member="bdlpcre::RegEx::clear" ref="aeb4b1af38f8f1414d040abc72d8ddd38" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlpcre::RegEx::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Free resources used by this regular-expression object and put this object into the "unprepared" state. This method has no effect if this object is already in the "unprepared" state. </p>

</div>
</div>
<a class="anchor" id="a7bdfc6923cee41c12f7c39879b4ff118"></a><!-- doxytag: member="bdlpcre::RegEx::prepare" ref="a7bdfc6923cee41c12f7c39879b4ff118" args="(bsl::string *errorMessage, size_t *errorOffset, const char *pattern, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1basic__string.html">bsl::string</a> *&nbsp;</td>
          <td class="paramname"> <em>errorMessage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&nbsp;</td>
          <td class="paramname"> <em>errorOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Prepare this regular-expression object with the specified <code>pattern</code> and the optionally specified <code>flags</code>. On success, put this object into the "prepared" state and return 0, with no effect on the specified <code>errorMessage</code> and <code>errorOffset</code>. Otherwise, (1) put this object into the "unprepared" state, (2) load <code>errorMessage</code> (if non-null) with a string describing the error detected, (3) load <code>errorOffset</code> (if non-null) with the offset in <code>pattern</code> at which the error was detected, and (4) return a non-zero value. The behavior is undefined unless <code>flags</code> is the bit-wise inclusive-or of 0 or more of the following values: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a2cd19dd684db922f15a6b7972608f2e1" title="case-insensitive matching">k_FLAG_CASELESS</a>
          <a class="code" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a9f1334e854f5b3fb1c9328c70c23ee64">k_FLAG_DOTMATCHESALL</a>
          <a class="code" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a8a8be75e1131edd126bf766182e53979" title="multi-line matching">k_FLAG_MULTILINE</a>
          <a class="code" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a8b56acb60ba66567374f10dd55ca5de1" title="UTF-8 support.">k_FLAG_UTF8</a>
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a0c6eaff1deec6e06930f53b99e965c15"></a><!-- doxytag: member="bdlpcre::RegEx::setDepthLimit" ref="a0c6eaff1deec6e06930f53b99e965c15" args="(int depthLimit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::setDepthLimit </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>depthLimit</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the evaluation recursion depth limit for this regular-expression object to the specified <code>depthLimit</code>. Return the previous depth limit. </p>

</div>
</div>
<a class="anchor" id="a528e3c16375b1505e20cd9408d9695fe"></a><!-- doxytag: member="bdlpcre::RegEx::depthLimit" ref="a528e3c16375b1505e20cd9408d9695fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::depthLimit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns the evaluation recursion depth limit for this regular-expression object. </p>

</div>
</div>
<a class="anchor" id="a4c60626a9ec2755e8e17a07e48daceb1"></a><!-- doxytag: member="bdlpcre::RegEx::flags" ref="a4c60626a9ec2755e8e17a07e48daceb1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::flags </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the flags that were supplied to the most recent successful call to the <code>prepare</code> method of this regular-expression object. The behavior is undefined unless <code><a class="el" href="classbdlpcre_1_1RegEx.html#a9afe579f21957d1fa532839a9e84cdc8">isPrepared()</a> == true</code>. Note that the returned value will be the bit-wise inclusive-or of 0 or more of the following values: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <a class="code" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a2cd19dd684db922f15a6b7972608f2e1" title="case-insensitive matching">k_FLAG_CASELESS</a>
          <a class="code" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a9f1334e854f5b3fb1c9328c70c23ee64">k_FLAG_DOTMATCHESALL</a>
          <a class="code" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a8a8be75e1131edd126bf766182e53979" title="multi-line matching">k_FLAG_MULTILINE</a>
          <a class="code" href="classbdlpcre_1_1RegEx.html#a826927503e25019333a9e0db982eeed7a8b56acb60ba66567374f10dd55ca5de1" title="UTF-8 support.">k_FLAG_UTF8</a>
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a9afe579f21957d1fa532839a9e84cdc8"></a><!-- doxytag: member="bdlpcre::RegEx::isPrepared" ref="a9afe579f21957d1fa532839a9e84cdc8" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlpcre::RegEx::isPrepared </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this regular-expression object is in the "prepared" state, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a0a82d9668f8c0ae3f4e3e5514428facc"></a><!-- doxytag: member="bdlpcre::RegEx::match" ref="a0a82d9668f8c0ae3f4e3e5514428facc" args="(const char *subject, size_t subjectLength, size_t subjectOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::match </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Match the specified <code>subject</code>, having the specified <code>subjectLength</code>, against the pattern held by this regular-expression object (<code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code>). Begin matching at the optionally specified <code>subjectOffset</code> in <code>subject</code>. If <code>subjectOffset</code> is not specified, then begin matching from the start of <code>subject</code>. Return 0 on success, 1 if the depth limit was exceeded, and another non-zero value otherwise. The behavior is undefined unless <code><a class="el" href="classbdlpcre_1_1RegEx.html#a9afe579f21957d1fa532839a9e84cdc8">isPrepared()</a> == true</code>, <code>0 &lt;= subjectLength</code>, <code>0 &lt;= subjectOffset</code>, and <code>subjectOffset &lt;= subjectLength</code>. The behavior is also undefined if <code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code> was prepared with <code>k_FLAG_UTF8</code>, but <code>subject</code> is not valid UTF-8. Note that <code>subject</code> need not be null-terminated and may contain embedded null characters. Also note that <code>subject</code> may be null if <code>0 == subjectLength</code> (denoting the empty string). </p>

</div>
</div>
<a class="anchor" id="a9b5e7df99a3aa22d3f87079df299f250"></a><!-- doxytag: member="bdlpcre::RegEx::match" ref="a9b5e7df99a3aa22d3f87079df299f250" args="(bsl::pair&lt; size_t, size_t &gt; *result, const char *subject, size_t subjectLength, size_t subjectOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; size_t, size_t &gt; *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a41a9fb681878e600b4d13a89535797dd"></a><!-- doxytag: member="bdlpcre::RegEx::match" ref="a41a9fb681878e600b4d13a89535797dd" args="(bslstl::StringRef *result, const char *subject, size_t subjectLength, size_t subjectOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Match the specified <code>subject</code>, having the specified <code>subjectLength</code>, against the pattern held by this regular-expression object (<code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code>). Begin matching at the optionally specified <code>subjectOffset</code> in <code>subject</code>. If <code>subjectOffset</code> is not specified, then begin matching from the start of <code>subject</code>. On success, load the specified <code>result</code> with respectively the <code>(offset, length)</code> pair or <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> indicating the leftmost match of <code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code>, and return 0. Otherwise, return a non-zero value with no effect on <code>result</code>. The return value is 1 if the failure is caused by exceeding the depth limit. The behavior is undefined unless <code><a class="el" href="classbdlpcre_1_1RegEx.html#a9afe579f21957d1fa532839a9e84cdc8">isPrepared()</a> == true</code>, <code>0 &lt;= subjectLength</code>, <code>0 &lt;= subjectOffset</code>, and <code>subjectOffset &lt;= subjectLength</code>. The behavior is also undefined if <code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code> was prepared with <code>k_FLAG_UTF8</code>, but <code>subject</code> is not valid UTF-8. Note that <code>subject</code> need not be null-terminated and may contain embedded null characters. Also note that <code>subject</code> may be null if <code>0 == subjectLength</code> (denoting the empty string). </p>

</div>
</div>
<a class="anchor" id="a6e63f49f7d5fb98cd39e54d7b2028ff3"></a><!-- doxytag: member="bdlpcre::RegEx::match" ref="a6e63f49f7d5fb98cd39e54d7b2028ff3" args="(bsl::vector&lt; bsl::pair&lt; size_t, size_t &gt; &gt; *result, const char *subject, size_t subjectLength, size_t subjectOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt; size_t, size_t &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf4a9b151b40a1ab3cf1b3adca049c74"></a><!-- doxytag: member="bdlpcre::RegEx::match" ref="aaf4a9b151b40a1ab3cf1b3adca049c74" args="(bsl::vector&lt; bslstl::StringRef &gt; *result, const char *subject, size_t subjectLength, size_t subjectOffset=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="classbslstl_1_1StringRefImp.html">bslstl::StringRef</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&nbsp;</td>
          <td class="paramname"> <em>subjectOffset</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Match the specified <code>subject</code>, having the specified <code>subjectLength</code>, against the pattern held by this regular-expression object (<code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code>). Begin matching at the optionally specified <code>subjectOffset</code> in <code>subject</code>. If <code>subjectOffset</code> is not specified, then begin matching from the start of <code>subject</code>. On success, (1) load the first element of the specified <code>result</code> with respectively <code>(offset, length)</code> pair or <code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code> indicating the leftmost match of <code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code>, (2) load elements of <code>result</code> in the range <code>[ 1 .. <a class="el" href="classbdlpcre_1_1RegEx.html#aa6e2c856eee2275d64ad335efcf7bed0">numSubpatterns()</a> ]</code> with the pairs (<code><a class="el" href="namespacebslstl.html#a10921a5e7fd9377149df174a1a12324f">bslstl::StringRef</a></code>) indicating the respective matches of sub-patterns (unmatched sub-patterns have their respective <code>result</code> elements loaded with <code>(-1, 0)</code> pair (empty <code>StringRef</code>); sub-patterns matching multiple times have their respective <code>result</code> elements loaded with the pairs indicating the rightmost match), and (3) return 0. Otherwise, return a non-zero value with no effect on <code>result</code>. The return value is 1 if the failure is caused by exceeding the depth limit. The behavior is undefined unless <code><a class="el" href="classbdlpcre_1_1RegEx.html#a9afe579f21957d1fa532839a9e84cdc8">isPrepared()</a> == true</code>, <code>0 &lt;= subjectLength</code>, <code>0 &lt;= subjectOffset</code>, and <code>subjectOffset &lt;= subjectLength</code>. The behavior is also undefined if <code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code> was prepared with <code>k_FLAG_UTF8</code>, but <code>subject</code> is not valid UTF-8. Note that <code>subject</code> need not be null-terminated and may contain embedded null characters. Also note that <code>subject</code> may be null if <code>0 == subjectLength</code> (denoting the empty string). Also note that after a successful call, <code>result</code> will contain exactly <code><a class="el" href="classbdlpcre_1_1RegEx.html#aa6e2c856eee2275d64ad335efcf7bed0">numSubpatterns()</a> + 1</code> elements. </p>

</div>
</div>
<a class="anchor" id="aa6e2c856eee2275d64ad335efcf7bed0"></a><!-- doxytag: member="bdlpcre::RegEx::numSubpatterns" ref="aa6e2c856eee2275d64ad335efcf7bed0" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::numSubpatterns </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of sub-patterns in the pattern held by this regular-expression object (<code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code>). The behavior is undefined unless <code><a class="el" href="classbdlpcre_1_1RegEx.html#a9afe579f21957d1fa532839a9e84cdc8">isPrepared()</a> == true</code>. </p>

</div>
</div>
<a class="anchor" id="a92b20208c0235988f752bf38198e9726"></a><!-- doxytag: member="bdlpcre::RegEx::pattern" ref="a92b20208c0235988f752bf38198e9726" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; bdlpcre::RegEx::pattern </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable pattern held by this regular-expression object. The behavior is undefined unless <code><a class="el" href="classbdlpcre_1_1RegEx.html#a9afe579f21957d1fa532839a9e84cdc8">isPrepared()</a> == true</code>. </p>

</div>
</div>
<a class="anchor" id="a7bccfda56a6f2201419993ba263a0c97"></a><!-- doxytag: member="bdlpcre::RegEx::subpatternIndex" ref="a7bccfda56a6f2201419993ba263a0c97" args="(const char *name) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlpcre::RegEx::subpatternIndex </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the 1-based index of the sub-pattern having the specified <code>name</code> in the pattern held by this regular-expression object (<code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code>); return -1 if <code><a class="el" href="classbdlpcre_1_1RegEx.html#a92b20208c0235988f752bf38198e9726">pattern()</a></code> does not contain a sub-pattern identified by <code>name</code>. The behavior is undefined unless <code><a class="el" href="classbdlpcre_1_1RegEx.html#a9afe579f21957d1fa532839a9e84cdc8">isPrepared()</a> == true</code>. Note that the returned value is intended to be used as an index into the <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;<a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;int, int&gt; &gt;</code> returned by <code>match</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bdlpcre__regex_8h_source.html">bdlpcre_regex.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:33 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
