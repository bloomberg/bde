<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslmf_isconvertible.h                                              -*-C++-*-
#ifndef INCLUDED_BSLMF_ISCONVERTIBLE
#define INCLUDED_BSLMF_ISCONVERTIBLE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a compile-time check for type conversion.
//
//@CLASSES:
//  bsl::is_convertible: standard meta-function for type conversion checking
//  bslmf::IsConvertible: meta-function for type conversion checking
//
//@SEE_ALSO: bslmf_integralconstant
//
//@DESCRIPTION: This component defines two meta-functions,
// &#39;bsl::is_convertible&#39; and &#39;BloombergLP::bslmf::IsConvertible&#39;, both of which
// may be used to check whether a conversion exists from one type to another.
//
// &#39;bsl::is_convertible&#39; meets the requirements of the &#39;is_convertible&#39;
// template defined in the C++11 standard [meta.rel], while
// &#39;bslmf::IsConvertible&#39; was devised before &#39;is_convertible&#39; was standardized.
//
// The two meta-functions are functionally equivalent except that
// &#39;bsl::is_convertible&#39; does not allow its template parameter types to be
// incomplete types according to the C++11 standard while
// &#39;bslmf::IsConvertible&#39; tests conversions involving incomplete types.  The
// other major difference between them is that the result for
// &#39;bsl::is_convertible&#39; is indicated by the class members &#39;value&#39; and &#39;type&#39;,
// whereas the result for &#39;bslmf::IsConvertible&#39; is indicated by the class
// members &#39;VALUE&#39; and &#39;Type&#39;.
//
// Note that &#39;bsl::is_convertible&#39; should be preferred over
// &#39;bslmf::IsConvertible&#39;, and in general, should be used by new components.
// Also note that &#39;bsl::is_convertible&#39; and &#39;bslmf::IsConvertible&#39; can produce
// compiler errors if the conversion is ambiguous.  For example:
//..
//  struct A {};
//  struct B : public A {};
//  struct C : public A {};
//  struct D : public B, public C {};
//
//  static int const C = bsl::is_convertible&lt;D*, A*&gt;::value;  // ERROR!
//..
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Select Function Based on Type Convertibility
///- - - - - - - - - - - - - - - - - - - - - - - - - - - -
// The &#39;bsl::is_convertible&#39; meta-function can be used to select an appropriate
// function (at compile time) based on the convertibility of one type to
// another without causing a compiler error by actually trying the conversion.
//
// Suppose we are implementing a &#39;convertToInt&#39; template method that converts a
// given object of the (template parameter) &#39;TYPE&#39; to &#39;int&#39; type, and returns
// the integer value.  If the given object can not convert to &#39;int&#39;, return 0.
// The method calls an overloaded function, &#39;getIntValue&#39;, to get the converted
// integer value.  The idea is to invoke one version of &#39;getIntValue&#39; if the
// type provides a conversion operator that returns an integer value, and
// another version if the type does not provide such an operator.
//
// First, we define two classes, &#39;Foo&#39; and &#39;Bar&#39;.  The &#39;Foo&#39; class has a
// conversion operator that returns an integer value while the &#39;Bar&#39; class does
// not:
//..
//  class Foo {
//      // DATA
//      int d_value;
//
//    public:
//      // CREATORS
//      explicit Foo(int value) : d_value(value) {}
//
//      // ACCESSORS
//      operator int() const { return d_value; }
//  };
//
//  class Bar {};
//..
// Then, we define the first &#39;getIntValue&#39; function that takes a
// &#39;bsl::false_type&#39; as its last argument, whereas the second &#39;getIntValue&#39;
// function takes a &#39;bsl::true_type&#39; object.  The result of the
// &#39;bsl::is_convertible&#39; meta-function (i.e., its &#39;type&#39; member) is used to
// create the last argument passed to &#39;getIntValue&#39;.  Neither version of
// &#39;getIntValue&#39; makes use of this argument -- it is used only to differentiate
// the argument list so we can overload the function.
//..
//  template &lt;class TYPE&gt;
//  inline
//  int getIntValue(TYPE *object, bsl::false_type)
//  {
//      // Return 0 because the specified &#39;object&#39; of the (template parameter)
//      // &#39;TYPE&#39; is not convertible to the &#39;int&#39; type.
//
//      return 0;
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  int getIntValue(TYPE *object, bsl::true_type)
//  {
//      // Return the integer value converted from the specified &#39;object&#39; of
//      // the (template parameter) &#39;TYPE&#39;.
//
//      return int(*object);
//  }
//..
// Now, we define our &#39;convertToInt&#39; method:
//..
//  template &lt;class TYPE&gt;
//  inline
//  int convertToInt(TYPE *object)
//  {
//      typedef typename bsl::is_convertible&lt;TYPE, int&gt;::type CanConvertToInt;
//      return getIntValue(object, CanConvertToInt());
//  }
//..
// Notice that we use &#39;bsl::is_convertible&#39; to get a &#39;bsl::false_type&#39; or
// &#39;bsl::true_type&#39;, and then call the corresponding overloaded &#39;getIntValue&#39;
// method.
//
// Finally, we call &#39;convertToInt&#39; with both &#39;Foo&#39; and &#39;Bar&#39; classes:
//..
//  Foo foo(99);
//  Bar bar;
//
//  printf(&quot;%d\n&quot;, convertToInt(&amp;foo));
//  printf(&quot;%d\n&quot;, convertToInt(&amp;bar));
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDCONST
#include &lt;bslmf_addconst.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDLVALUEREFERENCE
#include &lt;bslmf_addlvaluereference.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_CONDITIONAL
#include &lt;bslmf_conditional.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ENABLEIF
#include &lt;bslmf_enableif.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISARRAY
#include &lt;bslmf_isarray.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISFUNCTION
#include &lt;bslmf_isfunction.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISFUNDAMENTAL
#include &lt;bslmf_isfundamental.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISVOID
#include &lt;bslmf_isvoid.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MATCHANYTYPE
#include &lt;bslmf_matchanytype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECV
#include &lt;bslmf_removecv.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifdef BSLS_COMPILERFEATURES_SUPPORT_TRAITS_HEADER
#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_TYPE_TRAITS
# define BSLMF_INCLUDE_ONLY_NATIVE_TRAITS
# include &lt;type_traits&gt;
#endif

#endif // BSLS_COMPILERFEATURES_SUPPORT_TRAITS_HEADER

#if defined(BSLS_COMPILERFEATURES_SUPPORT_TRAITS_HEADER)
# if !defined(BSLS_PLATFORM_CMP_MSVC) || BSLS_PLATFORM_CMP_VERSION &gt; 1900
    // The Microsft implementation of native traits allows binding of rvalues
    // (including temporaries invented for conversion) to &#39;const volatile &amp;&#39;
    // references.  Early versions also do not correctly disallow conversion
    // from itself for types that are neither copy- nor move-constructible.
#   define BSLMF_ISCONVERTIBLE_USE_NATIVE_TRAITS
# endif
#endif

namespace BloombergLP {
namespace bslmf {

                 // =========================================
                 // private class IsConvertible_CheckComplete
                 // =========================================

template &lt;class TYPE,
          bool = bsl::is_function&lt;TYPE&gt;::value || bsl::is_void&lt;TYPE&gt;::value&gt;
struct IsConvertible_CheckComplete {
    typedef TYPE type;

    BSLMF_ASSERT((sizeof(TYPE) &gt; 0));
};

template &lt;class TYPE&gt;
struct IsConvertible_CheckComplete&lt;TYPE &amp;, false&gt;
     : IsConvertible_CheckComplete&lt;TYPE &gt; {
    typedef TYPE &amp; type;
};

#if defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
template &lt;class TYPE&gt;
struct IsConvertible_CheckComplete&lt;TYPE &amp;&amp;, false&gt;
     : IsConvertible_CheckComplete&lt;TYPE &gt; {
    typedef TYPE &amp;&amp; type;
};
#endif

template &lt;class TYPE&gt;
struct IsConvertible_CheckComplete&lt;TYPE, true&gt; {
    typedef TYPE type;
};

#if !defined(BSLS_PLATFORM_CMP_IBM)  // IBM rejects this valid specialization
template &lt;class TYPE&gt;
struct IsConvertible_CheckComplete&lt;TYPE[], false&gt; {
    typedef TYPE type[];
};
#endif

}  // close package namespace
}  // close enterprise namespace

#ifdef BSLMF_ISCONVERTIBLE_USE_NATIVE_TRAITS

namespace bsl {

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible
    : ::bsl::integral_constant&lt;bool,
                               ::native_std::is_convertible&lt;
     typename BloombergLP::bslmf::IsConvertible_CheckComplete&lt;FROM_TYPE&gt;::type,
     typename BloombergLP::bslmf::IsConvertible_CheckComplete&lt;  TO_TYPE&gt;::type
                                                           &gt;::value&gt; {
};

}
#else

namespace BloombergLP {
namespace bslmf {

                         // ==========================
                         // struct IsConvertible_Match
                         // ==========================

struct IsConvertible_Match {
    // This &#39;struct&#39; provides functions to check for successful conversion
    // matches.  Sun CC 5.2 requires that this &#39;struct&#39; not be nested within
    // &#39;IsConvertible_Imp&#39;.

    typedef struct { char a;    } yes_type;
    typedef struct { char a[2]; } no_type;

    static yes_type match(IsConvertible_Match&amp;);
        // Return &#39;yes_type&#39; if called on &#39;IsConvertible_Match&#39; type.

#if !defined(BSLS_COMPILERFEATURES_SUPPORT_RVALUE_REFERENCES)
    template &lt;class TYPE&gt;
    static no_type match(const TYPE&amp;);
        // Return &#39;yes_type&#39; if the (template parameter) &#39;TYPE&#39; is
        // &#39;IsConvertible_Match&#39;, and &#39;no_type&#39; otherwise.

    template &lt;class TYPE&gt;
    static no_type match(const volatile TYPE&amp;);
        // Return &#39;yes_type&#39; if the (template parameter) &#39;TYPE&#39; is
        // &#39;IsConvertible_Match&#39; and &#39;no_type&#39; otherwise.

    template &lt;class TYPE&gt;
    static
    typename bsl::enable_if&lt;bsl::is_function&lt;TYPE&gt;::value, no_type&gt;::type
        match(TYPE&amp;);
        // Return &#39;yes_type&#39; if the (template parameter) &#39;TYPE&#39; is
        // &#39;IsConvertible_Match&#39; and &#39;no_type&#39; otherwise.
#else
    template &lt;class TYPE&gt;
    static no_type match(TYPE&amp;&amp;);
        // Return &#39;yes_type&#39; if the (template parameter) &#39;TYPE&#39; is
        // &#39;IsConvertible_Match&#39;, and &#39;no_type&#39; otherwise.
#endif
};

                         // ========================
                         // struct IsConvertible_Imp
                         // ========================

template &lt;class FROM_TYPE, class TO_TYPE
#if defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
         , int IS_FROM_FUNDAMENTAL = bsl::is_fundamental&lt;FROM_TYPE&gt;::value
         , int IS_TO_FUNDAMENTAL   = bsl::is_fundamental&lt;TO_TYPE&gt;::value
#endif
         &gt;
struct IsConvertible_Imp {
    // This &#39;struct&#39; template implements the meta-function to determine type
    // conversion between the (template parameter) &#39;FROM_TYPE&#39; and the
    // (template parameter) &#39;TO_TYPE&#39; where the conversion to the &#39;TO_TYPE&#39; is
    // not necessarily the same as conversion to &#39;const TO_TYPE&amp;&#39;.
    //
    // Note that significant documentation about the details of this
    // implementation can be found in &#39;bslmf_isconvertible.cpp&#39;.

  private:
    struct Test
    {
        // A unique (empty) type returned by the comma operator.

        IsConvertible_Match&amp; operator, (TO_TYPE) const;
            // Return a reference to type &#39;IsConvertible_Match&#39;.
    };

  public:

#ifdef BSLS_PLATFORM_CMP_MSVC
#   pragma warning(push)
#   pragma warning(disable: 4244)  // loss of precision warning ignored
#endif
    enum {

        value = (sizeof(IsConvertible_Match::yes_type) ==
                 sizeof(IsConvertible_Match::match(
                                         (Test(), TypeRep&lt;FROM_TYPE&gt;::rep()))))
            // Return the convertibility between &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39;.
            // This is set by invoking the &#39;operator,&#39; method having &#39;Test&amp;&#39; on
            // the left and &#39;FROM_TYPE&#39; on the right.  The &#39;value&#39; is &#39;true&#39; if
            // &#39;FROM_TYPE&#39; is convertible to &#39;TO_TYPE&#39;, and &#39;false&#39; otherwise.
    };

#ifdef BSLS_PLATFORM_CMP_MSVC
#   pragma warning(pop)
#endif

    typedef bsl::integral_constant&lt;bool, value&gt; type;
        // This &#39;typedef&#39; returns &#39;bsl::true_type&#39; if &#39;FROM_TYPE&#39; is
        // convertible to &#39;TO_TYPE&#39;, and &#39;bsl::false_type&#39; otherwise.
};

#if 0 // defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
// The following template partial specializations produce the same results as
// the unspecialized template would, but avoid generating conversion warnings
// on the affected compilers.  However, there is one known bug in this block of
// code (reported by the test driver, not yet tracked down) and experimentally
// removing it seems to clear the bug, without raising the feared warnings on
// supported gcc platforms - although it still raises a few warnings with gcc
// 4.3.5.

#define BSLMF_ISCONVERTIBLE_SAMETYPEVALUE(VALUE, FROM, TO, FROM_FUND, TO_FUND)\
template &lt;class TYPE&gt;                                                         \
struct IsConvertible_Imp&lt;FROM, TO, FROM_FUND, TO_FUND&gt;                        \
     : bsl::integral_constant&lt;bool, VALUE&gt; {};
    // This partial specialization of &#39;bslmf::IsConvertible_Imp&#39; derives from
    // &#39;bsl::integral_constant&#39; having the specified macro argument &#39;VALUE&#39;.
    // The specified macro arguments &#39;FROM&#39; and &#39;TO&#39; are cv-qualified type
    // expressions constructed out of the (template parameter) &#39;TYPE&#39;.

#define BSLMF_ISCONVERTIBLE_VALUE(VALUE, FROM, TO, FROM_FUND, TO_FUND)        \
template &lt;class FROM_TYPE, class TO_TYPE&gt;                                     \
struct IsConvertible_Imp&lt;FROM, TO, FROM_FUND, TO_FUND&gt;                        \
     : bsl::integral_constant&lt;bool, VALUE&gt; {};
    // This partial specialization of &#39;bslmf::IsConvertible_Imp&#39; derives from
    // &#39;bsl::integral_constant&#39; having the specified macro argument &#39;VALUE&#39;.
    // The specified macro arguments &#39;FROM&#39; and &#39;TO&#39; are cv-qualified type
    // expressions constructed out of &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39;, respectively.

#define BSLMF_ISCONVERTIBLE_FORWARD(FROM, TO, FROM_FUND, TO_FUND)             \
template &lt;class FROM_TYPE, class TO_TYPE&gt;                                     \
struct IsConvertible_Imp&lt;FROM, TO, FROM_FUND, TO_FUND&gt;                        \
     : IsConvertible_Imp&lt;FROM, TO, 0, 0&gt; {};
    // This partial specialization of &#39;bslmf::IsConvertible_Imp&#39; applies the
    // general mechanism for non-fundamental types.  The specified macro
    // arguments &#39;FROM&#39; and &#39;TO&#39; are cv-qualified type expressions constructed
    // out of &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39;, respectively.

BSLMF_ISCONVERTIBLE_SAMETYPEVALUE(0, const volatile TYPE, const TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_SAMETYPEVALUE(0,       volatile TYPE, const TYPE&amp;, 1, 1)
    // These two partial specializations are instantiated when a (possibly
    // &#39;const&#39;-qualified) &#39;volatile&#39; fundamental type is tested for
    // convertibility to its &#39;const&#39; reference type.  The conversion shall
    // fail.

BSLMF_ISCONVERTIBLE_VALUE(1, const volatile FROM_TYPE, const TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_VALUE(1,       volatile FROM_TYPE, const TO_TYPE&amp;, 1, 1)
    // These two partial specializations are instantiated when a (possibly
    // &#39;const&#39;-qualified) &#39;volatile&#39; type is tested for convertibility to the
    // &#39;const&#39; reference type of another fundamental type.  These partial
    // specializations will be picked up if the previous two fail to match.
    // The conversion shall succeed.

BSLMF_ISCONVERTIBLE_VALUE(1, const FROM_TYPE, const TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_VALUE(1,       FROM_TYPE, const TO_TYPE&amp;, 1, 1)
    // These two partial specializations are instantiated when a (possibly
    // &#39;const&#39;-qualified) fundamental type is tested for convertibility to the
    // &#39;const&#39; reference type of another fundamental type.  These partial
    // specializations will be picked up if the previous two fail to match.
    // The conversion shall succeed.

BSLMF_ISCONVERTIBLE_FORWARD(const volatile FROM_TYPE,
                            const volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(      volatile FROM_TYPE,
                            const volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(const          FROM_TYPE,
                            const volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(               FROM_TYPE,
                            const volatile TO_TYPE&amp;, 1, 1)
    // These four partial specializations are instantiated when a (possibly
    // cv-qualified) fundamental type is tested for convertibility to the
    // &#39;const volatile&#39; reference type of another fundamental type.

BSLMF_ISCONVERTIBLE_FORWARD(const volatile FROM_TYPE,
                                  volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(      volatile FROM_TYPE,
                                  volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(const          FROM_TYPE,
                                  volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(               FROM_TYPE,
                                  volatile TO_TYPE&amp;, 1, 1)
    // These four partial specializations are instantiated when a (possibly
    // cv-qualified) fundamental type is tested for convertibility to the
    // &#39;volatile&#39; reference type of another fundamental type.

BSLMF_ISCONVERTIBLE_FORWARD(const volatile FROM_TYPE, TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(      volatile FROM_TYPE, TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(const          FROM_TYPE, TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(               FROM_TYPE, TO_TYPE&amp;, 1, 1)
    // These four partial specializations are instantiated when a (possibly
    // cv-qualified) fundamental type is tested for convertibility to the
    // non-cv-qualified reference type of another fundamental type.

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Imp&lt;const FROM_TYPE, TO_TYPE, 1, 1&gt;
    : IsConvertible_Imp&lt;const FROM_TYPE, double, 0, 0&gt;::type {
    // This partial specialization is instantiated when the &#39;const&#39; (template
    // parameter) fundamental &#39;FROM_TYPE&#39; is tested for convertibility to
    // another (template parameter) fundamental &#39;TO_TYPE&#39;.  This partial
    // specialization derives from
    // &#39;IsConvertible_Imp&lt;const FROM_TYPE, double, 0, 0&gt;&#39; to avoid any
    // compilation warnings in case the &#39;TO_TYPE&#39; is an integral type and
    // &#39;FROM_TYPE&#39; is a floating-point type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Imp&lt;FROM_TYPE, TO_TYPE, 1, 1&gt;
    : IsConvertible_Imp&lt;FROM_TYPE, double, 0, 0&gt;::type {
    // This partial specialization is instantiated when the (template
    // parameter) fundamental &#39;FROM_TYPE&#39; is tested for convertibility to
    // another (template parameter) fundamental &#39;TO_TYPE&#39;.  This partial
    // specialization derives from &#39;IsConvertible_Imp&lt;FROM_TYPE, double, 0, 0&gt;&#39;
    // to avoid any compilation warnings in case that the &#39;FROM_TYPE&#39; is a
    // floating-point type and &#39;TO_TYPE&#39; is an integral type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Imp&lt;FROM_TYPE, TO_TYPE, 0, 1&gt;
    : IsConvertible_Imp&lt;FROM_TYPE, double, 0, 0&gt;::type {
    // This partial specialization is instantiated when the (template
    // parameter) &#39;FROM_TYPE&#39; is a non-fundamental type, and the (template
    // parameter) &#39;TO_TYPE&#39; is a non-&#39;void&#39; fundamental type.  This partial
    // specialization derives from &#39;IsConvertible_Imp&lt;FROM_TYPE, double, 0, 0&gt;&#39;
    // to avoid any compilation warnings in case that the &#39;FROM_TYPE&#39; is a
    // floating-point type and the &#39;TO_TYPE&#39; is an integral type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Imp&lt;FROM_TYPE, TO_TYPE, 1, 0&gt;
    : IsConvertible_Imp&lt;int, TO_TYPE, 0, 0&gt;::type {
    // This partial specialization is instantiated when the (template
    // parameter) &#39;FROM_TYPE&#39; is a non-&#39;void&#39; fundamental type, and the
    // (template parameter) &#39;TO_TYPE&#39; is a non-fundamental type.  This partial
    // specialization derives from &#39;IsConvertible_Imp&lt;int, TO_TYPE, 0, 0&gt;&#39; to
    // avoid any compilation warnings in case that the &#39;FROM_TYPE&#39; is a
    // floating-point type and the &#39;TO_TYPE&#39; is an integral type.
};

#undef BSLMF_ISCONVERTIBLE_SAMETYPEVALUE
#undef BSLMF_ISCONVERTIBLE_VALUE
#undef BSLMF_ISCONVERTIBLE_FORWARD

#endif


template &lt;class TO_TYPE&gt;
struct IsConvertible_LazyTrait : bsl::add_lvalue_reference&lt;
                                     typename bsl::add_const&lt;
                                       typename bsl::remove_cv&lt;TO_TYPE&gt;::type
                                                                      &gt;::type
                                                                      &gt; {
};


template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_IsNeverConvertible
     : bsl::integral_constant&lt;bool, bsl::is_void&lt;FROM_TYPE&gt;::value
                                    || bsl::is_array&lt;TO_TYPE&gt;::value
                                    || bsl::is_function&lt;TO_TYPE&gt;::value&gt; {};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_FilterNeverConvertible
     : bsl::conditional&lt;
                   IsConvertible_IsNeverConvertible&lt;FROM_TYPE, TO_TYPE&gt;::value,
                   bsl::false_type,
                   IsConvertible_Imp&lt;
                                FROM_TYPE,
                                typename IsConvertible_LazyTrait&lt;TO_TYPE&gt;::type
                                    &gt;
                       &gt;::type {
};


template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Conditional : bsl::conditional&lt;
     bsl::is_void&lt;TO_TYPE&gt;::value,
     typename bsl::is_void&lt;FROM_TYPE&gt;::type,
     IsConvertible_FilterNeverConvertible&lt;
                        typename IsConvertible_CheckComplete&lt;FROM_TYPE&gt;::type,
                        typename IsConvertible_CheckComplete&lt;  TO_TYPE&gt;::type&gt;
                                                                      &gt;::type {
};

}  // close package namespace
}  // close enterprise namespace

namespace bsl {

                         // ==============================
                         // struct is_convertible_dispatch
                         // ==============================

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible_dispatch
    : BloombergLP::bslmf::IsConvertible_Conditional&lt;FROM_TYPE, TO_TYPE&gt;::type {
    // This &#39;struct&#39; template implements the &#39;is_convertible_dispatch&#39;
    // meta-function defined in the C++11 standard [meta.rel] to determine if
    // the (template parameter) &#39;FROM_TYPE&#39; is convertible to the (template
    // parameter) &#39;TO_TYPE&#39;.  This &#39;struct&#39; derives from &#39;bsl::true_type&#39; if
    // the &#39;FROM_TYPE&#39; is convertible to &#39;TO_TYPE&#39;, and from &#39;bsl::false_type&#39;
    // otherwise.  Note that both &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39; should be complete
    // types, arrays of unknown bound, or (possibly cv-qualified) &#39;void&#39; types.
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;TYPE, TYPE&amp;&gt;
     : integral_constant&lt; bool
                        , is_reference&lt;TYPE&gt;::value
                          || is_function&lt;TYPE&gt;::value
                          || is_const&lt;TYPE&gt;::value&gt; {
    // This set of rules corresponds with the reference binding rules in c++11,
    // where the specification of &#39;is_convertible_dispatch&#39; relies on
    // rvalue-references.  We must supply these specializations directly in
    // order to support C++03 compilers that do not have a good substitute for
    // rvalue-references, as using &#39;const &amp;&#39; instead produces subtly different
    // results in some cases.
};

// Some compilers need explicit guidance on a few of the reference-binding
// conversions.  All compilers get most of these correct, but once a few
// specializations are added, the full set is required to avoid ambiguities.

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;TYPE, const TYPE&amp;&gt;
    : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;TYPE, volatile TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;TYPE, const volatile TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const TYPE, TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const TYPE, const TYPE&amp;&gt;
    : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const TYPE, volatile TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const TYPE, const volatile TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE, TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE, const TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE, volatile TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE, const volatile TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const volatile TYPE, TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const volatile TYPE, const TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const volatile TYPE, volatile TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const volatile TYPE, const volatile TYPE&amp;&gt;
    : false_type {
};

// The next group of partial specializations deal with various cases of
// converting to an lvalue-reference, which we make explicitly conform to the
// C++11 idiom of converting from an rvalue (which may be an lvalue-reference).

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;TYPE&amp;, TYPE&amp;&gt; : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;TYPE&amp;, const TYPE&amp;&gt; : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;TYPE&amp;, volatile TYPE&amp;&gt; : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;TYPE&amp;, const volatile TYPE&amp;&gt; : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const TYPE&amp;, TYPE&amp;&gt; : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const TYPE&amp;, const TYPE&amp;&gt; : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const TYPE&amp;, volatile TYPE&amp;&gt; : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const TYPE&amp;, const volatile TYPE&amp;&gt; : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE&amp;, TYPE&amp;&gt; : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE&amp;, const TYPE&amp;&gt; : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE&amp;, volatile TYPE&amp;&gt; : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE&amp;, const volatile TYPE&amp;&gt;
    : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const volatile TYPE&amp;, TYPE&amp;&gt; : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const volatile TYPE&amp;, const TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const volatile TYPE&amp;, volatile TYPE&amp;&gt;
    : false_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;const volatile TYPE&amp;, const volatile TYPE&amp;&gt;
    : true_type {
};

template &lt;class TYPE&gt;
struct is_convertible_dispatch&lt;volatile TYPE, TYPE&gt;
     : BloombergLP::bslmf::IsConvertible_Conditional&lt;TYPE, TYPE&gt;::type {
    // Correct handling of non-fundamental volatile conversions to self.  Note
    // that this is not trivially true, but tests that &#39;TYPE&#39; is copy (or move)
    // constructible.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible_dispatch&lt;FROM_TYPE, volatile TO_TYPE&amp;&gt;
    : false_type {
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible_dispatch&lt;FROM_TYPE, const volatile TO_TYPE&amp;&gt;
    : false_type {
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible_dispatch&lt;volatile FROM_TYPE&amp;, volatile TO_TYPE&amp;&gt;
    : is_convertible_dispatch&lt;FROM_TYPE*, TO_TYPE*&gt;::type {
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible_dispatch&lt;volatile FROM_TYPE&amp;, const volatile TO_TYPE&amp;&gt;
     : is_convertible_dispatch&lt;FROM_TYPE, const volatile TO_TYPE&amp;&gt;::type {
};

                         // =====================
                         // struct is_convertible
                         // =====================

template &lt;class FROM_TYPE&gt;
struct EffectiveFromType : conditional&lt;
              is_fundamental&lt;FROM_TYPE&gt;::value || is_pointer&lt;FROM_TYPE&gt;::value,
              typename remove_cv&lt;FROM_TYPE&gt;::type,
              FROM_TYPE&gt; {
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible_dispatch&lt;volatile FROM_TYPE&amp;, TO_TYPE&gt;
     : bsl::conditional&lt;
              bsl::is_fundamental&lt;FROM_TYPE&gt;::value,
              typename bsl::is_convertible_dispatch&lt;FROM_TYPE, TO_TYPE&gt;::type,
              typename BloombergLP::bslmf::IsConvertible_Conditional&lt;
                                                            volatile FROM_TYPE,
                                                            TO_TYPE&gt;::type
                       &gt;::type {
};


template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible
    :  is_convertible_dispatch&lt; typename EffectiveFromType&lt;FROM_TYPE&gt;::type
                              , TO_TYPE
                              &gt;::type {
    // This &#39;struct&#39; template implements the &#39;is_convertible_dispatch&#39;
    // meta-function defined in the C++11 standard [meta.rel] to determine if
    // the (template parameter) &#39;FROM_TYPE&#39; is convertible to the (template
    // parameter) &#39;TO_TYPE&#39;.  This &#39;struct&#39; derives from &#39;bsl::true_type&#39; if
    // the &#39;FROM_TYPE&#39; is convertible to &#39;TO_TYPE&#39;, and from &#39;bsl::false_type&#39;
    // otherwise.  Note that both &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39; should be complete
    // types, arrays of unknown bound, or (possibly cv-qualified) &#39;void&#39; types.
};

}  // close namespace bsl
#endif

namespace BloombergLP {
namespace bslmf {

                         // ====================
                         // struct IsConvertible
                         // ====================

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible : bsl::is_convertible&lt;FROM_TYPE, TO_TYPE&gt;::type {
    // This &#39;struct&#39; template implements a meta-function to determine if the
    // (template parameter) &#39;FROM_TYPE&#39; is convertible to the (template
    // parameter) &#39;TO_TYPE&#39;.  This &#39;struct&#39; derives from &#39;bsl::true_type&#39; if
    // the &#39;FROM_TYPE&#39; is convertible to &#39;TO_TYPE&#39;, and from &#39;bsl::false_type&#39;
    // otherwise.  Note that both &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39; should be complete
    // types, arrays of unknown bound, or (possibly cv-qualified) &#39;void&#39; types.
};

}  // close package namespace


}  // close enterprise namespace

#endif // ! defined(INCLUDED_BSLMF_ISCONVERTIBLE)

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
