<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslmf_isconvertible.h                                              -*-C++-*-
#ifndef INCLUDED_BSLMF_ISCONVERTIBLE
#define INCLUDED_BSLMF_ISCONVERTIBLE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a compile-time check for type conversion.
//
//@CLASSES:
//  bsl::is_convertible: standard meta-function for type conversion checking
//  bslmf::IsConvertible: meta-function for type conversion checking
//
//@SEE_ALSO: bslmf_integralconstant
//
//@DESCRIPTION: This component defines two meta-functions,
// &#39;bsl::is_convertible&#39; and &#39;BloombergLP::bslmf::IsConvertible&#39;, both of which
// may be used to check whether a conversion exists from one type to another.
//
// &#39;bsl::is_convertible&#39; meets the requirements of the &#39;is_convertible&#39;
// template defined in the C++11 standard [meta.rel], while
// &#39;bslmf::IsConvertible&#39; was devised before &#39;is_convertible&#39; was standardized.
//
// The two meta-functions are functionally equivalent except that
// &#39;bsl::is_convertible&#39; does not allow its template parameter types to be
// incomplete types according to the C++11 standard while
// &#39;bslmf::IsConvertible&#39; tests conversions involving incomplete types.  The
// other major difference between them is that the result for
// &#39;bsl::is_convertible&#39; is indicated by the class members &#39;value&#39; and &#39;type&#39;,
// whereas the result for &#39;bslmf::IsConvertible&#39; is indicated by the class
// members &#39;VALUE&#39; and &#39;Type&#39;.
//
// Note that &#39;bsl::is_convertible&#39; should be preferred over
// &#39;bslmf::IsConvertible&#39;, and in general, should be used by new components.
// Also note that &#39;bsl::is_convertible&#39; and &#39;bslmf::IsConvertible&#39; can produce
// compiler errors if the conversion is ambiguous.  For example:
//..
//  struct A {};
//  struct B : public A {};
//  struct C : public A {};
//  struct D : public B, public C {};
//
//  static int const C = bsl::is_convertible&lt;D*, A*&gt;::value;  // ERROR!
//..
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Select Function Based on Type Convertibility
///- - - - - - - - - - - - - - - - - - - - - - - - - - - -
// The &#39;bsl::is_convertible&#39; meta-function can be used to select an appropriate
// function (at compile time) based on the convertibility of one type to
// another without causing a compiler error by actually trying the conversion.
//
// Suppose we are implementing a &#39;convertToInt&#39; template method that converts a
// given object of the (template parameter) &#39;TYPE&#39; to &#39;int&#39; type, and returns
// the integer value.  If the given object can not convert to &#39;int&#39;, return 0.
// The method calls an overloaded function, &#39;getIntValue&#39;, to get the converted
// integer value.  The idea is to invoke one version of &#39;getIntValue&#39; if the
// type provides a conversion operator that returns an integer value, and
// another version if the type does not provide such an operator.
//
// First, we define two classes, &#39;Foo&#39; and &#39;Bar&#39;.  The &#39;Foo&#39; class has a
// conversion operator that returns an integer value while the &#39;Bar&#39; class does
// not:
//..
//  class Foo {
//      // DATA
//      int d_value;
//
//    public:
//      // CREATORS
//      explicit Foo(int value) : d_value(value) {}
//
//      // ACCESSORS
//      operator int() const { return d_value; }
//  };
//
//  class Bar {};
//..
// Then, we define the first &#39;getIntValue&#39; function that takes a
// &#39;bsl::false_type&#39; as its last argument, whereas the second &#39;getIntValue&#39;
// function takes a &#39;bsl::true_type&#39; object.  The result of the
// &#39;bsl::is_convertible&#39; meta-function (i.e., its &#39;type&#39; member) is used to
// create the last argument passed to &#39;getIntValue&#39;.  Neither version of
// &#39;getIntValue&#39; makes use of this argument -- it is used only to differentiate
// the argument list so we can overload the function.
//..
//  template &lt;class TYPE&gt;
//  inline
//  int getIntValue(TYPE *object, bsl::false_type)
//  {
//      // Return 0 because the specified &#39;object&#39; of the (template parameter)
//      // &#39;TYPE&#39; is not convertible to the &#39;int&#39; type.
//
//      return 0;
//  }
//
//  template &lt;class TYPE&gt;
//  inline
//  int getIntValue(TYPE *object, bsl::true_type)
//  {
//      // Return the integer value converted from the specified &#39;object&#39; of
//      // the (template parameter) &#39;TYPE&#39;.
//
//      return int(*object);
//  }
//..
// Now, we define our &#39;convertToInt&#39; method:
//..
//  template &lt;class TYPE&gt;
//  inline
//  int convertToInt(TYPE *object)
//  {
//      typedef typename bsl::is_convertible&lt;TYPE, int&gt;::type CanConvertToInt;
//      return getIntValue(object, CanConvertToInt());
//  }
//..
// Notice that we use &#39;bsl::is_convertible&#39; to get a &#39;bsl::false_type&#39; or
// &#39;bsl::true_type&#39;, and then call the corresponding overloaded &#39;getIntValue&#39;
// method.
//
// Finally, we call &#39;convertToInt&#39; with both &#39;Foo&#39; and &#39;Bar&#39; classes:
//..
//  Foo foo(99);
//  Bar bar;
//
//  printf(&quot;%d\n&quot;, convertToInt(&amp;foo));
//  printf(&quot;%d\n&quot;, convertToInt(&amp;bar));
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDCONST
#include &lt;bslmf_addconst.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDLVALUEREFERENCE
#include &lt;bslmf_addlvaluereference.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ENABLEIF
#include &lt;bslmf_enableif.h&gt;
#endif

#ifndef INCLUDED_BSLMF_INTEGRALCONSTANT
#include &lt;bslmf_integralconstant.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISFUNCTION
#include &lt;bslmf_isfunction.h&gt;
#endif
#ifndef INCLUDED_BSLMF_ISFUNDAMENTAL
#include &lt;bslmf_isfundamental.h&gt;
#endif

#ifndef INCLUDED_BSLMF_MATCHANYTYPE
#include &lt;bslmf_matchanytype.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECV
#include &lt;bslmf_removecv.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

namespace BloombergLP {

namespace bslmf {

                         // ==========================
                         // struct IsConvertible_Match
                         // ==========================

struct IsConvertible_Match {
    // This &#39;struct&#39; provides functions to check for successful conversion
    // matches.  Sun CC 5.2 requires that this &#39;struct&#39; not be nested within
    // &#39;IsConvertible_Imp&#39;.

    typedef struct { char a;    } yes_type;
    typedef struct { char a[2]; } no_type;

    static yes_type match(IsConvertible_Match&amp;);
        // Return &#39;yes_type&#39; if called on &#39;IsConvertible_Match&#39; type.

    template &lt;class TYPE&gt;
    static no_type match(const TYPE&amp;);
        // Return &#39;yes_type&#39; if the (template parameter) &#39;TYPE&#39; is
        // &#39;IsConvertible_Match&#39;, and &#39;no_type&#39; otherwise.

    template &lt;class TYPE&gt;
    static no_type match(const volatile TYPE&amp;);
        // Return &#39;yes_type&#39; if the (template parameter) &#39;TYPE&#39; is
        // &#39;IsConvertible_Match&#39; and &#39;no_type&#39; otherwise.

    template &lt;class TYPE&gt;
    static
    typename bsl::enable_if&lt;bsl::is_function&lt;TYPE&gt;::value, no_type&gt;::type
        match(TYPE&amp;);
        // Return &#39;yes_type&#39; if the (template parameter) &#39;TYPE&#39; is
        // &#39;IsConvertible_Match&#39; and &#39;no_type&#39; otherwise.
};

                         // ========================
                         // struct IsConvertible_Imp
                         // ========================

template &lt;class FROM_TYPE, class TO_TYPE
#if defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)
         , int IS_FROM_FUNDAMENTAL = IsFundamental&lt;FROM_TYPE&gt;::value
         , int IS_TO_FUNDAMENTAL   = IsFundamental&lt;TO_TYPE&gt;::value
#endif
         &gt;
struct IsConvertible_Imp {
    // This &#39;struct&#39; template implements the meta-function to determine type
    // conversion between the (template parameter) &#39;FROM_TYPE&#39; and the
    // (template parameter) &#39;TO_TYPE&#39; where the conversion to the &#39;TO_TYPE&#39; is
    // not necessarily the same as conversion to &#39;const TO_TYPE&amp;&#39;.
    //
    // Note that significant documentation about the details of this
    // implementation can be found in &#39;bslmf_isconvertible.cpp&#39;.

  private:
    struct Test
    {
        // A unique (empty) type returned by the comma operator.

        IsConvertible_Match&amp; operator, (TO_TYPE) const;
            // Return a reference to type &#39;IsConvertible_Match&#39;.
    };

  public:

#ifdef BSLS_PLATFORM_CMP_MSVC
#   pragma warning(push)
#   pragma warning(disable: 4244)  // loss of precision warning ignored
#endif
    enum {

        value = (sizeof(IsConvertible_Match::yes_type) ==
                 sizeof(IsConvertible_Match::match(
                           (TypeRep&lt;Test&gt;::rep(), TypeRep&lt;FROM_TYPE&gt;::rep()))))
            // Return the convertibility between &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39;.
            // This is set by invoking the &#39;operator,&#39; method having &#39;Test&amp;&#39; on
            // the left and &#39;FROM_TYPE&#39; on the right.  The &#39;value&#39; is &#39;true&#39; if
            // &#39;FROM_TYPE&#39; is convertible to &#39;TO_TYPE&#39;, and &#39;false&#39; otherwise.
    };

#ifdef BSLS_PLATFORM_CMP_MSVC
#   pragma warning(pop)
#endif

    typedef bsl::integral_constant&lt;bool, value&gt; type;
        // This &#39;typedef&#39; returns &#39;bsl::true_type&#39; if &#39;FROM_TYPE&#39; is
        // convertible to &#39;TO_TYPE&#39;, and &#39;bsl::false_type&#39; otherwise.
};

#if defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG)

#define BSLMF_ISCONVERTIBLE_SAMETYPEVALUE(VALUE, FROM, TO, FROM_FUND, TO_FUND)\
template &lt;class TYPE&gt;                                                         \
struct IsConvertible_Imp&lt;FROM, TO, FROM_FUND, TO_FUND&gt;                        \
     : bsl::integral_constant&lt;bool, VALUE&gt; {};
    // This partial specialization of &#39;bslmf::IsConvertible_Imp&#39; derives from
    // &#39;bsl::integral_constant&#39; having the specified macro argument &#39;VALUE&#39;.
    // The specified macro arguments &#39;FROM&#39; and &#39;TO&#39; are cv-qualified type
    // expressions constructed out of the (template parameter) &#39;TYPE&#39;.

#define BSLMF_ISCONVERTIBLE_VALUE(VALUE, FROM, TO, FROM_FUND, TO_FUND)        \
template &lt;class FROM_TYPE, class TO_TYPE&gt;                                     \
struct IsConvertible_Imp&lt;FROM, TO, FROM_FUND, TO_FUND&gt;                        \
     : bsl::integral_constant&lt;bool, VALUE&gt; {};
    // This partial specialization of &#39;bslmf::IsConvertible_Imp&#39; derives from
    // &#39;bsl::integral_constant&#39; having the specified macro argument &#39;VALUE&#39;.
    // The specified macro arguments &#39;FROM&#39; and &#39;TO&#39; are cv-qualified type
    // expressions constructed out of &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39;, respectively.

#define BSLMF_ISCONVERTIBLE_FORWARD(FROM, TO, FROM_FUND, TO_FUND)             \
template &lt;class FROM_TYPE, class TO_TYPE&gt;                                     \
struct IsConvertible_Imp&lt;FROM, TO, FROM_FUND, TO_FUND&gt;                        \
     : IsConvertible_Imp&lt;FROM, TO, 0, 0&gt; {};
    // This partial specialization of &#39;bslmf::IsConvertible_Imp&#39; applies the
    // general mechanism for non-fundamental types.  The specified macro
    // arguments &#39;FROM&#39; and &#39;TO&#39; are cv-qualified type expressions constructed
    // out of &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39;, respectively.

BSLMF_ISCONVERTIBLE_SAMETYPEVALUE(0, const volatile TYPE, const TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_SAMETYPEVALUE(0,       volatile TYPE, const TYPE&amp;, 1, 1)
    // These two partial specializations are instantiated when a (possibly
    // &#39;const&#39;-qualified) &#39;volatile&#39; fundamental type is tested for
    // convertibility to its &#39;const&#39; reference type.  The conversion shall
    // fail.

BSLMF_ISCONVERTIBLE_VALUE(1, const volatile FROM_TYPE, const TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_VALUE(1,       volatile FROM_TYPE, const TO_TYPE&amp;, 1, 1)
    // These two partial specializations are instantiated when a (possibly
    // &#39;const&#39;-qualified) &#39;volatile&#39; type is tested for convertibility to the
    // &#39;const&#39; reference type of another fundamental type.  These partial
    // specializations will be picked up if the previous two fail to match.
    // The conversion shall succeed.

BSLMF_ISCONVERTIBLE_VALUE(1, const FROM_TYPE, const TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_VALUE(1,       FROM_TYPE, const TO_TYPE&amp;, 1, 1)
    // These two partial specializations are instantiated when a (possibly
    // &#39;const&#39;-qualified) fundamental type is tested for convertibility to the
    // &#39;const&#39; reference type of another fundamental type.  These partial
    // specializations will be picked up if the previous two fail to match.
    // The conversion shall succeed.

BSLMF_ISCONVERTIBLE_FORWARD(const volatile FROM_TYPE,
                            const volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(      volatile FROM_TYPE,
                            const volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(const          FROM_TYPE,
                            const volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(               FROM_TYPE,
                            const volatile TO_TYPE&amp;, 1, 1)
    // These four partial specializations are instantiated when a (possibly
    // cv-qualified) fundamental type is tested for convertibility to the
    // &#39;const volatile&#39; reference type of another fundamental type.

BSLMF_ISCONVERTIBLE_FORWARD(const volatile FROM_TYPE,
                                  volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(      volatile FROM_TYPE,
                                  volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(const          FROM_TYPE,
                                  volatile TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(               FROM_TYPE,
                                  volatile TO_TYPE&amp;, 1, 1)
    // These four partial specializations are instantiated when a (possibly
    // cv-qualified) fundamental type is tested for convertibility to the
    // &#39;volatile&#39; reference type of another fundamental type.

BSLMF_ISCONVERTIBLE_FORWARD(const volatile FROM_TYPE, TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(      volatile FROM_TYPE, TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(const          FROM_TYPE, TO_TYPE&amp;, 1, 1)
BSLMF_ISCONVERTIBLE_FORWARD(               FROM_TYPE, TO_TYPE&amp;, 1, 1)
    // These four partial specializations are instantiated when a (possibly
    // cv-qualified) fundamental type is tested for convertibility to the
    // non-cv-qualified reference type of another fundamental type.

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Imp&lt;const FROM_TYPE, TO_TYPE, 1, 1&gt;
    : IsConvertible_Imp&lt;const FROM_TYPE, double, 0, 0&gt;::type {
    // This partial specialization is instantiated when the &#39;const&#39; (template
    // parameter) fundamental &#39;FROM_TYPE&#39; is tested for convertibility to
    // another (template parameter) fundamental &#39;TO_TYPE&#39;.  This partial
    // specialization derives from
    // &#39;IsConvertible_Imp&lt;const FROM_TYPE, double, 0, 0&gt;&#39; to avoid any
    // compilation warnings in case the &#39;TO_TYPE&#39; is an integral type and
    // &#39;FROM_TYPE&#39; is a floating-point type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Imp&lt;FROM_TYPE, TO_TYPE, 1, 1&gt;
    : IsConvertible_Imp&lt;FROM_TYPE, double, 0, 0&gt;::type {
    // This partial specialization is instantiated when the (template
    // parameter) fundamental &#39;FROM_TYPE&#39; is tested for convertibility to
    // another (template parameter) fundamental &#39;TO_TYPE&#39;.  This partial
    // specialization derives from &#39;IsConvertible_Imp&lt;FROM_TYPE, double, 0, 0&gt;&#39;
    // to avoid any compilation warnings in case that the &#39;FROM_TYPE&#39; is a
    // floating-point type and &#39;TO_TYPE&#39; is an integral type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Imp&lt;FROM_TYPE, TO_TYPE, 0, 1&gt;
    : IsConvertible_Imp&lt;FROM_TYPE, double, 0, 0&gt;::type {
    // This partial specialization is instantiated when the (template
    // parameter) &#39;FROM_TYPE&#39; is a non-fundamental type, and the (template
    // parameter) &#39;TO_TYPE&#39; is a non-&#39;void&#39; fundamental type.  This partial
    // specialization derives from &#39;IsConvertible_Imp&lt;FROM_TYPE, double, 0, 0&gt;&#39;
    // to avoid any compilation warnings in case that the &#39;FROM_TYPE&#39; is a
    // floating-point type and the &#39;TO_TYPE&#39; is an integral type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible_Imp&lt;FROM_TYPE, TO_TYPE, 1, 0&gt;
    : IsConvertible_Imp&lt;int, TO_TYPE, 0, 0&gt;::type {
    // This partial specialization is instantiated when the (template
    // parameter) &#39;FROM_TYPE&#39; is a non-&#39;void&#39; fundamental type, and the
    // (template parameter) &#39;TO_TYPE&#39; is a non-fundamental type.  This partial
    // specialization derives from &#39;IsConvertible_Imp&lt;int, TO_TYPE, 0, 0&gt;&#39; to
    // avoid any compilation warnings in case that the &#39;FROM_TYPE&#39; is a
    // floating-point type and the &#39;TO_TYPE&#39; is an integral type.
};

#undef BSLMF_ISCONVERTIBLE_SAMETYPEVALUE
#undef BSLMF_ISCONVERTIBLE_VALUE
#undef BSLMF_ISCONVERTIBLE_FORWARD
#endif

}  // close package namespace

}  // close enterprise namespace

namespace bsl {

                         // =====================
                         // struct is_convertible
                         // =====================

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible
    : BloombergLP::bslmf::IsConvertible_Imp&lt;
                   FROM_TYPE,
                   typename add_lvalue_reference&lt;
                     typename add_const&lt;
                       typename remove_cv&lt;TO_TYPE&gt;::type&gt;::type&gt;::type&gt;::type {
    // This &#39;struct&#39; template implements the &#39;is_convertible&#39; meta-function
    // defined in the C++11 standard [meta.rel] to determine if the (template
    // parameter) &#39;FROM_TYPE&#39; is convertible to the (template parameter)
    // &#39;TO_TYPE&#39;.  This &#39;struct&#39; derives from &#39;bsl::true_type&#39; if the
    // &#39;FROM_TYPE&#39; is convertible to &#39;TO_TYPE&#39;, and from &#39;bsl::false_type&#39;
    // otherwise.  Note that both &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39; should be complete
    // types, arrays of unknown bound, or (possibly cv-qualified) &#39;void&#39; types.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible&lt;FROM_TYPE, TO_TYPE&amp;&gt;
    : BloombergLP::bslmf::IsConvertible_Imp&lt;FROM_TYPE, TO_TYPE&amp;&gt;::type {
    // This partial specialization is instantiated for the case where the
    // (template parameter) &#39;TO_TYPE&#39; is a reference type.
};

template &lt;class FROM_TYPE&gt;
struct is_convertible&lt;FROM_TYPE, void&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the (template parameter) &#39;FROM_TYPE&#39; is
    // a non-&#39;void&#39; type and is being converted to the &#39;void&#39; type.
};

template &lt;class FROM_TYPE&gt;
struct is_convertible&lt;FROM_TYPE, const void&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the (template parameter) &#39;FROM_TYPE&#39; is
    // a non-&#39;void&#39; type and is being converted to the &#39;const void&#39; type.
};

template &lt;class FROM_TYPE&gt;
struct is_convertible&lt;FROM_TYPE, volatile void&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the (template parameter) &#39;FROM_TYPE&#39; is
    // a non-&#39;void&#39; type and is being converted to the &#39;volatile void&#39; type.
};

template &lt;class FROM_TYPE&gt;
struct is_convertible&lt;FROM_TYPE, const volatile void&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the (template parameter) &#39;FROM_TYPE&#39; is
    // a non-&#39;void&#39; type and is being converted to the &#39;const volatile void&#39;
    // type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible&lt;volatile FROM_TYPE, TO_TYPE&gt;
   : BloombergLP::bslmf::IsConvertible_Imp&lt;volatile FROM_TYPE, TO_TYPE&gt;::type {
    // This partial specialization is instantiated for the case where the
    // (template parameter) &#39;FROM_TYPE&#39; is a &#39;volatile&#39; type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible&lt;volatile FROM_TYPE, TO_TYPE&amp;&gt;
  : BloombergLP::bslmf::IsConvertible_Imp&lt;volatile FROM_TYPE, TO_TYPE&amp;&gt;::type {
    // This partial specialization is instantiated for the case where the
    // (template parameter) &#39;FROM_TYPE&#39; is a &#39;volatile&#39; type and the (template
    // parameter) &#39;TO_TYPE&#39; is a reference type.
};

template &lt;class FROM_TYPE&gt;
struct is_convertible&lt;volatile FROM_TYPE, void&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the (template parameter) &#39;FROM_TYPE&#39; is
    // a &#39;volatile&#39; type and is being converted to the &#39;void&#39; type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible&lt;volatile FROM_TYPE&amp;, TO_TYPE&gt;
  : BloombergLP::bslmf::IsConvertible_Imp&lt;volatile FROM_TYPE&amp;, TO_TYPE&gt;::type {
    // This partial specialization is instantiated for the case where the
    // (template parameter) &#39;FROM_TYPE&#39; is a reference to a &#39;volatile&#39; type.
};

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct is_convertible&lt;volatile FROM_TYPE&amp;, TO_TYPE&amp;&gt;
 : BloombergLP::bslmf::IsConvertible_Imp&lt;volatile FROM_TYPE&amp;, TO_TYPE&amp;&gt;::type {
    // This partial specialization is instantiated for the case where the
    // (template parameter) &#39;FROM_TYPE&#39; is a reference to a &#39;volatile&#39; type and
    // the (template parameter) &#39;TO_TYPE&#39; is a reference type.
};

template &lt;class FROM_TYPE&gt;
struct is_convertible&lt;volatile FROM_TYPE&amp;, void&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the (template parameter) &#39;FROM_TYPE&#39; is
    // a reference to a &#39;volatile&#39; type and is being converted to the &#39;void&#39;
    // type.
};

template &lt;class TO_TYPE&gt;
struct is_convertible&lt;void, TO_TYPE&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the non-&#39;void&#39; (template parameter) &#39;TO_TYPE&#39;.
};

template &lt;class TO_TYPE&gt;
struct is_convertible&lt;const void, TO_TYPE&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the &#39;const void&#39; type is being converted
    // to the non-&#39;void&#39; (template parameter) &#39;TO_TYPE&#39;.
};

template &lt;class TO_TYPE&gt;
struct is_convertible&lt;volatile void, TO_TYPE&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the &#39;volatile void&#39; type is being
    // converted to the non-&#39;void&#39; (template parameter) &#39;TO_TYPE&#39;.
};

template &lt;class TO_TYPE&gt;
struct is_convertible&lt;const volatile void, TO_TYPE&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the &#39;const volatile void&#39; type is being
    // converted to the non-&#39;void&#39; (template parameter) &#39;TO_TYPE&#39;.
};

template &lt;class TO_TYPE&gt;
struct is_convertible&lt;void, TO_TYPE&amp;&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the non-&#39;void&#39; (template parameter) &#39;TO_TYPE&amp;&#39;.
};

template &lt;class TO_TYPE&gt;
struct is_convertible&lt;const void, TO_TYPE&amp;&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the &#39;const void&#39; type is being converted
    // to the non-&#39;void&#39; (template parameter) &#39;TO_TYPE&amp;&#39;.
};

template &lt;class TO_TYPE&gt;
struct is_convertible&lt;volatile void, TO_TYPE&amp;&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the &#39;volatile void&#39; type is being
    // converted to the non-&#39;void&#39; (template parameter) &#39;TO_TYPE&amp;&#39;.
};

template &lt;class TO_TYPE&gt;
struct is_convertible&lt;const volatile void, TO_TYPE&amp;&gt; : false_type {
    // This partial specialization deriving from &#39;bsl::false_type&#39; is
    // instantiated for the case where the &#39;const volatile void&#39; type is being
    // converted to the non-&#39;void&#39; (template parameter) &#39;TO_TYPE&amp;&#39;.
};

template &lt;&gt;
struct is_convertible&lt;void, void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;void, const void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;void, volatile void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;void, const volatile void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;const void, void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;const void, const void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;const void, volatile void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;const void, const volatile void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;volatile void, void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;volatile void, const void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;volatile void, volatile void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;volatile void, const volatile void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;const volatile void, void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;const volatile void, const void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;const volatile void, volatile void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

template &lt;&gt;
struct is_convertible&lt;const volatile void, const volatile void&gt; : true_type {
    // This partial specialization deriving from &#39;bsl::true_type&#39; is
    // instantiated for the case where the &#39;void&#39; type is being converted to
    // the &#39;void&#39; type.
};

}  // close namespace bsl

namespace BloombergLP {

namespace bslmf {

                         // ====================
                         // struct IsConvertible
                         // ====================

template &lt;class FROM_TYPE, class TO_TYPE&gt;
struct IsConvertible : bsl::is_convertible&lt;FROM_TYPE, TO_TYPE&gt;::type {
    // This &#39;struct&#39; template implements a meta-function to determine if the
    // (template parameter) &#39;FROM_TYPE&#39; is convertible to the (template
    // parameter) &#39;TO_TYPE&#39;.  This &#39;struct&#39; derives from &#39;bsl::true_type&#39; if
    // the &#39;FROM_TYPE&#39; is convertible to &#39;TO_TYPE&#39;, and from &#39;bsl::false_type&#39;
    // otherwise.  Note that both &#39;FROM_TYPE&#39; and &#39;TO_TYPE&#39; should be complete
    // types, arrays of unknown bound, or (possibly cv-qualified) &#39;void&#39; types.
};

}  // close package namespace


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
