<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmt_barrier Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmt_barrier<br/>
<small>
[<a class="el" href="group__bslmt.html">Package bslmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a thread barrier component.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Supported Clock-Types</a> </li>
<li>
<a href="#3.2">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a thread barrier component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a> </td><td>thread barrier class  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslmt__mutex.html" title="Provide a platform-independent mutex.">Component bslmt_mutex</a>, <a class="el" href="group__bslmt__condition.html" title="Provide a portable, efficient condition variable.">Component bslmt_condition</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a thread barrier named <code><a class="el" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a></code>. Barriers provide a simple mechanism for synchronizing a series of threads at a given point in a program. A barrier is constructed with a number <code>numThreads</code> which is the number of threads required to reach the synchronization point for the barrier to be unblocked. As each thread reaches the synchronization point, it calls the <code>wait</code> method and blocks. An invariant is that the number of threads blocking on a barrier is always less than <code>numThreads</code>. Once the required <code>numThreads</code> threads have called <code>wait</code>, the invariant is restored by unblocking all the threads and resetting the barrier to its initial state. In particular, the barrier can be reused several times in succession. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that the number of threads sharing the use of the barrier should be exactly <code>numThreads</code>, as only exactly <code>numThreads</code> threads calling <code>wait</code> will be unblocked. In particular, extra threads calling <code>wait</code> will block, perhaps unwittingly participating in the next round of reuse of the barrier together with the unblocked <code>numThreads</code> threads (leading to potential race conditions). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note also that the behavior is undefined if a barrier is destroyed while one or more threads are waiting on it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="supported_clock-types"></a> <a class="anchor" id="description.supported_clock-types"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Supported Clock-Types: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The component <code><a class="el" href="structbsls_1_1SystemClockType.html">bsls::SystemClockType</a></code> supplies the enumeration indicating the system clock on which timeouts supplied to other methods should be based. If the clock type indicated at construction is <code><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba4b4f6a6781cc76138225ba163ed717a8">bsls::SystemClockType::e_REALTIME</a></code>, the timeout should be expressed as an absolute offset since 00:00:00 UTC, January 1, 1970 (which matches the epoch used in <code>bsls::SystemTime::now(bsls::SystemClockType::e_REALTIME)</code>. If the clock type indicated at construction is <code><a class="el" href="structbsls_1_1SystemClockType.html#a6e75b1e793b629b48e21b6cee448d56ba28811e3a40d5ac56aeed9bd363c12201">bsls::SystemClockType::e_MONOTONIC</a></code>, the timeout should be expressed as an absolute offset since the epoch of this clock (which matches the epoch used in <code>bsls::SystemTime::now(bsls::SystemClockType::e_MONOTONIC)</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates the use of a <code><a class="el" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a></code> to create "checkpoints" in a threaded "basket trade" processing logic. In this example, a "basket" is a series of trades submitted as one logical trade. If any given trade fails to process for any reason, then all the trades must be cancelled. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The example is driven through function <code>processBasketTrade</code>, which takes as its argument a reference to a <code>BasketTrade</code> structure. The <code>BasketTrade</code> structure contains a collection of <code>Trade</code> objects; the <code>processBasketTrade</code> function creates a separate thread to manage each <code>Trade</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>Trade</code> threads proceed independently, except that they synchronize with one another at various stages of the trade processing: each thread waits for all trades to complete a given step before any individual trade thread proceeds to the next step. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a></code> is used repeatedly at each processing stage to wait for all trades to complete the given stage before continuing to the next stage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To begin, we define the fundamental structures <code>Trade</code> and <code>BasketTrade</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      k_MAX_BASKET_TRADES = 10
  };

  <span class="keyword">struct </span>Trade {
      <span class="comment">// Trade stuff...</span>
  };

  <span class="keyword">struct </span>BasketTrade {
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;Trade&gt;</a> d_trades;  <span class="comment">// array of trade that comprise the</span>
                                    <span class="comment">// basket</span>
  };
</pre></div><br/>
<br/>
 Functions <code>validateTrade</code>, <code>insertToDatabase</code>, and <code>submitToExchange</code> define functionality for the three stages of trade processing. Again, the <code><a class="el" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a></code> will be used so that no individual trade moves forward to the next stage before all trades have completed the given stage. So, for instance, no individual trade can call the <code>insertToDatabase</code> function until all trades have successfully completed the <code>validateTrade</code> function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Functions <code>deleteFromDatabase</code> and <code>cancelAtExchange</code> are used for rolling back all trades in the event that any one trade fails to move forward. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The implementation of these functions is left incomplete for our example. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> validateTrade(Trade &amp;trade)
  {
      (void)trade;
      <span class="keywordtype">int</span> result = 0;
      <span class="comment">// Do some checking here...</span>

      <span class="keywordflow">return</span> result;
  }

  <span class="keywordtype">int</span> insertToDatabase(Trade &amp;trade)
  {
      (void)trade;
      <span class="keywordtype">int</span> result = 0;
      <span class="comment">// Insert the record here...</span>

      <span class="keywordflow">return</span> result;
  }

  <span class="keywordtype">int</span> submitToExchange(Trade &amp;trade)
  {
      (void)trade;
      <span class="keywordtype">int</span> result = 0;
      <span class="comment">// Do submission here...</span>

      <span class="keywordflow">return</span> result;
  }

  <span class="keywordtype">int</span> deleteFromDatabase(Trade &amp;trade)
  {
      (void)trade;
      <span class="keywordtype">int</span> result = 0;
      <span class="comment">// Delete record here...</span>

      <span class="keywordflow">return</span> result;
  }

  <span class="keywordtype">int</span> cancelAtExchange(Trade &amp;trade)
  {
      (void)trade;
      <span class="keywordtype">int</span> result = 0;
      <span class="comment">// Cancel trade here...</span>

      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 The <code>processTrade</code> function handles a single trade within a Trade Basket. Because this function is called within a <code>bslmt::Thread</code> callback (see the <code>tradeProcessingThread</code> function, below), its arguments are passed in a single structure. The <code>processTrade</code> function validates a trade, stores the trade into a database, and registers that trade with an exchange. At each step, the <code>processTrade</code> function synchronizes with other trades in the Trade Basket. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>TradeThreadArgument {
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;Trade&gt;</a> *d_trades_p;
      <a class="code" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a>     *d_barrier_p;
      <span class="keyword">volatile</span> <span class="keywordtype">bool</span>      *d_errorFlag_p;
      <span class="keywordtype">int</span>                 d_tradeNum;
  };

  TradeThreadArgument *processTrade(TradeThreadArgument *arguments)
  {
      <span class="keywordtype">int</span> retval;
      Trade &amp;trade = (*arguments-&gt;d_trades_p)[arguments-&gt;d_tradeNum];

      retval = validateTrade(trade);
</pre></div><br/>
<br/>
 If this trade failed validation, then indicate that an error has occurred. Note that, even when an error occurs, we must still block on the barrier object; otherwise, other threads which did not fail would remain blocked indefinitely. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (retval) *arguments-&gt;d_errorFlag_p = <span class="keyword">true</span>;
      arguments-&gt;d_barrier_p-&gt;wait();
</pre></div><br/>
<br/>
 Once all threads have completed the validation phase, check to see if any errors occurred; if so, exit. Otherwise continue to the next step. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (*arguments-&gt;d_errorFlag_p) <span class="keywordflow">return</span> arguments;              <span class="comment">// RETURN</span>

      retval = insertToDatabase(trade);
      <span class="keywordflow">if</span> (retval) *arguments-&gt;d_errorFlag_p = <span class="keyword">true</span>;
      arguments-&gt;d_barrier_p-&gt;wait();
</pre></div><br/>
<br/>
 As before, if an error occurs on this thread, we must still block on the barrier object. This time, if an error has occurred, we need to check to see whether this trade had an error. If not, then the trade has been inserted into the database, so we need to remove it before we exit. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">if</span> (*arguments-&gt;d_errorFlag_p) {
          <span class="keywordflow">if</span> (!retval) deleteFromDatabase(trade);
          <span class="keywordflow">return</span> arguments;                                         <span class="comment">// RETURN</span>
      }
</pre></div><br/>
<br/>
 The final synchronization point is at the exchange. As before, if there is an error in the basket, we may need to cancel the individual trade. <br/>
<br/>
<div class="fragment"><pre class="fragment">      retval = submitToExchange(trade);
      <span class="keywordflow">if</span> (retval) *arguments-&gt;d_errorFlag_p = <span class="keyword">true</span>;
      arguments-&gt;d_barrier_p-&gt;wait();
      <span class="keywordflow">if</span> (*arguments-&gt;d_errorFlag_p) {
          <span class="keywordflow">if</span> (!retval) cancelAtExchange(trade);
          deleteFromDatabase(trade);
          <span class="keywordflow">return</span> arguments;                                         <span class="comment">// RETURN</span>
      }
</pre></div><br/>
<br/>
 All synchronized steps have completed for all trades in this basket. The basket trade is placed. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">return</span> arguments;
  }
</pre></div><br/>
<br/>
 Function <code>tradeProcessingThread</code> is a callback for <code><a class="el" href="structbslmt_1_1ThreadUtil.html">bslmt::ThreadUtil</a></code>, which requires <code>void</code> pointers for argument and return type and <code>extern "C"</code> linkage. <code><a class="el" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create()</a></code> expects a pointer to this function, and provides that function pointer to the newly created thread. The new thread then executes this function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>tradeProcessingThread</code> function receives the <code>void</code> pointer, casts it to our required type (<code>TradeThreadArgument *</code>), and then calls the type-specific function, <code>processTrade</code>. On return, the specific type is cast back to <code>void*</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> <span class="keywordtype">void</span> *tradeProcessingThread(<span class="keywordtype">void</span> *argumentsIn)
  {
      <span class="keywordflow">return</span> (<span class="keywordtype">void</span> *) processTrade ((TradeThreadArgument *)argumentsIn);
  }
</pre></div><br/>
<br/>
 Function <code>processBasketTrade</code> drives the example. Given a <code>BasketTrade</code>, the function spawns a separate thread for each individual trade in the basket, supplying the function <code>tradeProcessingThread</code> to be executed on each thread. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> processBasketTrade(BasketTrade&amp; trade)
      <span class="comment">// Return &#39;true&#39; if the specified basket &#39;trade&#39; was processed</span>
      <span class="comment">// successfully, and &#39;false&#39; otherwise.  The &#39;trade&#39; is processed</span>
      <span class="comment">// atomically, i.e., all the trades succeed, or none of the trades are</span>
      <span class="comment">// executed.</span>
  {
      TradeThreadArgument arguments[k_MAX_BASKET_TRADES];
      <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> attributes;
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> threadHandles[k_MAX_BASKET_TRADES];

      <span class="keywordtype">int</span> numTrades = trade.d_trades.size();
      assert(0 &lt; numTrades &amp;&amp; k_MAX_BASKET_TRADES &gt;= numTrades);
</pre></div><br/>
<br/>
 Construct the barrier that will be used by the processing threads. Since a thread will be created for each trade in the basket, use the number of trades as the barrier count. When <code><a class="el" href="classbslmt_1_1Barrier.html#a7df005643d9abf4691dc6deef4ca68bc">bslmt::Barrier::wait()</a></code> is called, the barrier will require <code>numTrades</code> objects to wait before all are released. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a> barrier(numTrades);
      <span class="keywordtype">bool</span> errorFlag = <span class="keyword">false</span>;
</pre></div><br/>
<br/>
 Create a thread to process each trade. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numTrades; ++i) {
          arguments[i].d_trades_p    = &amp;trade.d_trades;
          arguments[i].d_barrier_p   = &amp;barrier;
          arguments[i].d_errorFlag_p = &amp;errorFlag;
          arguments[i].d_tradeNum    = i;
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;threadHandles[i],
                                    attributes,
                                    tradeProcessingThread,
                                    &amp;arguments[i]);
      }
</pre></div><br/>
<br/>
 Wait for all threads to complete. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numTrades; ++i) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(threadHandles[i]);
      }
</pre></div><br/>
<br/>
 Check if any error occurred. <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">return</span> <span class="keyword">false</span> == errorFlag;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:53 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
