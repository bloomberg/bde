<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslh_seedgenerator.h                                               -*-C++-*-
#ifndef INCLUDED_BSLH_SEEDGENERATOR
#define INCLUDED_BSLH_SEEDGENERATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a class to generate arbitrary length seeds for algorithms.
//
//@CLASSES:
//  bslh::SeedGenerator: generator for arbitrary length seeds
//
//@SEE_ALSO:
//
//@DESCRIPTION: This component provides a class, &#39;bslh::SeedGenerator&#39;, which
// utilizes a user-supplied Random Number Generator (RNG) to generate arbitrary
// length seeds.  The quality of the seeds will only be as good as the quality
// of the supplied RNG.  A cryptographically secure RNG must be supplied in
// order for &#39;SeedGenerator&#39; to produce seeds suitable for a cryptographically
// secure algorithm.
//
// This class satisfies the requirements for a seed generator, defined in
// &#39;bslh_seededhash.h&#39;.  More information can be found in the package level
// documentation for &#39;bslh&#39; (internal users can also find information here
// {TEAM BDE:USING MODULAR HASHING&lt;GO&gt;})
//
///Requirements on RNG
///-------------------
// The (template parameter) type &#39;RANDOM_NUM_GEN&#39; shall be a class that
// provides a type alias &#39;result_type&#39; and exposes an &#39;operator()&#39; that returns
// a result of type &#39;result_type&#39;.  The value returned by &#39;operator()&#39; shall be
// random bits, the quality of which can be defined by &#39;RANDOM_NUM_GEN&#39;.
// &#39;RANDOM_NUM_GEN&#39; shall also be default and copy constructible.
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example: Seeding Hashing Algorithms Requiring Different Seed Sizes
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we have a number of hashing algorithms that all require different
// length seeds.  Some require 32 bits, some require 64 bits, some even require
// 1024 bits.  We want to generate all these seeds in the same way, but we do
// not want to keep manually generating seeds of different sizes for these
// algorithms.  Moreover, we want to be able to use all these algorithms
// through a general purpose functor.  To accomplish this, we give all our
// algorithm the same interface and supply a seed generator, which can create
// any size seed that the algorithms require.
//
// First, we write our first hashing algorithm, which accepts a 32-bit seed and
// returns a 32-bit unsigned int.
//..
//  class Seeded32BitHashingAlgorithm {
//      // This class is a functor that implements a hashing algorithm seeded
//      // with 32 bits.
//
//    public:
//      typedef unsigned result_type; // Type of the hash returned
//      enum { k_SEED_LENGTH = 4 };   // Seed length in bytes
//
//    private:
//      const char *d_seed; // Seed used in the generation of hashes
//
//    public:
//      explicit Seeded32BitHashingAlgorithm(const char *seed);
//          // Construct a &#39;Seeded32BitHashingAlgorithm&#39; that will use the
//          // first 4 bytes of the specified &#39;seed&#39; to seed the algorithm.
//
//      result_type operator()(const char *data, size_t length);
//          // Return a hash of the specified &#39;length&#39; bytes of &#39;data&#39;.
//  };
//..
// Then, we define another hashing algorithm, which accepts a 64-bit seed and
// returns a 32-bit unsigned int
//..
//  class Seeded64BitHashingAlgorithm {
//      // This class is a functor that implements a hashing algorithm seeded
//      // with 64 bits.
//
//    public:
//      typedef unsigned result_type; // Type of the hash returned
//      enum { k_SEED_LENGTH = 8 };     // Seed length in bytes
//
//    private:
//      const char *d_seed; // Seed used in the generation of hashes
//
//    public:
//      explicit Seeded64BitHashingAlgorithm(const char *seed);
//          // Construct a &#39;Seeded64BitHashingAlgorithm&#39; that will use the
//          // first 8 bytes of the specified &#39;seed&#39; to seed the algorithm.
//
//      result_type operator()(const char *data, size_t length);
//          // Return a hash of the specified &#39;length&#39; bytes of &#39;data&#39;.
//  };
//..
// Next, we define a final hashing algorithm, which accepts a 1024-bit seed and
// returns a 32-bit unsigned int
//..
//  class Seeded1024BitHashingAlgorithm {
//      // This class is a functor that implements a hashing algorithm seeded
//      // with 1024 bits.
//
//    public:
//      typedef unsigned result_type; // Type of the hash returned
//      enum { k_SEED_LENGTH = 128 };   // Seed length in bytes
//
//    private:
//      const char *d_seed; // Seed used in the generation of hashes
//
//    public:
//      explicit Seeded1024BitHashingAlgorithm(const char *seed);
//          // Construct a &#39;Seeded1024BitHashingAlgorithm&#39; that will use the
//          // first 128 bytes of the specified &#39;seed&#39; to seed the algorithm.
//
//      result_type operator()(const char *data, size_t length);
//          // Return a hash of the specified &#39;length&#39; bytes of &#39;data&#39;.
//  };
//..
// Then, we declare our functor, &#39;SeededHash&#39;, which will take a seed
// generator, and be able to run any of our hashing algorithms by generating
// the correct size seed with the seed generator.
//..
//  template &lt;class HASH_ALGORITHM&gt;
//  class SeededHash {
//      // This class template implements an interface similar to &#39;std::hash&#39;,
//      // which will used the (template parameter) type &#39;SEED_GENERATOR&#39; and
//      // &#39;HASH_ALGORITHM&#39; to compute hashes.
//
//    public:
//      typedef typename HASH_ALGORITHM::result_type result_type;
//          // Type of the hash that will be returned.
//
//    private:
//      char seed[HASH_ALGORITHM::k_SEED_LENGTH];
//          // Stores the seed that will be used to run the (template
//          // parameter) type &#39;HASH_ALGORITHM&#39;
//
//    public:
//      template&lt;class SEED_GENERATOR&gt;
//      SeededHash(SEED_GENERATOR seedGenerator);
//          //Create a &#39;SeededHash&#39; and generate a seed using the specified
//          //&#39;seedGenerator&#39;.
//
//      result_type operator()(const char *data, size_t length) const;
//          // Returns a hash generated by the (template parameter) type
//          // &#39;HASH_ALGORITHM&#39; for the specified &#39;length&#39; bytes of &#39;data&#39;.
//
//  };
//..
// Next, we define our constructor where we actually use &#39;bslh::SeedGenerator&#39;.
// &#39;bslh::SeedGenerator&#39; allows us to create arbitrary length seeds to match
// the requirements of the above declared algorithms.
//..
//  template &lt;class HASH_ALGORITHM&gt;
//  template&lt;class SEED_GENERATOR&gt;
//  SeededHash&lt;HASH_ALGORITHM&gt;::SeededHash(SEED_GENERATOR seedGenerator) {
//      seedGenerator.generateSeed(seed, HASH_ALGORITHM::k_SEED_LENGTH);
//  }
//
//  template &lt;class HASH_ALGORITHM&gt;
//  typename SeededHash&lt;HASH_ALGORITHM&gt;::result_type
//  SeededHash&lt;HASH_ALGORITHM&gt;::operator()(const char *data,
//                                         size_t length) const {
//      HASH_ALGORITHM hashAlg(seed);
//      return hashAlg(data, length);
//  }
//..
// Now, we generate some data that we want to hash.
//..
//      const char *data[] = { &quot;asdf&quot;,
//                             &quot;qwer&quot;,
//                             &quot;gskgf&quot;,
//                             &quot;ujkagad&quot;,
//                             &quot;rwwfwe&quot;, };
//      enum { NUM_STRINGS = sizeof data / sizeof *data };
//..
// Finally, we can hash the data the same way using all of the different
// hashing algorithms.  The seed generator allows us to abstract away the
// different requirements each algorithm has on seed size.  Each algorithm will
// produce different output because it has been supplied with a different seed.
//..
//      MockRNG                                   rng;
//      SeedGenerator&lt;MockRNG&gt;                    seedGen(rng);
//      SeededHash&lt;Seeded32BitHashingAlgorithm&gt;   hashAlg32BitSeed(seedGen);
//      SeededHash&lt;Seeded64BitHashingAlgorithm&gt;   hashAlg64BitSeed(seedGen);
//      SeededHash&lt;Seeded1024BitHashingAlgorithm&gt; hashAlg1024BitSeed(seedGen);
//
//      for (int i = 0; i &lt; NUM_STRINGS; ++i) {
//          unsigned int hash32BitSeed   = hashAlg32BitSeed(data[i],
//                                                            strlen(data[i]));
//          unsigned int hash64BitSeed   = hashAlg64BitSeed(data[i],
//                                                            strlen(data[i]));
//          unsigned int hash1024BitSeed = hashAlg1024BitSeed(data[i],
//                                                            strlen(data[i]));
//
//          if (veryVerbose) printf(&quot;Asserting hashes of %s come out&quot;
//                                 &quot; different\n&quot;, data[i]);
//          ASSERT(hash32BitSeed   != hash64BitSeed);
//          ASSERT(hash32BitSeed   != hash1024BitSeed);
//          ASSERT(hash1024BitSeed != hash64BitSeed);
//      }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_STRING_H
#include &lt;string.h&gt;  // for &#39;memcpy&#39;
#define INCLUDED_STRING_H
#endif

#ifndef INCLUDED_STDDEF_H
#include &lt;stddef.h&gt;  // for &#39;size_t&#39;
#define INCLUDED_STDDEF_H
#endif

namespace BloombergLP {

namespace bslh {

                        // =========================
                        // class bslh::SeedGenerator
                        // =========================
template&lt;class RANDOM_NUM_GEN&gt;
class SeedGenerator : private RANDOM_NUM_GEN {
    // This class template implements a seed generator which takes a user
    // supplied random number generator and uses it to generate an arbitrary
    // length seed.  Note that this type inherits from the (template parameter)
    // type &#39;RANDOM_NUM_GEN&#39; to take advantage of the empty-base optimization.

  private:
    // PRIVATE TYPES
    typedef typename RANDOM_NUM_GEN::result_type result_type;
        // &#39;result_type&#39; is an alias for the value returned by a call to
        // &#39;operator()&#39; on the (template parameter) type &#39;RNG&#39;.

    // DATA
    enum { k_RNGOUTPUTSIZE = sizeof(typename RANDOM_NUM_GEN::result_type)};
        // Size in bytes of the rng&#39;s output.

  public:
    // CREATORS
    SeedGenerator();
        // Create a &#39;bslh::SeedGenerator&#39; that will default construct the
        // parameterized &#39;RNG&#39; and use it to generate its seeds.

    explicit SeedGenerator(const RANDOM_NUM_GEN &amp;randomNumberGenerator);
        // Create a &#39;bslh::SeedGenerator&#39; that will use the specified
        // &#39;randomNumberGenerator&#39; to generate its seeds.

    //! SeedGenerator(const SeedGenerator&amp; original) = default;
        // Create a &#39;bslh::SeedGenerator&#39; object with a copy of the random
        // number generator used by the specified &#39;original&#39;.

    //! ~SeedGenerator() = default;
        // Destroy this object.

    // MANIPULATORS
    //! SeedGenerator&amp; operator=(const SeedGenerator&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.

    void generateSeed(char *seedLocation, size_t seedLength);
        // Generate a seed of the specified &#39;seedLength&#39; bytes and store it at
        // the specified &#39;seedLocation&#39;.  The seed will be generated with bytes
        // from the random number generator supplied at construction.  All of
        // the returned bytes will come from the RNG, meaning if the requested
        // seed is larger than the return type of the RNG, the RNG will be
        // called multiple times.  The behaviour is undefined unless the memory
        // at &#39;seedLocation&#39; can store &#39;seedLength&#39; bytes.
};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

// CREATORS
template&lt;class RANDOM_NUM_GEN&gt;
inline
SeedGenerator&lt;RANDOM_NUM_GEN&gt;::SeedGenerator()
: RANDOM_NUM_GEN()
{
}

template&lt;class RANDOM_NUM_GEN&gt;
inline
SeedGenerator&lt;RANDOM_NUM_GEN&gt;::SeedGenerator(
                                   const RANDOM_NUM_GEN &amp;randomNumberGenerator)
: RANDOM_NUM_GEN(randomNumberGenerator)
{
}

// MANIPULATORS
template&lt;class RANDOM_NUM_GEN&gt;
inline
void SeedGenerator&lt;RANDOM_NUM_GEN&gt;::generateSeed(char *seedLocation,
                                                 size_t seedLength)
{
    BSLS_ASSERT(seedLocation || !seedLength);

    size_t numChunks = seedLength / k_RNGOUTPUTSIZE;
    size_t remainder = seedLength % k_RNGOUTPUTSIZE;

    for (size_t i = 0; i != numChunks; ++i) {
        result_type rand = RANDOM_NUM_GEN::operator()();
        memcpy(seedLocation + i * sizeof(rand), &amp;rand, sizeof(rand));
    }

    if (remainder) {
        result_type rand = RANDOM_NUM_GEN::operator()();
        memcpy(seedLocation + numChunks * sizeof(rand), &amp;rand, remainder);
    }
}

}  // close package namespace

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
