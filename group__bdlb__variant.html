<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlb_variant Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlb_variant<br/>
<small>
[<a class="el" href="group__bdlb.html">Package bdlb</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a variant (discriminated <code>union</code>-like) type.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlb.html">bdlb</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Default Construction</a> </li>
<li>
<a href="#3.2">Visitors</a> </li>
<li>
<a href="#3.3">BDEX Streamability</a> </li>
<li>
<a href="#3.4">Class Synopsis</a> <ul>
<li>
<a href="#3.4.1">Creators</a> </li>
<li>
<a href="#3.4.2">Manipulators</a> </li>
<li>
<a href="#3.4.3">Accessors</a> </li>
</ul>
</li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Variant Construction</a> </li>
<li>
<a href="#3.5.2">Example 2: Variant Assignment</a> <ul>
<li>
<a href="#3.5.2.1"><code>operator=</code></a> </li>
<li>
<a href="#3.5.2.2"><code>assignTo&lt;TYPE&gt;</code></a> </li>
<li>
<a href="#3.5.2.3"><code>assign</code></a> </li>
</ul>
</li>
<li>
<a href="#3.5.3">Example 3: Visiting a Variant via <code>apply</code></a> <ul>
<li>
<a href="#3.5.3.1"><code>bslmf::Nil</code> Passed to Visitor</a> </li>
<li>
<a href="#3.5.3.2">User-Specified Default Value Passed to Visitor</a> </li>
<li>
<a href="#3.5.3.3"><code>applyRaw</code> Undefined If Variant Is Unset</a> </li>
<li>
<a href="#3.5.3.4">Return Value Specified in Visitor</a> </li>
<li>
<a href="#3.5.3.5">Return Value Specified with Function Call</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a variant (discriminated <code>union</code>-like) type. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlb_1_1Variant.html">bdlb::Variant</a> </td><td>variant of up to 20 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant2.html">bdlb::Variant2</a> </td><td>variant of exactly 2 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant3.html">bdlb::Variant3</a> </td><td>variant of exactly 3 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a> </td><td>variant of exactly 4 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant5.html">bdlb::Variant5</a> </td><td>variant of exactly 5 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant6.html">bdlb::Variant6</a> </td><td>variant of exactly 6 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant7.html">bdlb::Variant7</a> </td><td>variant of exactly 7 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant8.html">bdlb::Variant8</a> </td><td>variant of exactly 8 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant9.html">bdlb::Variant9</a> </td><td>variant of exactly 9 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant10.html">bdlb::Variant10</a> </td><td>variant of exactly 10 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant11.html">bdlb::Variant11</a> </td><td>variant of exactly 11 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant12.html">bdlb::Variant12</a> </td><td>variant of exactly 12 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant13.html">bdlb::Variant13</a> </td><td>variant of exactly 13 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant14.html">bdlb::Variant14</a> </td><td>variant of exactly 14 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant15.html">bdlb::Variant15</a> </td><td>variant of exactly 15 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant16.html">bdlb::Variant16</a> </td><td>variant of exactly 16 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant17.html">bdlb::Variant17</a> </td><td>variant of exactly 17 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant18.html">bdlb::Variant18</a> </td><td>variant of exactly 18 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1Variant19.html">bdlb::Variant19</a> </td><td>variant of exactly 19 types  </td></tr>
<tr>
<td><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a> </td><td>variant from a type list  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides: (1) a variant class template, <code><a class="el" href="classbdlb_1_1Variant.html">bdlb::Variant</a></code>, that can store an instance of one of up to some (implementation-defined) number of parameter types (currently 20), (2) several variant class templates that accommodate a <em>fixed</em> number (from 2 to 19) of types, <code><a class="el" href="classbdlb_1_1Variant2.html">bdlb::Variant2</a></code>, <code><a class="el" href="classbdlb_1_1Variant3.html">bdlb::Variant3</a></code>, <code><a class="el" href="classbdlb_1_1Variant4.html">bdlb::Variant4</a></code>, <code><a class="el" href="classbdlb_1_1Variant5.html">bdlb::Variant5</a></code>, <code><a class="el" href="classbdlb_1_1Variant6.html">bdlb::Variant6</a></code>, <code><a class="el" href="classbdlb_1_1Variant7.html">bdlb::Variant7</a></code>, <code><a class="el" href="classbdlb_1_1Variant8.html">bdlb::Variant8</a></code>, <code><a class="el" href="classbdlb_1_1Variant9.html">bdlb::Variant9</a></code>, <code><a class="el" href="classbdlb_1_1Variant10.html">bdlb::Variant10</a></code>, <code><a class="el" href="classbdlb_1_1Variant11.html">bdlb::Variant11</a></code>, <code><a class="el" href="classbdlb_1_1Variant12.html">bdlb::Variant12</a></code>, <code><a class="el" href="classbdlb_1_1Variant13.html">bdlb::Variant13</a></code>, <code><a class="el" href="classbdlb_1_1Variant14.html">bdlb::Variant14</a></code>, <code><a class="el" href="classbdlb_1_1Variant15.html">bdlb::Variant15</a></code>, <code><a class="el" href="classbdlb_1_1Variant16.html">bdlb::Variant16</a></code>, <code><a class="el" href="classbdlb_1_1Variant17.html">bdlb::Variant17</a></code>, <code><a class="el" href="classbdlb_1_1Variant18.html">bdlb::Variant18</a></code>, and <code><a class="el" href="classbdlb_1_1Variant19.html">bdlb::Variant19</a></code>, and (3) a final variant class template, <code><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a></code>, whose supported types are specified via a <code><a class="el" href="structbslmf_1_1TypeList.html">bslmf::TypeList</a></code>. A variant (of any of the aforementioned classes) can hold any one of the types defined in its signature at any point in time. Clients can retrieve the value and type that a variant currently holds, assign a new value to the variant, or apply a visitor to the variant. A vistor's action is based on the value and type the variant currently holds. Assigning a value of a new type destroys the object of the old type and constructs the new value by copy constructing the supplied value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the number (<code>N</code>) of types that need to be supported is known, it is better to use the <code>bdlb::VariantN</code> templates that use an identical implementation, but generate shorter symbols and debugging information due to the lack of defaulted template argument types. Note that <code>bdlb::VariantN&lt;T1, ..., TN&gt;</code> and <code><a class="el" href="classbdlb_1_1Variant.html">bdlb::Variant</a>&lt;T1, ..., TN&gt;</code>, nevertheless, are distinct types. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>When the variant types are (directly) supplied as a type list (of type <code><a class="el" href="structbslmf_1_1TypeList.html">bslmf::TypeList</a></code>), the type <code><a class="el" href="classbdlb_1_1VariantImp.html">bdlb::VariantImp</a>&lt;TYPELIST&gt;</code> can be used in place of: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant</a>&lt;<span class="keyword">typename</span> TYPELIST::Type1, <span class="keyword">typename</span> TYPELIST::Type2, ...&gt;
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="default_construction"></a> <a class="anchor" id="description.default_construction"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Default Construction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlb_1_1Variant.html">bdlb::Variant</a></code> class, when default constructed, does not hold a value and <code>isUnset</code> returns <code>true</code>. This state is the same as that of a <code><a class="el" href="classbdlb_1_1Variant.html">bdlb::Variant</a></code> that is reset by the <code>reset</code> method. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="visitors"></a> <a class="anchor" id="description.visitors"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Visitors: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlb_1_1Variant.html">bdlb::Variant</a></code> provides an <code>apply</code> method that implements the visitor design pattern. <code>apply</code> accepts a visitor (functor) that provides an <code>operator()</code> that is invoked with the value that the variant currently holds. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>apply</code> method should be preferred over a <code>switch</code> statement based on the type index of a variant. If the order or types contained by the variant is changed in the future, every place where the type index is hard-coded needs to be updated. Whereas if <code>apply</code> were used, no change would be needed because function overloading will automatically resolve to the proper <code>operator()</code> to invoke. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>There are several variations of the <code>apply</code> method, varying based on the return type of <code>operator()</code> and the handling of unset variants. Firstly, the method varies based on whether <code>operator()</code> returns a value or not. There can either be: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
No return value.  </li>
<li>
A return type specified in the visitor interface.  </li>
<li>
A return type specified explicitly when invoking <code>apply</code>.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default is no return value. If users would like to return a value from the visitor's <code>operator()</code>, the functor should specify an alias <code>ResultType</code> to the desired return type. For example, if <code>operator()</code> were to return an <code>int</code>, the functor class should specify: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <span class="keywordtype">int</span> ResultType;
</pre></div><br/>
<br/>
 If <code>ResultType</code> cannot be determined, users also have the option of explicitly specifying the return type when invoking apply: <br/>
<br/>
<div class="fragment"><pre class="fragment">  apply&lt;int&gt;(visitor);
</pre></div><br/>
<br/>
 Secondly, the <code>apply</code> method varies based on how the method handles an unset variant. A user can choose to: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
Pass a default constructed <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> to the visitor.  </li>
<li>
Pass a user-specified "default" value to the visitor.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>Furthermore, if the user is sure that the variant cannot be unset, the user can invoke <code>applyRaw</code>, which is slightly more efficient. However, if the variant is, in fact, unset, the behavior of <code>applyRaw</code> is undefined. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bdex_streamability"></a> <a class="anchor" id="description.bdex_streamability"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>BDEX Streamability: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>BDEX streaming is not implemented for any of the variant classes. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="class_synopsis"></a> <a class="anchor" id="description.class_synopsis"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Class Synopsis: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Due to the complexity of the implementation, the following synopsis is provided to aid users in locating documentation for functions. Note that this is not a complete summary of all available methods; only the key methods are shown. For more information, refer to the function-level documentation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="creators"></a> <a class="anchor" id="class_synopsis.creators"></a> <a class="anchor" id="description.class_synopsis.creators"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Creators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant</a>()
  bdlb::Variant(const TYPE_OR_ALLOCATOR&amp; typeOrAllocator);
  bdlb::Variant(const TYPE&amp; value, bslma::Allocator *basicAllocator);
</pre></div><br/>
<br/>
 Create a variant. Users can choose to initialize a variant with a specified value, or leave the variant in the unset state (via default construction). Users can also supply a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code> for memory allocation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="manipulators"></a> <a class="anchor" id="class_synopsis.manipulators"></a> <a class="anchor" id="description.class_synopsis.manipulators"></a> <a class="anchor" id="3.4.2"></a> </dd></dl>
<dl class="user"><dt><b>Manipulators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant</a>&amp; operator=(<span class="keyword">const</span> TYPE&amp; value);
</pre></div><br/>
<br/>
 Assign a different value of template parameter <code>TYPE</code> to the variant. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant</a>&amp; operator=(<span class="keyword">const</span> <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant</a>&amp; rhs);
</pre></div><br/>
<br/>
 Assign another variant to a variant. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span>                apply(VISITOR&amp; visitor);
  VISITOR::ResultType apply(VISITOR&amp; visitor);
  RET_TYPE            apply(VISITOR&amp; visitor);
</pre></div><br/>
<br/>
 Access a variant's value using a specified visitor functor whereby <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the visitor's <code>operator()</code> if the variant is unset. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span>                apply(VISITOR&amp; visitor, <span class="keyword">const</span> TYPE&amp; dV);
  VISITOR::ResultType apply(VISITOR&amp; visitor, <span class="keyword">const</span> TYPE&amp; dV);
  RET_TYPE            apply(VISITOR&amp; visitor, <span class="keyword">const</span> TYPE&amp; dV);
</pre></div><br/>
<br/>
 Access a variant's value using a specified visitor functor whereby a user-specified default value (<code>dV</code>) is passed to the visitor's <code>operator()</code> if the variant is unset. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span>                applyRaw(VISITOR&amp; visitor);
  VISITOR::ResultType applyRaw(VISITOR&amp; visitor);
  RET_TYPE            applyRaw(VISITOR&amp; visitor);
</pre></div><br/>
<br/>
 Access a variant's value using a specified visitor functor whereby the behavior is undefined if the variant is unset. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">void</span> createInPlace();
  <span class="keywordtype">void</span> createInPlace(<span class="keyword">const</span> A1&amp; a1);
  <span class="comment">// ...</span>
  <span class="keywordtype">void</span> createInPlace(<span class="keyword">const</span> A1&amp; a1, <span class="keyword">const</span> A2&amp; a2, ..., <span class="keyword">const</span> A14&amp; a14);
</pre></div><br/>
<br/>
 Create a new value of template parameter <code>TYPE</code> in-place, with up to 14 constructor arguments. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> <a class="code" href="namespacebdlat__ValueTypeFunctions.html#a712743f16be0f4121bca7574c9face99">reset</a>();
</pre></div><br/>
<br/>
 Reset a variant to the unset state. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  TYPE&amp; the();
</pre></div><br/>
<br/>
 Access the value of template parameter <code>TYPE</code> currently held by a variant. This method should be invoked using the syntax <code>the&lt;TYPE&gt;()</code>, e.g., <code>the&lt;int&gt;()</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="accessors"></a> <a class="anchor" id="class_synopsis.accessors"></a> <a class="anchor" id="description.class_synopsis.accessors"></a> <a class="anchor" id="3.4.3"></a> </dd></dl>
<dl class="user"><dt><b>Accessors: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keywordtype">bool</span> is() <span class="keyword">const</span>;
</pre></div><br/>
<br/>
 Check whether a variant is currently holding a particular type. This method should be invoked using the syntax <code>is&lt;TYPE&gt;()</code>, e.g., <code>is&lt;int&gt;()</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> isUnset() <span class="keyword">const</span>;
</pre></div><br/>
<br/>
 Return <code>true</code> if a variant is currently unset, and <code>false</code> otherwise. <br/>
<br/>
<div class="fragment"><pre class="fragment">  bsl::ostream&amp; <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(bsl::ostream&amp; stream,
                      <span class="keywordtype">int</span>           level          = 0,
                      <span class="keywordtype">int</span>           spacesPerLevel = 4) <span class="keyword">const</span>;
</pre></div><br/>
<br/>
 Write a description of a variant to a specified <code>stream</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_variant_construction"></a> <a class="anchor" id="usage.example_1~3A_variant_construction"></a> <a class="anchor" id="description.usage.example_1~3A_variant_construction"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Variant Construction: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates the different ways of constructing a <code><a class="el" href="classbdlb_1_1Variant.html">bdlb::Variant</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant &lt;int, double, bsl::string&gt;</a> List;
  <span class="keyword">typedef</span> <a class="code" href="classbdlb_1_1Variant3.html">bdlb::Variant3&lt;int, double, bsl::string&gt;</a> List3;  <span class="comment">// equivalent</span>
</pre></div><br/>
<br/>
 The contained types can be retrieved as a <code><a class="el" href="structbslmf_1_1TypeList.html">bslmf::TypeList</a></code> (using the <code>TypeList</code> nested type), or individually (using <code>TypeN</code>, for <code>N</code> varying from 1 to the length of the <code>TypeList</code>). In the example below, we use the <code>List</code> variant, but this could be substituted with <code>List3</code> with no change to the code: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(3 == List::TypeList::LENGTH);
  assert(3 == List3::TypeList::LENGTH);
</pre></div><br/>
<br/>
 We can check whether the variant defaults to the unset state by using the <code>is&lt;TYPE&gt;</code> and <code>typeIndex</code> methods: <br/>
<br/>
<div class="fragment"><pre class="fragment">  List x;

  assert(!x.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(!x.is&lt;<span class="keywordtype">double</span>&gt;());
  assert(!x.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
  assert(0 == x.typeIndex());
</pre></div><br/>
<br/>
 Single-argument construction from a type in the <code>TypeList</code> of a variant is also supported. This is more efficient than creating an unset variant and assigning a value to it: <br/>
<br/>
<div class="fragment"><pre class="fragment">  List3 y(<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>(<span class="stringliteral">&quot;Hello&quot;</span>));

  assert(!y.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(!y.is&lt;<span class="keywordtype">double</span>&gt;());
  assert( y.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());

  assert(<span class="stringliteral">&quot;Hello&quot;</span> == y.the&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
</pre></div><br/>
<br/>
 Furthermore, <code>createInPlace</code> is provided to support direct in-place construction. This method allows users to directly construct the target type inside the variant, instead of first creating a temporary object, then copy constructing the object to initialize the variant: <br/>
<br/>
<div class="fragment"><pre class="fragment">  List z;
  z.createInPlace&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;(<span class="stringliteral">&quot;Hello&quot;</span>, 5);

  assert(!z.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(!z.is&lt;<span class="keywordtype">double</span>&gt;());
  assert( z.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());

  assert(<span class="stringliteral">&quot;Hello&quot;</span> == z.the&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
</pre></div><br/>
<br/>
 Up to 14 constructor arguments are supported for in-place construction of an object. Users can also safely create another object of the same or different type in a variant that already holds a value using the <code>createInPlace</code> method. No memory will be leaked in all cases and the destructor for the currently held object will be invoked: <br/>
<br/>
<div class="fragment"><pre class="fragment">  z.createInPlace&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;(<span class="stringliteral">&quot;Hello&quot;</span>, 5);
  assert(z.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
  assert(<span class="stringliteral">&quot;Hello&quot;</span> == z.the&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());

  z.createInPlace&lt;<span class="keywordtype">double</span>&gt;(10.0);
  assert(z.is&lt;<span class="keywordtype">double</span>&gt;());
  assert(10.0 == z.the&lt;<span class="keywordtype">double</span>&gt;());

  z.createInPlace&lt;<span class="keywordtype">int</span>&gt;(10);
  assert(z.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(10 == z.the&lt;<span class="keywordtype">int</span>&gt;());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_variant_assignment"></a> <a class="anchor" id="usage.example_2~3A_variant_assignment"></a> <a class="anchor" id="description.usage.example_2~3A_variant_assignment"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.5.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Variant Assignment: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A value of a given type can be stored in a variant in three different ways: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code>operator=</code>  </li>
<li>
<code>assignTo&lt;TYPE&gt;</code>  </li>
<li>
<code>assign</code>  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>operator=</code> automatically deduces the type that the user is trying to assign to the variant. This should be used most of the time. The <code>assignTo&lt;TYPE&gt;</code> method should be used when conversion to the type that the user is assigning to is necessary (see the first two examples below for more details). Finally, <code>assign</code> is equivalent to <code>operator=</code> and exists simply for backwards compatibility. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="operator="></a> <a class="anchor" id="example_2.operator="></a> <a class="anchor" id="usage.example_2.operator="></a> <a class="anchor" id="description.usage.example_2.operator="></a> <a class="anchor" id="3.5.2.1"></a> </dd></dl>
<dl class="user"><dt><b>operator=: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example illustrates how to use <code>operator=</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">typedef</span> <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant &lt;int, double, bsl::string&gt;</a> List;

  List x;

  List::Type1 v1 = 1;       <span class="comment">// &#39;int&#39;</span>
  List::Type2 v2 = 2.0;     <span class="comment">// &#39;double&#39;</span>
  List::Type3 v3(<span class="stringliteral">&quot;hello&quot;</span>);  <span class="comment">// &#39;bsl::string&#39;</span>

  x = v1;
  assert( x.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(!x.is&lt;<span class="keywordtype">double</span>&gt;());
  assert(!x.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
  assert(v1 == x.the&lt;<span class="keywordtype">int</span>&gt;());

  x = v2;
  assert(!x.is&lt;<span class="keywordtype">int</span>&gt;());
  assert( x.is&lt;<span class="keywordtype">double</span>&gt;());
  assert(!x.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
  assert(v2 == x.the&lt;<span class="keywordtype">double</span>&gt;());

  x = v3;
  assert(!x.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(!x.is&lt;<span class="keywordtype">double</span>&gt;());
  assert( x.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
  assert(v3 == x.the&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
</pre></div><br/>
<br/>
 Note that the type of the object can be deduced automatically during assignment, as in: <br/>
<br/>
<div class="fragment"><pre class="fragment">  x = v1;
</pre></div><br/>
<br/>
 This automatic deduction, however, cannot be extended to conversion constructors, such as: <br/>
<br/>
<div class="fragment"><pre class="fragment">  x = (<span class="keyword">const</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;Bye&quot;</span>;  <span class="comment">// ERROR</span>
</pre></div><br/>
<br/>
 The compiler will diagnose that <code>const char *</code> is not a variant type specified in the list of parameter types used in the definition of <code>List</code>, and will trigger a compile-time assertion. To overcome this problem, see the next usage example of <code>assignTo&lt;TYPE&gt;</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="assignto~3Ctype~3E"></a> <a class="anchor" id="example_2.assignto~3Ctype~3E"></a> <a class="anchor" id="usage.example_2.assignto~3Ctype~3E"></a> <a class="anchor" id="description.usage.example_2.assignto~3Ctype~3E"></a> <a class="anchor" id="3.5.2.2"></a> </dd></dl>
<dl class="user"><dt><b>assignTo&lt;TYPE&gt;: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the previous example, <code>const char *</code> was not part of the variant's type list, which resulted in a compilation diagnostic. The use of <code>assignTo&lt;TYPE&gt;</code> explicitly informs the compiler of the intended type to assign to the variant: <br/>
<br/>
<div class="fragment"><pre class="fragment">  x.assignTo&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;((<span class="keyword">const</span> <span class="keywordtype">char</span>*)<span class="stringliteral">&quot;Bye&quot;</span>);

  assert(!x.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(!x.is&lt;<span class="keywordtype">double</span>&gt;());
  assert( x.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());

  assert(<span class="stringliteral">&quot;Bye&quot;</span> == x.the&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="assign"></a> <a class="anchor" id="example_2.assign"></a> <a class="anchor" id="usage.example_2.assign"></a> <a class="anchor" id="description.usage.example_2.assign"></a> <a class="anchor" id="3.5.2.3"></a> </dd></dl>
<dl class="user"><dt><b>assign: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, for backwards compatibility, <code>assign</code> can also be used in place of <code>operator=</code> (but not <code>assignTo</code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  x.assign&lt;<span class="keywordtype">int</span>&gt;(v1);
  assert( x.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(!x.is&lt;<span class="keywordtype">double</span>&gt;());
  assert(!x.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
  assert(v1 == x.the&lt;<span class="keywordtype">int</span>&gt;());

  x.assign&lt;<span class="keywordtype">double</span>&gt;(v2);
  assert(!x.is&lt;<span class="keywordtype">int</span>&gt;());
  assert( x.is&lt;<span class="keywordtype">double</span>&gt;());
  assert(!x.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
  assert(v2 == x.the&lt;<span class="keywordtype">double</span>&gt;());

  x.assign&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;(v3);
  assert(!x.is&lt;<span class="keywordtype">int</span>&gt;());
  assert(!x.is&lt;<span class="keywordtype">double</span>&gt;());
  assert( x.is&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
  assert(v3 == x.the&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_3~3A_visiting_a_variant_via_apply"></a> <a class="anchor" id="usage.example_3~3A_visiting_a_variant_via_apply"></a> <a class="anchor" id="description.usage.example_3~3A_visiting_a_variant_via_apply"></a> <a class="anchor" id="example_3"></a> <a class="anchor" id="usage.example_3"></a> <a class="anchor" id="description.usage.example_3"></a> <a class="anchor" id="3.5.3"></a> </dd></dl>
<dl class="user"><dt><b>Example 3: Visiting a Variant via apply: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>As described in <a href="group__bdlb__variant.html#visitors" class="el">Visitors</a> (above), there are different ways to invoke the <code>apply</code> method. The first two examples below illustrate the different ways to invoke <code>apply</code> (with no return value) to control the behavior of visiting an unset variant: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
<code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the visitor.  </li>
<li>
A user-specified default value is passed to the visitor.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd>A third example illustrates use of <code>applyRaw</code>, the behavior of which is undefined if the variant is unset. Two final examples illustrate different ways to specify the return value from 'apply: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ul>
<li>
The return value is specified in the visitor.  </li>
<li>
The return value is specified with the function call.  </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslmf~3A~3Anil_passed_to_visitor"></a> <a class="anchor" id="example_3.bslmf~3A~3Anil_passed_to_visitor"></a> <a class="anchor" id="usage.example_3.bslmf~3A~3Anil_passed_to_visitor"></a> <a class="anchor" id="description.usage.example_3.bslmf~3A~3Anil_passed_to_visitor"></a> <a class="anchor" id="bslmf"></a> <a class="anchor" id="example_3.bslmf"></a> <a class="anchor" id="usage.example_3.bslmf"></a> <a class="anchor" id="description.usage.example_3.bslmf"></a> <a class="anchor" id="3.5.3.1"></a> </dd></dl>
<dl class="user"><dt><b>bslmf::Nil Passed to Visitor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A simple visitor that does not require any return value might be one that prints the value of the variant to <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_PrintVisitor {
    <span class="keyword">public</span>:
      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
      <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> TYPE&amp; value)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          bsl::cout &lt;&lt; value &lt;&lt; bsl::endl;
      }

      <span class="keywordtype">void</span> operator()(<a class="code" href="structbslmf_1_1Nil.html">bslmf::Nil</a> value)<span class="keyword"> const</span>
<span class="keyword">      </span>{
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;null&quot;</span> &lt;&lt; bsl::endl;
      }
  };

  <span class="keyword">typedef</span> <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant &lt;int, double, bsl::string&gt;</a> List;

  List x[4];

  <span class="comment">//*************************************</span>
  <span class="comment">// Note that &#39;x[3]&#39; is uninitialized. *</span>
  <span class="comment">//*************************************</span>

  x[0].assign(1);
  x[1].assign(1.1);
  x[2].assignTo&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;((<span class="keyword">const</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;Hello&quot;</span>);

  my_PrintVisitor printVisitor;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {
      x[i].apply(printVisitor);
  }
</pre></div><br/>
<br/>
 The above prints the following on <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  1
  1.1
  Hello
  null
</pre></div><br/>
<br/>
 Note that <code>operator()</code> is overloaded with <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>. A direct match has higher precedence than a template parameter match. When the variant is unset (such as <code>x[3]</code>), a <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code> is passed to the visitor. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="user-specified_default_value_passed_to_visitor"></a> <a class="anchor" id="example_3.user-specified_default_value_passed_to_visitor"></a> <a class="anchor" id="usage.example_3.user-specified_default_value_passed_to_visitor"></a> <a class="anchor" id="description.usage.example_3.user-specified_default_value_passed_to_visitor"></a> <a class="anchor" id="3.5.3.2"></a> </dd></dl>
<dl class="user"><dt><b>User-Specified Default Value Passed to Visitor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Instead of using <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>, users can also specify a default value to pass to the visitor when the variant is currently unset. Using the same <code>my_PrintVisitor</code> class from previous example: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {
      x[i].apply(printVisitor, <span class="stringliteral">&quot;Print this when unset&quot;</span>);
  }
</pre></div><br/>
<br/>
 Now, the above code prints the following on <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  1
  1.1
  Hello
  Print <span class="keyword">this</span> when unset
</pre></div><br/>
<br/>
 This variation of <code>apply</code> is useful since the user can provide a default value to the visitor without incurring the cost of initializing the variant itself. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="applyraw_undefined_if_variant_is_unset"></a> <a class="anchor" id="example_3.applyraw_undefined_if_variant_is_unset"></a> <a class="anchor" id="usage.example_3.applyraw_undefined_if_variant_is_unset"></a> <a class="anchor" id="description.usage.example_3.applyraw_undefined_if_variant_is_unset"></a> <a class="anchor" id="3.5.3.3"></a> </dd></dl>
<dl class="user"><dt><b>applyRaw Undefined If Variant Is Unset: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If it is certain that a variant is not unset, then the <code>applyRaw</code> method can be used instead of <code>apply</code>. <code>applyRaw</code> is slightly more efficient than <code>apply</code>, but the behavior of <code>applyRaw</code> is undefined if the variant is unset. In the following application of <code>applyRaw</code>, we purposely circumvent <code>x[3]</code> from being visited because we know that it is unset: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {     <span class="comment">// NOT &#39;i &lt; 4&#39; as above.</span>
      assert(!x[i].isUnset());
      x[i].applyRaw(printVisitor);  <span class="comment">// undefined behavior for &#39;x[3]&#39;</span>
  }
  assert(x[3].isUnset());
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="return_value_specified_in_visitor"></a> <a class="anchor" id="example_3.return_value_specified_in_visitor"></a> <a class="anchor" id="usage.example_3.return_value_specified_in_visitor"></a> <a class="anchor" id="description.usage.example_3.return_value_specified_in_visitor"></a> <a class="anchor" id="3.5.3.4"></a> </dd></dl>
<dl class="user"><dt><b>Return Value Specified in Visitor: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Users can also specify a return type that <code>operator()</code> will return by specifying a <code>typedef</code> with the name <code>ResultType</code> in their functor class. This is necessary in order for the <code>apply</code> method to know what type to return at compile time: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>my_AddVisitor {
    <span class="keyword">public</span>:
      <span class="keyword">typedef</span> <span class="keywordtype">bool</span> ResultType;

      <span class="comment">//*************************************************************</span>
      <span class="comment">// Note that the return type of &#39;operator()&#39; is &#39;ResultType&#39;. *</span>
      <span class="comment">//*************************************************************</span>

      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
      ResultType operator()(TYPE&amp; value) <span class="keyword">const</span>
          <span class="comment">// Return &#39;true&#39; when addition is performed successfully, and</span>
          <span class="comment">// &#39;false&#39; otherwise.</span>
      {
          <span class="keywordflow">if</span> (<a class="code" href="structbslmf_1_1IsConvertible.html">bslmf::IsConvertible&lt;TYPE, double&gt;::VALUE</a>) {

              <span class="comment">// Add certain values to the variant.  The details are elided</span>
              <span class="comment">// as it is the return value that is the focus of this example.</span>

              <span class="keywordflow">return</span> <span class="keyword">true</span>;                                          <span class="comment">// RETURN</span>
          }
          <span class="keywordflow">return</span> <span class="keyword">false</span>;
      }
  };

  <span class="keyword">typedef</span> <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant &lt;int, double, bsl::string&gt;</a> List;

  List x[3];

  x[0].assign(1);
  x[1].assign(1.1);
  x[2].assignTo&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;((<span class="keyword">const</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;Hello&quot;</span>);

  my_AddVisitor addVisitor;

  <span class="keywordtype">bool</span> ret[3];

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {
      ret[i] = x[i].apply(addVisitor);
      <span class="keywordflow">if</span> (!ret[i]) {
          bsl::cout &lt;&lt; <span class="stringliteral">&quot;Cannot add to types not convertible to &#39;double&#39;.&quot;</span>
                    &lt;&lt; bsl::endl;
      }
  }
  assert(<span class="keyword">true</span>  == ret[0]);
  assert(<span class="keyword">true</span>  == ret[1]);
  assert(<span class="keyword">false</span> == ret[2]);
</pre></div><br/>
<br/>
 The above prints the following on <code>stdout</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Cannot add to types not convertible to <span class="stringliteral">&#39;double&#39;</span>.
</pre></div><br/>
<br/>
 Note that if no <code>typedef</code> is provided (as in the <code>my_PrintVisitor</code> class), then the default return value is <code>void</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="return_value_specified_with_function_call"></a> <a class="anchor" id="example_3.return_value_specified_with_function_call"></a> <a class="anchor" id="usage.example_3.return_value_specified_with_function_call"></a> <a class="anchor" id="description.usage.example_3.return_value_specified_with_function_call"></a> <a class="anchor" id="3.5.3.5"></a> </dd></dl>
<dl class="user"><dt><b>Return Value Specified with Function Call: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>There may be some cases when a visitor interface is not owned by a client (hence the client cannot add a <code>typedef</code> to the visitor), or the visitor could not determine the return type at design time. In these scenarios, users can explicitly specify the return type when invoking <code>apply</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>ThirdPartyVisitor {
    <span class="keyword">public</span>:
      <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> operator()(<span class="keyword">const</span> TYPE&amp; value) <span class="keyword">const</span>;
          <span class="comment">// Return the name of the specified &#39;value&#39; as a &#39;bsl::string&#39;.</span>
          <span class="comment">// Note that the implementation of this class is deliberately not</span>
          <span class="comment">// shown since this class belongs to a third-party library.</span>
  };

  <span class="keyword">typedef</span> <a class="code" href="classbdlb_1_1Variant.html">bdlb::Variant &lt;int, double, bsl::string&gt;</a> List;

  List x[3];

  x[0].assign(1);
  x[1].assign(1.1);
  x[2].assignTo&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;((<span class="keyword">const</span> <span class="keywordtype">char</span> *)<span class="stringliteral">&quot;Hello&quot;</span>);

  ThirdPartyVisitor visitor;

  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) {

      <span class="comment">//*****************************************************</span>
      <span class="comment">// Note that the return type is explicitly specified. *</span>
      <span class="comment">//*****************************************************</span>

      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> ret = x[i].apply&lt;<a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&gt;(visitor);
      bsl::cout &lt;&lt; ret &lt;&lt; bsl::endl;
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:35 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
