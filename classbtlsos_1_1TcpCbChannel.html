<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlsos::TcpCbChannel</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlsos.html">btlsos</a>      </li>
      <li><a class="el" href="classbtlsos_1_1TcpCbChannel.html">btlsos::TcpCbChannel</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlsos::TcpCbChannel Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlsos::TcpCbChannel" --><!-- doxytag: inherits="btlsc::CbChannel" -->
<p><code>#include &lt;<a class="el" href="btlsos__tcpcbchannel_8h_source.html">btlsos_tcpcbchannel.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for btlsos::TcpCbChannel:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbtlsos_1_1TcpCbChannel.png" usemap="#btlsos::TcpCbChannel_map" alt=""/>
  <map id="btlsos::TcpCbChannel_map" name="btlsos::TcpCbChannel_map">
<area href="classbtlsc_1_1CbChannel.html" alt="btlsc::CbChannel" shape="rect" coords="0,0,134,24"/>
</map>
</div>

<p><a href="classbtlsos_1_1TcpCbChannel-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int, <br class="typebreak"/>
int)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(const <br class="typebreak"/>
char *, int, int)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int, <br class="typebreak"/>
int)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a62b614de20c34cade46668b2c57d1448">TcpCbChannel</a> (<a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *sSocket, <a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *manager, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#aa15aefe21f68d465512ad16fb42f7e5a">TcpCbChannel</a> (<a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *sSocket, <a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *rManager, <a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *wManager, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a276e6a81e7ae8ba93b70f13e105421ff">~TcpCbChannel</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a2385288c221a27881079c63fdc5961dd">read</a> (char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;readCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a2c22471eaf6f0ea2921c31a340749bae">readv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;readCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a29fb5a562e6984a8025af18f0ce273a8">readRaw</a> (char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;readCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a028aa5fdce088af97656ed948edbfa83">readvRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;readCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#afe26a4b1f56a27676742ac4af1fb1559">bufferedRead</a> (int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> &amp;bufferedReadCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a7b244f581d2610dbcbd0b7a77dfc94da">bufferedReadRaw</a> (int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> &amp;bufferedReadCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#aceddf2e82892b0a1a4df41df937a9245">write</a> (const char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a2d4bdc0158177ff02c8ed5a584d11a3f">writeRaw</a> (const char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a533fbbcc29975628ecc68cfc8abe5b75">writev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#afec512208f16032995f481649fd38710">writev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#af706da2510bbc10e4cf43ef050e73c92">writevRaw</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#ab0ec62a200ac9ea554cd198af64710d1">writevRaw</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#ad7cdab6c8de6acaef9e2181714fa3ad9">bufferedWrite</a> (const char *buffer, int numBytes, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#aa498d10ad0ddab1d8a4282f918892cdb">bufferedWritev</a> (const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#acd6f0ffa6afe69e8c7abaed73486c4a9">bufferedWritev</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *buffers, int numBuffers, const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;writeCallback, int flags=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a4e2c47f34a2231f79dfabcf96857718d">cancelAll</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a8c4b23b69ea5b9437d5b60df9a9abece">cancelRead</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#aa36e3388dd763bbfee8636f594d30c79">cancelWrite</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#ac131d05d998fa5e85fcbc3612031abb7">invalidate</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a3778be0ebbdbd11bbe5ff6837c7a84c5">invalidateRead</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#acf8bf06f822acd4e62046309159a0270">invalidateWrite</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a042beb6e3410cb5a59b2d3c23914a780">setReadEventManager</a> (<a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *manager)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a7c92cbcaadc53fb3806bd141ea930fb0">setWriteEventManager</a> (<a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *manager)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a015ccf112db2eb3107e9c0704262cd3e">isInvalidRead</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a1ceb2a6b4e064f3f0024500c13d16cde">isInvalidWrite</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a28f6a1d5aa858507659508a29307bcde">isInvalid</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#ac93805eb683df565df916fbefd9b5201">numPendingReadOperations</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a4abaa4191af9b6f2062712beb5ebe66a">numPendingWriteOperations</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a><br class="typebreak"/>
&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#aa9e9078523634f104b5cde8bd1c88b25">socket</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a4ab640bfb09d91979d7c2f9aa967c1cb">readEventManager</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlsos_1_1TcpCbChannel.html#a3438cfdc3d2af69eb1e45671c8ad38bd">writeEventManager</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class implements a <code>btesc</code>-style (non-timed) callback-based channel for a single TCP/IPv4 socket. The I/O requests are enqueued along with their callbacks. The callbacks are invoked as appropriate. In general, the status supplied to the callback is less than -1 for failure, -1 when channel detects that connection is closed, 0 for an interrupted operation due to either restartable interruption of an underlying system call (secondary status of 1), or dequeueing/cancellation (secondary status of -1). A registration method returns 0 if registration is successful, and a non-zero value otherwise, in which case the channel is invalid and no other registration attempts will succeed. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a9a33340398e368155dd8d6df7a2433fe"></a><!-- doxytag: member="btlsos::TcpCbChannel::ReadCallback" ref="a9a33340398e368155dd8d6df7a2433fe" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int, int)&gt; <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">btlsc::CbChannel::ReadCallback</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a result of any non-buffered read method, <code>ReadCallback</code> is an alias for a callback function object (functor) that returns <code>void</code> and takes as arguments an integer "status" indicating <em>success</em>, an <em>incomplete</em> <em>read</em>, or an <em>error</em>, and a second integer "augStatus". Together, the two status values indicate three possible reasons for any incomplete result: (1) a (caller-authorized) interruption by an asynchronous event, (2) a (caller-authorized) implementation-dependent, data-driven optimization, or (3) an operation dequeued (canceled) by the implementation or the user. </p>

<p>Reimplemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#af2269d5a75219ce003c35c70e1a8c245">btlsc::TimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a808401f2ddc7b467842899e3bf5dbd9d"></a><!-- doxytag: member="btlsos::TcpCbChannel::BufferedReadCallback" ref="a808401f2ddc7b467842899e3bf5dbd9d" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(const char *, int, int) <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">btlsc::CbChannel::BufferedReadCallback</a>)<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a result of any buffered read method, <code>BufferedReadCallback</code> is an alias for a callback function object (functor) that returns <code>void</code> and takes as arguments the (potential) address of a non-modifiable character "buffer", an integer "status" indicating <em>success</em>, an <em>incomplete</em> <em>read</em>, or an <em>error</em>, and a second integer "augStatus". Together, the two status values indicate three possible reasons for any incomplete result: (1) a (caller-authorized) interruption by an asynchronous event, (2) a (caller-authorized) implementation-dependent, data-driven optimization, or (3) an operation dequeued (canceled) by the implementation or the user. </p>

<p>Reimplemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#a59d8adcfe643e0468504b0b0342dd2f8">btlsc::TimedCbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a0a7a36015788139496abcf47ec1ba712"></a><!-- doxytag: member="btlsos::TcpCbChannel::WriteCallback" ref="a0a7a36015788139496abcf47ec1ba712" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int, int)&gt; <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">btlsc::CbChannel::WriteCallback</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invoked as a result of any write method, <code>WriteCallback</code> is an alias for a callback function object (functor) that returns <code>void</code> and takes as arguments an integer "status" indicating <em>success</em>, an <em>incomplete</em> <em>write</em>, or an <em>error</em>, and a second integer "augStatus". Together, the two status values indicate three possible reasons for any incomplete result: (1) a (caller-authorized) interruption by an asynchronous event, (2) a (caller-authorized) implementation-dependent, data-driven optimization, or (3) an operation dequeued (canceled) by the implementation or the user. </p>

<p>Reimplemented in <a class="el" href="classbtlsc_1_1TimedCbChannel.html#aae5dd7f12c6b1d98eab280fd8f64060b">btlsc::TimedCbChannel</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a62b614de20c34cade46668b2c57d1448"></a><!-- doxytag: member="btlsos::TcpCbChannel::TcpCbChannel" ref="a62b614de20c34cade46668b2c57d1448" args="(btlso::StreamSocket&lt; btlso::IPv4Address &gt; *sSocket, btlso::TimerEventManager *manager, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpCbChannel::TcpCbChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>sSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a callback channel for the TCP/IPv4 that uses the specified <code>sSocket</code> for socket-level communications, the specified <code>manager</code> to monitor for incoming data and for availability of space in the system's buffer for outgoing data. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless both <code>sSocket</code> and <code>manager</code> are not 0. Note that the I/O mode of <code>sSocket</code> will be changed to non-blocking. Usage of <code>sSocket</code> directly simultaneously with this channel may result in an undefined behavior of the channel. </p>

</div>
</div>
<a class="anchor" id="aa15aefe21f68d465512ad16fb42f7e5a"></a><!-- doxytag: member="btlsos::TcpCbChannel::TcpCbChannel" ref="aa15aefe21f68d465512ad16fb42f7e5a" args="(btlso::StreamSocket&lt; btlso::IPv4Address &gt; *sSocket, btlso::TimerEventManager *rManager, btlso::TimerEventManager *wManager, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpCbChannel::TcpCbChannel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>sSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>rManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>wManager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a callback channel for the TCP/IPv4 that uses the specified <code>sSocket</code> for socket-level communications, the specified <code>rManager</code> to monitor for incoming data and the specified <code>wManager</code> for availability of space in the system's buffer for outgoing data. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used. The behavior is undefined unless <code>sSocket</code>, <code>rManager</code> and <code>wManager</code> are not 0. Note that the I/O mode of <code>sSocket</code> will be changed to non-blocking. Usage of <code>sSocket</code> directly simultaneously with this channel may result in an undefined behavior of the channel. </p>

</div>
</div>
<a class="anchor" id="a276e6a81e7ae8ba93b70f13e105421ff"></a><!-- doxytag: member="btlsos::TcpCbChannel::~TcpCbChannel" ref="a276e6a81e7ae8ba93b70f13e105421ff" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlsos::TcpCbChannel::~TcpCbChannel </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidate this channel, cancel all read and write pending requests (and invoke the associated callbacks), deregister from event manager(s) as required, and destroy this channel. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2385288c221a27881079c63fdc5961dd"></a><!-- doxytag: member="btlsos::TcpCbChannel::read" ref="a2385288c221a27881079c63fdc5961dd" args="(char *buffer, int numBytes, const ReadCallback &amp;readCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::read </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to read the specified <code>numBytes</code> from this channel into the specified <code>buffer</code>; execute the specified <code>readCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>readCallback</code> will not be invoked).</p>
<p>When invoked, the <code>readCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and <code>buffer</code> is loaded with <code>numBytes</code> of newly read data. Otherwise, if "status" is non-negative (incomplete read), it indicates the number of bytes read into <code>buffer</code> in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was cancelled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and remains valid until the (non-null) <code>readCallback</code> completes, and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a71fcb3cb575021a5bff1e1d996ae3dc9">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2c22471eaf6f0ea2921c31a340749bae"></a><!-- doxytag: member="btlsos::TcpCbChannel::readv" ref="a2c22471eaf6f0ea2921c31a340749bae" args="(const btls::Iovec *buffers, int numBuffers, const ReadCallback &amp;readCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::readv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to read from this channel into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as defined by the <code>d_length</code> fields of each <code>Iovec</code> structure; execute the specified <code>readCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>readCallback</code> will not be invoked).</p>
<p>When invoked, <code>readCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to the total number of requested bytes (i.e., the sum of the <code>numBuffers</code> <code>d_length</code> fields in <code>buffers</code>) the operation was successful and each respective <code>d_buffer_p</code> is loaded with its corresponding <code>d_length</code> bytes of newly read data. Otherwise, if "status" is non-negative (incomplete read), it indicates the number of bytes read into these respective buffers in sequence in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was cancelled. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and remains valid until the (non-null) <code>readCallback</code> completes, and 0 &lt; numBytes. </p>

</div>
</div>
<a class="anchor" id="a29fb5a562e6984a8025af18f0ce273a8"></a><!-- doxytag: member="btlsos::TcpCbChannel::readRaw" ref="a29fb5a562e6984a8025af18f0ce273a8" args="(char *buffer, int numBytes, const ReadCallback &amp;readCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::readRaw </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> read <em>up *to</em> the specified <code>numBytes</code> from this channel into the specified <code>buffer</code>; execute the specified <code>readCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>readCallback</code> will not be invoked).</p>
<p>When invoked, <code>readCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and <code>buffer</code> is loaded with <code>numBytes</code> of newly read data. Otherwise, if "status" is non-negative (incomplete read), it indicates the number of bytes read into <code>buffer</code> in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative (status &gt; 0) if the atomic OS-level write operation wrote at least one but less than <code>numBytes</code> or ("status" identically 0) if this operation was cancelled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error: -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and remains valid until the (non-null) <code>readCallback</code> completes, and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#adb7ade594003c33472a35749462f76e0">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a028aa5fdce088af97656ed948edbfa83"></a><!-- doxytag: member="btlsos::TcpCbChannel::readvRaw" ref="a028aa5fdce088af97656ed948edbfa83" args="(const btls::Iovec *buffers, int numBuffers, const ReadCallback &amp;readCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::readvRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a9a33340398e368155dd8d6df7a2433fe">ReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>readCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> read from this channel into the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> <em>up</em> <em>to</em> the respective numbers of bytes as defined by the <code>d_length</code> fields of each <code>Iovec</code> structure; execute the specified <code>readCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>readCallback</code> will not be invoked).</p>
<p>When invoked, <code>readCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to the total number of requested bytes (i.e., the sum of the <code>numBuffers</code> <code>d_length</code> fields in <code>buffers</code>) the operation was successful and each respective <code>d_buffer_p</code> is loaded with its corresponding <code>d_length</code> bytes of newly read data. Otherwise, if "status" is non-negative (incomplete read), it indicates the number of bytes read into these respective buffers in sequence in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative (status &gt; 0) if the atomic OS-level operation transmitted at least one but less than the total requested number of bytes or ("status" identically 0) if this operation was cancelled. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> has sufficient capacity to hold the requested data and remains valid until the (non-null) <code>readCallback</code> completes, and 0 &lt; numBytes. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a9fcff7d3b744f8dbb05a094b203523e5">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="afe26a4b1f56a27676742ac4af1fb1559"></a><!-- doxytag: member="btlsos::TcpCbChannel::bufferedRead" ref="afe26a4b1f56a27676742ac4af1fb1559" args="(int numBytes, const BufferedReadCallback &amp;bufferedReadCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::bufferedRead </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bufferedReadCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to read the specified <code>numBytes</code> from this channel into a channel-supplied buffer; execute the specified <code>bufferedReadCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>bufferedReadCallback</code> will not be invoked).</p>
<p>When invoked, <code>bufferedReadCallback</code> is passed the address of a non-modifiable character "buffer", an integer "status", and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and "buffer" contains <code>numBytes</code> of newly read data (which will remain valid only until the callback completes). Otherwise, if "status" is non-negative (incomplete read), it indicates the number of (accessible) bytes in "buffer", in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was cancelled. If the transmission is partial, the data is retained in the channel's buffer and the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code> and <code>bufferedReadCallback</code> is non-null. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a8cc6b0bd0b4cf6070d6b164a1726a7e1">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a7b244f581d2610dbcbd0b7a77dfc94da"></a><!-- doxytag: member="btlsos::TcpCbChannel::bufferedReadRaw" ref="a7b244f581d2610dbcbd0b7a77dfc94da" args="(int numBytes, const BufferedReadCallback &amp;bufferedReadCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::bufferedReadRaw </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a808401f2ddc7b467842899e3bf5dbd9d">BufferedReadCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>bufferedReadCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> read <em>up *to</em> the specified <code>numBytes</code> from this channel into a channel-supplied buffer; execute the specified <code>bufferedReadCallback</code> functor after this read operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>bufferedReadCallback</code> will not be invoked).</p>
<p>When invoked, <code>bufferedReadCallback</code> is passed the address of a non-modifiable character "buffer", an integer "status", and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and "buffer" contains <code>numBytes</code> of newly read data (which will remain valid only until the callback completes). Otherwise, if "status" is non-negative (incomplete read), it indicates the number of (accessible) bytes in "buffer", in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event and negative (status &gt; 0) if the atomic OS-level operation transmitted at least one but less than <code>numBytes</code> or ("status" identically 0) if this operation was cancelled. If the transmission is incomplete, the data is retained in the channel's buffer and the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error (leaving the contents of <code>buffer</code> undefined); -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>0 &lt; numBytes</code> and <code>bufferedReadCallback</code> is non-null. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a6ac1deccdd7bdcf1a949638e532c2ed9">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aceddf2e82892b0a1a4df41df937a9245"></a><!-- doxytag: member="btlsos::TcpCbChannel::write" ref="aceddf2e82892b0a1a4df41df937a9245" args="(const char *buffer, int numBytes, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::write </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to write the specified <code>numBytes</code> from the specified <code>buffer</code> to this channel; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and all <code>numBytes</code> of data were transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written from <code>buffer</code>, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was cancelled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> remains valid until the (non-null) <code>writeCallback</code> completes, and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#ac58ed54ff869f449e6672a6bd470ff2d">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a2d4bdc0158177ff02c8ed5a584d11a3f"></a><!-- doxytag: member="btlsos::TcpCbChannel::writeRaw" ref="a2d4bdc0158177ff02c8ed5a584d11a3f" args="(const char *buffer, int numBytes, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::writeRaw </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> write <em>up *to</em> the specified <code>numBytes</code> from the specified <code>buffer</code> to this channel; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and all <code>numBytes</code> of data were transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written from <code>buffer</code>, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative (status &gt; 0) if the atomic OS-level operation transmitted at least one but less than <code>numBytes</code> or ("status" identically 0) if this operation was cancelled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> remains valid until the (non-null) <code>writeCallback</code> completes, and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#ab07c45b0997c2e66e3b28943be4e1948">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a533fbbcc29975628ecc68cfc8abe5b75"></a><!-- doxytag: member="btlsos::TcpCbChannel::writev" ref="a533fbbcc29975628ecc68cfc8abe5b75" args="(const btls::Ovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="afec512208f16032995f481649fd38710"></a><!-- doxytag: member="btlsos::TcpCbChannel::writev" ref="afec512208f16032995f481649fd38710" args="(const btls::Iovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to write to this channel from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as defined by the <code>d_length</code> fields of each <code>Ovec</code> (or <code>Iovec</code>) structure; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to the total number bytes to be written (i.e., the sum of the <code>numBuffers</code> <code>d_length</code> fields in <code>buffers</code>), all indicated data was transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written in sequence from the indicated buffers, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was cancelled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless the total number of bytes to be written is <em>positive</em> and <code>buffers</code> (and the data to which it refers) remains valid until the (non-null) <code>writeCallback</code> completes. </p>

</div>
</div>
<a class="anchor" id="af706da2510bbc10e4cf43ef050e73c92"></a><!-- doxytag: member="btlsos::TcpCbChannel::writevRaw" ref="af706da2510bbc10e4cf43ef050e73c92" args="(const btls::Ovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> write <em>up</em> <em>to</em> the total number of bytes indicated by the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> the respective number of bytes as defined by the <code>length</code> method of each <code>Ovec</code> (or <code>Iovec</code>) structure; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful for this method only when "status" is zero). A non-negative "status" indicates the total number of bytes written from <code>buffers</code>. If "status" is positive, the atomic ("raw") vector-write operation completed; "status" equals the requested number of bytes (i.e., the sum of the lengths of the <code>numBuffers</code> <code>buffers</code>) upon success. In either case, "augStatus" has no meaning. If "status" is zero, the atomic write operation did not complete, in which case "augStatus" is positive if an "asynchronous event" interrupted the operation, and negative if the operation was canceled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless the total number of bytes to be written is <em>positive</em> and <code>buffers</code> (and the data to which it refers) remains valid until the (non-null) <code>writeCallback</code> completes. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#ae3d0fe91594c169bc3b0123d7124e758">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ab0ec62a200ac9ea554cd198af64710d1"></a><!-- doxytag: member="btlsos::TcpCbChannel::writevRaw" ref="ab0ec62a200ac9ea554cd198af64710d1" args="(const btls::Iovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::writevRaw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to <em>atomically</em> write <em>up *to</em> the total number of bytes indicated by the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as defined by the <code>d_length</code> fields of each <code>Ovec</code> (or <code>Iovec</code>) structure; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to the total number bytes to be written (i.e., the sum of the <code>numBuffers</code> <code>d_length</code> fields in <code>buffers</code>), all indicated data was transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written in sequence from the indicated buffers, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative (status &gt; 0) if the atomic OS-level operation transmitted at least one but less than <code>numBytes</code> or ("status" identically 0) if this operation was cancelled. If the transmission is incomplete, the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless the total number of bytes to be written is <em>positive</em> and <code>buffers</code> (and the data to which it refers) remains valid until the (non-null) <code>writeCallback</code> completes. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#ace33a3f5d0ae273230d79898827dd21f">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ad7cdab6c8de6acaef9e2181714fa3ad9"></a><!-- doxytag: member="btlsos::TcpCbChannel::bufferedWrite" ref="ad7cdab6c8de6acaef9e2181714fa3ad9" args="(const char *buffer, int numBytes, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::bufferedWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to write the specified <code>numBytes</code> from the specified <code>buffer</code> to this channel; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked). Note that the contents of <code>buffer</code> need not be preserved after this method returns (except for the purpose of initiating a retry in the event that this operation results in a partial write.</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to <code>numBytes</code>, the operation was successful and all <code>numBytes</code> of data were transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written from <code>buffer</code>, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event and negative (with "status" identically 0) if this operation was cancelled. If the transmission is incomplete, the remaining buffered data is discarded, but the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless <code>buffer</code> remains valid until the (non-null) <code>writeCallback</code> completes, and <code>0 &lt; numBytes</code>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a2e12ce40b22aabba8689d4325efea1b4">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa498d10ad0ddab1d8a4282f918892cdb"></a><!-- doxytag: member="btlsos::TcpCbChannel::bufferedWritev" ref="aa498d10ad0ddab1d8a4282f918892cdb" args="(const btls::Ovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::bufferedWritev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to write to this channel from the specified sequence of <code>buffers</code> of the specified sequence length <code>numBuffers</code> the respective number of bytes as defined by the <code>length</code> method of each <code>Ovec</code> (or <code>Iovec</code>) structure; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked). Note that neither <code>buffers</code> nor the data to which it refers need be preserved after this method returns (except for the purpose of initiating a retry in the event that this operation results in a partial write).</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to the total number bytes to be written (i.e., the sum of calls to <code>length</code> on the <code>numBuffers</code> <code>buffers</code>), all indicated data was transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written in sequence from the indicated buffers, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was canceled. If the transmission is incomplete, the remaining buffered data is discarded, but the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless the total number of bytes to be written is <em>positive</em>. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a7c153666e294299a83bff84ffcc6dc08">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="acd6f0ffa6afe69e8c7abaed73486c4a9"></a><!-- doxytag: member="btlsos::TcpCbChannel::bufferedWritev" ref="acd6f0ffa6afe69e8c7abaed73486c4a9" args="(const btls::Iovec *buffers, int numBuffers, const WriteCallback &amp;writeCallback, int flags=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::bufferedWritev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>buffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlsc_1_1CbChannel.html#a0a7a36015788139496abcf47ec1ba712">WriteCallback</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>writeCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>flags</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initiate a non-blocking operation to write to this channel from the specified sequence of <code>buffers</code> of specified sequence length <code>numBuffers</code> the respective numbers of bytes as defined by the <code>d_length</code> fields of each <code>Ovec</code> (or <code>Iovec</code>) structure; execute the specified <code>writeCallback</code> functor after this write operation terminates. If the optionally specified <code>flags</code> incorporates <code><a class="el" href="structbtlsc_1_1Flag.html#abcbf762868a0e74ada7e002ca08faed2a290d31aa8f0959bacf75b52f89940782">btlsc::Flag::k_ASYNC_INTERRUPT</a></code>, "asynchronous events" are permitted to interrupt this operation; by default, such events are ignored. Return 0 on successful initiation, and a non-zero value otherwise (in which case <code>writeCallback</code> will not be invoked). Note that neither <code>buffers</code> nor the data to which it refers need be preserved after this method returns (except for the purpose of initiating a retry in the event that this operation results in a partial write.</p>
<p>When invoked, <code>writeCallback</code> is passed an integer "status" and a second integer "augStatus" (which is meaningful only upon an incomplete transmission). If "status" is equal to the total number bytes to be written (i.e., the sum of the <code>numBuffers</code> <code>d_length</code> fields in <code>buffers</code>), all indicated data was transmitted to the channel. Otherwise, if "status" is non-negative (incomplete write), it indicates the number of bytes written in sequence from the indicated buffers, in which case "augStatus" will be positive if the operation was interrupted due to an asynchronous event, and negative ("status" identically 0) if this operation was cancelled. If the transmission is incomplete, the remaining buffered data is discarded, but the channel itself potentially remains valid; hence, this (or another) operation may be retried (with arguments suitably adjusted) with some reasonable hope of success. A negative "status", however, indicates a permanent error; -1 implies that the connection was closed by the peer (but the converse is not guaranteed). The behavior is undefined unless the total number of bytes to be written is <em>positive</em> and <code>buffers</code> (and the data to which it refers) remains valid until the (non-null) <code>writeCallback</code> </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a2e102b37af56ff4502dde940d7ac46fd">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a4e2c47f34a2231f79dfabcf96857718d"></a><!-- doxytag: member="btlsos::TcpCbChannel::cancelAll" ref="a4e2c47f34a2231f79dfabcf96857718d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpCbChannel::cancelAll </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all enqueued operations from both the read queue and the write queue of this channel, and, in turn, invoke each callback with a 0 "status" and a negative "augStatus". Note that the validity of this channel is not altered by this operation. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a92c1e71d3d0378dcbe198018ab14a2ea">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a8c4b23b69ea5b9437d5b60df9a9abece"></a><!-- doxytag: member="btlsos::TcpCbChannel::cancelRead" ref="a8c4b23b69ea5b9437d5b60df9a9abece" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpCbChannel::cancelRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all enqueued operations from the read queue of this channel, and, in turn, invoke each callback with a 0 "status" and a negative "augStatus". Note that the validity of this channel is not altered by this operation. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a98b8fbce01bfbf03f1d1b5b9c67c3eb9">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa36e3388dd763bbfee8636f594d30c79"></a><!-- doxytag: member="btlsos::TcpCbChannel::cancelWrite" ref="aa36e3388dd763bbfee8636f594d30c79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpCbChannel::cancelWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all enqueued operations from the write queue of this channel, and, in turn, invoke each callback with a 0 "status" and a negative "augStatus". Note that the validity of this channel is not altered by this operation. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a1a6e0c4c40a1401ad43003c38f997a00">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="ac131d05d998fa5e85fcbc3612031abb7"></a><!-- doxytag: member="btlsos::TcpCbChannel::invalidate" ref="ac131d05d998fa5e85fcbc3612031abb7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpCbChannel::invalidate </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Make this channel invalid; no new operations can be initiated successfully. Pending operations are not affected. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#ad1d652169b74a4a7c8609547e242898a">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a3778be0ebbdbd11bbe5ff6837c7a84c5"></a><!-- doxytag: member="btlsos::TcpCbChannel::invalidateRead" ref="a3778be0ebbdbd11bbe5ff6837c7a84c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpCbChannel::invalidateRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidate the read portion of this channel; no new read operations can be initiated successfully. Pending operations are not affected. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a5e223877ed9b0eea354960757769b9eb">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="acf8bf06f822acd4e62046309159a0270"></a><!-- doxytag: member="btlsos::TcpCbChannel::invalidateWrite" ref="acf8bf06f822acd4e62046309159a0270" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpCbChannel::invalidateWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invalidate the write portion of this channel; no new write operations can be initiated successfully. Pending operations are not affected. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a88e8f4b0da32d77b35de2c22e4720448">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a042beb6e3410cb5a59b2d3c23914a780"></a><!-- doxytag: member="btlsos::TcpCbChannel::setReadEventManager" ref="a042beb6e3410cb5a59b2d3c23914a780" args="(btlso::TimerEventManager *manager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpCbChannel::setReadEventManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>manager</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the event manager used for read operations on this channel to the specified <code>manager</code>. The behavior is undefined if manager is 0 or unless <a class="el" href="classbtlsos_1_1TcpCbChannel.html#ac93805eb683df565df916fbefd9b5201">numPendingReadOperations()</a> is 0. </p>

</div>
</div>
<a class="anchor" id="a7c92cbcaadc53fb3806bd141ea930fb0"></a><!-- doxytag: member="btlsos::TcpCbChannel::setWriteEventManager" ref="a7c92cbcaadc53fb3806bd141ea930fb0" args="(btlso::TimerEventManager *manager)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlsos::TcpCbChannel::setWriteEventManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a> *&nbsp;</td>
          <td class="paramname"> <em>manager</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the event manager used for write operations on this channel to the specified <code>manager</code>. The behavior is undefined if manager is 0 or unless <a class="el" href="classbtlsos_1_1TcpCbChannel.html#a4abaa4191af9b6f2062712beb5ebe66a">numPendingWriteOperations()</a> is 0. </p>

</div>
</div>
<a class="anchor" id="a015ccf112db2eb3107e9c0704262cd3e"></a><!-- doxytag: member="btlsos::TcpCbChannel::isInvalidRead" ref="a015ccf112db2eb3107e9c0704262cd3e" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::isInvalidRead </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if the read portion of this (full-duplex) channel is invalid (e.g., due to a read error or an explicit call to <code>invalidateRead</code>), and 0 otherwise. Once the read portion of a channel is invalid, no new read operations can be initiated successfully. Note that a 0 return value cannot be relied upon to indicate that the read portion of this channel <em>is</em> valid. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#a8d33bdf80527d19a95559d9834c63814">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a1ceb2a6b4e064f3f0024500c13d16cde"></a><!-- doxytag: member="btlsos::TcpCbChannel::isInvalidWrite" ref="a1ceb2a6b4e064f3f0024500c13d16cde" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::isInvalidWrite </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return 1 if the write portion of this (full-duplex) channel is invalid (e.g., due to a write error or an explicit call to <code>invalidateWrite</code>), and 0 otherwise. Once the write portion of a channel is invalid, no new write operations can be initiated successfully. Note that a 0 return value cannot be relied upon to indicate that the write portion of this channel <em>is</em> valid. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#aa69b72f04f1d01ccad96923c61bb7a14">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a28f6a1d5aa858507659508a29307bcde"></a><!-- doxytag: member="btlsos::TcpCbChannel::isInvalid" ref="a28f6a1d5aa858507659508a29307bcde" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::isInvalid </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>TBD - remove it. </p>

</div>
</div>
<a class="anchor" id="ac93805eb683df565df916fbefd9b5201"></a><!-- doxytag: member="btlsos::TcpCbChannel::numPendingReadOperations" ref="ac93805eb683df565df916fbefd9b5201" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::numPendingReadOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of pending (buffered and unbuffered) read operations for this channel. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#ac13128f3bb11696dd22ad286efe9bd64">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="a4abaa4191af9b6f2062712beb5ebe66a"></a><!-- doxytag: member="btlsos::TcpCbChannel::numPendingWriteOperations" ref="a4abaa4191af9b6f2062712beb5ebe66a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlsos::TcpCbChannel::numPendingWriteOperations </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the total number of pending write operations for this channel. </p>

<p>Implements <a class="el" href="classbtlsc_1_1CbChannel.html#ac653cbfea8a41ce9eaf71bd85f87acb7">btlsc::CbChannel</a>.</p>

</div>
</div>
<a class="anchor" id="aa9e9078523634f104b5cde8bd1c88b25"></a><!-- doxytag: member="btlsos::TcpCbChannel::socket" ref="aa9e9078523634f104b5cde8bd1c88b25" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt;<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&gt;* btlsos::TcpCbChannel::socket </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the stream-socket used by this channel. </p>

</div>
</div>
<a class="anchor" id="a4ab640bfb09d91979d7c2f9aa967c1cb"></a><!-- doxytag: member="btlsos::TcpCbChannel::readEventManager" ref="a4ab640bfb09d91979d7c2f9aa967c1cb" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>* btlsos::TcpCbChannel::readEventManager </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of an event manager used for monitoring for incoming data on this channel. </p>

</div>
</div>
<a class="anchor" id="a3438cfdc3d2af69eb1e45671c8ad38bd"></a><!-- doxytag: member="btlsos::TcpCbChannel::writeEventManager" ref="a3438cfdc3d2af69eb1e45671c8ad38bd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlso_1_1TimerEventManager.html">btlso::TimerEventManager</a>* btlsos::TcpCbChannel::writeEventManager </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of an event manager used for monitoring for availability of space in the outgoing buffer on this channel. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlsos__tcpcbchannel_8h_source.html">btlsos_tcpcbchannel.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:16 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
