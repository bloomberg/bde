<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// baltzo_zoneinfoutil.h                                              -*-C++-*-
#ifndef INCLUDED_BALTZO_ZONEINFOUTIL
#define INCLUDED_BALTZO_ZONEINFOUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide utility operations on &#39;baltzo::Zoneinfo&#39; objects.
//
//@CLASSES:
//  baltzo::ZoneinfoUtil: utility for operations on a &#39;baltzo::Zoneinfo&#39; object
//
//@SEE_ALSO: baltzo_zoneinfo, baltzo_localtimevalidity
//
//@DESCRIPTION: This component provides a suite of pure functions that operate
// on objects of type &#39;baltzo::Zoneinfo&#39;.  A &#39;baltzo::Zoneinfo&#39; is a value
// semantic-type providing information about a time zone, mirroring the
// information found in the Zoneinfo Database, a public-domain distribution of
// time zone data (see &#39;baltzo_zoneinfo&#39; for more information).  The primary
// functions provided by &#39;baltzo::ZoneinfoUtil&#39; are &#39;convertUtcToLocalTime&#39; and
// &#39;loadRelevantTransitions&#39;: &#39;convertUtcToLocalTime&#39; converts a UTC time into
// its corresponding local time in the time zone described by the supplied
// &#39;baltzo::Zoneinfo&#39; object; &#39;loadRelevantTransitions&#39; returns the transition,
// from the supplied &#39;baltzo::Zoneinfo&#39; object&#39;s list of transitions that
// describes the attributes of local time in effect at supplied local time;
// returning two possible transitions in instances where the supplied local
// time is either invalid or ambiguous (see &#39;baltzo_localtimevalidity&#39;).  Note
// that the time supplied as input to &#39;convertUtcToLocalTime&#39; is a *UTC* time,
// whereas the time supplied as input to &#39;loadRelevantTransitions&#39; is a *local*
// time.
//
///Determining Relevant Transitions with &#39;loadRelevantTransitions&#39;
///---------------------------------------------------------------
// The function &#39;loadRelevantTransitions&#39; is used to find the transition in a
// &#39;baltzo::Zoneinfo&#39; object that describes the properties of a client supplied
// local time value.  In instances where the client supplied local time is
// either ambiguous or invalid &#39;loadRelevantTransitions&#39; returns an alternative
// transition that refers to a second set of properties that could be used to
// describe the supplied local time.  To understand why multiple transitions
// might be needed, consider the impact of daylight-saving time transitions on
// local time in New York:
//..
// Figure 1: Mapping between UTC Time and New York Local Time
//
//    EST - Eastern Standard Time (UTC-5:00)
//    EDT - Eastern Daylight Time (UTC-4:00)
//
//                                        ,-invalid times    ,- ambiguous times
//                                    T2 /  T3           T4 /   T5
//                                    @-----O            @------O
//
//               T1      EST          T2                 T4        EST
// New York Time @--------------------O                  @------------------&gt;
//                                    |     T3    EDT    |      T5
//                                    |     @------------|------O
//                                   /   __/            /    __/
//                                 /  __/              /  __/
//                                /__/                /__/
//      UTC Time +---------------+-------------------+----------------------&gt;
//               |               |                   |
//               Transition 1    Transition 2        Transition 3
//               (to EST)        (to EDT)            (to EST)
//
//..
// In New York, clocks are set forward an hour in the spring, creating the
// discontinuity between T2 and T3 in the diagram.  A New York local time value
// in the range [T2, T3) is considered invalid, because a correctly set clock
// in New York would never display that value.  Similarly, clocks are set back
// an hour in the fall, creating the discontinuity between T4 and T5 in the
// diagram.  A New York local time value in the range [T4, T5) is considered
// ambiguous, as local times in that range occur twice.  For either invalid or
// ambiguous times, &#39;loadRelevantTransitions&#39; will return two distinct
// iterators referring to the adjacent transitions holding the two descriptions
// that might be applied to that local time.
//
// For example, consider the returned validity and transitions for the
// following New York local times:
//..
//  New York Local Time  Validity     1st Transition      2nd Transition
//  -------------------  -----------  ------------------  ------------------
//  Jan  1, 2010 2:30am  *_UNIQUE     Nov  1, 2009 (EST)  Nov  1, 2009 (EST)
//  Mar 14, 2010 2:30am  *_INVALID    Nov  1, 2009 (EST)  Mar 14, 2010 (EDT)
//  Nov  7, 2010 1:30am  *_AMBIGUOUS  Mar 14, 2010 (EDT)  Nov  7, 2010 (EST)
//..
//
///Well-Formed Time Zone Information
///---------------------------------
// The primary operations provided by this component require the supplied
// Zoneinfo value meet certain constraints that are not enforced by the
// &#39;baltzo::Zoneinfo&#39; type itself.  A Zoneinfo meeting these constraints is
// considered *well-formed*, and &#39;baltzo::ZoneinfoUtil::isWellFormed&#39; will
// return &#39;true&#39; for such a value.  Specifically, a &#39;baltzo::Zoneinfo&#39; object
// is considered well-formed only if *all* of the following are true:
//
//: 1 The Zoneinfo provides at least one transition.
//:
//: 2 The first transition in the Zoneinfo is at the first representable
//:   &#39;bdlt::Datetime&#39; value, &quot;Jan 01, 0001 00:00&quot; -- i.e.,
//:   &#39;bdlt::Datetime(1, 1, 1)&#39;.
//:
//: 3 There is no transition in the ordered sequence of transitions described
//:   by the Zoneinfo where local clock time is adjusted (either forwards or
//:   backwards) introducing a period of invalid or ambiguous local times,
//:   where that range of invalid or ambiguous local times overlaps with the
//:   range of invalid or ambiguous local times introduced by subsequent
//:   transition.
//
// Note that &#39;baltzo::ZoneinfoUtil::isWellFormed&#39; has linear complexity with
// respect to the number of transitions that the Zoneinfo value defines.
//
///Overlapping Transitions
///- - - - - - - - - - - -
// In order to better understand the 3rd constraint (above) on a well-formed
// Zoneinfo object, first, notice that Figure 1 above (showing local time in
// New York) illustrates a well-formed sequence of transitions.  Both
// Transition 2 (to EDT) and Transition 3 (to EST) introduce a range of
// ambiguous or invalid times (ambiguous when clocks are adjusted backwards,
// invalid when clocks are adjusted forward), but those two ranges of ambiguous
// and invalid local times do not overlap.
//
// However, a Zoneinfo object is not well-formed if two transitions occur so
// close together that the respective ranges of invalid or ambiguous times that
// those transitions introduce, overlap with one and other, as illustrated in
// Figure 2.
//..
//  Figure 2:  Overlapping Transitions
//
//  Standard Time (STD):        UTC+00:00
//  Daylight-Saving Time (DST): UTC+01:00
//
//  Transition 1 (to DST): At 00:00 UTC (00:00 local)
//  Transition 2 (to STD): At 00:30 UTC (01:30 local)
//
//
//                                   (00:30)    STD
//                    STD   (00:00)    @--------------------------
//    Local Time @------------O        |           DST
//                            |        | (01:00) @------O (01:30)
//                            |        |      __/     _/
//                             \        \  __/     __/
//                              \      __\/     __/
//                               \ ___/   \ __/
//      UTC Time +---------------+---------+----------------------------
//                          Transition 1   Transition 2
//                           (01:00 UTC)   (01:30 UTC)
//..
// Notice that between [ 00:30 .. 01:00 ] local time, the range of invalid
// times introduced by Transition 1, overlaps with the range of ambiguous times
// introduced by Transition 2.  The above time zone would therefore *not* be
// well-formed.
//
///Usage
///-----
// The following examples demonstrate how to use a &#39;ZoneinfoUtil&#39; to perform
// common operations on time values using a Zoneinfo description of a time
// zone.
//
///Prologue: Initializing a &#39;baltzo::Zoneinfo&#39; Object
/// - - - - - - - - - - - - - - - - - - - - - - - - -
// We start by creating a Zoneinfo time zone description for New York, which we
// will use in subsequent examples.  Note that, in practice, clients should
// obtain time zone information from a data source (see
// &#39;baltzo_zoneinfocache&#39;).
//
// First we create a Zoneinfo object for New York, and populate &#39;newYork&#39; with
// the correct time zone identifier:
//..
//  baltzo::Zoneinfo newYork;
//  newYork.setIdentifier(&quot;America/New_York&quot;);
//..
// Next we create two local-time descriptors, one for standard time and one for
// daylight-saving time:
//..
//  baltzo::LocalTimeDescriptor est(-18000, false, &quot;EST&quot;);
//  baltzo::LocalTimeDescriptor edt(-14400, true,  &quot;EDT&quot;);
//..
// Then we set the initial descriptor for &#39;newYork&#39; to Eastern Standard Time.
// Note that such an initial transition is required for a &#39;baltzo::Zoneinfo&#39;
// object to be considered Well-Formed (see &#39;isWellFormed&#39;):
//..
//  newYork.addTransition(bdlt::EpochUtil::convertToTimeT64(
//                                                    bdlt::Datetime(1, 1, 1)),
//                        est);
//..
// Next we create a series of transitions between these local-time descriptors
// for the years 2007-2011.  Note that the United States transitions to
// daylight saving time on the second Sunday in March, at 2am local time (07:00
// UTC), and transitions back to standard time on the first Sunday in November
// at 2am local time (06:00 UTC), resulting in an even number of transitions:
//..
//  static const bdlt::Datetime TRANSITION_TIMES[] = {
//      bdlt::Datetime(2007,  3, 11, 7),
//      bdlt::Datetime(2007, 11,  4, 6),
//      bdlt::Datetime(2008,  3,  9, 7),
//      bdlt::Datetime(2008, 11,  2, 6),
//      bdlt::Datetime(2009,  3,  8, 7),
//      bdlt::Datetime(2009, 11,  1, 6),
//      bdlt::Datetime(2010,  3, 14, 7),
//      bdlt::Datetime(2010, 11,  7, 6),
//      bdlt::Datetime(2011,  3, 13, 7),
//      bdlt::Datetime(2011, 11,  6, 6),
//  };
//  const int NUM_TRANSITION_TIMES =
//                          sizeof TRANSITION_TIMES / sizeof *TRANSITION_TIMES;
//  assert(0 == NUM_TRANSITION_TIMES % 2);
//
//  for (int i = 0; i &lt; NUM_TRANSITION_TIMES; i += 2) {
//      newYork.addTransition(bdlt::EpochUtil::convertToTimeT64(
//                                                        TRANSITION_TIMES[i]),
//                            edt);
//      newYork.addTransition(bdlt::EpochUtil::convertToTimeT64(
//                                                    TRANSITION_TIMES[i + 1]),
//                            est);
//  }
//..
// Finally we verify that the time zone information we&#39;ve created is considered
// well-formed (as discussed above):
//..
//  assert(true == baltzo::ZoneinfoUtil::isWellFormed(newYork));
//..
//
///Example 1: Converting from a UTC Time to a Local Time
///- - - - - - - - - - - - - - - - - - - - - - - - - - -
// In this example we demonstrate how to convert a UTC time to the
// corresponding local time using the &#39;convertUtcToLocalTime&#39; class method.
//
// We start by creating a &#39;bdlt::Datetime&#39; representing the UTC time &quot;Dec 12,
// 2010 15:00&quot;:
//..
//  bdlt::Datetime utcTime(2010, 12, 12, 15, 0, 0);
//..
// Now, we call &#39;convertUtcToLocalTime&#39; and supply as input both &#39;utcTime&#39; and
// the Zoneinfo description for &#39;newYork&#39; (which we initialized in the prologue
// above):
//..
//  bdlt::DatetimeTz                          localNYTime;
//  baltzo::Zoneinfo::TransitionConstIterator iterator;
//  baltzo::ZoneinfoUtil::convertUtcToLocalTime(&amp;localNYTime,
//                                              &amp;iterator,
//                                              utcTime,
//                                              newYork);
//..
// Then we verify that &#39;localNYTime&#39; is &quot;Dec 12, 2010 10:00+5:00&quot;, the time in
// New York corresponding to the UTC time &quot;Dec 12, 2010 15:00&quot;.
//..
//  assert(utcTime                          == localNYTime.utcDatetime());
//  assert(bdlt::Datetime(2010, 12, 12, 10) == localNYTime.localDatetime());
//  assert(-5 * 60                          == localNYTime.offset());
//..
// Finally, we verify that the returned &#39;iterator&#39; refers to the local-time
// transition immediately before &#39;utcTime&#39;, and that that transition refers to
// a local-time descriptor characterizing standard-time in New York:
//..
//  baltzo::Zoneinfo::TransitionConstIterator transitionIter     = iterator;
//  baltzo::Zoneinfo::TransitionConstIterator nextTransitionIter = ++iterator;
//
//  const bdlt::EpochUtil::TimeT64 utcTimeT =
//                                   bdlt::EpochUtil::converToTimeT64(utcTime);
//  assert(utcTimeT &gt;= transitionIter-&gt;transition());
//  assert(utcTimeT &lt;  nextTransitionIter-&gt;transition());
//
//  assert(false        == transitionIter-&gt;descriptor().dstInEffectFlag());
//  assert(-5 * 60 * 60 == transitionIter-&gt;descriptor().utcOffsetInSeconds());
//  assert(&quot;EST&quot;        == transitionIter-&gt;descriptor().description());
//..
//
///Example 2: Determining the Type of a Local Time
///- - - - - - - - - - - - - - - - - - - - - - - -
// In this next example we use &#39;loadRelevantTransitions&#39; to determine the
// local-time descriptor (see &#39;baltzo_localtimedescriptor&#39;) that applies to a
// local time value, represented using a &#39;bdlt::Datetime&#39; object.
//
// We start by defining a &#39;bdlt::Datetime&#39; object for &quot;Jan 1, 2011 12:00&quot; in
// New York:
//..
//  bdlt::Datetime nyLocalTime(2011, 1, 1, 12);
//..
// Then, we call &#39;loadRelevantTransitions&#39;, and supply, as input, both
// &#39;nyLocalTime&#39; and the Zoneinfo description for &#39;newYork&#39; (which we
// initialized in the prologue above):
//..
//  baltzo::LocalTimeValidity::Enum           validity;
//  baltzo::Zoneinfo::TransitionConstIterator firstTransition;
//  baltzo::Zoneinfo::TransitionConstIterator secondTransition;
//  baltzo::ZoneinfoUtil::loadRelevantTransitions(&amp;firstTransition,
//                                                &amp;secondTransition,
//                                                &amp;validity,
//                                                nyLocalTime,
//                                                newYork);
//..
// &quot;Jan 1, 2011 12:00&quot; in New York, is not near a daylight-saving time
// transition, so it uniquely describes a valid time (in New York) which falls
// during Eastern Standard Time, and whose local time offset from UTC is -5:00.
// Because &quot;Jan 1, 2011 12:00&quot; is both a valid and unique local time, the
// returned validity will be &#39;baltzo::LocalTimeValidity::e_VALID_UNIQUE&#39; and
// the two returned transition iterators will be equal:
//..
//  assert(baltzo::LocalTimeValidity::e_VALID_UNIQUE == validity);
//  assert(firstTransition == secondTransition);
//
//  assert(false    == firstTransition-&gt;descriptor().dstInEffectFlag());
//  assert(-5*60*60 == firstTransition-&gt;descriptor().utcOffsetInSeconds());
//  assert(&quot;EST&quot;    == firstTransition-&gt;descriptor().description());
//..
// Next, we create a second &#39;bdlt::Datetime&#39; object to represent &quot;Nov 7, 2010
// 1:30&quot; in New York.  Note that the clock time &quot;Nov 7, 2010 1:30&quot; occurred
// twice in New York, as clocks were set back by an hour an instant before the
// local clock would have reached &quot;Nov 7, 2010 02:00 EDT&quot;, and it is therefore
// ambiguous which of those two values that local time is meant to refer.
//..
//  bdlt::Datetime ambiguousLocalTime(2010, 11, 7, 1, 30);
//..
// Now, we call &#39;loadRelevantTransitions&#39;, this time supplying
// &#39;ambiguousLocalTime&#39;:
//..
//  baltzo::ZoneinfoUtil::loadRelevantTransitions(&amp;firstTransition,
//                                                &amp;secondTransition,
//                                                &amp;validity,
//                                                ambiguousLocalTime,
//                                                newYork);
//..
// Finally we observe that the local time was ambiguous and that the returned
// transitions are distinct:
//..
//  assert(baltzo::LocalTimeValidity::e_VALID_AMBIGUOUS == validity);
//  assert(firstTransition != secondTransition);
//..
// Because &#39;ambiguousLocalTime&#39; may refer to either the standard or the
// daylight-saving time value &quot;Nov 7, 2010 01:30&quot;, the returned validity will
// be &#39;e_VALID_AMBIGUOUS&#39;, and the &#39;first&#39; and &#39;second&#39; iterators will differ.
// &#39;first&#39; will refer to a description of the local time before the transition
// (daylight-saving time) and &#39;second&#39; will refer to a description of local
// time after the transition (standard-time):
//..
//  assert(true      == firstTransition-&gt;descriptor().dstInEffectFlag());
//  assert(-4*60*60  == firstTransition-&gt;descriptor().utcOffsetInSeconds());
//  assert(&quot;EDT&quot;     == firstTransition-&gt;descriptor().description());
//
//  assert(false     == secondTransition-&gt;descriptor().dstInEffectFlag());
//  assert(-5*60*60  == secondTransition-&gt;descriptor().utcOffsetInSeconds());
//  assert(&quot;EST&quot;     == secondTransition-&gt;descriptor().description());
//..
// Note that the two transitions returned are adjacent:
//..
//  ++firstTransition;
//  assert(firstTransition == secondTransition);
//..

#ifndef INCLUDED_BALSCM_VERSION
#include &lt;balscm_version.h&gt;
#endif

#ifndef INCLUDED_BALTZO_LOCALTIMEVALIDITY
#include &lt;baltzo_localtimevalidity.h&gt;
#endif

#ifndef INCLUDED_BALTZO_ZONEINFO
#include &lt;baltzo_zoneinfo.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIME
#include &lt;bdlt_datetime.h&gt;
#endif

#ifndef INCLUDED_BDLT_DATETIMETZ
#include &lt;bdlt_datetimetz.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace baltzo {
                             // ==================
                             // class ZoneinfoUtil
                             // ==================

struct ZoneinfoUtil {
    // This &#39;struct&#39; provides a namespace for utility operations using a
    // &#39;Zoneinfo&#39; object.

    // CLASS METHODS
    static void convertUtcToLocalTime(
                           bdlt::DatetimeTz                  *resultTime,
                           Zoneinfo::TransitionConstIterator *resultTransition,
                           const bdlt::Datetime&amp;              utcTime,
                           const Zoneinfo&amp;                    timeZone);
        // Load, into the specified &#39;resultTime&#39;, the local date-time value, in
        // the specified &#39;timeZone&#39;, corresponding to the specified &#39;utcTime&#39;,
        // and load, into the specified &#39;resultTransition&#39;, an iterator
        // referring to the first transition in &#39;timeZone&#39; whose
        // transition-time is before &#39;utcTime&#39;.  The behavior is undefined
        // unless &#39;isWellFormed(timeZone)&#39; returns &#39;true&#39;.

    static void loadRelevantTransitions(
                     Zoneinfo::TransitionConstIterator *firstResultTransition,
                     Zoneinfo::TransitionConstIterator *secondResultTransition,
                     LocalTimeValidity::Enum           *resultValidity,
                     const bdlt::Datetime&amp;              localTime,
                     const Zoneinfo&amp;                    timeZone);
        // Load, into the specified &#39;firstResultTransition&#39;, an iterator
        // referring to the transition describing the characteristics of local
        // time in effect at the specified &#39;localTime&#39; in the specified
        // &#39;timeZone&#39;; in instances where &#39;localTime&#39; is not both a unique and
        // valid local time in &#39;timeZone&#39;, load, into the specified
        // &#39;secondResultTransition&#39;, an iterator referring to a subsequent
        // transition describing the alternative characteristics of local time
        // that could also apply to &#39;localTime&#39;; finally load, into the
        // specified &#39;resultValidity&#39;, the validity of &#39;localTime&#39; as being
        // unique, ambiguous but valid, or invalid.  If &#39;resultValidity&#39; is
        // &#39;e_VALID_UNIQUE&#39;, then &#39;firstResultTransition&#39; and
        // &#39;secondResultTransition&#39; will be loaded with the same transition,
        // otherwise the returned transitions will be distinct with
        // &#39;secondResultTransition&#39; referring to the transition immediately
        // after &#39;firstResultTransition&#39;.  The behavior is undefined unless
        // &#39;isWellFormed(timeZone)&#39; is &#39;true&#39;, and
        // &#39;firstResultTransition != secondResultTransition&#39;.

    static bool isWellFormed(const Zoneinfo&amp; timeZone);
        // Return &#39;true&#39; if the specified &#39;timeZone&#39; is a well-formed Zoneinfo
        // object (which can be used by other methods on this utility), and
        // &#39;false&#39; otherwise.  For a Zoneinfo to be considered well-formed
        // *all* of the following must be true:
        //
        //: 1 &#39;timeZone.numTransitions() &gt; 0&#39;
        //:
        //: 2 The first transition in &#39;timeZone&#39; is at the first representable
        //:   &#39;bdlt::Datetime&#39; value, &quot;Jan 01, 0001 00 00.000&quot; -- i.e.,
        //:   &#39;bdlt::Datetime(1, 1, 1)&#39;.
        //:
        //: 3 There is no transition in the ordered sequence of transitions
        //:   described by &#39;timeZone&#39; where the local clock time is adjusted
        //:   (either forwards or backwards) introducing a period of invalid or
        //:   ambiguous local times, where that range of invalid or ambiguous
        //:   local times overlaps with a range of invalid or or ambiguous
        //:   local times introduced by the subsequent transition (see
        //:   component documentation for an illustration).
        //
        // Note that this method has linear worst-case time complexity with
        // respect to &#39;timeZone.numTransitions()&#39;.
};

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
