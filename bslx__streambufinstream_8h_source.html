<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslx_streambufinstream.h                                           -*-C++-*-
#ifndef INCLUDED_BSLX_STREAMBUFINSTREAM
#define INCLUDED_BSLX_STREAMBUFINSTREAM

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Unexternalization of fundamental types from a &#39;bsl::streambuf&#39;.
//
//@CLASSES:
//  bslx::StreambufInStream: &#39;bsl::streambuf&#39; input stream for fundamentals
//
//@SEE_ALSO: bslx_streambufoutstream, bslx_genericinstream
//
//@DESCRIPTION: This component implements a &#39;bsl::streambuf&#39; input stream
// class, &#39;bslx::StreambufInStream&#39;, that provides platform-independent input
// methods (&quot;unexternalization&quot;) on values, and arrays of values, of
// fundamental types, and on &#39;bsl::string&#39;.
//
// The &#39;bslx::StreambufInStream&#39; type reads from a user-supplied
// &#39;bsl::streambuf&#39; directly, with no data copying or assumption of ownership.
// The user must therefore make sure that the lifetime and visibility of the
// buffer is sufficient to satisfy the needs of the input stream.
//
// This component is intended to be used in conjunction with the
// &#39;bslx_streambufoutstream&#39; &quot;externalization&quot; component.  Each input method of
// &#39;bslx::StreambufInStream&#39; reads either a value or a homogeneous array of
// values of a fundamental type, in a format that was written by the
// corresponding &#39;bslx::StreambufOutStream&#39; method.  In general, the user of
// this component cannot rely on being able to read data that was written by
// any mechanism other than &#39;bslx::StreambufOutStream&#39;.
//
// The supported types and required content are listed in the &#39;bslx&#39;
// package-level documentation under &quot;Supported Types&quot;.
//
// Note that input streams can be *invalidated* explicitly and queried for
// *validity*.  Reading from an initially invalid stream has no effect.
// Attempting to read beyond the end of a stream will automatically invalidate
// the stream.  Whenever an inconsistent value is detected, the stream should
// be invalidated explicitly.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Unexternalization
///- - - - - - - - - - - - - - - - -
// Suppose we wish to implement a (deliberately simple) &#39;MyPerson&#39; class as a
// value-semantic object that supports BDEX externalization and
// unexternalization.  In addition to whatever data and methods that we choose
// to put into our design, we must supply three methods having specific names
// and signatures in order to comply with the BDEX protocol: a class method
// &#39;maxSupportedBdexVersion&#39;, an accessor (i.e., a &#39;const&#39; method)
// &#39;bdexStreamOut&#39;, and a manipulator (i.e., a non-&#39;const&#39; method)
// &#39;bdexStreamIn&#39;.  This example shows how to implement those three methods.
//
// In this example we will not worry overly about &quot;good design&quot; of the
// &#39;MyPerson&#39; component, and we will declare but not implement illustrative
// methods and free operators, except for the three required BDEX methods,
// which are implemented in full.  In particular, we will not make explicit use
// of &#39;bslma&#39; allocators; a more complete design would do so:
//
// First, we implement &#39;MyPerson&#39;:
//..
//  class MyPerson {
//      bsl::string d_firstName;
//      bsl::string d_lastName;
//      int         d_age;
//
//      friend bool operator==(const MyPerson&amp;, const MyPerson&amp;);
//
//    public:
//      // CLASS METHODS
//      static int maxSupportedBdexVersion(int versionSelector);
//          // Return the maximum valid BDEX format version, as indicated by
//          // the specified &#39;versionSelector&#39;, to be passed to the
//          // &#39;bdexStreamOut&#39; method.  Note that it is highly recommended that
//          // &#39;versionSelector&#39; be formatted as &quot;YYYYMMDD&quot;, a date
//          // representation.  Also note that &#39;versionSelector&#39; should be a
//          // *compile*-time-chosen value that selects a format version
//          // supported by both externalizer and unexternalizer.  See the
//          // &#39;bslx&#39; package-level documentation for more information on BDEX
//          // streaming of value-semantic types and containers.
//
//      // CREATORS
//      MyPerson();
//          // Create a default person.
//
//      MyPerson(const char *firstName, const char *lastName, int age);
//          // Create a person having the specified &#39;firstName&#39;, &#39;lastName&#39;,
//          // and &#39;age&#39;.
//
//      MyPerson(const MyPerson&amp; original);
//          // Create a person having the value of the specified &#39;original&#39;
//          // person.
//
//      ~MyPerson();
//          // Destroy this object.
//
//      // MANIPULATORS
//      MyPerson&amp; operator=(const MyPerson&amp; rhs);
//          // Assign to this person the value of the specified &#39;rhs&#39; person,
//          // and return a reference to this person.
//
//      template &lt;class STREAM&gt;
//      STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
//          // Assign to this object the value read from the specified input
//          // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
//          // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
//          // operation has no effect.  If &#39;version&#39; is not supported, this
//          // object is unaltered and &#39;stream&#39; is invalidated, but otherwise
//          // unmodified.  If &#39;version&#39; is supported but &#39;stream&#39; becomes
//          // invalid during this operation, this object has an undefined, but
//          // valid, state.  Note that no version is read from &#39;stream&#39;.  See
//          // the &#39;bslx&#39; package-level documentation for more information on
//          // BDEX streaming of value-semantic types and containers.
//
//      //...
//
//      // ACCESSORS
//      int age() const;
//          // Return the age of this person.
//
//      template &lt;class STREAM&gt;
//      STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
//          // Write the value of this object, using the specified &#39;version&#39;
//          // format, to the specified output &#39;stream&#39;, and return a reference
//          // to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation
//          // has no effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is
//          // invalidated, but otherwise unmodified.  Note that &#39;version&#39; is
//          // not written to &#39;stream&#39;.  See the &#39;bslx&#39; package-level
//          // documentation for more information on BDEX streaming of
//          // value-semantic types and containers.
//
//      const bsl::string&amp; firstName() const;
//          // Return the first name of this person.
//
//      const bsl::string&amp; lastName() const;
//          // Return the last name of this person.
//
//      //...
//
//  };
//
//  // FREE OPERATORS
//  bool operator==(const MyPerson&amp; lhs, const MyPerson&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects have
//      // the same value, and &#39;false&#39; otherwise.  Two person objects have the
//      // same value if they have the same first name, last name, and age.
//
//  bool operator!=(const MyPerson&amp; lhs, const MyPerson&amp; rhs);
//      // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; person objects do not
//      // have the same value, and &#39;false&#39; otherwise.  Two person objects
//      // differ in value if they differ in first name, last name, or age.
//
//  // ========================================================================
//  //                  INLINE FUNCTION DEFINITIONS
//  // ========================================================================
//
//  // CLASS METHODS
//  inline
//  int MyPerson::maxSupportedBdexVersion(int /* versionSelector */) {
//      return 1;
//  }
//
//  // CREATORS
//  inline
//  MyPerson::MyPerson()
//  : d_firstName(&quot;&quot;)
//  , d_lastName(&quot;&quot;)
//  , d_age(0)
//  {
//  }
//
//  inline
//  MyPerson::MyPerson(const char *firstName, const char *lastName, int age)
//  : d_firstName(firstName)
//  , d_lastName(lastName)
//  , d_age(age)
//  {
//  }
//
//  inline
//  MyPerson::~MyPerson()
//  {
//  }
//
//  template &lt;class STREAM&gt;
//  STREAM&amp; MyPerson::bdexStreamIn(STREAM&amp; stream, int version)
//  {
//      if (stream) {
//          switch (version) {  // switch on the &#39;bslx&#39; version
//            case 1: {
//              stream.getString(d_firstName);
//              if (!stream) {
//                  d_firstName = &quot;stream error&quot;;  // *might* be corrupted;
//                                                 //  value for testing
//                  return stream;                                    // RETURN
//              }
//              stream.getString(d_lastName);
//              if (!stream) {
//                  d_lastName = &quot;stream error&quot;;  // *might* be corrupted;
//                                                //  value for testing
//                  return stream;                                    // RETURN
//              }
//              stream.getInt32(d_age);
//              if (!stream) {
//                  d_age = 999;     // *might* be corrupted; value for testing
//                  return stream;                                    // RETURN
//              }
//            } break;
//            default: {
//              stream.invalidate();
//            }
//          }
//      }
//      return stream;
//  }
//
//  // ACCESSORS
//  inline
//  int MyPerson::age() const
//  {
//      return d_age;
//  }
//
//  template &lt;class STREAM&gt;
//  STREAM&amp; MyPerson::bdexStreamOut(STREAM&amp; stream, int version) const
//  {
//      switch (version) {
//        case 1: {
//          stream.putString(d_firstName);
//          stream.putString(d_lastName);
//          stream.putInt32(d_age);
//        } break;
//        default: {
//          stream.invalidate();
//        } break;
//      }
//      return stream;
//  }
//
//  inline
//  const bsl::string&amp; MyPerson::firstName() const
//  {
//      return d_firstName;
//  }
//
//  inline
//  const bsl::string&amp; MyPerson::lastName() const
//  {
//      return d_lastName;
//  }
//
//  // FREE OPERATORS
//  inline
//  bool operator==(const MyPerson&amp; lhs, const MyPerson&amp; rhs)
//  {
//      return lhs.d_firstName == rhs.d_firstName &amp;&amp;
//             lhs.d_lastName  == rhs.d_lastName  &amp;&amp;
//             lhs.d_age       == rhs.d_age;
//  }
//
//  inline
//  bool operator!=(const MyPerson&amp; lhs, const MyPerson&amp; rhs)
//  {
//      return !(lhs == rhs);
//  }
//..
// Then, we can exercise the new &#39;MyPerson&#39; value-semantic class by
// externalizing and reconstituting an object.  First, create a &#39;MyPerson&#39;
// &#39;janeSmith&#39; and a &#39;bslx::StreambufOutStream&#39; &#39;outStream&#39;:
//..
//  MyPerson                 janeSmith(&quot;Jane&quot;, &quot;Smith&quot;, 42);
//  bsl::stringbuf           buffer;
//  bslx::StreambufOutStream outStream(&amp;buffer, 20131127);
//  const int                VERSION = 1;
//  outStream.putVersion(VERSION);
//  janeSmith.bdexStreamOut(outStream, VERSION);
//  assert(outStream.isValid());
//..
// Next, create a &#39;MyPerson&#39; &#39;janeCopy&#39; initialized to the default value, and
// assert that &#39;janeCopy&#39; is different from &#39;janeSmith&#39;:
//..
//  MyPerson janeCopy;
//  assert(janeCopy != janeSmith);
//..
// Then, create a &#39;bslx::StreambufInStream&#39; &#39;inStream&#39; initialized with the
// buffer from the &#39;bslx::StreambufOutStream&#39; object &#39;outStream&#39; and
// unexternalize this data into &#39;janeCopy&#39;:
//..
//  bslx::StreambufInStream inStream(&amp;buffer);
//  int                     version;
//  inStream.getVersion(version);
//  janeCopy.bdexStreamIn(inStream, version);
//  assert(inStream.isValid());
//..
// Finally, &#39;assert&#39; the obtained values are as expected and display the
// results to &#39;bsl::stdout&#39;:
//..
//  assert(version  == VERSION);
//  assert(janeCopy == janeSmith);
//
//  if (janeCopy == janeSmith) {
//      bsl::cout &lt;&lt; &quot;Successfully serialized and de-serialized Jane Smith:&quot;
//                &lt;&lt; &quot;\n\tFirstName: &quot; &lt;&lt; janeCopy.firstName()
//                &lt;&lt; &quot;\n\tLastName : &quot; &lt;&lt; janeCopy.lastName()
//                &lt;&lt; &quot;\n\tAge      : &quot; &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
//  }
//  else {
//      bsl::cout &lt;&lt; &quot;Serialization unsuccessful.  &#39;janeCopy&#39; holds:&quot;
//                &lt;&lt; &quot;\n\tFirstName: &quot; &lt;&lt; janeCopy.firstName()
//                &lt;&lt; &quot;\n\tLastName : &quot; &lt;&lt; janeCopy.lastName()
//                &lt;&lt; &quot;\n\tAge      : &quot; &lt;&lt; janeCopy.age() &lt;&lt; bsl::endl;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLX_GENERICINSTREAM
#include &lt;bslx_genericinstream.h&gt;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;
#endif

namespace BloombergLP {
namespace bslx {

                       // =======================
                       // class StreambufInStream
                       // =======================

typedef GenericInStream&lt;bsl::streambuf&gt; StreambufInStream;
    // This class facilitates the unexternalization of values (and C-style
    // arrays of values) of the fundamental integral and floating-point types
    // in a data-independent, platform-neutral representation.  It is currently
    // a &#39;typedef&#39; for &#39;bslx::GenericInStream&lt;bsl::streambuf&gt;&#39;.

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2014 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
