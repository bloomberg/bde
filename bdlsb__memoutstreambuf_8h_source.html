<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlsb_memoutstreambuf.h                                            -*-C++-*-
#ifndef INCLUDED_BDLSB_MEMOUTSTREAMBUF
#define INCLUDED_BDLSB_MEMOUTSTREAMBUF

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an output &#39;basic_streambuf&#39; using managed memory.
//
//@CLASSES:
//   bdlsb::MemOutStreamBuf: output stream buffer using memory allocator
//
//@SEE_ALSO: bdlsb_fixedmemoutstreambuf, bdlsb_fixedmeminstreambuf
//
//@DESCRIPTION: This component provides a mechanism, &#39;bdlsb::MemOutStreamBuf&#39;,
// that implements the output portion of the &#39;bsl::basic_streambuf&#39; protocol
// using a managed, allocator-supplied memory buffer.  Method names necessarily
// correspond to those specified by the protocol.
//
// This component provides none of the input-related functionality of
// &#39;basic_streambuf&#39; (see &quot;Streaming Architecture&quot;, below), nor does it use
// locales in any way.
//
// Because the underlying buffer is always obtained from the client-specified
// allocator, the &#39;pubsetbuf&#39; method in this component has no effect.
//
// Note that this component has an unspecified minimum allocation size, and
// therefore users trying to limit themselves to a fixed buffer should use
// bdlsb_fixedmemoutstreambuf.
//
///Streaming Architecture
///----------------------
// Stream buffers are designed to decouple device handling from content
// formatting, providing the requisite device handling and possible buffering
// services, and leaving the formatting to the client stream.  The standard C++
// IOStreams library further partitions streaming into input streaming and
// output streaming, separating responsibilities for each at both the stream
// layer and the stream buffer layer.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
/// Example 1: Basic Use of &#39;bdlsb::MemOutStreamBuf&#39;
///- - - - - - - - - - - - - - - - - - - - - - - - -
// This example demonstrates using a &#39;bdlsb::MemOutStreamBuf&#39; in order to test
// a user defined stream type, &#39;CapitalizingStream&#39;.  In this example, we&#39;ll
// define a simple example stream type &#39;CapitalizingStream&#39; that capitalizing
// lower-case ASCII data written to the stream.  In order to test this
// &#39;CapitalizingStream&#39; type, we&#39;ll create an instance, and supply it a
// &#39;bdlsb::MemOutStreamBuf&#39; object as its stream buffer; after we write some
// character data to the &#39;CapitalizingStream&#39; we&#39;ll inspect the buffer of the
// &#39;bdlsb::MemOutStreamBuf&#39; and verify its contents match our expected output.
// Note that to simplify the example, we do not include the functions for
// streaming non-character data, e.g., numeric values.
//
// First, we define our example stream class, &#39;CapitalizingStream&#39; (which we
// will later test using &#39;bdlsb::MemOutStreamBuf):
//..
//  class CapitalizingStream {
//      // This class capitalizes lower-case ASCII characters that are output.
//
//      // DATA
//      bsl::streambuf  *d_streamBuffer_p;   // pointer to a stream buffer
//
//      // FRIENDS
//      friend CapitalizingStream&amp; operator&lt;&lt;(CapitalizingStream&amp;  stream,
//                                            const char          *data);
//    public:
//      // CREATORS
//      explicit CapitalizingStream(bsl::streambuf *streamBuffer);
//          // Create a capitalizing stream using the specified &#39;streamBuffer&#39;
//          // as underlying stream buffer to the stream.
//  };
//
//  // FREE OPERATORS
//  CapitalizingStream&amp; operator&lt;&lt;(CapitalizingStream&amp;  stream,
//                                 const char          *data);
//      // Write the specified &#39;data&#39; in capitalized form to the specified
//      // &#39;stream&#39;.
//
//  CapitalizingStream::CapitalizingStream(bsl::streambuf *streamBuffer)
//  : d_streamBuffer_p(streamBuffer)
//  {
//  }
//..
// As is typical, the streaming operators are made friends of the class.
//
// Note that we cannot directly use &#39;bsl::toupper&#39; to capitalize each
// individual character, because &#39;bsl::toupper&#39; operates on &#39;int&#39; instead of
// &#39;char&#39;.  Instead, we call a function &#39;ucharToUpper&#39; that works in terms of
// &#39;unsigned char&#39;.  some care must be made to avoid undefined and
// implementation-specific behavior during the conversions to and from &#39;int&#39;.
// Therefore we wrap &#39;bsl::toupper&#39; in an interface that works in terms of
// &#39;unsigned char&#39;:
//..
//  static unsigned char ucharToUpper(unsigned char input)
//      // Return the upper-case equivalent to the specified &#39;input&#39; character.
//  {
//      return bsl::toupper(input);
//  }
//..
// Finally, we use the &#39;transform&#39; algorithm to convert lower-case characters
// to upper-case.
//..
//  // FREE OPERATORS
//  CapitalizingStream&amp; operator&lt;&lt;(CapitalizingStream&amp;  stream,
//                                 const char          *data)
//  {
//      bsl::string tmp(data);
//      bsl::transform(tmp.begin(),
//                     tmp.end(),
//                     tmp.begin(),
//                     ucharToUpper);
//      stream.d_streamBuffer_p-&gt;sputn(tmp.data(), tmp.length());
//      return stream;
//  }
//..
// Now, we create an instance of &#39;bdlsb::MemOutStreamBuf&#39; that will serve as
// underlying stream buffer for our &#39;CapitalingStream&#39;:
//..
//  bdlsb::MemOutStreamBuf streamBuffer;
//..
// Now, we test our &#39;CapitalingStream&#39; by supplying the created instance of
// &#39;bdlsb::MemOutStreamBuf&#39; and using it to inspect the output of the stream:
//..
//  CapitalizingStream  testStream(&amp;streamBuffer);
//  testStream &lt;&lt; &quot;Hello world.&quot;;
//..
// Finally, we verify that the streamed data has been capitalized and placed
// into dynamically allocated buffer:
//..
//  assert(12 == streamBuffer.length());
//  assert(0  == bsl::strncmp(&quot;HELLO WORLD.&quot;,
//                            streamBuffer.data(),
//                            streamBuffer.length()));
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDDEF
#include &lt;bsl_cstddef.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTDLIB
#include &lt;bsl_cstdlib.h&gt;
#endif

#ifndef INCLUDED_BSL_CSTRING
#include &lt;bsl_cstring.h&gt;
#endif

#ifndef INCLUDED_BSL_IOS
#include &lt;bsl_ios.h&gt;
#endif

#ifndef INCLUDED_BSL_STREAMBUF
#include &lt;bsl_streambuf.h&gt;  // (char|int|pos|off|traits)_type
#endif

namespace BloombergLP {
namespace bdlsb {

                         // =====================
                         // class MemOutStreamBuf
                         // =====================

class MemOutStreamBuf : public bsl::streambuf {
    // This &#39;class&#39; implements the output functionality of the
    // &#39;basic_streambuf&#39; protocol, using a user-supplied or default &#39;bslma&#39;
    // allocator to supply memory.

    // PRIVATE CONSTANTS
    enum {
        k_INITIAL_BUFFER_SIZE = 256,  // default initial buffer size

        k_GROWTH_FACTOR       =   2   // geometric growth factor to use when
                                      // resizing internal buffer

    };

    // DATA
    bslma::Allocator *d_allocator_p;  // memory source for buffer memory
                                      // (held, not owned)

  private:
    // NOT IMPLEMENTED
    MemOutStreamBuf(const MemOutStreamBuf&amp;); // = delete;
    MemOutStreamBuf&amp; operator=(const MemOutStreamBuf&amp;); // = delete;

  private:
    // PRIVATE MANIPULATORS
    void grow(bsl::size_t newLength);
        // Grow the size of the internal buffer to be at least large enough to
        // fit the specified &#39;newLength&#39; characters.  The buffer size is grown
        // by the minimum power of &#39;k_GROWTH_FACTOR&#39; needed to accommodate the
        // new length, but with a final size not less than
        // &#39;k_INITIAL_BUFFER_SIZE&#39;.  This method has no effect if &#39;newLength &lt;=
        // capacity()&#39; holds before the call.

    // PRIVATE ACCESSORS
    bsl::size_t capacity() const;
        // Return the current buffer capacity.

  protected:
    // PROTECTED MANIPULATORS
    virtual int_type overflow(
                  int_type insertionChar = bsl::streambuf::traits_type::eof());
        // Append the optionally specified &#39;insertionChar&#39; to this stream
        // buffer&#39;s character buffer and return &#39;insertionChar&#39;.  If
        // &#39;insertionChar&#39; is not specified, &#39;traits_type::eof()&#39; is appended
        // instead.

    virtual pos_type seekoff(off_type                offset,
                             bsl::ios_base::seekdir  way,
                             bsl::ios_base::openmode which = bsl::ios_base::in
                                                         | bsl::ios_base::out);
        // Set the position indicator to the relative specified &#39;offset&#39; from
        // the base position indicated by the specified &#39;way&#39; and return the
        // resulting absolute position on success or pos_type(-1) on failure.
        // Optionally specify &#39;which&#39; area of the stream buffer.  The seek
        // operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::out&#39; or if the resulting absolute position is less
        // than zero or greater then &#39;length()&#39;.

    virtual pos_type seekpos(pos_type                position,
                             bsl::ios_base::openmode which = bsl::ios_base::in
                                                         | bsl::ios_base::out);
        // Set the position indicator to the specified &#39;position&#39; and return
        // the resulting absolute position on success or pos_type(-1) on
        // failure.  Optionally specify &#39;which&#39; area of the stream buffer.  The
        // &#39;seekpos&#39; operation will fail if &#39;which&#39; does not include the flag
        // &#39;bsl::ios_base::out&#39; or if &#39;position&#39; is less then zero or greater
        // than &#39;length()&#39;.

    virtual bsl::streamsize xsputn(const char_type *source,
                                   bsl::streamsize  numChars);
        // Write the specified &#39;numChars&#39; characters from the specified
        // &#39;source&#39; to the stream buffer.  Return the number of characters
        // successfully written.  The behavior is undefined unless &#39;(source &amp;&amp;
        // 0 &lt; numChars) || 0 == numChars&#39;.

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(MemOutStreamBuf,
                                   bslma::UsesBslmaAllocator);

    // CREATORS
    explicit
    MemOutStreamBuf(bslma::Allocator *basicAllocator = 0);
        // Create an empty stream buffer.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    explicit
    MemOutStreamBuf(bsl::size_t       numElements,
                    bslma::Allocator *basicAllocator = 0);
        // Create an empty stream buffer with sufficient initial capacity to
        // accommodate up to the specified &#39;numElements&#39; characters without
        // subsequent reallocation.  If &#39;numElements == 0&#39;, an implementation-
        // defined initial capacity is used.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    ~MemOutStreamBuf();
        // Destroy this stream buffer.

    // MANIPULATORS
    void reserveCapacity(bsl::size_t numCharacters);
        // Reserve sufficient internal capacity to store at least the specified
        // &#39;numCharacters&#39; characters without reallocation.  Note that if the
        // storage size specified is less than the number of characters already
        // in the buffer, this method has no effect.

    void reset();
        // Destroy the contents of this stream buffer, return all allocated
        // memory to the allocator, and reset the buffer to the default
        // constructed state.  Note that &#39;length() == 0&#39; holds following a call
        // to this method.

    // ACCESSORS
    const char *data() const;
        // Return the address of the non-modifiable character buffer managed by
        // this stream buffer.

    bsl::size_t length() const;
        // Return the number of valid characters in this stream buffer.
};

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                         // ---------------------
                         // class MemOutStreamBuf
                         // ---------------------

// PRIVATE ACCESSORS
inline
bsl::size_t MemOutStreamBuf::capacity() const
{
    return epptr() - pbase();
}

// CREATORS
inline
MemOutStreamBuf::MemOutStreamBuf(bslma::Allocator *basicAllocator)
: d_allocator_p(bslma::Default::allocator(basicAllocator))
{
    setp(0, 0);
}

inline
MemOutStreamBuf::MemOutStreamBuf(bsl::size_t       numElements,
                                 bslma::Allocator *basicAllocator)
: d_allocator_p(bslma::Default::allocator(basicAllocator))
{
    setp(0, 0);
    reserveCapacity(numElements == 0
                    ? static_cast&lt;bsl::streamsize&gt;(k_INITIAL_BUFFER_SIZE)
                    : numElements);
}

inline
MemOutStreamBuf::~MemOutStreamBuf()
{
    d_allocator_p-&gt;deallocate(pbase());
}

// MANIPULATORS
inline
void MemOutStreamBuf::reset()
{
    d_allocator_p-&gt;deallocate(pbase());
    setp(0, 0);
}

// ACCESSORS
inline
const char *MemOutStreamBuf::data() const
{
    return pbase();
}

inline
bsl::size_t MemOutStreamBuf::length() const
{
    return pptr() - pbase();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
