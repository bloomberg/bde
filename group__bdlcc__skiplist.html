<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlcc_skiplist Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlcc_skiplist<br/>
<small>
[<a class="el" href="group__bdlcc.html">Package bdlcc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a generic thread-safe Skip List.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlcc.html">bdlcc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Template Requirements</a> </li>
<li>
<a href="#3.2">Glossary</a> </li>
<li>
<a href="#3.3">"R" Methods: Optimized Search From The Back Of The List</a> </li>
<li>
<a href="#3.4"><code>bdlcc::SkipListPair</code> Usage Rules</a> </li>
<li>
<a href="#3.5">Thread Safety</a> </li>
<li>
<a href="#3.6">Exception Safety</a> </li>
<li>
<a href="#3.7">Usage</a> <ul>
<li>
<a href="#3.7.1">Example 1: Creating a Scheduler</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a generic thread-safe Skip List. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a> </td><td>generic thread-aware ordered map  </td></tr>
<tr>
<td><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a> </td><td>type for opaque pointers  </td></tr>
<tr>
<td><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">bdlcc::SkipListPairHandle</a> </td><td>scope mechanism for safe item references  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a thread-safe value-semantic associative Skip List container. A Skip List stores objects of a parameterized <code>DATA</code> type, ordered by values of a parameterized <code>KEY</code> type. <code>DATA</code> objects can be added, looked up, and removed quickly on the basis of their <code>KEY</code> value. In addition, <code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> provides methods to change the <code>KEY</code> value associated with an object in the list such that it is efficiently moved to an appropriate location within the list for the new <code>KEY</code> value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Associations (pairings of data objects with key values) in the list are identified by <code><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">bdlcc::SkipListPairHandle</a></code> objects or <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> pointers. <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> pointers must be used with caution: See the "'bdlcc::SkipListPair' Usage Rules" below. <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> and <code><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">bdlcc::SkipListPairHandle</a></code> objects are optionally populated when new associations are added, and are also populated whenever associations are looked up (either by key or by position). There is an implementation-defined maximum number of references (whether by <code><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">bdlcc::SkipListPairHandle</a></code> or <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> pointer) to any single association element in the list, not less than <code>2^bdlccSkipList_Control::k_NUM_REFERENCE_BITS - 1</code>. The behavior of this component is undefined if more than that number of references are simultaneously acquired for a single element. Note that in addition to <code>addPairReferenceRaw</code>, member functions of <code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> such as <code>front</code>, <code>back</code>, and <code>find</code> also add a reference to the specified element. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="template_requirements"></a> <a class="anchor" id="description.template_requirements"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Template Requirements: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> ordered associative container is parameterized on two types, <code>KEY</code> and <code>DATA</code>. Each type must have a public copy constructor, and it is important to declare the "Uses Bdema Allocator" trait if the type accepts a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> in its constructor (see <code>bslalg_typetraits</code>). In addition, operators <code>=</code>, <code>&lt;</code>, and <code>==</code> must be defined for the type <code>KEY</code>; for correct behavior, operator <code>&lt;</code> must define a Strict Weak Ordering on <code>KEY</code> values. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="glossary"></a> <a class="anchor" id="description.glossary"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Glossary: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Some terms used frequently in this documentation: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> Back: <br/>
 The last element in the list. The key value at the back is greater than or equal to every other key value in the list.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> Front: <br/>
 The beginning of the list. The key value at the front is less than or equal to every other key value in the list.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> Pair: <br/>
 An element of the list; a pairing (association) of a data object with a key value. Also a type name used fororeferences* to such objects (<code>bdlcc:SkipListPair</code> objects cannot be constructed directly).</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> PairHandle: <br/>
 An object (of type <code><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">bdlcc::SkipListPairHandle</a></code>) with scope and copy semantics which make it easier to manage and use than a raw <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a>*</code>.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> R: <br/>
 Stands for "Reverse search" (see <code>"R" Methods</code> documentation below).</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> Reference: <br/>
 An object referring to a pair; either a <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a>*</code> which has not yet been released, or a <code><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">bdlcc::SkipListPairHandle</a></code> object.</div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="~22r~22_methods~3A_optimized_search_from_the_back_of_the_list"></a> <a class="anchor" id="description.~22r~22_methods~3A_optimized_search_from_the_back_of_the_list"></a> <a class="anchor" id="~22r~22_methods"></a> <a class="anchor" id="description.~22r~22_methods"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>R</b></dt><dd>Methods: Optimized Search From The Back Of The List:  </dd></dl>
<dl class="user"><dt><b></b></dt><dd>All methods of <code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> that result in a search through the list have corresponding "R" versions: for example, there are <code>add</code> and <code>addR</code> methods, <code>find</code> and <code>findR</code> methods, etc. The "R" versions of these methods search from the back of the list (i.e., in descending (reverse) order). Use of an "R" method is a hint to the Skip List that the desired key is more likely to be near the back than the front. In no case does the use of one version of a method over the other affect the correctness of the result. Note that if there are pairs in the list with duplicate keys, the specific pair found by <code>find</code> may (or may not) be different from the one found by <code>findR</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bdlcc~3A~3Askiplistpair_usage_rules"></a> <a class="anchor" id="description.bdlcc~3A~3Askiplistpair_usage_rules"></a> <a class="anchor" id="bdlcc"></a> <a class="anchor" id="description.bdlcc"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>bdlcc::SkipListPair Usage Rules: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>For safe and correct behavior of this component, it is critical that <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> pointers be treated similarly to HANDLEs in the Windows API: they should be released (using <code>releaseReferenceRaw</code>) when they are no longer needed, they must not be used after being released, and they must be released only once. To use a <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> pointer that refers to a particular pair in multiple places - e.g., in different functions or in different threads - use the <code>addPairReferenceRaw</code> method to add additional references to the same pair. Remember that <code>releaseReferenceRaw</code> must be called for <em>each</em> such pair reference when it is no longer needed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> is thread-safe and thread-aware; that is, multiple threads may use their own Skip List objects or may concurrently use the same object. Note that safe usage of the component depends upon correct usage of <code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> objects (see above). </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">bdlcc::SkipListPairHandle</a></code> is only <em>const</em> <em>thread-safe</em>. It is not safe for multiple threads to invoke non-const methods on the same PairHandle object concurrently. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> is a name used for opaque pointers; the concept of thread safety does not apply to it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="exception_safety"></a> <a class="anchor" id="description.exception_safety"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Exception Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> is exception-neutral: no method invokes <code>throw</code> or <code>catch</code>. Insertion methods (<code>add</code>, <code>addR</code>, etc) invoke the copy constructors of the contained <code>KEY</code> and <code>DATA</code> types; if those constructors throw an exception, the list provides a full rollback guarantee (it will have the same state it had prior to the call to <code>add</code>). The assignment operator may also indirectly cause <code>bad_alloc</code> to be thrown if the system is out of memory, but in that case there is <em>no</em> guarantee of rollback on the left-hand list. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>No method of <code><a class="el" href="classbdlcc_1_1SkipListPairHandle.html">bdlcc::SkipListPairHandle</a></code> can throw. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlcc_1_1SkipListPair.html">bdlcc::SkipListPair</a></code> is only a name used for opaque pointers; the concept of exception safety does not apply to it. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_creating_a_scheduler"></a> <a class="anchor" id="usage.example_1~3A_creating_a_scheduler"></a> <a class="anchor" id="description.usage.example_1~3A_creating_a_scheduler"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.7.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Creating a Scheduler: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "R" methods of <code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> make it ideal for use in a scheduler, in which events are likely to be scheduled after existing events. In such an implementation, events are stored in the list with their scheduled execution times as <code>KEY</code> objects: Searching near the end of the list for the right location for new events, and removing events from the front of the list for execution, are very efficient operations. Being thread- enabled also makes <code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> well-suited to use in a scheduler - a "dispatcher" thread can safety use the list at the same time that events are being scheduled from other threads. The following is an implementation of a simple scheduler class using <code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code>. Note that the mutex in the scheduler is used only in connection with the scheduler's condition variable<ul>
<li>thread-safe access to the <code><a class="el" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList</a></code> object does <em>not</em> require any synchronization. </li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd><br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keyword">class </span>SimpleScheduler
 {
    <span class="comment">// DATA</span>
    <span class="keyword">typedef</span> <a class="code" href="classbdlcc_1_1SkipList.html">bdlcc::SkipList&lt;bdlt::Datetime, bsl::function&lt;void()&gt;</a> &gt; List;

    List                     d_list;
    <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> d_dispatcher;
    <a class="code" href="classbslmt_1_1Condition.html">bslmt::Condition</a>          d_notEmptyCond;
    <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>              d_condMutex;
    <span class="keyword">volatile</span> <span class="keywordtype">bool</span>            d_doneFlag;

    <span class="comment">// PRIVATE METHODS</span>
    <span class="keywordtype">void</span> dispatcherThread()
    {
        <span class="keywordflow">while</span> (!d_doneFlag) {
            List::PairHandle firstItem;
            <span class="keywordflow">if</span> (0 == d_list.front(&amp;firstItem)) {
                <span class="comment">// The list is not empty.</span>

                <a class="code" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> when;
                <a class="code" href="structbdlt_1_1IntervalConversionUtil.html#a26fc24aa8f997f86fd940d780c28a7c0">bdlt::IntervalConversionUtil::convertToTimeInterval</a>(&amp;when,
                               firstItem.key() -
                               <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>());
                <span class="keywordflow">if</span> (when.<a class="code" href="classbsls_1_1TimeInterval.html#a649cad30ff67b82ca51f650254218ece">totalSecondsAsDouble</a>() &lt;= 0) {
                    <span class="comment">// Execute now and remove from schedule, then iterate.</span>

                    d_list.remove(firstItem);
                    firstItem.data()();
                }
                <span class="keywordflow">else</span> {
                    <span class="comment">// Wait until the first scheduled item is due (no</span>
                    <span class="comment">// problem if we wake up early, since we&#39;ll just check</span>
                    <span class="comment">// the list and go back to sleep).</span>

                    d_condMutex.lock();
                    List::PairHandle newFirst;
                    <span class="keywordflow">if</span> (!d_doneFlag &amp;&amp; (0 != d_list.front(&amp;newFirst) ||
                                        newFirst.key() == firstItem.key())) {
                        d_notEmptyCond.timedWait(&amp;d_condMutex,
                                                  <a class="code" href="structbdlt_1_1CurrentTime.html#af4a53b1fb4f2fdfa249d57980e6d02de">bdlt::CurrentTime::now</a>() +
                                                                      when);
                    }
                    d_condMutex.unlock();
                }
            }
            <span class="keywordflow">else</span> {
                <span class="comment">// The list is empty; wait on the condition variable.</span>

                d_condMutex.lock();
                <span class="keywordflow">if</span> (d_list.isEmpty() &amp;&amp; !d_doneFlag) {
                   d_notEmptyCond.wait(&amp;d_condMutex);
                }
                d_condMutex.unlock();
            }

            <span class="comment">// When firstItem goes out of scope here, it releases the</span>
            <span class="comment">// associated resources in the Skip List.</span>
        }
    }

  <span class="keyword">public</span>:
    <span class="comment">// CREATORS</span>
    SimpleScheduler(<a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator = 0)
    : d_list(basicAllocator)
    , d_doneFlag(false)
    {
        <span class="keywordtype">int</span> rc = <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(
                    &amp;d_dispatcher,
                    <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;SimpleScheduler::dispatcherThread,
                                        <span class="keyword">this</span>));
        <a class="code" href="bsls__assert_8h.html#a52b2a865ec62420b3681e39fa5cab9c0">BSLS_ASSERT_SAFE</a>(0 == rc);
    }

    ~SimpleScheduler()
    {
        stop();
    }

    <span class="comment">// MANIPULATORS</span>
    <span class="keywordtype">void</span> stop()
    {
        <span class="comment">// NOTE: this method will deadlock if invoked from an event callback</span>
        <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> guard(&amp;d_condMutex);
        <span class="keywordflow">if</span> (<a class="code" href="structbslmt_1_1ThreadUtil.html#a6ac8cf16bde241bc72c8ed38c3f0364f">bslmt::ThreadUtil::invalidHandle</a>() != d_dispatcher) {
            <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> dispatcher = d_dispatcher;
            d_doneFlag = <span class="keyword">true</span>;
            d_notEmptyCond.signal();
            {
                <a class="code" href="classbslmt_1_1UnLockGuard.html">bslmt::UnLockGuard&lt;bslmt::Mutex&gt;</a> g(&amp;d_condMutex);
                <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(dispatcher);
            }
            d_dispatcher = <a class="code" href="structbslmt_1_1ThreadUtil.html#a6ac8cf16bde241bc72c8ed38c3f0364f">bslmt::ThreadUtil::invalidHandle</a>();
        }
    }

    <span class="keywordtype">void</span> scheduleEvent(<span class="keyword">const</span> bsl::function&lt;<span class="keywordtype">void</span>()&gt;&amp; event,
                       <span class="keyword">const</span> <a class="code" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a>&amp; when)
    {
        <span class="comment">// Use &#39;addR&#39; since this event will probably be placed near the end</span>
        <span class="comment">// of the list.</span>

        <span class="keywordtype">bool</span> newFrontFlag;
        d_list.addR(when, event, &amp;newFrontFlag);
        <span class="keywordflow">if</span> (newFrontFlag) {
            <span class="comment">// This event is scheduled before all other events.  Wake up</span>
            <span class="comment">// the dispatcher thread.</span>

            d_condMutex.lock();
            d_notEmptyCond.signal();
            d_condMutex.unlock();
        }
    }
 };
</pre></div><br/>
<br/>
 We can verify the correct behavior of <code>SimpleScheduler</code>. First, we need a wrapper around vector&lt;int&gt;push_back, since this function is overloaded and cannot be bound directly: <br/>
<br/>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> pushBackWrapper(<a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> *vector, <span class="keywordtype">int</span> item)
 {
     vector-&gt;<a class="code" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a>(item);
 }
</pre></div><br/>
<br/>
 Now verify that the scheduler executes events when expected: <br/>
<br/>
<div class="fragment"><pre class="fragment"> SimpleScheduler scheduler;

 <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;int&gt;</a> values;

 <a class="code" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> now = <a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>();
 <a class="code" href="classbdlt_1_1Datetime.html">bdlt::Datetime</a> scheduleTime = now;

 <span class="comment">// Add events out of sequence and ensure they are executed</span>
 <span class="comment">// in the proper order:</span>

 scheduleTime.<a class="code" href="classbdlt_1_1Datetime.html#acb7121192b7786726e0d9de44bad4bb6">addMilliseconds</a>(1500);
 scheduler.scheduleEvent(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                         &amp;vector&lt;int&gt;::push_back, &amp;values, 1),
                         scheduleTime);

 scheduleTime = now;
 scheduleTime.<a class="code" href="classbdlt_1_1Datetime.html#acb7121192b7786726e0d9de44bad4bb6">addMilliseconds</a>(750);
 scheduler.scheduleEvent(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                         &amp;vector&lt;int&gt;::push_back, &amp;values, 0),
                         scheduleTime);

 scheduleTime = now;
 scheduleTime.<a class="code" href="classbdlt_1_1Datetime.html#acb7121192b7786726e0d9de44bad4bb6">addMilliseconds</a>(2250);
 scheduler.scheduleEvent(<a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(
                         &amp;vector&lt;int&gt;::push_back, &amp;values, 2),
                         scheduleTime);
 assert(values.isEmpty());
 scheduleTime.<a class="code" href="classbdlt_1_1Datetime.html#acb7121192b7786726e0d9de44bad4bb6">addMilliseconds</a>(250);
 <span class="keywordflow">while</span> (<a class="code" href="structbdlt_1_1CurrentTime.html#a42d082242c48b7445d21cabbaec1b50b">bdlt::CurrentTime::utc</a>() &lt; scheduleTime) {
     <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(10000);
 }
 scheduler.stop();
 assert(3 == values.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>());
 assert(0 == values[0]);
 assert(1 == values[1]);
 assert(2 == values[2]);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:41 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
