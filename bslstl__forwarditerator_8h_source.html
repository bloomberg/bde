<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslstl_forwarditerator.h                                           -*-C++-*-
#ifndef INCLUDED_BSLSTL_FORWARDITERATOR
#define INCLUDED_BSLSTL_FORWARDITERATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a template to create STL-compliant forward iterators.
//
//@CLASSES:
//  bslstl::ForwardIterator: forward iterator template
//
//@SEE_ALSO: bslstl_iterator, bslstl_bidirectionaliterator,
//           bslstl_randomaccessiterator
//
//@DESCRIPTION: This component provides an iterator adaptor that, given an
// implementation class defining a core set of iterator functionality, adapts
// it to provide an STL-compliant forward iterator interface.  The set of
// requirements for a forward iterator is found in &quot;Table 106: Forward iterator
// requirements&quot;, under the tag &quot;[forward.iterators]&quot;.  (Note that this
// reference is sourced in N3092, a C++0x working paper; the actual table
// number may vary in the actual standard.)  Include bsl_iterator.h to use this
// component.
//
///Usage
///-----
// Given the following &quot;iterator-like&quot; implementation class:
//..
//  template &lt;class T&gt;
//  class my_IteratorImp {
//    public:
//      // CREATORS
//      my_IteratorImp();
//      my_IteratorImp(const my_IteratorImp&amp;);
//      ~my_IteratorImp();
//
//      // An additional value-constructor should be supplied that can be
//      // called by the unspecified container type, providing access to the
//      // container&#39;s internal data structure that is to be iterated over.
//      // This would typically be called by &#39;begin&#39; and &#39;end&#39;.
//
//      // MANIPULATORS
//      my_IteratorImp&amp; operator=(const my_IteratorImp&amp;);
//
//      void operator++();
//
//      // ACCESSORS
//      T&amp; operator*() const;
//  };
//
//  template &lt;class T&gt;
//  bool operator==(const my_IteratorImp&lt;T&gt;&amp; lhs,
//                  const my_IteratorImp&lt;T&gt;&amp; rhs);
//..
// simply add the following two &#39;typedef&#39;s to any container class that provides
// &#39;my_IteratorImp&lt;T&gt;&#39; access, and the container will have STL-compliant
// forward iterators:
//..
//  typedef bslstl::ForwardIterator&lt;T, my_IteratorImp&lt;T&gt; &gt; iterator;
//  typedef bslstl::ForwardIterator&lt;const T, my_IteratorImp&lt;T&gt; &gt;
//                                                              const_iterator;
//..
// Note that the implementation for &#39;const_iterator&#39; is &#39;my_IteratorImp&lt;T&gt;&#39; and
// *not* &#39;my_IteratorImp&lt;const T&gt;&#39;, rather the &#39;const&#39; is added to the return
// value of &#39;operator*&#39; by way of conversion to the first template argument.

// DOCUMENTATION IS INCOMPLETE: Note that we need to say something about &#39;T&#39;
// and iterator stability.  Incrementing two copies of &#39;T&#39; must produce two
// iterators that compare equal, and refer to exactly the same object.  Without
// this guarantee, we cannot build the multi-pass property of Forward Iterator,
// and merely have an Input Iterator.  This is not something we can detect at
// compile time, and is prohibitively expensive to validate at runtime.  It is
// the sort of thing that should be validated by a Forward Iterator test suite,
// it could be what we really need, in addition to the adapters, is a
// generalized test case to validate that a type conforms to the iterator
// requirements.

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;&lt;bslstl_forwarditerator.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ITERATOR
#include &lt;bslstl_iterator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_REMOVECVQ
#include &lt;bslmf_removecvq.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

#ifndef INCLUDED_ITERATOR
#include &lt;iterator&gt;
#define INCLUDED_ITERATOR
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;  // &#39;ptrdiff_t&#39;
#define INCLUDED_CSTDDEF
#endif

namespace BloombergLP {

namespace bslstl {

                    //======================
                    // class ForwardIterator
                    //======================

template &lt;typename T, typename ITER_IMP, typename TAG_TYPE =
                                                     std::forward_iterator_tag&gt;
class ForwardIterator
                   : public std::iterator&lt;TAG_TYPE, T, std::ptrdiff_t, T *, T&amp;&gt;
{
    // Given an &#39;ITER_IMP&#39; type that implements a minimal subset of an iterator
    // interface, this template generates a complete iterator that meets all of
    // the requirements of a &quot;forward iterator&quot; in the C++ standard.  If &#39;T&#39; is
    // const-qualified, then the resulting type is a const iterator.  &#39;T&#39; shall
    // not be a function or reference type.  &#39;ITER_IMP&#39; must provide public
    // operations so that, for objects &#39;i&#39; and &#39;j&#39; of type &#39;ITER_IMP&#39;, the
    // following operations are supported:
    //..
    //     ITER_IMP i;                          Default construction
    //     ITER_IMP j(i);                       Copy construction
    //     i = j                                Assignment
    //     ++i                                  Increment to next element
    //     i == j     // convertible to bool    Equality comparison
    //     *i         // convertible to T&amp;      Element access (dereference)
    //..

    // PRIVATE TYPES
    typedef typename bsl::remove_cv&lt;T&gt;::type UnCvqT;   // value type without
                                                       // &#39;const&#39; and
                                                       // &#39;volatile&#39;
                                                       // qualifications

  private:
    // DATA
    ITER_IMP d_imp;  // externally-supplied implementation of iterator
                     // functionality

  public:
    // TYPES
    typedef T                          value_type;
    typedef std::ptrdiff_t             difference_type;
    typedef T                         *pointer;
    typedef T&amp;                         reference;
    typedef std::forward_iterator_tag  iterator_category;

    // CREATORS
    ForwardIterator();
        // Construct the default value for this iterator type.  All default-
        // constructed &#39;ForwardIterator&#39; objects represent non-dereferenceable
        // iterators into the same empty range.  They do not have a singular
        // value unless an object of the type specified by the template
        // parameter &#39;ITER_IMP&#39; has a singular value after
        // value-initialization.

    ForwardIterator(const ITER_IMP&amp; implementation);
        // Construct a forward iterator having the specified &#39;implementation&#39;
        // of the parameterized &#39;ITER_IMP&#39; type.

    //! ForwardIterator(const ForwardIterator&amp; original);
        // Create a &#39;ForwardIterator&#39; having the same value as the specified
        // &#39;original&#39; iterator.  Note that this method&#39;s definition is compiler
        // generated.

    ForwardIterator(const ForwardIterator&lt;UnCvqT,ITER_IMP,TAG_TYPE&gt;&amp; other);
        // Construct a forward iterator from another (compatible)
        // &#39;ForwardIterator&#39; type, e.g., a mutable iterator of the same type.
        // Note that since this is a template, it has a lower priority in
        // overload resolution than the other constructors.

    //! ~ForwardIterator();
        // Destroy this iterator.  Note that this method&#39;s definition is
        // compiler generated.

    // MANIPULATORS
    //! ForwardIterator&amp; operator=(const ForwardIterator&amp; rhs);
        // Copy the value of the specified &#39;rhs&#39; to this iterator.  Return a
        // reference to this modifiable object.  Note that this method&#39;s
        // definition is compiler generated.

    ForwardIterator&amp; operator++();
        // Increment to the next element.  Return a reference to this
        // modifiable iterator.  The behavior is undefined if, on entry, this
        // iterator has the past-the-end value for an iterator over the
        // underlying sequence.

    ITER_IMP&amp; imp();
        // Return a modifiable reference to the implementation object.

    // ACCESSORS
    T&amp; operator*() const;
        // Return a reference to the current, modifiable element.  The behavior
        // is undefined if this iterator has the past-the-end value for an
        // iterator over the underlying sequence.

    T *operator-&gt;() const;
        // Return a pointer to the current, modifiable element.  The behavior
        // is undefined if this iterator has the past-the-end value for an
        // iterator over the underlying sequence.

    const ITER_IMP&amp; imp() const;
        // Return a non-modifiable reference to the implementation object.
};

// FREE OPERATORS
template &lt;typename T1, typename T2, typename ITER_IMP, typename TAG_TYPE&gt;
bool operator==(const ForwardIterator&lt;T1,ITER_IMP,TAG_TYPE&gt;&amp; lhs,
                const ForwardIterator&lt;T2,ITER_IMP,TAG_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; iterator has the same value as the
    // specified &#39;rhs&#39; iterator, and &#39;false&#39; otherwise.  Two iterators have the
    // same value if they refer to the same element, or both have the past-the-
    // end value for the underlying sequence.  The behavior is undefined unless
    // both iterators refer to the same underlying sequence.

template &lt;typename T1, typename T2, typename ITER_IMP, typename TAG_TYPE&gt;
bool operator!=(const ForwardIterator&lt;T1,ITER_IMP,TAG_TYPE&gt;&amp; lhs,
                const ForwardIterator&lt;T2,ITER_IMP,TAG_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; iterator does not have the same
    // value as the specified &#39;rhs&#39; iterator, and &#39;false&#39; otherwise.  Two
    // iterators do not have the same value if (1) they do not refer to the
    // same element and (2) both do not have the past-the-end iterator value
    // for the underlying sequence.  The behavior is undefined unless both
    // iterators refer to the same underlying sequence.

template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;
operator++(ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;&amp; iter, int);
    // Increment the specified &#39;iter&#39; to the next element.  Return the previous
    // value of &#39;iter&#39;.  The behavior is undefined if, on entry, &#39;iter&#39; has the
    // past-the-end value for an iterator of the underlying sequence.

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

                        //-----------------------------
                        // class ForwardIterator
                        //-----------------------------

// CREATORS
template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;::ForwardIterator()
: d_imp()
{
}

template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;::
ForwardIterator(const ITER_IMP&amp; implementation)
: d_imp(implementation)
{
}

template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;::
ForwardIterator(const ForwardIterator&lt;UnCvqT,ITER_IMP,TAG_TYPE&gt;&amp; other)
: d_imp(other.imp())
{
}

// MANIPULATORS
template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;&amp;
ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;::operator++()
{
    ++this-&gt;d_imp;
    return *this;
}

template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
ITER_IMP&amp; ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;::imp()
{
    return d_imp;
}

// ACCESSORS
template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
T&amp; ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;::operator*() const
{
    return *d_imp;
}

template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
T *ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;::operator-&gt;() const
{
    return BSLS_UTIL_ADDRESSOF(*d_imp);
}

template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
const ITER_IMP&amp;
ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;::imp() const
{
    return d_imp;
}

}  // close package namespace

// FREE OPERATORS
template &lt;typename T, typename ITER_IMP, typename TAG_TYPE&gt;
inline
bslstl::ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;
bslstl::operator++(ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt;&amp; iter, int)
{
    ForwardIterator&lt;T,ITER_IMP,TAG_TYPE&gt; tmp(iter);
    ++iter;
    return tmp;
}

template &lt;typename T1, typename T2, typename ITER_IMP, typename TAG_TYPE&gt;
inline
bool bslstl::operator==(const ForwardIterator&lt;T1,ITER_IMP,TAG_TYPE&gt;&amp; lhs,
                        const ForwardIterator&lt;T2,ITER_IMP,TAG_TYPE&gt;&amp; rhs)
{
    return lhs.imp() == rhs.imp();
}

template &lt;typename T1,  typename T2, typename ITER_IMP, typename TAG_TYPE&gt;
inline
bool bslstl::operator!=(const ForwardIterator&lt;T1,ITER_IMP,TAG_TYPE&gt;&amp; lhs,
                        const ForwardIterator&lt;T2,ITER_IMP,TAG_TYPE&gt;&amp; rhs)
{
    return !(lhs == rhs);
}


}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
