<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bslstl_stringbuf Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>Component bslstl_stringbuf<br/>
<small>
[<a class="el" href="group__bslstl.html">Package bslstl</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a C++03-compatible <code>stringbuf</code> class.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CHAR_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga7c3b0f93c394d608791716748de25a09">bsl::basic_stringbuf::char_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef CHAR_TRAITS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga85f1451fb6d7a702c6aab33dc7fc742b">bsl::basic_stringbuf::traits_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">bsl::basic_stringbuf::allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef traits_type::int_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gadef523fece1174fd6e45af7208aa9352">bsl::basic_stringbuf::int_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef traits_type::off_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga28f442f6ed5e4ba0fee622955ca46c4a">bsl::basic_stringbuf::off_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef traits_type::pos_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gae11c10232ad490123724c0a9b21340f5">bsl::basic_stringbuf::pos_type</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual pos_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga0d846e2e9a94826c08dfa06c93f6e97e">bsl::basic_stringbuf::seekoff</a> (off_type offset, ios_base::seekdir whence, ios_base::openmode modeBitMask=ios_base::in|ios_base::out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual pos_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga272da383142a789c53fc46fdc3284774">bsl::basic_stringbuf::seekpos</a> (pos_type absoluteOffset, ios_base::openmode modeBitMask=ios_base::in|ios_base::out)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual native_std::streamsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga8bdec61ab0dcbb13ebd2954381004fdc">bsl::basic_stringbuf::xsgetn</a> (char_type *result, native_std::streamsize numCharacters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gad92b8be128b449fa89dc5c4fae6b1046">bsl::basic_stringbuf::underflow</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gaa210d8626097007e3374e3730eef2658">bsl::basic_stringbuf::uflow</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga11906fc4b7c1b8d8e3dfedfa0607ea10">bsl::basic_stringbuf::pbackfail</a> (int_type character=traits_type::eof())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual native_std::streamsize&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga135b1efa7fe5b6022b56f16e8a89b1fd">bsl::basic_stringbuf::xsputn</a> (const char_type *inputString, native_std::streamsize numCharacters)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gae8a925166e9e7071fbc78ccca5c2fb7f">bsl::basic_stringbuf::overflow</a> (int_type character=traits_type::eof())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga7074ad810f4ff4e2e9da9d1d3b54b3e2">bsl::basic_stringbuf::basic_stringbuf</a> (const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga1d0b60dd3c0be5584925394cce918c1b">bsl::basic_stringbuf::basic_stringbuf</a> (ios_base::openmode modeBitMask, const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga2d5aeb3a09282aef135a305c36fa6406">bsl::basic_stringbuf::basic_stringbuf</a> (const StringType &amp;initialString, const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gaab97503db6eae15b51d1c45c8694e717">bsl::basic_stringbuf::basic_stringbuf</a> (const StringType &amp;initialString, ios_base::openmode modeBitMask, const allocator_type &amp;allocator=allocator_type())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga8a37f30181b44753d4b0483daf0704fa">bsl::basic_stringbuf::~basic_stringbuf</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga3edf3d8359dd3d334f60c690fd79e8a2">bsl::basic_stringbuf::str</a> (const StringType &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">StringType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gafe021b05a126b3d4532c9587f6d9f4eb">bsl::basic_stringbuf::str</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gab5d1207177ba0834c63b8f0215ecc665">bsl::StringBufContainer::StringBufContainer</a> (const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga67fc9e726d64939525c2664268f6774b">bsl::StringBufContainer::StringBufContainer</a> (ios_base::openmode modeBitMask, const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#gaee8b11dfd77855c98641a51b9a2a16d7">bsl::StringBufContainer::StringBufContainer</a> (const StringType &amp;initialString, const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga58a49f935dd612d35ddb5b7ea45c039f">bsl::StringBufContainer::StringBufContainer</a> (const StringType &amp;initialString, ios_base::openmode modeBitMask, const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga450cd7881e7496861e240916ecc0fe3c">bsl::StringBufContainer::~StringBufContainer</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">StreamBufType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__stringbuf.html#ga92b99eb21691cb75b7144f396fcdb540">bsl::StringBufContainer::rdbuf</a> () const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Memory Allocation</a> <ul>
<li>
<a href="#3.1.1"><code>bslma</code>-Style Allocators</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Basic Operations</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a C++03-compatible <code>stringbuf</code> class. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td>bsl::stringbuf </td><td>C++03-compatible <code>stringbuf</code> class  </td></tr>
<tr>
<td><a class="el" href="classbsl_1_1StringBufContainer.html">bsl::StringBufContainer</a> </td><td>wrapper for <code><a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a></code>  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslstl__stringstream.html" title="Provide a C++03-compatible stringstream class.">Component bslstl_stringstream</a>, <a class="el" href="group__bslstl__ostringstream.html" title="Provide a C++03-compatible ostringstream class.">Component bslstl_ostringstream</a>, <a class="el" href="group__bslstl__istringstream.html" title="Provide a C++03-compatible istringstream class.">Component bslstl_istringstream</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component is for internal use only. Please include <code>&lt;bsl_sstream.h&gt;</code> instead. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a class template, <code><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a></code>, that implements a standard string buffer, providing an unformatted character input sequence and an unformatted character output sequence that may be initialized or accessed using a string value (see 27.8.2 [stringbuf] of the C++11 standard). This component also defines two standard aliases, <code>bsl::stringbuf</code> and <code>bsl::wstringbuf</code>, that refer to specializations of the <code><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a></code> template for <code>char</code> and <code>wchar_t</code> types, respectively. As with any stream buffer class, <code><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a></code> is rarely used directly. Stream buffers provide low-level unformatted input/output. They are usually plugged into <code>std::basic_stream</code> classes to provide higher-level formatted input and output via <code>operator&lt;&lt;</code> and <code>operator&gt;&gt;</code>. <code><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a></code> is used in the <code><a class="el" href="classbsl_1_1basic__stringstream.html">bsl::basic_stringstream</a></code> family of classes and users should prefer those classes over direct use of <code><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a></code> derives from <code>std::basic_streambuf</code> and implements the necessary protected virtual methods. In this way <code><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a></code> customizes the behavior of <code>std::basic_streambuf</code> to redirect the reading and writing of characters to an internally-maintained sequence of characters that can be initialized or accessed using a <code><a class="el" href="classbsl_1_1basic__string.html">bsl::basic_string</a></code>. Note that although the standard mandates functions that access and modify the buffered sequence using a <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code>, it does not mandate that a <code><a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a></code> internally store this buffer in a <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code>; this implementation currently uses a <code><a class="el" href="classbsl_1_1basic__string.html">basic_string</a></code> as its internal buffer, but that is subject to change without warning. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>bsl::stringbuf</code> template has three parameters, <code>CHAR_TYPE</code>, <code>CHAR_TRAITS</code>, and <code>ALLOCATOR</code>. The <code>CHAR_TYPE</code> and <code>CHAR_TRAITS</code> parameters respectively define the character type for the stream buffer and a type providing a set of operations the stream buffer will use to manipulate characters of that type, which must meet the character traits requirements defined by the C++11 standard, 21.2 [char.traits]. The <code>ALLOCATOR</code> template parameter is described in the "Memory Allocation" section below. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="memory_allocation"></a> <a class="anchor" id="description.memory_allocation"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Memory Allocation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The type supplied as a stream buffer's <code>ALLOCATOR</code> template parameter determines how that stream buffer will allocate memory. The <code><a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a></code> template supports allocators meeting the requirements of the C++11 standard, 17.6.3.5 [allocator.requirements]; in addition, it supports scoped-allocators derived from the <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> memory allocation protocol. Clients intending to use <code>bslma</code>-style allocators should use <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, which provides a C++11 standard-compatible adapter for a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object. Note that the standard aliases <code>bsl::stringbuf</code> and <code>bsl::wstringbuf</code> both use <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bslma-style_allocators"></a> <a class="anchor" id="memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="description.memory_allocation.bslma-style_allocators"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>bslma-Style Allocators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the type supplied for the <code>ALLOCATOR</code> template parameter of a <code>stringbuf</code> instantiation is <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code>, then objects of that stream buffer type will conform to the standard behavior of a <code>bslma</code>-allocator-enabled type. Such a stream buffer accepts an optional <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> argument at construction. If the address of a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> object is explicitly supplied at construction, it will be used to supply memory for the stream buffer throughout its lifetime; otherwise, the stream buffer will use the default allocator installed at the time of the stream buffer's construction (see <code>bslma_default</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Basic Operations: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following example demonstrates the use of <code>bsl::stringbuf</code> to read and write character data from and to a <code>bsl::string</code> object. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we want to implement a simplified converter from <code>unsigned int</code> to <code>bsl::string</code> and back. First, we define the prototypes of two conversion functions: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>  toString(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> from);
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fromString(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; from);
</pre></div><br/>
<br/>
 Then, we use <code>bsl::stringbuf</code> to implement the <code>toString</code> function. We write all digits into <code>bsl::stringbuf</code> individually using <code>sputc</code> methods and then return the resulting <code>bsl::string</code> object: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;algorithm&gt;</span>

  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> toString(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> from)
  {
      <a class="code" href="classbsl_1_1basic__stringbuf.html">bsl::stringbuf</a> out;

      <span class="keywordflow">for</span> (; from != 0; from /= 10) {
          out.sputc(<span class="charliteral">&#39;0&#39;</span> + from % 10);
      }

      <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a> result(out.<a class="code" href="group__bslstl__stringbuf.html#ga3edf3d8359dd3d334f60c690fd79e8a2">str</a>());
      std::reverse(result.begin(), result.end());
      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Now, we implement the <code>fromString</code> function that converts from <code>bsl::string</code> to <code>unsigned int</code> by using <code>bsl::stringbuf</code> to read individual digits from the string object: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fromString(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp; from)
  {
      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result = 0;

      <span class="keywordflow">for</span> (<a class="code" href="classbsl_1_1basic__stringbuf.html">bsl::stringbuf</a> in(from); in.in_avail(); ) {
          result = result * 10 + (in.sbumpc() - <span class="charliteral">&#39;0&#39;</span>);
      }

      <span class="keywordflow">return</span> result;
  }
</pre></div><br/>
<br/>
 Finally, we verify that the result of the round-trip conversion is identical to the original value: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> orig   = 92872498;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> result = fromString(toString(orig));

  assert(orig == result);
</pre></div><br/>
<br/>
 </dd></dl>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ga7c3b0f93c394d608791716748de25a09"></a><!-- doxytag: member="bsl::basic_stringbuf::char_type" ref="ga7c3b0f93c394d608791716748de25a09" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CHAR_TYPE <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::char_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga85f1451fb6d7a702c6aab33dc7fc742b"></a><!-- doxytag: member="bsl::basic_stringbuf::traits_type" ref="ga85f1451fb6d7a702c6aab33dc7fc742b" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef CHAR_TRAITS <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::traits_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gafe54a05b5cec652325ce3de7a80bab97"></a><!-- doxytag: member="bsl::basic_stringbuf::allocator_type" ref="gafe54a05b5cec652325ce3de7a80bab97" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef ALLOCATOR <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::allocator_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadef523fece1174fd6e45af7208aa9352"></a><!-- doxytag: member="bsl::basic_stringbuf::int_type" ref="gadef523fece1174fd6e45af7208aa9352" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef traits_type::int_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::int_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga28f442f6ed5e4ba0fee622955ca46c4a"></a><!-- doxytag: member="bsl::basic_stringbuf::off_type" ref="ga28f442f6ed5e4ba0fee622955ca46c4a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef traits_type::off_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::off_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae11c10232ad490123724c0a9b21340f5"></a><!-- doxytag: member="bsl::basic_stringbuf::pos_type" ref="gae11c10232ad490123724c0a9b21340f5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE, class CHAR_TRAITS, class ALLOCATOR&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef traits_type::pos_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pos_type<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga0d846e2e9a94826c08dfa06c93f6e97e"></a><!-- doxytag: member="bsl::basic_stringbuf::seekoff" ref="ga0d846e2e9a94826c08dfa06c93f6e97e" args="(off_type offset, ios_base::seekdir whence, ios_base::openmode modeBitMask=ios_base::in|ios_base::out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pos_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::seekoff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__stringbuf.html#ga28f442f6ed5e4ba0fee622955ca46c4a">off_type</a>&nbsp;</td>
          <td class="paramname"> <em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ios_base::seekdir&nbsp;</td>
          <td class="paramname"> <em>whence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ios_base::openmode&nbsp;</td>
          <td class="paramname"> <em>modeBitMask</em> = <code>ios_base::in&nbsp;|&nbsp;ios_base::out</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the current input position or the current output position (or both) to the specified <code>offset</code> from the specified <code>whence</code> location. Optionally specify a <code>modeBitMask</code> indicating whether to set the current input position, current output position, or both. If <code>whence</code> is <code>ios_base::beg</code>, set the current position to the indicated <code>offset</code> from the beginning of the stream; if <code>whence</code> is <code>ios_base::end</code>, set the current position to the indicated <code>offset</code> from the end of the stream; and if <code>whence</code> is <code>ios_base::cur</code>, set the current input or output position to the indicated <code>offset</code> from its current position. If <code>whence</code> is <code>ios_base::cur</code>, then <code>modeBitMask</code> may be either <code>ios_base::in</code> or <code>ios_base::out</code>, but not both. Return the offset of the new position on success, and <code>pos_type(off_type(-1))</code> otherwise. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a68505741fd0625240b1fbd8c9f40643c">BSLS_ASSERT_OPT</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__stringbuf.html#ga272da383142a789c53fc46fdc3284774">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::seekpos()</a>.</p>

</div>
</div>
<a class="anchor" id="ga272da383142a789c53fc46fdc3284774"></a><!-- doxytag: member="bsl::basic_stringbuf::seekpos" ref="ga272da383142a789c53fc46fdc3284774" args="(pos_type absoluteOffset, ios_base::openmode modeBitMask=ios_base::in|ios_base::out)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pos_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::seekpos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__stringbuf.html#gae11c10232ad490123724c0a9b21340f5">pos_type</a>&nbsp;</td>
          <td class="paramname"> <em>absoluteOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ios_base::openmode&nbsp;</td>
          <td class="paramname"> <em>modeBitMask</em> = <code>ios_base::in&nbsp;|&nbsp;ios_base::out</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the current input position or the current output position (or both) to the specified <code>absoluteOffset</code> from the beginning of the stream. Optionally specify a <code>modeBitMask</code> indicating whether to set the current input position, current output position, or both. Return the offset of the new position on success, and <code>pos_type(off_type(-1))</code> otherwise. </p>

<p>References <a class="el" href="group__bslstl__stringbuf.html#ga0d846e2e9a94826c08dfa06c93f6e97e">bsl::basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::seekoff()</a>.</p>

</div>
</div>
<a class="anchor" id="ga8bdec61ab0dcbb13ebd2954381004fdc"></a><!-- doxytag: member="bsl::basic_stringbuf::xsgetn" ref="ga8bdec61ab0dcbb13ebd2954381004fdc" args="(char_type *result, native_std::streamsize numCharacters)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">native_std::streamsize <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::xsgetn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__stringbuf.html#ga7c3b0f93c394d608791716748de25a09">char_type</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native_std::streamsize&nbsp;</td>
          <td class="paramname"> <em>numCharacters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read up to the specified <code>numCharacters</code> from this <code>stringbuf</code> object and store them in the specified <code>result</code> array. Return the number of characters loaded into <code>result</code>. Note that if fewer than <code>numCharacters</code> characters are available in the buffer, all available characters are loaded into <code>result</code>. The behavior is undefined unless <code>result</code> refers to a contiguous sequence of characters of at least <code>numCharacters</code>. </p>

</div>
</div>
<a class="anchor" id="gad92b8be128b449fa89dc5c4fae6b1046"></a><!-- doxytag: member="bsl::basic_stringbuf::underflow" ref="gad92b8be128b449fa89dc5c4fae6b1046" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::int_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::underflow </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the character at the current input position, if a character is available, and <code>traits_type::eof()</code> otherwise. Update the end of the input area, <code>egptr</code>, if additional characters are available (as may occur if additional characters have been written to the string buffer). Note that this operation is similar to <code>uflow</code>, but does not advance the current input position. </p>

</div>
</div>
<a class="anchor" id="gaa210d8626097007e3374e3730eef2658"></a><!-- doxytag: member="bsl::basic_stringbuf::uflow" ref="gaa210d8626097007e3374e3730eef2658" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::int_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::uflow </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the character at the current input position and advance the input position by 1. If no character is available at the current input position, return <code>traits_type::eof()</code>. Update the end of the input area, <code>egptr</code>, if additional characters are available (as may occur if additional characters have been written to the string buffer). Note that this operation is similar to <code>underflow</code>, but advances the current input position. </p>

</div>
</div>
<a class="anchor" id="ga11906fc4b7c1b8d8e3dfedfa0607ea10"></a><!-- doxytag: member="bsl::basic_stringbuf::pbackfail" ref="ga11906fc4b7c1b8d8e3dfedfa0607ea10" args="(int_type character=traits_type::eof())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::int_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::pbackfail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__stringbuf.html#gadef523fece1174fd6e45af7208aa9352">int_type</a>&nbsp;</td>
          <td class="paramname"> <em>character</em> = <code>traits_type::eof()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Put back the specified <code>character</code> into the input sequence so that the next character read from the input sequence will be <code>character</code>. If <code>character</code> is either <code>traits_type::eof()</code> or is the same as the previously read character from the input sequence, then adjust the current input position, <code>gptr</code>, back one position. If <code>character</code> is neither <code>traits_type::eof()</code> nor the character previously read from the input sequence, but this string buffer was opened for writing (<code>ios_base::out</code>), then adjust the input sequence back one position and write <code>character</code> to that position. Return the character that was put back on success and <code>traits_type::eof()</code> if either the input position is currently at the beginning of the sequence or if the previous character in the input sequence is not <code>character</code> and this buffer was not opened for writing. </p>

</div>
</div>
<a class="anchor" id="ga135b1efa7fe5b6022b56f16e8a89b1fd"></a><!-- doxytag: member="bsl::basic_stringbuf::xsputn" ref="ga135b1efa7fe5b6022b56f16e8a89b1fd" args="(const char_type *inputString, native_std::streamsize numCharacters)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">native_std::streamsize <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::xsputn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__stringbuf.html#ga7c3b0f93c394d608791716748de25a09">char_type</a> *&nbsp;</td>
          <td class="paramname"> <em>inputString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">native_std::streamsize&nbsp;</td>
          <td class="paramname"> <em>numCharacters</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>numCharacters</code> from the specified <code>inputString</code> to the output sequence starting at the current output position (<code>pptr</code>). Update the current output position of this string buffer to refer to the last appended character. Return the number of characters that were appended. The behavior is undefined unless <code>inputString</code> refers to a contiguous sequence of characters of at least <code>numCharacters</code>. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga9c2fb86b756802242f98cedc716073b1">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::append()</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="gae8a925166e9e7071fbc78ccca5c2fb7f"></a><!-- doxytag: member="bsl::basic_stringbuf::overflow" ref="gae8a925166e9e7071fbc78ccca5c2fb7f" args="(int_type character=traits_type::eof())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::int_type <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::overflow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__stringbuf.html#gadef523fece1174fd6e45af7208aa9352">int_type</a>&nbsp;</td>
          <td class="paramname"> <em>character</em> = <code>traits_type::eof()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [protected, virtual, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append the specified <code>character</code> to the output sequence of this stream buffer at the current output position (<code>pptr</code>), and advance the output position by one. This operation may update the end of output area (<code>epptr</code>) to allow for additional writes (e.g., by the base <code>basic_streambuf</code> type) to the output sequence without calling a method on this type. Return the written character on success, and <code>traits_type::eof()</code> if <code>character</code> is <code>traits_type::eof()</code> or this stream buffer was not opened for writing. </p>

<p>References <a class="el" href="group__bslstl__string.html#ga6cf77eba8e1c6889f82179256b876446">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::push_back()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7074ad810f4ff4e2e9da9d1d3b54b3e2"></a><!-- doxytag: member="bsl::basic_stringbuf::basic_stringbuf" ref="ga7074ad810f4ff4e2e9da9d1d3b54b3e2" args="(const allocator_type &amp;allocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_stringbuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code><a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">allocator_type</a>()</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga1d0b60dd3c0be5584925394cce918c1b"></a><!-- doxytag: member="bsl::basic_stringbuf::basic_stringbuf" ref="ga1d0b60dd3c0be5584925394cce918c1b" args="(ios_base::openmode modeBitMask, const allocator_type &amp;allocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_stringbuf </td>
          <td>(</td>
          <td class="paramtype">ios_base::openmode&nbsp;</td>
          <td class="paramname"> <em>modeBitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code><a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga2d5aeb3a09282aef135a305c36fa6406"></a><!-- doxytag: member="bsl::basic_stringbuf::basic_stringbuf" ref="ga2d5aeb3a09282aef135a305c36fa6406" args="(const StringType &amp;initialString, const allocator_type &amp;allocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_stringbuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">StringType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initialString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code><a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaab97503db6eae15b51d1c45c8694e717"></a><!-- doxytag: member="bsl::basic_stringbuf::basic_stringbuf" ref="gaab97503db6eae15b51d1c45c8694e717" args="(const StringType &amp;initialString, ios_base::openmode modeBitMask, const allocator_type &amp;allocator=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::basic_stringbuf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">StringType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initialString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ios_base::openmode&nbsp;</td>
          <td class="paramname"> <em>modeBitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">allocator_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em> = <code><a class="el" href="group__bslstl__stringbuf.html#gafe54a05b5cec652325ce3de7a80bab97">allocator_type</a>()</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a <code><a class="el" href="classbsl_1_1basic__stringbuf.html">basic_stringbuf</a></code> object. Optionally specify a <code>modeBitMask</code> indicating whether this buffer may be read from, written to, or both. If <code>modeBitMask</code> is not supplied, this buffer is created with <code>ios_base::in | ios_base::out</code>. Optionally specify an <code>initialString</code> indicating the initial sequence of characters that this buffer will access or manipulate. If <code>initialString</code> is not supplied, the initial sequence of characters will be empty. Optionally specify an <code>allocator</code> used to supply memory. If <code>allocator</code> is not supplied, a default-constructed object of the (template parameter) <code>ALLOCATOR</code> type is used. If the <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> (the default), then <code>allocator</code>, if supplied, shall be convertible to <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *</code>. If the <code>ALLOCATOR</code> argument is of type <code><a class="el" href="classbsl_1_1allocator.html">bsl::allocator</a></code> and <code>allocator</code> is not supplied, the currently installed default allocator will be used to supply memory. </p>

</div>
</div>
<a class="anchor" id="ga8a37f30181b44753d4b0483daf0704fa"></a><!-- doxytag: member="bsl::basic_stringbuf::~basic_stringbuf" ref="ga8a37f30181b44753d4b0483daf0704fa" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::~basic_stringbuf </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

<p>References <a class="el" href="bsls__assert_8h.html#a1d80716f3bc5018941bcaf0856d93a1b">BSLS_ASSERT</a>, <a class="el" href="group__bslstl__string.html#gaac917fd3a1a7498eef93bc91d8348c8d">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::data()</a>, and <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3edf3d8359dd3d334f60c690fd79e8a2"></a><!-- doxytag: member="bsl::basic_stringbuf::str" ref="ga3edf3d8359dd3d334f60c690fd79e8a2" args="(const StringType &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::str </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">StringType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the internally buffered sequence of characters to the specified <code>value</code>. Update the beginning and end of both the input and output sequences to be the beginning and end of the updated buffer, update the current input position to be the beginning of the updated buffer, and update the current output position to be the end of the updated buffer. </p>

<p>References <a class="el" href="group__bslstl__string.html#gab550ff7fbf2bc8edf24ee0a3ed8ac140">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::size()</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__stringstream.html#gabc665fb8f263f6c87fe5709fb2b03176">bsl::basic_stringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::str()</a>, <a class="el" href="group__bslstl__ostringstream.html#ga23ddb310164dea8c696231517b0e1f5e">bsl::basic_ostringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::str()</a>, and <a class="el" href="group__bslstl__istringstream.html#ga4353e5c476c86ebdcaa429a0b2bd200a">bsl::basic_istringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::str()</a>.</p>

</div>
</div>
<a class="anchor" id="gafe021b05a126b3d4532c9587f6d9f4eb"></a><!-- doxytag: member="bsl::basic_stringbuf::str" ref="gafe021b05a126b3d4532c9587f6d9f4eb" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">basic_stringbuf&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::StringType <a class="el" href="classbsl_1_1basic__stringbuf.html">bsl::basic_stringbuf</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::str </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the currently buffered sequence of characters. </p>

<p>References <a class="el" href="group__bslstl__string.html#gaaedf4e0c4484a05f260fda8f45aa6887">bsl::basic_string&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::begin()</a>.</p>

</div>
</div>
<a class="anchor" id="gab5d1207177ba0834c63b8f0215ecc665"></a><!-- doxytag: member="bsl::StringBufContainer::StringBufContainer" ref="gab5d1207177ba0834c63b8f0215ecc665" args="(const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1StringBufContainer.html">bsl::StringBufContainer</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::StringBufContainer </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, explicit, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga67fc9e726d64939525c2664268f6774b"></a><!-- doxytag: member="bsl::StringBufContainer::StringBufContainer" ref="ga67fc9e726d64939525c2664268f6774b" args="(ios_base::openmode modeBitMask, const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1StringBufContainer.html">bsl::StringBufContainer</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::StringBufContainer </td>
          <td>(</td>
          <td class="paramtype">ios_base::openmode&nbsp;</td>
          <td class="paramname"> <em>modeBitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaee8b11dfd77855c98641a51b9a2a16d7"></a><!-- doxytag: member="bsl::StringBufContainer::StringBufContainer" ref="gaee8b11dfd77855c98641a51b9a2a16d7" args="(const StringType &amp;initialString, const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1StringBufContainer.html">bsl::StringBufContainer</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::StringBufContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">StringType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initialString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga58a49f935dd612d35ddb5b7ea45c039f"></a><!-- doxytag: member="bsl::StringBufContainer::StringBufContainer" ref="ga58a49f935dd612d35ddb5b7ea45c039f" args="(const StringType &amp;initialString, ios_base::openmode modeBitMask, const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1StringBufContainer.html">bsl::StringBufContainer</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::StringBufContainer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbsl_1_1basic__string.html">StringType</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>initialString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ios_base::openmode&nbsp;</td>
          <td class="paramname"> <em>modeBitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga450cd7881e7496861e240916ecc0fe3c"></a><!-- doxytag: member="bsl::StringBufContainer::~StringBufContainer" ref="ga450cd7881e7496861e240916ecc0fe3c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1StringBufContainer.html">bsl::StringBufContainer</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::~StringBufContainer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga92b99eb21691cb75b7144f396fcdb540"></a><!-- doxytag: member="bsl::StringBufContainer::rdbuf" ref="ga92b99eb21691cb75b7144f396fcdb540" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CHAR_TYPE , class CHAR_TRAITS , class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">StreamBufType* <a class="el" href="classbsl_1_1StringBufContainer.html">bsl::StringBufContainer</a>&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rdbuf </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reimplemented in <a class="el" href="group__bslstl__istringstream.html#ga1f3188661e106d68232070a6fec2dbfe">bsl::basic_istringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;</a>, <a class="el" href="group__bslstl__ostringstream.html#ga8bcabce0ff45ba673e9c1321bb28aea9">bsl::basic_ostringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;</a>, and <a class="el" href="group__bslstl__stringstream.html#ga6edddecadc082deafa0dc22b8e612626">bsl::basic_stringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;</a>.</p>

<p>Referenced by <a class="el" href="group__bslstl__stringstream.html#ga6edddecadc082deafa0dc22b8e612626">bsl::basic_stringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rdbuf()</a>, <a class="el" href="group__bslstl__ostringstream.html#ga8bcabce0ff45ba673e9c1321bb28aea9">bsl::basic_ostringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rdbuf()</a>, and <a class="el" href="group__bslstl__istringstream.html#ga1f3188661e106d68232070a6fec2dbfe">bsl::basic_istringstream&lt; CHAR_TYPE, CHAR_TRAITS, ALLOCATOR &gt;::rdbuf()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
