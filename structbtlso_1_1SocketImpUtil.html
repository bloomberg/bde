<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct btlso::SocketImpUtil</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlso.html">btlso</a>      </li>
      <li><a class="el" href="structbtlso_1_1SocketImpUtil.html">btlso::SocketImpUtil</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>btlso::SocketImpUtil Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlso::SocketImpUtil" -->
<p><code>#include &lt;<a class="el" href="btlso__socketimputil_8h_source.html">btlso_socketimputil.h</a>&gt;</code></p>

<p><a href="structbtlso_1_1SocketImpUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">Type</a> { <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6aaece360fe0b1e6567973c9b1e51f9f963">k_SOCKET_STREAM</a> =  SOCK_STREAM, 
<a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6aa97f935810807283bfdd89897e9f77bf1">k_SOCKET_DATAGRAM</a> =  SOCK_DGRAM, 
<a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6aaf31223657196baffe24034491fa4dce6">k_SOCKET_RAW</a> =  SOCK_RAW
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7">ShutDownType</a> { <a class="el" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7a602cf2a31704a1ac70c0726a29648f23">e_SHUTDOWN_RECEIVE</a>, 
<a class="el" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7a18df818281682125dff63e68155e4004">e_SHUTDOWN_SEND</a>, 
<a class="el" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7ab8c652c9e5ada32da6eb143d8b389535">e_SHUTDOWN_BOTH</a>
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Indicates how to shut down the socket with <code>shutDown</code> operation. </p>
 <a href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#af25625ffa040b5bda669480b44b042c0">accept</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSocket, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#af6ad1877865457933ee260eebee0df86">accept</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSocket, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int *errorCode)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a1f03b8bc533788abec9e68ee71795779">accept</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSocket, ADDRESS *peerAddress, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a7f9e7da1143a34fb1e0ec7a8de564e45">accept</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSocket, ADDRESS *peerAddress, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int *errorCode)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a3b8e082ec68f6c61595081362f36cd01">bind</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const ADDRESS &amp;address)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a1ca7a3d1ac82fcbbd070bcbbae0db942">bind</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const ADDRESS &amp;address, int *errorCode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a6d2436f0b4ccf92c4609c89896b6dc63">cleanup</a> (int *errorCode=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a7325d5370d7aca579a1db09f81e56475">close</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int *errorCode=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5fa4886708b7cc7587e29fa14972bd41">connect</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const ADDRESS &amp;address)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a4d2b1cb06369a3eb56b6344bf444a8a6">connect</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const ADDRESS &amp;address, int *errorCode)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a38a631465d6f642a93bce20a472f8fe3">getLocalAddress</a> (ADDRESS *localAddress, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a8da1212285f54ad0fcffd75595063885">getLocalAddress</a> (ADDRESS *localAddress, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int *errorCode)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a504c9cea21fce08e048c1bcd6ee1035e">getPeerAddress</a> (ADDRESS *peerAddress, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a47174b96ef808b0bde8dd4929ad602c3">getPeerAddress</a> (ADDRESS *peerAddress, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int *errorCode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#ab532d5cb596d8362dc70d34dba65040e">listen</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int queueSize, int *errorCode=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a83b50e6dfe4ec0d68d1bf646795a63e6">open</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSocket, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a> type)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#ae052d520d37a4684f278549e340b35e4">open</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSocket, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a> type, int *errorCode)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#aa4be7e16e4e83be60b017560a804b49e">open</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSocket, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a> type, int protocol)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a47fd3edc158ddcb2d7b1afd204a6d92d">open</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSocket, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a> type, int protocol, int *errorCode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a153aa8f6c8c42dc5c8ac96ea2ddb5341">read</a> (void *buffer, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int numBytes, int *errorCode=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a3b00a92343c9e7f7a91f0b30e673d1f2">readFrom</a> (ADDRESS *fromAddress, void *buffer, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int numBytes)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a0dd6619030788c0a3968a2c5e3a746a4">readFrom</a> (ADDRESS *fromAddress, void *buffer, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int numBytes, int *errorCode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#accbc86f434f5b75de427c41e301bd05e">readv</a> (const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *iovec, const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, int numBuffs, int *errorCode=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a7b3741ff6d3d1a7b2723f717de76d146">socketPair</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSockets, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a> type)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a281cd0ce4bb480088548c1e58fc57ecb">socketPair</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSockets, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a> type, int *errorCode)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#ab673186c951e9941b94ff002d1fdb1b4">socketPair</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSockets, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a> type, int protocol)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a25b90dedba9b9935cfe685b4608d6108">socketPair</a> (<a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *newSockets, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a> type, int protocol, int *errorCode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a635e8ba101b004a75235e7e83d509b44">write</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const void *buffer, int numBytes, int *errorCode=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#aa9d45d50179c05c1661f477fc9e5af9e">writeTo</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const ADDRESS &amp;toAddress, const void *buffer, int numBytes)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#ad8330becf3ead07bb21f9f7487383ded">writeTo</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const ADDRESS &amp;toAddress, const void *buffer, int numBytes, int *errorCode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#aa9678b299d8d2d2b5a2e98772e0e3374">writev</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *ovec, int numBuffs, int *errorCode=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ADDRESS &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#ad22e3e455db6f0a3ce53cdc6fb04b18c">writevTo</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, const ADDRESS &amp;toAddress, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *ovec, int numBuffs, int *errorCode=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#ad0fe311b3f4f8409ace35cb491bac37a">shutDown</a> (const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;socket, <a class="el" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7">SocketImpUtil::ShutDownType</a> value, int *errorCode=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlso_1_1SocketImpUtil.html#ab899cc56fedaa558d3502e0351a8819f">startup</a> (int *errorCode=0)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a suite of platform-independent pure procedures that manipulate operating-system-level sockets. All methods take an <code>errorCode</code> as an optional parameter, which is loaded with platform-specific error number if an error occurs during the operation. All functions return a negative value on error. This value defined in <code><a class="el" href="structbtlso_1_1SocketHandle.html">SocketHandle</a></code> classifies the error and is not platform-specific. </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="a5a8a7feee2f57e1d05a5f9c6012d9c6a"></a><!-- doxytag: member="btlso::SocketImpUtil::Type" ref="a5a8a7feee2f57e1d05a5f9c6012d9c6a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">btlso::SocketImpUtil::Type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>When creating a socket with the <code>open</code> or <code>socketPair</code> operations, this indicates the type of socket(s) to be created. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a5a8a7feee2f57e1d05a5f9c6012d9c6aaece360fe0b1e6567973c9b1e51f9f963"></a><!-- doxytag: member="k_SOCKET_STREAM" ref="a5a8a7feee2f57e1d05a5f9c6012d9c6aaece360fe0b1e6567973c9b1e51f9f963" args="" -->k_SOCKET_STREAM</em>&nbsp;</td><td>
<p>Provides sequenced, reliable, two-way, connection-based byte streams. An out-of-band data transmission mechanism may be supported. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5a8a7feee2f57e1d05a5f9c6012d9c6aa97f935810807283bfdd89897e9f77bf1"></a><!-- doxytag: member="k_SOCKET_DATAGRAM" ref="a5a8a7feee2f57e1d05a5f9c6012d9c6aa97f935810807283bfdd89897e9f77bf1" args="" -->k_SOCKET_DATAGRAM</em>&nbsp;</td><td>
<p>Supports datagrams (connectionless, unreliable messages of a fixed maximum length). </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a5a8a7feee2f57e1d05a5f9c6012d9c6aaf31223657196baffe24034491fa4dce6"></a><!-- doxytag: member="k_SOCKET_RAW" ref="a5a8a7feee2f57e1d05a5f9c6012d9c6aaf31223657196baffe24034491fa4dce6" args="" -->k_SOCKET_RAW</em>&nbsp;</td><td>
<p>Provides raw network protocol access. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a28643b9454f79d1e7751753a81fc8ad7"></a><!-- doxytag: member="btlso::SocketImpUtil::ShutDownType" ref="a28643b9454f79d1e7751753a81fc8ad7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7">btlso::SocketImpUtil::ShutDownType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a28643b9454f79d1e7751753a81fc8ad7a602cf2a31704a1ac70c0726a29648f23"></a><!-- doxytag: member="e_SHUTDOWN_RECEIVE" ref="a28643b9454f79d1e7751753a81fc8ad7a602cf2a31704a1ac70c0726a29648f23" args="" -->e_SHUTDOWN_RECEIVE</em>&nbsp;</td><td>
<p>shut down the receive half of the full-duplex connection associated with the specified <code>socket</code>, leaving its send half unaffected. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a28643b9454f79d1e7751753a81fc8ad7a18df818281682125dff63e68155e4004"></a><!-- doxytag: member="e_SHUTDOWN_SEND" ref="a28643b9454f79d1e7751753a81fc8ad7a18df818281682125dff63e68155e4004" args="" -->e_SHUTDOWN_SEND</em>&nbsp;</td><td>
<p>shut down the send half of the full-duplex connection associated with the specified <code>socket</code>, leaving its receive half unaffected. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a28643b9454f79d1e7751753a81fc8ad7ab8c652c9e5ada32da6eb143d8b389535"></a><!-- doxytag: member="e_SHUTDOWN_BOTH" ref="a28643b9454f79d1e7751753a81fc8ad7ab8c652c9e5ada32da6eb143d8b389535" args="" -->e_SHUTDOWN_BOTH</em>&nbsp;</td><td>
<p>shut down both halves of the full-duplex connection associated with the specified <code>socket</code>. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="af25625ffa040b5bda669480b44b042c0"></a><!-- doxytag: member="btlso::SocketImpUtil::accept" ref="af25625ffa040b5bda669480b44b042c0" args="(SocketHandle::Handle *newSocket, const SocketHandle::Handle &amp;socket)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="af6ad1877865457933ee260eebee0df86"></a><!-- doxytag: member="btlso::SocketImpUtil::accept" ref="af6ad1877865457933ee260eebee0df86" args="(SocketHandle::Handle *newSocket, const SocketHandle::Handle &amp;socket, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept a connection request on the specified listening <code>socket</code>. On success, load the specified <code>newSocket</code> with the handle for the socket created for the newly established connection. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return 0 on success and a negative value otherwise representing an error classification. Note that if <code>socket</code> is in non-blocking mode and there is no pending connection request available, this call returns immediately with an error status, but if <code>socket</code> is in blocking mode, this call blocks until either it succeeds or an error occurs. Also note that, when created, <code>newSocket</code> has exactly the same socket options as <code>socket</code>. </p>

</div>
</div>
<a class="anchor" id="a1f03b8bc533788abec9e68ee71795779"></a><!-- doxytag: member="btlso::SocketImpUtil::accept" ref="a1f03b8bc533788abec9e68ee71795779" args="(SocketHandle::Handle *newSocket, ADDRESS *peerAddress, const SocketHandle::Handle &amp;socket)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>peerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f9e7da1143a34fb1e0ec7a8de564e45"></a><!-- doxytag: member="btlso::SocketImpUtil::accept" ref="a7f9e7da1143a34fb1e0ec7a8de564e45" args="(SocketHandle::Handle *newSocket, ADDRESS *peerAddress, const SocketHandle::Handle &amp;socket, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>peerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Accept a connection request on the specified listening <code>socket</code>. On success, load the specified <code>newSocket</code> with the handle for the socket created for the newly established connection, and also load the specified <code>peerAddress</code> with the address of the newly connected client. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. Note that if <code>socket</code> is in non-blocking mode and there is no pending connection request available, this call returns immediately with an error status, but if <code>socket</code> is in blocking mode, this call blocks until either it succeeds or an error occurs. Also note that, when created, <code>newSocket</code> has exactly the same socket options as <code>socket</code>. If a connection has been closed before the accept call is made, the call may fail and <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debcae59989ad2ee76ca0439e2e0ed1172481">SocketHandle::e_ERROR_CONNDEAD</a></code> will be returned. </p>

</div>
</div>
<a class="anchor" id="a3b8e082ec68f6c61595081362f36cd01"></a><!-- doxytag: member="btlso::SocketImpUtil::bind" ref="a3b8e082ec68f6c61595081362f36cd01" args="(const SocketHandle::Handle &amp;socket, const ADDRESS &amp;address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1ca7a3d1ac82fcbbd070bcbbae0db942"></a><!-- doxytag: member="btlso::SocketImpUtil::bind" ref="a1ca7a3d1ac82fcbbd070bcbbae0db942" args="(const SocketHandle::Handle &amp;socket, const ADDRESS &amp;address, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::bind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate the specified <code>address</code> with the specified <code>socket</code>. Load the optionally specified <code>errorCode</code> with a platform-specific error number on error. Return 0 on success and a negative value otherwise representing an error classification. Note that (a) typically, servers call <code>bind</code> with a well-known port number since they are known by their port numbers, and (b) typically, stream based clients allow the kernel to choose a temporary (ephemeral) port by not invoking this operation at all. Note also that a port number 0 can be specified so that an address can be bound to a socket without binding a specific port number. </p>

</div>
</div>
<a class="anchor" id="a6d2436f0b4ccf92c4609c89896b6dc63"></a><!-- doxytag: member="btlso::SocketImpUtil::cleanup" ref="a6d2436f0b4ccf92c4609c89896b6dc63" args="(int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::cleanup </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clean up the environment created for sockets-based activity. All open sockets should be explicitly closed prior to this operation. No assumptions should be made about the state of any remaining open socket after this operation. Load the optionally specified <code>errorCode</code> with a platform-specific error number on error. Return 0 on success and a negative value otherwise representing an error classification. </p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocketFactory.html#a1020511098b83fad39d9b9678e535c71">btlso::InetStreamSocketFactory&lt; ADDRESS &gt;::~InetStreamSocketFactory()</a>.</p>

</div>
</div>
<a class="anchor" id="a7325d5370d7aca579a1db09f81e56475"></a><!-- doxytag: member="btlso::SocketImpUtil::close" ref="a7325d5370d7aca579a1db09f81e56475" args="(const SocketHandle::Handle &amp;socket, int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::close </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the specified <code>socket</code> and release all the resources associated with it. If this socket is the last reference to an existing connection, this connection will be terminated. Load the optionally specified <code>errorCode</code> with a platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. Note that although call to <code>close</code> returns immediately, by default, the kernel tries to send all untransmitted data before actually closing the connection. This default behavior can be altered by changing the socket linger options (see btlso_socketoptutil). </p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocketFactory.html#a0d04e0214dc3075539e9b318120274ca">btlso::InetStreamSocketFactory&lt; ADDRESS &gt;::deallocate()</a>, and <a class="el" href="classbtlso_1_1InetStreamSocketCloseGuard.html#a1a8aba37c13569622391cee7989eb635">btlso::InetStreamSocketCloseGuard::~InetStreamSocketCloseGuard()</a>.</p>

</div>
</div>
<a class="anchor" id="a5fa4886708b7cc7587e29fa14972bd41"></a><!-- doxytag: member="btlso::SocketImpUtil::connect" ref="a5fa4886708b7cc7587e29fa14972bd41" args="(const SocketHandle::Handle &amp;socket, const ADDRESS &amp;address)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4d2b1cb06369a3eb56b6344bf444a8a6"></a><!-- doxytag: member="btlso::SocketImpUtil::connect" ref="a4d2b1cb06369a3eb56b6344bf444a8a6" args="(const SocketHandle::Handle &amp;socket, const ADDRESS &amp;address, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>For a stream type socket, connect the specified <code>socket</code> with the server process listening at the specified <code>address</code>. Load the optionally specified <code>errorCode</code> with a platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. If the socket is in blocking mode, the call will block until the connection is established or an error occurs. If the socket is in non-blocking mode, the call may complete immediately returning <code><a class="el" href="structbtlso_1_1SocketHandle.html#a2e562725b56a850d6da4fa52f548debca72ca55a2add5ff8bab4c88b90b758a97">SocketHandle::e_ERROR_WOULDBLOCK</a></code> indicating that the operation has been initiated but may not have completed. In this case the <code>select</code> function can be used to determine when the connection has completed. For a datagram socket, associate the specified <code>address</code> with the specified <code>socket</code>. If no address is specified for a send operation, the specified <code>address</code> is used. For receive operations, only data from the specified <code>address</code> is received. </p>

</div>
</div>
<a class="anchor" id="a38a631465d6f642a93bce20a472f8fe3"></a><!-- doxytag: member="btlso::SocketImpUtil::getLocalAddress" ref="a38a631465d6f642a93bce20a472f8fe3" args="(ADDRESS *localAddress, const SocketHandle::Handle &amp;socket)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::getLocalAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>localAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a8da1212285f54ad0fcffd75595063885"></a><!-- doxytag: member="btlso::SocketImpUtil::getLocalAddress" ref="a8da1212285f54ad0fcffd75595063885" args="(ADDRESS *localAddress, const SocketHandle::Handle &amp;socket, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::getLocalAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>localAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load the local address and port number associated with the specified <code>socket</code> in the specified <code>localAddress</code>. The result is undefined if the socket was not initially created with the specified ADDRESS type. Load the optionally specified <code>errorCode</code> with a platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. </p>

</div>
</div>
<a class="anchor" id="a504c9cea21fce08e048c1bcd6ee1035e"></a><!-- doxytag: member="btlso::SocketImpUtil::getPeerAddress" ref="a504c9cea21fce08e048c1bcd6ee1035e" args="(ADDRESS *peerAddress, const SocketHandle::Handle &amp;socket)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::getPeerAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>peerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a47174b96ef808b0bde8dd4929ad602c3"></a><!-- doxytag: member="btlso::SocketImpUtil::getPeerAddress" ref="a47174b96ef808b0bde8dd4929ad602c3" args="(ADDRESS *peerAddress, const SocketHandle::Handle &amp;socket, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::getPeerAddress </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>peerAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load the specified <code>peerAddress</code> with the address and port number of the peer connected to the specified <code>socket</code>. Load the optionally specified <code>errorCode</code> with a platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. </p>

</div>
</div>
<a class="anchor" id="ab532d5cb596d8362dc70d34dba65040e"></a><!-- doxytag: member="btlso::SocketImpUtil::listen" ref="ab532d5cb596d8362dc70d34dba65040e" args="(const SocketHandle::Handle &amp;socket, int queueSize, int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::listen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>queueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Listen passively to the incoming connection requests on the specified stream <code>socket</code>. Also set the maximum number of pending connection requests to be queued before "accepted" to the specified <code>queueSize</code>. If the backlog value is (system dependent) <code>SOMAXCONN</code>, then the backlog will be set to the maximum "reasonable" value. There is no standard provision to find out the actual backlog value. Load the optionally specified <code>errorCode</code> with a platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. The behavior is undefined unless <code>0 &lt; queueSize</code>. </p>

</div>
</div>
<a class="anchor" id="a83b50e6dfe4ec0d68d1bf646795a63e6"></a><!-- doxytag: member="btlso::SocketImpUtil::open" ref="a83b50e6dfe4ec0d68d1bf646795a63e6" args="(SocketHandle::Handle *newSocket, SocketImpUtil::Type type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ae052d520d37a4684f278549e340b35e4"></a><!-- doxytag: member="btlso::SocketImpUtil::open" ref="ae052d520d37a4684f278549e340b35e4" args="(SocketHandle::Handle *newSocket, SocketImpUtil::Type type, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the specified <code>newSocket</code> with a newly created socket of the specified <code>type</code>. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. </p>

</div>
</div>
<a class="anchor" id="aa4be7e16e4e83be60b017560a804b49e"></a><!-- doxytag: member="btlso::SocketImpUtil::open" ref="aa4be7e16e4e83be60b017560a804b49e" args="(SocketHandle::Handle *newSocket, SocketImpUtil::Type type, int protocol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a47fd3edc158ddcb2d7b1afd204a6d92d"></a><!-- doxytag: member="btlso::SocketImpUtil::open" ref="a47fd3edc158ddcb2d7b1afd204a6d92d" args="(SocketHandle::Handle *newSocket, SocketImpUtil::Type type, int protocol, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the specified <code>newSocket</code> with a newly created socket of the specified <code>type</code> and the specified <code>protocol</code>. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. </p>

</div>
</div>
<a class="anchor" id="a153aa8f6c8c42dc5c8ac96ea2ddb5341"></a><!-- doxytag: member="btlso::SocketImpUtil::read" ref="a153aa8f6c8c42dc5c8ac96ea2ddb5341" args="(void *buffer, const SocketHandle::Handle &amp;socket, int numBytes, int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::read </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive up to a maximum of the specified <code>numBytes</code> bytes from the specified <code>socket</code> in the specified <code>buffer</code>. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return the non-negative number of bytes read on success, 0 on EOF (when <code>0 &lt; numBytes</code>), and a negative value otherwise representing an error classification. The behavior is undefined unless <code>0 &lt;= numBytes</code> and <code>buffer</code> refers to at least <code>numBytes</code> valid memory locations. Note that if <code>socket</code> is in blocking mode, this call blocks until (a) data is read, (b) an EOF indication occurs, or (c) an error occurs. Note that if <code>numBytes</code> is 0, this call returns immediately, with no effect on <code>buffer</code>. </p>

</div>
</div>
<a class="anchor" id="a3b00a92343c9e7f7a91f0b30e673d1f2"></a><!-- doxytag: member="btlso::SocketImpUtil::readFrom" ref="a3b00a92343c9e7f7a91f0b30e673d1f2" args="(ADDRESS *fromAddress, void *buffer, const SocketHandle::Handle &amp;socket, int numBytes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::readFrom </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>fromAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0dd6619030788c0a3968a2c5e3a746a4"></a><!-- doxytag: member="btlso::SocketImpUtil::readFrom" ref="a0dd6619030788c0a3968a2c5e3a746a4" args="(ADDRESS *fromAddress, void *buffer, const SocketHandle::Handle &amp;socket, int numBytes, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::readFrom </td>
          <td>(</td>
          <td class="paramtype">ADDRESS *&nbsp;</td>
          <td class="paramname"> <em>fromAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive up to a maximum of the specified <code>numBytes</code> bytes from the specified <code>socket</code> in the specified <code>buffer</code> and load the address and port number of the source of the data in <code>fromAddress</code>. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return the non-negative number of bytes read on success, 0 on EOF or when <code>0 == numBytes</code>, and a negative value otherwise representing an error classification. The <code>socket</code> must not be connected. The <code>fromAddress</code> parameter will be ignored for connection-oriented sockets. For message-oriented sockets data is extracted from the first enqueued message, up to the size of <code>buffer</code>. If the datagram or message is larger than the buffer, it is filled with the first part of the datagram, and an error is generated. For unreliable protocols (e.g., UDP) the excess data is lost. The behavior is undefined unless <code>0 &lt;= numBytes</code> and <code>buffer</code> refers to at least <code>numBytes</code> valid memory locations. Note that if <code>socket</code> is in blocking mode, this call blocks until (a) data is read, (b) an EOF indication occurs, or (c) an error occurs. Note also that if <code>numBytes</code> is 0, this call returns immediately, with no effect on <code>buffer</code>. </p>

</div>
</div>
<a class="anchor" id="accbc86f434f5b75de427c41e301bd05e"></a><!-- doxytag: member="btlso::SocketImpUtil::readv" ref="accbc86f434f5b75de427c41e301bd05e" args="(const btls::Iovec *iovec, const SocketHandle::Handle &amp;socket, int numBuffs, int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::readv </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> *&nbsp;</td>
          <td class="paramname"> <em>iovec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Receive from the specified <code>socket</code> into the buffers specified by <code>iovec</code> where the specified <code>numBuffs</code> is the number of buffers. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return the non-negative number of bytes read on success, 0 on EOF or when <code>0 == numBytes</code>, and a negative value otherwise representing an error classification. The behavior is undefined unless <code>0 &lt; numBuffs</code> and <code>iovec</code> refers to buffers at valid memory locations. Note that if <code>socket</code> is in blocking mode, this call blocks until (a) data is read, (b) an EOF indication occurs, or (c) an error occurs. </p>

</div>
</div>
<a class="anchor" id="a7b3741ff6d3d1a7b2723f717de76d146"></a><!-- doxytag: member="btlso::SocketImpUtil::socketPair" ref="a7b3741ff6d3d1a7b2723f717de76d146" args="(SocketHandle::Handle *newSockets, SocketImpUtil::Type type)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::socketPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSockets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a281cd0ce4bb480088548c1e58fc57ecb"></a><!-- doxytag: member="btlso::SocketImpUtil::socketPair" ref="a281cd0ce4bb480088548c1e58fc57ecb" args="(SocketHandle::Handle *newSockets, SocketImpUtil::Type type, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::socketPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSockets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a pair of connected sockets of the specified <code>type</code>. On success, the specified <code>newSockets</code> will point to the handles for the new sockets. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. </p>

</div>
</div>
<a class="anchor" id="ab673186c951e9941b94ff002d1fdb1b4"></a><!-- doxytag: member="btlso::SocketImpUtil::socketPair" ref="ab673186c951e9941b94ff002d1fdb1b4" args="(SocketHandle::Handle *newSockets, SocketImpUtil::Type type, int protocol)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::socketPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSockets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>protocol</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a25b90dedba9b9935cfe685b4608d6108"></a><!-- doxytag: member="btlso::SocketImpUtil::socketPair" ref="a25b90dedba9b9935cfe685b4608d6108" args="(SocketHandle::Handle *newSockets, SocketImpUtil::Type type, int protocol, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::socketPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> *&nbsp;</td>
          <td class="paramname"> <em>newSockets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a5a8a7feee2f57e1d05a5f9c6012d9c6a">SocketImpUtil::Type</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>protocol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a pair of connected sockets of the specified <code>type</code> and <code>protocol</code>. On success, the specified <code>newSockets</code> will point to the handles for the new sockets. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. The behavior is undefined unless <code>newSockets</code> refers to at least 2 writable memory locations. </p>

</div>
</div>
<a class="anchor" id="a635e8ba101b004a75235e7e83d509b44"></a><!-- doxytag: member="btlso::SocketImpUtil::write" ref="a635e8ba101b004a75235e7e83d509b44" args="(const SocketHandle::Handle &amp;socket, const void *buffer, int numBytes, int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::write </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send up to a maximum of the specified <code>numBytes</code> bytes using the specified <code>socket</code> from the specified <code>buffer</code>. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return the non-negative number of bytes written on success, and a negative value otherwise representing an error classification. The behavior is undefined unless <code>0 &lt;= numBytes</code> and <code>buffer</code> refers to at least <code>numBytes</code> valid memory locations. Note that if <code>socket</code> is in blocking mode, this call blocks until either data is written or an error occurs. </p>

</div>
</div>
<a class="anchor" id="aa9d45d50179c05c1661f477fc9e5af9e"></a><!-- doxytag: member="btlso::SocketImpUtil::writeTo" ref="aa9d45d50179c05c1661f477fc9e5af9e" args="(const SocketHandle::Handle &amp;socket, const ADDRESS &amp;toAddress, const void *buffer, int numBytes)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::writeTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>toAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8330becf3ead07bb21f9f7487383ded"></a><!-- doxytag: member="btlso::SocketImpUtil::writeTo" ref="ad8330becf3ead07bb21f9f7487383ded" args="(const SocketHandle::Handle &amp;socket, const ADDRESS &amp;toAddress, const void *buffer, int numBytes, int *errorCode)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::writeTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>toAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send up to a maximum of the specified <code>numBytes</code> bytes using the specified <code>socket</code> from the specified <code>buffer</code> to the destination described by the specified <code>toAddress</code>. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return the non-negative number of bytes written on success, and a negative value otherwise representing an error classification. If <code>socket</code> is a connectionless socket that had previously been connected to a specific destination, the <code>toAddress</code> will override the destination (if different) for this call only. If <code>socket</code> is a connection-oriented socket, <code>toAddress</code> are ignored, making the function equivalent to <code>write</code>. For message-oriented sockets, care must be taken not to exceed the maximum packet size of the underlying subnets; if the data is too long to pass atomically through the underlying protocol, an error indication will be returned and no data will be sent. The behavior is undefined unless <code>0 &lt;= numBytes</code> and <code>buffer</code> refers to at least <code>numBytes</code> valid memory locations. Note that if <code>socket</code> is in blocking mode, this call blocks until either data is written or an error occurs. Note also that if <code>numBytes</code> is 0, this call returns immediately. </p>

</div>
</div>
<a class="anchor" id="aa9678b299d8d2d2b5a2e98772e0e3374"></a><!-- doxytag: member="btlso::SocketImpUtil::writev" ref="aa9678b299d8d2d2b5a2e98772e0e3374" args="(const SocketHandle::Handle &amp;socket, const btls::Ovec *ovec, int numBuffs, int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::writev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>ovec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send to the specified <code>socket</code> from the buffers specified by <code>ovec</code> where <code>numBuffs</code> is the number of buffers. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return the non-negative number of bytes written on success, and a negative value otherwise representing an error classification. The behavior is undefined unless <code>0 &lt; numBuffs</code> and <code>iovec</code> refers to buffers at valid writable memory locations. Note that if <code>socket</code> is in blocking mode, this call blocks until either data is written or an error occurs. </p>

</div>
</div>
<a class="anchor" id="ad22e3e455db6f0a3ce53cdc6fb04b18c"></a><!-- doxytag: member="btlso::SocketImpUtil::writevTo" ref="ad22e3e455db6f0a3ce53cdc6fb04b18c" args="(const SocketHandle::Handle &amp;socket, const ADDRESS &amp;toAddress, const btls::Ovec *ovec, int numBuffs, int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ADDRESS &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::writevTo </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ADDRESS &amp;&nbsp;</td>
          <td class="paramname"> <em>toAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> *&nbsp;</td>
          <td class="paramname"> <em>ovec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBuffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Send to the specified <code>socket</code> from the buffers specified by <code>ovec</code> where <code>numBuffs</code> is the number of buffers to the destination described by the specified <code>toAddress</code>. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return the non-negative number of bytes written on success and a negative value otherwise representing an error classification. For message-oriented sockets, care must be taken not to exceed the maximum packet size of the underlying subnets; if the data is too long to pass atomically through the underlying protocol, an error indication will be returned and no data will be sent. The behavior is undefined unless the specified <code>socket</code> is not connected, <code>0 &lt; numBuffs</code> and <code>iovec</code> refers to buffers at valid writable memory locations. Note that if <code>socket</code> is in blocking mode, this call blocks until either data is written or an error occurs. </p>

</div>
</div>
<a class="anchor" id="ad0fe311b3f4f8409ace35cb491bac37a"></a><!-- doxytag: member="btlso::SocketImpUtil::shutDown" ref="ad0fe311b3f4f8409ace35cb491bac37a" args="(const SocketHandle::Handle &amp;socket, SocketImpUtil::ShutDownType value, int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::shutDown </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structbtlso_1_1SocketHandle.html#a92cfe6067b84ee5301cc25d0f1a80a11">SocketHandle::Handle</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1SocketImpUtil.html#a28643b9454f79d1e7751753a81fc8ad7">SocketImpUtil::ShutDownType</a>&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shutdown the specified send and/or receive direction of the full-duplexed connection associated with this socket. Return 0 on success, and a non-zero value otherwise representing an error classification. A <code>value</code> of <code>e_SHUTDOWN_RECEIVE</code> or <code>e_SHUTDOWN_SEND</code> will close the receive or send stream, respectively, leaving the other stream unaffected. A <code>value</code> of <code>e_SHUTDOWN_BOTH</code> will close both. Once the receive(send) stream has been closed, any attempted read(write) operations will fail. Any data received after successfully shutting down the receive stream will be acknowledged but silently discarded. Note that this function is typically used to transmit an EOF indication to the peer. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. </p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocket.html#aca27775f1d7b9c93b84b0d853b2c682d">btlso::InetStreamSocket&lt; ADDRESS &gt;::shutdown()</a>.</p>

</div>
</div>
<a class="anchor" id="ab899cc56fedaa558d3502e0351a8819f"></a><!-- doxytag: member="btlso::SocketImpUtil::startup" ref="ab899cc56fedaa558d3502e0351a8819f" args="(int *errorCode=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int btlso::SocketImpUtil::startup </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>errorCode</em> = <code>0</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize the environment for sockets-based activity. Load the optionally specified <code>errorCode</code> with the platform-specific error number on error. Return 0 on success, and a negative value otherwise representing an error classification. </p>

<p>Referenced by <a class="el" href="classbtlso_1_1InetStreamSocketFactory.html#a8529814160d7d6f1e71c1369b51b821a">btlso::InetStreamSocketFactory&lt; ADDRESS &gt;::InetStreamSocketFactory()</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="btlso__socketimputil_8h_source.html">btlso_socketimputil.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:15 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
