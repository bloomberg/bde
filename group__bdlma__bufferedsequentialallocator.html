<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bdlma_bufferedsequentialallocator Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlma_bufferedsequentialallocator<br/>
<small>
[<a class="el" href="group__bdlma.html">Package bdlma</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an efficient managed allocator using an external buffer.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlma.html">bdlma</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
&nbsp; <ul>
<li>
<a href="#3.0.1">Optional <code>maxBufferSize</code> Parameter</a> </li>
</ul>
</li>
<li>
<a href="#3.1">Warning</a> </li>
<li>
<a href="#3.2">Usage</a> <ul>
<li>
<a href="#3.2.1">Example 1: Using <code>bdlma::BufferedSequentialAllocator</code> with Exact Calculation</a> </li>
<li>
<a href="#3.2.2">Example 2: Using <code>bdlma::BufferedSequentialAllocator</code> with Fallback</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an efficient managed allocator using an external buffer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a> </td><td>allocator using an external buffer  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlma__bufferedsequentialpool.html" title="Provide sequential memory using an external buffer and a fallback.">Component bdlma_bufferedsequentialpool</a>, <a class="el" href="group__bdlma__sequentialallocator.html" title="Provide a managed allocator using dynamically-allocated buffers.">Component bdlma_sequentialallocator</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a concrete mechanism, <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code>, that implements the <code><a class="el" href="classbdlma_1_1ManagedAllocator.html">bdlma::ManagedAllocator</a></code> protocol to very efficiently allocate heterogeneous memory blocks (of varying, user-specified sizes) from an external buffer supplied at construction: <br/>
<br/>
<div class="fragment"><pre class="fragment">   ,----------------------------------.
  ( <a class="code" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a> )
   `----------------------------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                   |        ctor/dtor</span>
<span class="stringliteral">                   |</span>
<span class="stringliteral">                   V</span>
<span class="stringliteral">       ,-----------------------.</span>
<span class="stringliteral">      ( bdlma::ManagedAllocator )</span>
<span class="stringliteral">       `-----------------------&#39;</span>
                   |        release
                   V
          ,----------------.
         ( <a class="code" href="classbslma_1_1Allocator.html">bslma::Allocator</a> )
          `----------------<span class="stringliteral">&#39;</span>
<span class="stringliteral">                            allocate</span>
<span class="stringliteral">                            deallocate</span>
</pre></div><br/>
<br/>
 If an allocation request exceeds the remaining free memory space in the external buffer, the allocator will fall back to a sequence of dynamically-allocated buffers. Users can optionally specify a growth strategy at construction that governs the growth rate of the dynamically-allocated buffers. If no growth strategy is specified at construction, geometric growth is used. Users can also optionally specify an alignment strategy at construction that governs the alignment of allocated memory blocks. If no alignment strategy is specified at construction, natural alignment is used. The <code>release</code> method releases all memory allocated through the allocator, as does the destructor. Note that, even though a <code>deallocate</code> method is available, it has no effect: Individually allocated memory blocks cannot be separately deallocated. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code> is typically used when users have a reasonable estimation of the amount of memory needed. This amount of memory would typically be created directly on the program stack, and used as the initial external buffer of the allocator for very fast memory allocation. While the buffer has sufficient capacity, memory allocations using the pool will not trigger <em>any</em> dynamic memory allocation, will have optimal locality of reference, and will not require deallocation upon destruction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once the external buffer is exhausted, subsequent allocation requests require dynamic memory allocation, and the performance of the allocator degrades. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The main difference between a <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code> and a <code><a class="el" href="classbdlma_1_1BufferedSequentialPool.html">bdlma::BufferedSequentialPool</a></code> is that, very often, the allocator is maintained through a <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a></code> pointer - hence, every call to <code>allocate</code> is a virtual function call, which is slower than invoking <code>allocate</code> with the pool directly. However, the allocator interface is much more widely accepted across objects, and hence more general purpose. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="optional_maxbuffersize_parameter"></a> <a class="anchor" id=".optional_maxbuffersize_parameter"></a> <a class="anchor" id="description..optional_maxbuffersize_parameter"></a> <a class="anchor" id="3.0.1"></a> </dd></dl>
<dl class="user"><dt><b>Optional maxBufferSize Parameter: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An optional <code>maxBufferSize</code> parameter can be supplied at construction to specify the maximum size (in bytes) of the dynamically-allocated buffers for geometric growth. Once the internal buffer grows up to the <code>maxBufferSize</code>, further requests that exceed this size will be served by a separate memory block instead of the internal buffer. The behavior is undefined unless <code>size &lt;= maxBufferSize</code>, where <code>size</code> is the extent (in bytes) of the external buffer supplied at construction. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="warning"></a> <a class="anchor" id="description.warning"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Warning: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that, even when a buffer having <code>n</code> bytes of memory is supplied at construction, it does <em>not</em> mean that <code>n</code> bytes of memory are available before dynamic memory allocation is triggered. This is due to memory alignment requirements. If the buffer supplied is not aligned, the first call to the <code>allocate</code> method will automatically skip one or more bytes such that the memory allocated is properly aligned. The number of bytes that are wasted depends on whether natural alignment, maximum alignment, or 1-byte alignment is used (see <code>bsls_alignment</code> for more details). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_using_bdlma~3A~3Abufferedsequentialallocator_with_exact_calculation"></a> <a class="anchor" id="usage.example_1~3A_using_bdlma~3A~3Abufferedsequentialallocator_with_exact_calculation"></a> <a class="anchor" id="description.usage.example_1~3A_using_bdlma~3A~3Abufferedsequentialallocator_with_exact_calculation"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.2.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Using bdlma::BufferedSequentialAllocator with Exact Calculation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we need to implement a method, <code>calculate</code>, that performs calculations (where the specifics are not important to illustrate the use of this component), which require three vectors of <code>double</code> values. Furthermore, suppose we know that we need to store at most 100 values for each vector: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">double</span> calculate(<span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;double&gt;</a>&amp; data)
  {
</pre></div><br/>
<br/>
 Since the amount of memory needed is known in advance, we can optimize the memory allocation by using a <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code> to supply memory for the vectors. We can also prevent the vectors from resizing (which triggers more allocations) by reserving for the specific capacity we need: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keyword">enum</span> { SIZE = 3 * 100 * <span class="keyword">sizeof</span>(double) };
</pre></div><br/>
<br/>
 In the above calculation, we assume that the only memory allocation requested by the vector is the allocation for the array that stores the <code>double</code> values. Furthermore, we assume that the <code>reserve</code> method allocates the exact amount of memory for the number of items specified (in this case, of type <code>double</code>). Note that both of these assumptions are true for BDE's implementation of <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To avoid alignment issues described in the "Warning" section (above), we create a <code><a class="el" href="classbsls_1_1AlignedBuffer.html">bsls::AlignedBuffer</a></code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <a class="code" href="classbsls_1_1AlignedBuffer.html">bsls::AlignedBuffer&lt;SIZE&gt;</a> bufferStorage;

      <a class="code" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a> alloc(bufferStorage.<a class="code" href="classbsls_1_1AlignedBuffer.html#a46dbd83076424915a6cab625e2088ca4">buffer</a>(), SIZE);

      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;double&gt;</a> v1(&amp;alloc);     v1.reserve(100);
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;double&gt;</a> v2(&amp;alloc);     v2.reserve(100);
      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;double&gt;</a> v3(&amp;alloc);     v3.reserve(100);

      <span class="comment">// ...</span>
  }
</pre></div><br/>
<br/>
 By making use of a <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code>, <em>all</em> dynamic memory allocation is eliminated in the above example. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_bdlma~3A~3Abufferedsequentialallocator_with_fallback"></a> <a class="anchor" id="usage.example_2~3A_using_bdlma~3A~3Abufferedsequentialallocator_with_fallback"></a> <a class="anchor" id="description.usage.example_2~3A_using_bdlma~3A~3Abufferedsequentialallocator_with_fallback"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.2.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using bdlma::BufferedSequentialAllocator with Fallback: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we are receiving updates for price quotes for a list of securities through the following function: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> receivePriceQuotes(<a class="code" href="classbsl_1_1map.html">bsl::map&lt;bsl::string, double&gt;</a> *updateMap);
      <span class="comment">// Load into the specified &#39;updateMap&#39; updates for price quotes for a</span>
      <span class="comment">// list of securities.</span>
</pre></div><br/>
<br/>
 Furthermore, suppose the number of securities we are interested in is limited. We can then use a <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code> to optimize memory allocation for the <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code>. We first create a buffer on the stack: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">enum</span> {
      NUM_SECURITIES = 100,

      TREE_NODE_SIZE = <span class="keyword">sizeof</span>(<a class="code" href="classbsl_1_1pair.html">bsl::map&lt;bsl::string, double&gt;::value_type</a>)
                       + <span class="keyword">sizeof</span>(<span class="keywordtype">void</span> *) * 4,

      AVERAGE_SECURITY_LENGTH = 5,

      TOTAL_SIZE = NUM_SECURITIES *
                   (TREE_NODE_SIZE + AVERAGE_SECURITY_LENGTH )
  };

  <a class="code" href="classbsls_1_1AlignedBuffer.html">bsls::AlignedBuffer&lt;TOTAL_SIZE&gt;</a> bufferStorage;
</pre></div><br/>
<br/>
 The calculation of the amount of memory needed is just an estimate, as we used the average security size instead of the maximum security size. We also assume that a <code><a class="el" href="classbsl_1_1map.html">bsl::map</a></code>s node size is roughly the size of 4 pointers. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a> bsa(bufferStorage.buffer(), TOTAL_SIZE);
  <a class="code" href="classbsl_1_1map.html">bsl::map&lt;bsl::string, double&gt;</a> updateMap(&amp;bsa);

  receivePriceQuotes(&amp;updateMap);
</pre></div><br/>
<br/>
 With the use of a <code><a class="el" href="classbdlma_1_1BufferedSequentialAllocator.html">bdlma::BufferedSequentialAllocator</a></code>, we can be reasonably assured that the memory allocation performance is optimized (i.e., minimal use of dynamic allocation). </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:19 for BDE Release 2.23.1 Open-Source by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
