<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bsls_atomicoperations_arm_all_gcc.h                                -*-C++-*-
#ifndef INCLUDED_BSLS_ATOMICOPERATIONS_ARM_ALL_GCC
#define INCLUDED_BSLS_ATOMICOPERATIONS_ARM_ALL_GCC

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide implementations of atomic operations for ARM/GCC.
//
//@CLASSES:
//  bsls::AtomicOperations_ARM_ALL_GCC: implementation of atomics for ARM/GCC.
//
//@DESCRIPTION: This component provides classes necessary to implement atomics
// on the Linux ARM platform with GCC.  The classes are for private use only.
// See &#39;bsls_atomicoperations&#39; and &#39;bsls_atomic&#39; for the public interface to
// atomics.
//
// IMPLEMENTATION NOTES: Wherever possible we use atomic intrinsics that both
// GCC 4.6+ and Clang 3.2+ support.  Otherwise the inline assembly code is
// used that can be compiled both by GCC and Clang.  This puts some
// restrictions on the assembly code because Clang doesn&#39;t support register
// pairs that represent a 64bit value.  So instead of &#39;ldrexd %1, %H1, [%3]&#39;
// the exact registers have to be specified, as in &#39;ldrexd r2, r3, [%3]&#39;.  Note
// also that operations like &#39;ldrexd&#39; and &#39;stdrexd&#39; are supported only starting
// from &#39;armv6zk&#39;, so not every armv6 platform will work.
//
// For more details on ARM atomic pritives see the Linux kernel source code
// (arch/arm/include/asm/atomic.h) and the &quot;C/C++11 mappings to processors&quot;
// (http://www.cl.cam.ac.uk/~pes20/cpp/cpp0xmappings.html), and the
// &quot;ARM1156T2F-S Technical Reference Manual&quot;
// (http://infocenter.arm.com/help/index.jsp?
// topic=/com.arm.doc.ddi0290g/Babebdcb.html), which contains documentation on
// the p15 coprocessor opcodes used in this component).

#ifndef INCLUDED_BSLS_ATOMICOPERATIONS_DEFAULT
#include &lt;bsls_atomicoperations_default.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#if defined(BSLS_PLATFORM_CPU_ARM) \
    &amp;&amp; (defined(BSLS_PLATFORM_CMP_GNU) || defined(BSLS_PLATFORM_CMP_CLANG))

namespace BloombergLP {

namespace bsls {

struct AtomicOperations_ARM_ALL_GCC;
typedef AtomicOperations_ARM_ALL_GCC  AtomicOperations_Imp;

           // ======================================================
           // struct Atomic_TypeTraits&lt;AtomicOperations_ARM_ALL_GCC&gt;
           // ======================================================

template &lt;&gt;
struct Atomic_TypeTraits&lt;AtomicOperations_ARM_ALL_GCC&gt;
{
    struct Int
    {
        volatile int d_value __attribute__((__aligned__(sizeof(int))));
    };

    struct Int64
    {
        volatile Types::Int64 d_value
                       __attribute__((__aligned__(sizeof(Types::Int64))));
    };

    struct Pointer
    {
        void * volatile d_value __attribute__((__aligned__(sizeof(void *))));
    };
};

                     // ===================================
                     // struct AtomicOperations_ARM_ALL_GCC
                     // ===================================

struct AtomicOperations_ARM_ALL_GCC
    : AtomicOperations_Default32&lt;AtomicOperations_ARM_ALL_GCC&gt;
{
private:
    // PRIVATE TYPES
    struct Int64_Words {
        int w1;
        int w2;
    };

public:
    typedef Atomic_TypeTraits&lt;AtomicOperations_ARM_ALL_GCC&gt; AtomicTypes;

        // *** atomic functions for int ***

    static int getInt(const AtomicTypes::Int *atomicInt);

    static int getIntAcquire(const AtomicTypes::Int *atomicInt);

    static void setInt(AtomicTypes::Int *atomicInt, int value);

    static void setIntRelease(AtomicTypes::Int *atomicInt, int value);

    static int swapInt(AtomicTypes::Int *atomicInt, int swapValue);

    static int testAndSwapInt(AtomicTypes::Int *atomicInt,
                              int compareValue,
                              int swapValue);

    static int addIntNv(AtomicTypes::Int *atomicInt, int value);

        // *** atomic functions for Int64 ***

    static Types::Int64 getInt64(const AtomicTypes::Int64 *atomicInt);

    static void setInt64(AtomicTypes::Int64 *atomicInt, Types::Int64 value);

    static Types::Int64 swapInt64(AtomicTypes::Int64  *atomicInt,
                                  Types::Int64 swapValue);

    static Types::Int64 testAndSwapInt64(AtomicTypes::Int64 *atomicInt,
                                         Types::Int64 compareValue,
                                         Types::Int64 swapValue);

    static Types::Int64 addInt64Nv(AtomicTypes::Int64 *atomicInt,
                                   Types::Int64 value);
};

// ===========================================================================
//                        INLINE FUNCTION DEFINITIONS
// ===========================================================================

                     // -----------------------------------
                     // struct AtomicOperations_ARM_ALL_GCC
                     // -----------------------------------

#if BSLS_PLATFORM_CMP_VERSION &lt; 40700
#   if defined(BSLS_PLATFORM_CPU_ARM_V7)

#       define BSLS_ATOMICOPERATIONS_BARRIER()          \
            asm volatile (&quot;dmb&quot; ::: &quot;memory&quot;)           \

#       define BSLS_ATOMICOPERATIONS_INSTR_BARRIER()    \
            asm volatile (&quot;isb&quot;)                        \

#   else

#       define BSLS_ATOMICOPERATIONS_BARRIER()                      \
            do {                                                    \
                int temp_reg = 0;                                   \
                asm volatile (                                      \
                        &quot;mcr p15, 0, %[temp_reg], c7, c10, 5 \n\t&quot;  \
                        :                                           \
                        : [temp_reg] &quot;r&quot; (temp_reg)                 \
                        : &quot;memory&quot;);                                \
            } while (0)                                             \

#       define BSLS_ATOMICOPERATIONS_INSTR_BARRIER()                \
            do {                                                    \
                int temp_reg = 0;                                   \
                asm volatile (                                      \
                        &quot;mcr p15, 0, %[temp_reg], c7, c5, 4 \n\t&quot;   \
                        :                                           \
                        : [temp_reg] &quot;r&quot; (temp_reg));               \
            } while (0)                                             \

#   endif
#else
#   define BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
#endif

inline
int AtomicOperations_ARM_ALL_GCC::
    getInt(const AtomicTypes::Int *atomicInt)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    return __atomic_load_n(&amp;atomicInt-&gt;d_value, __ATOMIC_SEQ_CST);
#else
    int result = atomicInt-&gt;d_value;
    BSLS_ATOMICOPERATIONS_BARRIER();

    return result;

#endif
}

inline
int AtomicOperations_ARM_ALL_GCC::
    getIntAcquire(const AtomicTypes::Int *atomicInt)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    return __atomic_load_n(&amp;atomicInt-&gt;d_value, __ATOMIC_ACQUIRE);
#else
    return getInt(atomicInt);
#endif
}

inline
void AtomicOperations_ARM_ALL_GCC::
    setInt(AtomicTypes::Int *atomicInt, int value)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    __atomic_store_n(&amp;atomicInt-&gt;d_value, value, __ATOMIC_SEQ_CST);
#else
    BSLS_ATOMICOPERATIONS_BARRIER();
    atomicInt-&gt;d_value = value;
    BSLS_ATOMICOPERATIONS_BARRIER();
#endif
}

inline
void AtomicOperations_ARM_ALL_GCC::
    setIntRelease(AtomicTypes::Int *atomicInt, int value)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    __atomic_store_n(&amp;atomicInt-&gt;d_value, value, __ATOMIC_RELEASE);
#else
    BSLS_ATOMICOPERATIONS_BARRIER();
    setInt(atomicInt, value);
#endif
}

inline
int AtomicOperations_ARM_ALL_GCC::
    swapInt(AtomicTypes::Int *atomicInt, int swapValue)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    return __atomic_exchange_n(&amp;atomicInt-&gt;d_value,
                               swapValue,
                               __ATOMIC_SEQ_CST);
#else
    int oldValue;
    int tmp;

    BSLS_ATOMICOPERATIONS_BARRIER();

    asm volatile (
        &quot;1:     ldrex   %[old], [%3]            \n\t&quot;
        &quot;       strex   %[tmp], %[val], [%3]    \n\t&quot;
        &quot;       teq     %[tmp], #0              \n\t&quot;
        &quot;       bne     1b                      \n\t&quot;

                : [old] &quot;=&amp;r&quot; (oldValue),
                  [tmp] &quot;=&amp;r&quot; (tmp),
                        &quot;+Qo&quot; (*atomicInt)
                :       &quot;r&quot;   (atomicInt),
                  [val] &quot;r&quot;   (swapValue)
                : &quot;cc&quot;, &quot;memory&quot;);

    BSLS_ATOMICOPERATIONS_INSTR_BARRIER();

    return oldValue;
#endif
}

inline
int AtomicOperations_ARM_ALL_GCC::
    testAndSwapInt(AtomicTypes::Int *atomicInt,
                   int compareValue,
                   int swapValue)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    __atomic_compare_exchange_n(&amp;atomicInt-&gt;d_value, &amp;compareValue, swapValue,
                                false, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST);
    return compareValue;
#else
    return __sync_val_compare_and_swap(&amp;atomicInt-&gt;d_value,
                                       compareValue,
                                       swapValue);
#endif
}

inline
int AtomicOperations_ARM_ALL_GCC::
    addIntNv(AtomicTypes::Int *atomicInt, int value)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    return __atomic_add_fetch(&amp;atomicInt-&gt;d_value, value, __ATOMIC_SEQ_CST);
#else
    return __sync_add_and_fetch(&amp;atomicInt-&gt;d_value, value);
#endif
}

inline
Types::Int64 AtomicOperations_ARM_ALL_GCC::
    getInt64(const AtomicTypes::Int64 *atomicInt)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    return __atomic_load_n(&amp;atomicInt-&gt;d_value, __ATOMIC_SEQ_CST);
#else
    Types::Int64 result;

    asm volatile (
        &quot;       ldrexd  r2, r3, [%2]       \n\t&quot;
        &quot;       mov     %[res1], r2        \n\t&quot;
        &quot;       mov     %[res2], r3        \n\t&quot;

                : [res1] &quot;=&amp;r&quot; (((Int64_Words &amp;) result).w1),
                  [res2] &quot;=&amp;r&quot; (((Int64_Words &amp;) result).w2)
                :        &quot;r&quot;   (atomicInt),
                         &quot;Qo&quot;  (*atomicInt)
                : &quot;r2&quot;, &quot;r3&quot;);

    BSLS_ATOMICOPERATIONS_BARRIER();

    return result;
#endif
}

inline
void AtomicOperations_ARM_ALL_GCC::
    setInt64(AtomicTypes::Int64 *atomicInt, Types::Int64 value)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    return __atomic_store_n(&amp;atomicInt-&gt;d_value, value, __ATOMIC_SEQ_CST);
#else
    swapInt64(atomicInt, value);
#endif
}

inline
Types::Int64 AtomicOperations_ARM_ALL_GCC::
    swapInt64(AtomicTypes::Int64 *atomicInt,
              Types::Int64 swapValue)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    return __atomic_exchange_n(&amp;atomicInt-&gt;d_value,
                               swapValue,
                               __ATOMIC_SEQ_CST);
#else
    Types::Int64 oldValue;
    int rc;

    BSLS_ATOMICOPERATIONS_BARRIER();

    asm volatile (
        &quot;1:     ldrexd  r2, r3, [%4]           \n\t&quot;
        &quot;       mov     %[old1], r2            \n\t&quot;
        &quot;       mov     %[old2], r3            \n\t&quot;
        &quot;       mov     r2, %[val1]            \n\t&quot;
        &quot;       mov     r3, %[val2]            \n\t&quot;
        &quot;       strexd  %[rc], r2, r3, [%4]    \n\t&quot;
        &quot;       teq     %[rc], #0              \n\t&quot;
        &quot;       bne     1b                     \n\t&quot;

                : [rc]   &quot;=&amp;r&quot; (rc),
                  [old1] &quot;=&amp;r&quot; (((Int64_Words &amp;) oldValue).w1),
                  [old2] &quot;=&amp;r&quot; (((Int64_Words &amp;) oldValue).w2),
                         &quot;+Qo&quot; (*atomicInt)
                :        &quot;r&quot;   (atomicInt),
                  [val1] &quot;r&quot;   (((Int64_Words &amp;) swapValue).w1),
                  [val2] &quot;r&quot;   (((Int64_Words &amp;) swapValue).w2)
                : &quot;r2&quot;, &quot;r3&quot;, &quot;cc&quot;, &quot;memory&quot;);

    BSLS_ATOMICOPERATIONS_INSTR_BARRIER();

    return oldValue;
#endif
}

inline
Types::Int64 AtomicOperations_ARM_ALL_GCC::
    testAndSwapInt64(AtomicTypes::Int64 *atomicInt,
                     Types::Int64 compareValue,
                     Types::Int64 swapValue)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    __atomic_compare_exchange_n(&amp;atomicInt-&gt;d_value,
                                &amp;compareValue,
                                swapValue,
                                false,
                                __ATOMIC_SEQ_CST,
                                __ATOMIC_SEQ_CST);
    return compareValue;
#else
    Types::Int64 oldValue;
    int rc;

    BSLS_ATOMICOPERATIONS_BARRIER();

    asm volatile (
        &quot;1:     ldrexd  r2, r3, [%4]           \n\t&quot;
        &quot;       mov     %[old1], r2            \n\t&quot;
        &quot;       mov     %[old2], r3            \n\t&quot;
        &quot;       mov     r2, %[val1]            \n\t&quot;
        &quot;       mov     r3, %[val2]            \n\t&quot;
        &quot;       mov     %[rc], #0              \n\t&quot;
        &quot;       teq     %[old1], %[cmp1]       \n\t&quot;
        &quot;       itt     eq                     \n\t&quot;
        &quot;       teqeq   %[old2], %[cmp2]       \n\t&quot;
        &quot;       strexdeq %[rc], r2, r3, [%4]   \n\t&quot;
        &quot;       teq     %[rc], #0              \n\t&quot;
        &quot;       bne     1b                     \n\t&quot;

                : [rc]   &quot;=&amp;r&quot; (rc),
                  [old1] &quot;=&amp;r&quot; (((Int64_Words &amp;) oldValue).w1),
                  [old2] &quot;=&amp;r&quot; (((Int64_Words &amp;) oldValue).w2),
                         &quot;+Qo&quot; (*atomicInt)
                :        &quot;r&quot;   (atomicInt),
                  [cmp1] &quot;r&quot;   (((Int64_Words &amp;) compareValue).w1),
                  [cmp2] &quot;r&quot;   (((Int64_Words &amp;) compareValue).w2),
                  [val1] &quot;r&quot;   (((Int64_Words &amp;) swapValue).w1),
                  [val2] &quot;r&quot;   (((Int64_Words &amp;) swapValue).w2)
                : &quot;r2&quot;, &quot;r3&quot;, &quot;cc&quot;, &quot;memory&quot;);

    BSLS_ATOMICOPERATIONS_INSTR_BARRIER();

    return oldValue;
#endif
}

inline
Types::Int64 AtomicOperations_ARM_ALL_GCC::
    addInt64Nv(AtomicTypes::Int64 *atomicInt,
               Types::Int64 value)
{
#ifdef BSLS_ATOMICOPERATIONS_USE_CPP11_INTRINSICS
    return __atomic_add_fetch(&amp;atomicInt-&gt;d_value, value, __ATOMIC_SEQ_CST);
#else
    Types::Int64 old;
    Types::Int64 newVal;
    Types::Int64 prev = atomicInt-&gt;d_value;

    do {
        old = prev;
        newVal = old + value;
    } while (old != (prev = testAndSwapInt64(atomicInt, old, newVal)));

    return newVal;
#endif
}

}  // close package namespace

}  // close enterprise namespace

#endif  // defined(BSLS_PLATFORM_CPU_ARM) &amp;&amp; (CMP_GNU || CMP_CLANG)

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
