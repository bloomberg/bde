<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlb_nullableallocatedvalue.h                                      -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLB_NULLABLEALLOCATEDVALUE
#define INCLUDED_BDLB_NULLABLEALLOCATEDVALUE

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a template for nullable allocated (out-of-place) objects.
//
//@CLASSES:
//  bdlb::NullableAllocatedValue: template for nullable allocated objects
//
//@SEE_ALSO: bdlb_nullablevalue
//
//@DESCRIPTION: This component provides a template class,
// &#39;bdlb::NullableAllocatedValue&lt;TYPE&gt;&#39;, that has nearly the same interface as
// &#39;bdlb::NullableValue&#39; (see &#39;bdlb_nullablevalue&#39;), but, in contrast with that
// template class, the implementation of &#39;bdlb::NullableAllocatedValue&#39; does
// not require that the &#39;TYPE&#39; parameter be a complete type when the *class* is
// instantiated.  However, the template parameter &#39;TYPE&#39; must be complete when
// *methods* of the class (and free operators) are instantiated.
//
// Note that, as a consequence, the object of template parameter &#39;TYPE&#39; that
// is managed by a &#39;bdlb::NullableAllocatedValue&lt;TYPE&gt;&#39; object is necessarily
// allocated out-of-place.  This implies that an allocator is in effect for
// *any* &#39;bdlb::NullableAllocatedValue&lt;TYPE&gt;&#39; object, regardless of the &#39;TYPE&#39;.
// In particular, a &#39;bdlb::NullableAllocatedValue&lt;int&gt;&#39; object, for example,
// incurs use of the default allocator (in effect at the time of creation of
// the object) unless an alternative allocator is supplied at construction.
//
///Usage
///-----
// The following snippets of code illustrate use of this component.
//
// Suppose we want to create a linked list of nodes that contain integers:
//..
//  struct LinkedListNode {
//      int                                          d_value;
//      bdlb::NullableAllocatedValue&lt;LinkedListNode&gt; d_next;
//  };
//..
// Note that &#39;bdlb::NullableValue&lt;LinkedListNode&gt;&#39; cannot be used for &#39;d_next&#39;
// because &#39;bdlb::NullableValue&#39; requires that the template parameter &#39;TYPE&#39; be
// a complete type when the class is instantiated.
//
// We can now traverse a linked list and add a new value at the end using the
// following code:
//..
//  void addValueAtEnd(LinkedListNode *node, int value)
//  {
//      while (!node-&gt;d_next.isNull()) {
//          node = &amp;node-&gt;d_next.value();
//      }
//
//      node-&gt;d_next.makeValue();
//      node = &amp;node-&gt;d_next.value();
//      node-&gt;d_value = value;
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLB_PRINTMETHODS
#include &lt;bdlb_printmethods.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SCALARPRIMITIVES
#include &lt;bslalg_scalarprimitives.h&gt;
#endif

#ifndef INCLUDED_BSLALG_SWAPUTIL
#include &lt;bslalg_swaputil.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEALLOCATORPROCTOR
#include &lt;bslma_deallocatorproctor.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLX_INSTREAMFUNCTIONS
#include &lt;bslx_instreamfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLX_OUTSTREAMFUNCTIONS
#include &lt;bslx_outstreamfunctions.h&gt;
#endif

#ifndef INCLUDED_BSLX_VERSIONFUNCTIONS
#include &lt;bslx_versionfunctions.h&gt;
#endif

#ifndef INCLUDED_BSL_ALGORITHM
#include &lt;bsl_algorithm.h&gt;
#endif

#ifndef INCLUDED_BSL_IOSFWD
#include &lt;bsl_iosfwd.h&gt;
#endif

namespace BloombergLP {
namespace bdlb {

                  // ==================================
                  // class NullableAllocatedValue&lt;TYPE&gt;
                  // ==================================

template &lt;class TYPE&gt;
class NullableAllocatedValue {
    // This template class extends the set of values of its value-semantic
    // &#39;TYPE&#39; parameter to include the notion of a &quot;null&quot; value.  If &#39;TYPE&#39; is
    // fully value-semantic, then the augmented type
    // &#39;NullableAllocatedValue&lt;TYPE&gt;&#39; will be as well.  In addition to
    // supporting all homogeneous value-semantic operations, conversions
    // between comparable underlying value types is also supported.  Two
    // nullable objects with different underlying types compare equal if their
    // underlying types are comparable and either (1) both objects are null or
    // (2) the non-null values compare equal.  Attempts to copy construct, copy
    // assign, or compare incompatible values types will fail to compile.  The
    // &#39;NullableAllocatedValue&#39; template can be instantiated on an incomplete
    // type, but it cannot be instantiated on a type that overloads
    // &#39;operator&amp;&#39;.

    // DATA
    TYPE             *d_value_p;      // managed out-of-place &#39;TYPE&#39; object
    bslma::Allocator *d_allocator_p;  // held, not owned

  public:
    // TYPES
    typedef TYPE ValueType;
        // &#39;ValueType&#39; is an alias for the underlying &#39;TYPE&#39; upon which this
        // template class is instantiated, and represents the type of the
        // managed object.

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(NullableAllocatedValue,
                                   bslma::UsesBslmaAllocator);
    BSLMF_NESTED_TRAIT_DECLARATION(NullableAllocatedValue,
                                   bslmf::IsBitwiseMoveable);
    BSLMF_NESTED_TRAIT_DECLARATION(NullableAllocatedValue,
                                   bdlb::HasPrintMethod);

    // CREATORS
    explicit NullableAllocatedValue(bslma::Allocator *basicAllocator = 0);
        // Create a nullable object having the null value.  Optionally specify
        // a &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    NullableAllocatedValue(const NullableAllocatedValue&amp;  original,
                           bslma::Allocator              *basicAllocator = 0);
        // Create a nullable object having the value of the specified
        // &#39;original&#39; object.  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    NullableAllocatedValue(const TYPE&amp;       value,
                           bslma::Allocator *basicAllocator = 0);
        // Create a nullable object having the specified &#39;value&#39;.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is 0, the currently installed default allocator is
        // used.

    ~NullableAllocatedValue();
        // Destroy this object.

    // MANIPULATORS
    NullableAllocatedValue&lt;TYPE&gt;&amp; operator=(const NullableAllocatedValue&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39;, and return a
        // reference providing modifiable access to this object.

    TYPE&amp; operator=(const TYPE&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39;, and return a
        // reference providing modifiable access to the underlying &#39;TYPE&#39;
        // object.

    void swap(NullableAllocatedValue&amp; other);
        // Efficiently exchange the value of this object with the value of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee if the template parameter &#39;TYPE&#39; provides
        // that guarantee and the result of the &#39;isNull&#39; method for the two
        // objects being swapped is the same.  The behavior is undefined unless
        // this object was created with the same allocator as &#39;other&#39;.

    TYPE&amp; makeValue(const TYPE&amp; value);
        // Assign to this object the specified &#39;value&#39;, and return a reference
        // providing modifiable access to the underlying &#39;TYPE&#39; object.

    TYPE&amp; makeValue();
        // Assign to this object the default value for &#39;TYPE&#39;, and return a
        // reference providing modifiable access to the underlying &#39;TYPE&#39;
        // object.

    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamIn(STREAM&amp; stream, int version);
        // Assign to this object the value read from the specified input
        // &#39;stream&#39; using the specified &#39;version&#39; format, and return a
        // reference to &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this
        // operation has no effect.  If &#39;version&#39; is not supported, this object
        // is unaltered and &#39;stream&#39; is invalidated, but otherwise unmodified.
        // If &#39;version&#39; is supported but &#39;stream&#39; becomes invalid during this
        // operation, this object has an undefined, but valid, state.  Note
        // that no version is read from &#39;stream&#39;.  See the &#39;bslx&#39; package-level
        // documentation for more information on BDEX streaming of
        // value-semantic types and containers.

    void reset();
        // Reset this object to the default constructed state (i.e., to have
        // the null value).

    TYPE&amp; value();
        // Return a reference providing modifiable access to the underlying
        // &#39;TYPE&#39; object.  The behavior is undefined unless this object is
        // non-null.

    // ACCESSORS
    template &lt;class STREAM&gt;
    STREAM&amp; bdexStreamOut(STREAM&amp; stream, int version) const;
        // Write the value of this object, using the specified &#39;version&#39;
        // format, to the specified output &#39;stream&#39;, and return a reference to
        // &#39;stream&#39;.  If &#39;stream&#39; is initially invalid, this operation has no
        // effect.  If &#39;version&#39; is not supported, &#39;stream&#39; is invalidated, but
        // otherwise unmodified.  Note that &#39;version&#39; is not written to
        // &#39;stream&#39;.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.

    bool isNull() const;
        // Return &#39;true&#39; if this object is null, and &#39;false&#39; otherwise.

    int maxSupportedBdexVersion(int versionSelector) const;
        // Return the maximum valid BDEX format version, as indicated by the
        // specified &#39;versionSelector&#39;, to be passed to the &#39;bdexStreamOut&#39;
        // method.  Note that it is highly recommended that &#39;versionSelector&#39;
        // be formatted as &quot;YYYYMMDD&quot;, a date representation.  Also note that
        // &#39;versionSelector&#39; should be a *compile*-time-chosen value that
        // selects a format version supported by both externalizer and
        // unexternalizer.  See the &#39;bslx&#39; package-level documentation for more
        // information on BDEX streaming of value-semantic types and
        // containers.


    bsl::ostream&amp; print(bsl::ostream&amp; stream,
                        int           level          = 0,
                        int           spacesPerLevel = 4) const;
        // Format this object to the specified output &#39;stream&#39; at the (absolute
        // value of) the optionally specified indentation &#39;level&#39; and return a
        // reference to &#39;stream&#39;.  If &#39;level&#39; is specified, optionally specify
        // &#39;spacesPerLevel&#39;, the number of spaces per indentation level for
        // this and all of its nested objects.  If &#39;level&#39; is negative,
        // suppress indentation of the first line.  If &#39;spacesPerLevel&#39; is
        // negative, format the entire output on one line, suppressing all but
        // the initial indentation (as governed by &#39;level&#39;).  If &#39;stream&#39; is
        // not valid on entry, this operation has no effect.

    const TYPE&amp; value() const;
        // Return a reference providing non-modifiable access to the underlying
        // &#39;TYPE&#39; object.  The behavior is undefined unless this object is
        // non-null.
};

// FREE OPERATORS
template &lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator==(const NullableAllocatedValue&lt;LHS_TYPE&gt;&amp; lhs,
                const NullableAllocatedValue&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; nullable objects have the
    // same value, and &#39;false&#39; otherwise.  Two nullable objects have the same
    // value if both are null, or if both are non-null and the values of their
    // underlying objects compare equal.  Note that this function will fail to
    // compile if &#39;LHS_TYPE&#39; and &#39;RHS_TYPE&#39; are not compatible.

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
bool operator!=(const NullableAllocatedValue&lt;LHS_TYPE&gt;&amp; lhs,
                const NullableAllocatedValue&lt;RHS_TYPE&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; nullable objects do not
    // have the same value, and &#39;false&#39; otherwise.  Two nullable objects do not
    // have the same value if one is null and the other is non-null, or if both
    // are non-null and the values of their underlying objects do not compare
    // equal.  Note that this function will fail to compile if &#39;LHS_TYPE&#39; and
    // &#39;RHS_TYPE&#39; are not compatible.

template &lt;class TYPE&gt;
bsl::ostream&amp; operator&lt;&lt;(bsl::ostream&amp;                       stream,
                         const NullableAllocatedValue&lt;TYPE&gt;&amp; object);
    // Write the value of the specified &#39;object&#39; to the specified output
    // &#39;stream&#39; in a single-line format, and return a reference to &#39;stream&#39;.
    // If &#39;stream&#39; is not valid on entry, this operation has no effect.  Note
    // that this human-readable format is not fully specified, can change
    // without notice, and is logically equivalent to:
    //..
    //  print(stream, 0, -1);
    //..

// FREE FUNCTIONS
template &lt;class TYPE&gt;
void swap(NullableAllocatedValue&lt;TYPE&gt;&amp; a,
          NullableAllocatedValue&lt;TYPE&gt;&amp; b);
    // Efficiently exchange the values of the specified &#39;a&#39; and &#39;b&#39; objects.
    // This method provides the no-throw exception-safety guarantee if the
    // template parameter &#39;TYPE&#39; provides that guarantee and the result of
    // the &#39;isNull&#39; method for &#39;a&#39; and &#39;b&#39; is the same.  The behavior is
    // undefined unless both objects were created with the same allocator.

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                  // ----------------------------------
                  // class NullableAllocatedValue&lt;TYPE&gt;
                  // ----------------------------------

// CREATORS
template &lt;class TYPE&gt;
inline
NullableAllocatedValue&lt;TYPE&gt;
::NullableAllocatedValue(bslma::Allocator *basicAllocator)
: d_value_p(0)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
}

template &lt;class TYPE&gt;
inline
NullableAllocatedValue&lt;TYPE&gt;
::NullableAllocatedValue(const NullableAllocatedValue&lt;TYPE&gt;&amp;  original,
                         bslma::Allocator                    *basicAllocator)
: d_value_p(0)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
    if (!original.isNull()) {
        makeValue(original.value());
    }
}

template &lt;class TYPE&gt;
inline
NullableAllocatedValue&lt;TYPE&gt;::NullableAllocatedValue(
                                              const TYPE&amp;       value,
                                              bslma::Allocator *basicAllocator)
: d_value_p(0)
, d_allocator_p(bslma::Default::allocator(basicAllocator))
{
    makeValue(value);
}

template &lt;class TYPE&gt;
inline
NullableAllocatedValue&lt;TYPE&gt;::~NullableAllocatedValue()
{
    reset();
}

// MANIPULATORS
template &lt;class TYPE&gt;
inline
NullableAllocatedValue&lt;TYPE&gt;&amp;
NullableAllocatedValue&lt;TYPE&gt;::operator=(
                                       const NullableAllocatedValue&lt;TYPE&gt;&amp; rhs)
{
    if (!rhs.isNull()) {
        makeValue(rhs.value());
    }
    else {
        reset();
    }

    return *this;
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableAllocatedValue&lt;TYPE&gt;::operator=(const TYPE&amp; rhs)
{
    return makeValue(rhs);
}

template &lt;class TYPE&gt;
void NullableAllocatedValue&lt;TYPE&gt;::swap(NullableAllocatedValue&amp; other)
{
    // &#39;swap&#39; is undefined for non-equal allocators.

    BSLS_ASSERT(d_allocator_p == other.d_allocator_p);

    // Nothing to do if both objects are null.

    if (isNull() &amp;&amp; other.isNull()) {
        return;                                                       // RETURN
    }

    // Otherwise, simply swap the pointers to the out-of-place objects.

    bslalg::SwapUtil::swap(&amp;d_value_p, &amp;other.d_value_p);
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableAllocatedValue&lt;TYPE&gt;::makeValue(const TYPE&amp; value)
{
    if (d_value_p) {
        *d_value_p = value;
        return *d_value_p;                                            // RETURN
    }

    TYPE *tmpPtr = reinterpret_cast&lt;TYPE *&gt;(
                                        d_allocator_p-&gt;allocate(sizeof(TYPE)));
    bslma::DeallocatorProctor&lt;bslma::Allocator&gt; proctor(tmpPtr, d_allocator_p);
    bslalg::ScalarPrimitives::copyConstruct(tmpPtr, value, d_allocator_p);
    proctor.release();
    d_value_p = tmpPtr;

    return *d_value_p;
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableAllocatedValue&lt;TYPE&gt;::makeValue()
{
    reset();

    // Note that this alternative implementation, instead of &#39;reset()&#39;,
    // provides stronger exception-safety, but it breaks some client code that
    // uses &#39;NullableAllocatedValue&#39; with a non-value-semantic &#39;TYPE&#39;.
    //..
    //  if (d_value_p) {
    //      *d_value_p = TYPE(d_allocator_p);
    //      return *d_value_p;                                        // RETURN
    //  }
    //..

    TYPE *value = reinterpret_cast&lt;TYPE *&gt;(
                                        d_allocator_p-&gt;allocate(sizeof(TYPE)));
    bslma::DeallocatorProctor&lt;bslma::Allocator&gt; proctor(value, d_allocator_p);
    bslalg::ScalarPrimitives::defaultConstruct(value, d_allocator_p);
    proctor.release();
    d_value_p = value;

    return *d_value_p;
}

template &lt;class TYPE&gt;
template &lt;class STREAM&gt;
STREAM&amp; NullableAllocatedValue&lt;TYPE&gt;::bdexStreamIn(STREAM&amp; stream, int version)
{
    using bslx::InStreamFunctions::bdexStreamIn;

    char isNull;

    stream.getInt8(isNull);

    if (stream) {
        if (!isNull) {
            makeValue();
            bdexStreamIn(stream, value(), version);
        }
        else {
            reset();
        }
    }

    return stream;
}

template &lt;class TYPE&gt;
inline
void NullableAllocatedValue&lt;TYPE&gt;::reset()
{
    if (d_value_p) {
        d_value_p-&gt;~TYPE();
        d_allocator_p-&gt;deallocate(d_value_p);
        d_value_p = 0;
    }
}

template &lt;class TYPE&gt;
inline
TYPE&amp; NullableAllocatedValue&lt;TYPE&gt;::value()
{
    BSLS_ASSERT_SAFE(!isNull());

    return *d_value_p;
}

// ACCESSORS
template &lt;class TYPE&gt;
template &lt;class STREAM&gt;
STREAM&amp; NullableAllocatedValue&lt;TYPE&gt;::bdexStreamOut(STREAM&amp; stream,
                                                    int     version) const
{
    using bslx::OutStreamFunctions::bdexStreamOut;

    stream.putInt8(isNull() ? 1 : 0);

    if (!isNull()) {
        bdexStreamOut(stream, value(), version);
    }

    return stream;
}

template &lt;class TYPE&gt;
inline
bool NullableAllocatedValue&lt;TYPE&gt;::isNull() const
{
    return 0 == d_value_p;
}

template &lt;class TYPE&gt;
inline
int NullableAllocatedValue&lt;TYPE&gt;::maxSupportedBdexVersion(
                                                     int versionSelector) const
{
    using bslx::VersionFunctions::maxSupportedBdexVersion;

    // We need to call the &#39;bslx::VersionFunctions&#39; helper function, because we
    // cannot guarantee that &#39;TYPE&#39; implements &#39;maxSupportedBdexVersion&#39; as a
    // class method.

    return maxSupportedBdexVersion(reinterpret_cast&lt;TYPE *&gt;(0),
                                   versionSelector);
}


template &lt;class TYPE&gt;
inline
bsl::ostream&amp; NullableAllocatedValue&lt;TYPE&gt;::print(
                                            bsl::ostream&amp; stream,
                                            int           level,
                                            int           spacesPerLevel) const
{
    if (isNull()) {
        return bdlb::PrintMethods::print(stream,
                                         &quot;NULL&quot;,
                                         level,
                                         spacesPerLevel);             // RETURN
    }

    return bdlb::PrintMethods::print(stream, value(), level, spacesPerLevel);
}

template &lt;class TYPE&gt;
inline
const TYPE&amp; NullableAllocatedValue&lt;TYPE&gt;::value() const
{
    BSLS_ASSERT_SAFE(!isNull());

    return *d_value_p;
}

}  // close package namespace

// FREE OPERATORS
template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bdlb::operator==(const NullableAllocatedValue&lt;LHS_TYPE&gt;&amp; lhs,
                      const NullableAllocatedValue&lt;RHS_TYPE&gt;&amp; rhs)
{
    if (!lhs.isNull() &amp;&amp; !rhs.isNull()) {
        return lhs.value() == rhs.value();                            // RETURN
    }

    return lhs.isNull() == rhs.isNull();
}

template &lt;class LHS_TYPE, class RHS_TYPE&gt;
inline
bool bdlb::operator!=(const NullableAllocatedValue&lt;LHS_TYPE&gt;&amp; lhs,
                      const NullableAllocatedValue&lt;RHS_TYPE&gt;&amp; rhs)
{
    if (!lhs.isNull() &amp;&amp; !rhs.isNull()) {
        return lhs.value() != rhs.value();                            // RETURN
    }

    return lhs.isNull() != rhs.isNull();
}

template &lt;class TYPE&gt;
inline
bsl::ostream&amp; bdlb::operator&lt;&lt;(bsl::ostream&amp;                       stream,
                               const NullableAllocatedValue&lt;TYPE&gt;&amp; object)
{
    return object.print(stream, 0, -1);
}

// FREE FUNCTIONS
template &lt;class TYPE&gt;
inline
void bdlb::swap(NullableAllocatedValue&lt;TYPE&gt;&amp; a,
                NullableAllocatedValue&lt;TYPE&gt;&amp; b)
{
    a.swap(b);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
