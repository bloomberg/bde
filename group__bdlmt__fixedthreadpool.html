<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlmt_fixedthreadpool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlmt_fixedthreadpool<br/>
<small>
[<a class="el" href="group__bdlmt.html">Package bdlmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide portable implementation for a fixed-size pool of threads.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlmt.html">bdlmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Thread Safety</a> </li>
<li>
<a href="#3.2">Synchronous Signals on Unix</a> </li>
<li>
<a href="#3.3">Usage</a> <ul>
<li>
<a href="#3.3.1">Setting FixedThreadPool Attributes</a> </li>
<li>
<a href="#3.3.2">The "void function/void pointer" Interface</a> </li>
<li>
<a href="#3.3.3">The Functor Interface</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide portable implementation for a fixed-size pool of threads. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a> </td><td>portable fixed-size thread pool  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlmt__threadpool.html" title="Provide portable implementation for a dynamic pool of threads.">Component bdlmt_threadpool</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component defines a portable and efficient implementation of a thread pool, <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code>, that can be used to distribute various user-defined functions ("jobs") to a separate threads to execute the jobs concurrently. Each thread pool object manages a fixed number of processing threads and can hold up to a fixed maximum number of pending jobs. </dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code> implements a queuing mechanism that distributes work among the threads. Jobs are queued for execution as they arrive, and each queued job is processed by the next available thread. If each of the concurrent threads is busy processing a job, new jobs will remain enqueued until a thread becomes available. If the queue capacity is reached, enqueuing jobs will block until threads consume more jobs from the queue, causing its length to drop below its capacity. Both the queue's capacity and number of threads are specified at construction and cannot be changed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The thread pool provides two interfaces for specifying jobs: the commonly used "void function/void pointer" interface and the more versatile functor based interface. The void function/void pointer interface allows callers to use a C-style function to be executed as a job. The application need only specify the address of the function, and a single void pointer argument, to be passed to the function. The specified function will be invoked with the specified argument by the processing thread. The functor based interface allows for more flexible job execution such as the invocation of member functions or the passing of multiple user-defined arguments. See the <code>bdef</code> package-level documentation for more on functors and their usage. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Unlike a <code><a class="el" href="classbdlmt_1_1ThreadPool.html">bdlmt::ThreadPool</a></code>, an application can not tune a <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code> once it is created with a specified number of threads and queue capacity, hence the name "fixed" thread pool. An application can, however, specify the attributes of the threads in the pool (e.g., thread priority or stack size), by providing a <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a></code> object with the desired values set. See <code>bslmt_threadutil</code> package documentation for a description of <code><a class="el" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Thread pools are ideal for developing multi-threaded server applications. A server need only package client requests to execute as jobs, and <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code> will handle the queue management, thread management, and request dispatching. Thread pools are also well suited for parallelizing certain types of application logic. Without any complex or redundant thread management code, an application can easily create a thread pool, enqueue a series of jobs to be executed, and wait until all the jobs have executed. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="thread_safety"></a> <a class="anchor" id="description.thread_safety"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Thread Safety: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code> class is both <em>fully thread-safe</em> (i.e., all non-creator methods can correctly execute concurrently), and is <em>thread-enabled</em> (i.e., the classes does not function correctly in a non-multi-threading environment). See <code>bsldoc_glossary</code> for complete definitions of <em>fully thread-safe</em> and <em>thread-enabled</em>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="synchronous_signals_on_unix"></a> <a class="anchor" id="description.synchronous_signals_on_unix"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Synchronous Signals on Unix: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A thread pool ensures that, on unix platforms, all the threads in the pool block all asynchronous signals. Specifically all the signals, except the following synchronous signals are blocked: <br/>
<br/>
<div class="fragment"><pre class="fragment"> SIGBUS
 SIGFPE
 SIGILL
 SIGSEGV
 SIGSYS
 SIGABRT
 SIGTRAP
 SIGIOT
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This example demonstrates the use of a <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code> to parallelize a segment of program logic. The example implements a multi-threaded file search utility. The utility searches multiple files for a string, similar to the Unix command <code>fgrep</code>; the use of a <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code> allows the utility to search multiple files concurrently. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The example program will take as input a string and a list of files to search. The program creates a <code><a class="el" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a></code>, and then enqueues a single "job" for each file to be searched. Each thread in the pool will take a job from the queue, open the file, and search for the string. If a match is found, the job adds the filename to an array of matching filenames. Because this array of filenames is shared across multiple jobs and across multiple threads, access to the array is controlled via a <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="setting_fixedthreadpool_attributes"></a> <a class="anchor" id="usage.setting_fixedthreadpool_attributes"></a> <a class="anchor" id="description.usage.setting_fixedthreadpool_attributes"></a> <a class="anchor" id="3.3.1"></a> </dd></dl>
<dl class="user"><dt><b>Setting FixedThreadPool Attributes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>To get started, we declare thread attributes, to be used in constructing the thread pool. In this example, our choices for number of threads and queue capacity are arbitrary. <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #define SEARCH_THREADS         10</span>
<span class="preprocessor">  #define SEARCH_QUEUE_CAPACITY  50</span>
</pre></div><br/>
<br/>
 Below is the structure that will be used to pass arguments to the file search function. Since each job will be searching a separate file, a distinct instance of the structure will be used for each job. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>my_FastSearchJobInfo {
       <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>        *d_word;    <span class="comment">// word to search for</span>
       <span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>        *d_path;    <span class="comment">// path of the file to search</span>
       <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>             *d_mutex;   <span class="comment">// mutex to control access to the</span>
                                            <span class="comment">// result file list</span>
       <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a> *d_outList; <span class="comment">// list of matching files</span>
   };
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_~22void_function~2Fvoid_pointer~22_interface"></a> <a class="anchor" id="usage.the_~22void_function~2Fvoid_pointer~22_interface"></a> <a class="anchor" id="description.usage.the_~22void_function~2Fvoid_pointer~22_interface"></a> <a class="anchor" id="3.3.2"></a> </dd></dl>
<dl class="user"><dt><b>The "void function/void pointer" Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code>myFastSearchJob</code> is the search function to be executed as a job by threads in the thread pool, matching the "void function/void pointer" interface. The single <code>void *</code> argument is received and cast to point to a 'struct my_FastSearchJobInfo', which then points to the search string and a single file to be searched. Note that different <code>my_FastSearchInfo</code> structures for the same search request will differ only in the attribute <code>d_path</code>, which points to a specific filename among the set of files to be searched; other fields will be identical across all structures for a given Fast Search. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See the following section for an illustration of the functor interface. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keyword">static</span> <span class="keywordtype">void</span> myFastSearchJob(<span class="keywordtype">void</span> *arg)
   {
       myFastSearchJobInfo *job =  (myFastSearchJobInfo*)arg;
       FILE *file;

       file = fopen(job-&gt;d_path-&gt;c_str(), <span class="stringliteral">&quot;r&quot;</span>);

       <span class="keywordflow">if</span> (file) {
           <span class="keywordtype">char</span>  buffer[1024];
           <span class="keywordtype">size_t</span> nread;
           <span class="keywordtype">int</span> wordLen = job-&gt;d_word-&gt;length();
           <span class="keyword">const</span> <span class="keywordtype">char</span> *word = job-&gt;d_word-&gt;c_str();

           nread = fread(buffer, 1, <span class="keyword">sizeof</span>(buffer) - 1, file);
           <span class="keywordflow">while</span>(nread &gt;= wordLen) {
               buffer[nread] = 0;
               <span class="keywordflow">if</span> (strstr(buffer, word)) {
</pre></div><br/>
<br/>
 If we find a match, we add the file to the result list and return. Since the result list is shared among multiple processing threads, we use a mutex lock to regulate access to the list. We use a <code><a class="el" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard</a></code> to manage access to the mutex lock. This template object acquires a mutex lock on <code>job-&gt;d_mutex</code> at construction, releases that lock on destruction. Thus, the mutex will be locked within the scope of the <code>if</code> block, and released when the program exits that scope. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>See <code>bslmt_threadutil</code> for information about the <code><a class="el" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a></code> class, and component <code>bslmt_lockguard</code> for information about the <code><a class="el" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard</a></code> template class. <br/>
<br/>
<div class="fragment"><pre class="fragment">                <a class="code" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard&lt;bslmt::Mutex&gt;</a> lock(job-&gt;d_mutex);
                job-&gt;d_outList-&gt;push_back(*job-&gt;d_path);
                <span class="keywordflow">break</span>;  <span class="comment">// bslmt::LockGuard destructor unlocks mutex.</span>
            }
            memcpy(buffer, &amp;buffer[nread - wordLen - 1], wordLen - 1);
            nread = fread(buffer + wordLen - 1, 1, <span class="keyword">sizeof</span>(buffer) - wordLen,
                          file);
        }
        fclose(file);
       }
   }
</pre></div><br/>
<br/>
 Routine <code>myFastSearch</code> is the main driving routine, taking three arguments: a single string to search for (<code>word</code>), a list of files to search, and an output list of files. When the function completes, the file list will contain the names of files where a match was found. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keywordtype">void</span>  myFastSearch(<span class="keyword">const</span> <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>&amp;              word,
                      <span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp; fileList,
                      <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp;       outFileList)
   {
       <a class="code" href="classbslmt_1_1Mutex.html">bslmt::Mutex</a>     mutex;
       <a class="code" href="classbslmt_1_1ThreadAttributes.html">bslmt::ThreadAttributes</a> defaultAttributes;
</pre></div><br/>
<br/>
 We initialize the thread pool using default thread attributes. We then start the pool so that the threads can begin while we prepare the jobs. <br/>
<br/>
<div class="fragment"><pre class="fragment">       <a class="code" href="classbdlmt_1_1FixedThreadPool.html">bdlmt::FixedThreadPool</a> pool(defaultAttributes,
                                 SEARCH_THREADS,
                                 SEARCH_QUEUE_CAPACITY);

       <span class="keywordflow">if</span> (0 != pool.start()) {
           bsl::cerr &lt;&lt; <span class="stringliteral">&quot;Thread start() failed.  Thread quota exceeded?&quot;</span>
                     &lt;&lt; bsl::endl;
           exit(1);
       }
</pre></div><br/>
<br/>
 For each file to be searched, we create the job info structure that will be passed to the search function and add the job to the pool. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>As noted above, all jobs will share a single mutex to guard the output file list. Function <code>myFastSearchJob</code> uses a <code><a class="el" href="classbslmt_1_1LockGuard.html">bslmt::LockGuard</a></code> on this mutex to serialize access to the list. <br/>
<br/>
<div class="fragment"><pre class="fragment">       <span class="keywordtype">int</span> count = fileList.<a class="code" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a>();
       my_FastSearchJobInfo *jobInfoArray = <span class="keyword">new</span> my_FastSearchJobInfo[count];

       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i) {
           my_FastSearchJobInfo &amp;job = jobInfoArray[i];
           job.d_word    = &amp;word;
           job.d_path    = &amp;fileList[i];
           job.d_mutex   = &amp;mutex;
           job.d_outList = &amp;outFileList;
           pool.enqueueJob(myFastSearchJob, &amp;job);
       }
</pre></div><br/>
<br/>
 Now we simply wait for all the jobs in the queue to complete. Any matched files should have been added to the output file list. <br/>
<br/>
<div class="fragment"><pre class="fragment">       pool.drain();
       <span class="keyword">delete</span>[] jobInfoArray;
   }
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="the_functor_interface"></a> <a class="anchor" id="usage.the_functor_interface"></a> <a class="anchor" id="description.usage.the_functor_interface"></a> <a class="anchor" id="3.3.3"></a> </dd></dl>
<dl class="user"><dt><b>The Functor Interface: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The "void function/void pointer" convention is idiomatic for C programs. The <code>void</code> pointer argument provides a generic way of passing in user data, without regard to the data type. Clients who prefer better or more explicit type safety may wish to use the Functor Interface instead. This interface uses <code>bsl::function</code> to provide type-safe wrappers that can match argument number and type for a C++ free function or member function. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To illustrate the Functor Interface, we will make two small changes to the usage example above. First, we change the signature of the function that executes a single job, so that it uses a <code>myFastSearchJobInfo</code> pointer rather than a <code>void</code> pointer. With this change, we can remove the first executable statement, which casts the <code>void *</code> pointer to <code>myFastSearchJobInfo *</code>. <br/>
<br/>
<div class="fragment"><pre class="fragment">   <span class="keyword">static</span> <span class="keywordtype">void</span> myFastFunctorSearchJob(myFastSearchJobInfo *job)
   {
       FILE *file;

       file = fopen(job-&gt;d_path-&gt;c_str(), <span class="stringliteral">&quot;r&quot;</span>);
       <span class="comment">// the rest of the function is unchanged.</span>
</pre></div><br/>
<br/>
 Next, we make a change to the loop that enqueues the jobs in <code>myFastSearch</code>. We create a functor - a C++ object that acts as a function. The thread pool will "execute" this functor (by calling its <code>operator()</code> member function) on a thread when one becomes available. <br/>
<br/>
<div class="fragment"><pre class="fragment">       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; count; ++i) {
           my_FastSearchJobInfo &amp;job = jobInfoArray[i];
           job.d_word    = &amp;word;
           job.d_path    = &amp;fileList[i];
           job.d_mutex   = &amp;mutex;
           job.d_outList = &amp;outFileList;

           bsl::function&lt;void()&gt; jobHandle =
                         <a class="code" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a>(&amp;myFastFunctorSearchJob, &amp;job);
           pool.enqueueJob(jobHandle);
       }
</pre></div><br/>
<br/>
 Use of <code>bsl::function</code> and <code><a class="el" href="structbdlf_1_1BindUtil.html">bdlf::BindUtil</a></code> is described in the <code>bdef</code> package documentation. For this example, it is important to note that <code>jobHandle</code> is a functor object, and that <code><a class="el" href="structbdlf_1_1BindUtil.html#abed946d413bfd0d0abbe7f87b3ed16e4">bdlf::BindUtil::bind</a></code> populates that functor object with a function pointer (to the <code>void</code> function <code>myFastFunctorSearchJob</code>) and user data (<code>&amp;job</code>). When the functor is executed via <code>operator()</code>, it will in turn execute the <code>myFastFunctorSearchJob</code> function with the supplied data as its argument. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note also that the functor is created locally and handed to the thread pool. The thread pool copies the functor onto its internal queue, and takes responsibility for the copied functor until execution is complete. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The function is completed exactly as it was in the previous example. <br/>
<br/>
<div class="fragment"><pre class="fragment">       pool.drain();
       <span class="keyword">delete</span>[] jobInfoArray;
   }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:46 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
