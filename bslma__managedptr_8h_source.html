<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslma_managedptr.h                                                 -*-C++-*-
#ifndef INCLUDED_BSLMA_MANAGEDPTR
#define INCLUDED_BSLMA_MANAGEDPTR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide a managed pointer class.
//
//@CLASSES:
//     bslma::ManagedPtr: proctor for automatic memory management
// bslma::ManagedPtrUtil: Namespace for deleter for stack-allocated objects
//
//@SEE_ALSO: bslmf_ispolymporphic
//
//@DESCRIPTION: This component provides a proctor, &#39;bslma::ManagedPtr&#39;, similar
// to &#39;bsl::auto_ptr&#39;, that supports user-specified deleters.  The proctor is
// responsible for the automatic destruction of the object referenced by the
// managed pointer.  As a &quot;smart pointer&quot;, this object offers an interface
// similar to a native pointer, supporting dereference operators (*, -&gt;),
// (in)equality comparison and testing as if it were a boolean value.  However,
// like &#39;bsl::auto_ptr&#39; it has unusual &quot;copy-semantics&quot; that transfer ownership
// of the managed object, rather than making a copy.  It should be noted that
// this signature does not satisfy the requirements for an element-type stored
// in any of the standard library containers.  Note that this component will
// fail to compile when instantiated for a class that gives a false-positive
// for the type trait &#39;bslmf::IsPolymorphic&#39;.  See the &#39;bslmf_ispolymporphic&#39;
// component for more details.
//
///Factories
///---------
// An object that will be managed by a &#39;ManagedPtr&#39; object is typically
// dynamically allocated and destroyed by a factory.  For the purposes of this,
// component, a factory is any class that provides a &#39;deleteObject&#39; function
// taking a single argument of the (pointer) type of the managed pointer.
// E.g., &#39;bslma::Allocator&#39; is a commonly used factory, and the currently
// installed default allocator is the factory that is assumed to be used if
// neither a factory nor deleter (see below) are specified when supplying a
// pointer to be managed.
//
///Deleters
///--------
// When a managed pointer is destroyed, the managed object is destroyed using
// the user supplied &quot;deleter&quot;.  A deleter is simply a function that is invoked
// with two &#39;void *&#39; arguments: a pointer to the object to be destroyed, and a
// pointer to a &#39;cookie&#39; that is supplied at the same time as the &#39;deleter&#39; and
// managed object.
//..
//  typedef void (*DeleterFunc)(void *managedObject, void *cookie);
//..
// The meaning of the &#39;cookie&#39; depends on the specific deleter.  Typically a
// deleter function will accept the two &#39;void *&#39; pointers and internally cast
// them to the appropriate types for pointers to the managed object and
// &#39;cookie&#39;.  Note that there are no methods taking just a deleter, as the user
// must always supply a &#39;cookie&#39; to be passed when the deleter is actually
// invoked.
//
//
///Aliasing
///--------
// In a managed pointer, the pointer value (the value returned by the &#39;get&#39;
// method) and the pointer to the managed object need not have the same value.
// The &#39;loadAlias&#39; method allows a managed pointer to be created as an &quot;alias&quot;
// to another managed pointer (possibly of a different type), which we&#39;ll call
// the &quot;original&quot; managed pointer.  When &#39;get&#39; is invoked on the alias, the
// aliased pointer value is returned, but when the managed pointer is
// destroyed, the original managed object will be passed to the deleter.  (See
// also the documentation of the &#39;alias&#39; constructor or of the &#39;loadAlias&#39;
// method.)
//
///Exception Safety
///----------------
// The principal usage of a managed pointer is to guarantee that a local object
// will be deallocated properly should an operation throw after its allocation.
// In this, it is very similar to &#39;bsl::auto_ptr&#39;.  It is required for the
// proper functioning of this component that a deleter does not throw at
// invocation (upon destruction or re-assignment of the managed pointer).
//
///Type Casting
///------------
// &#39;ManagedPtr&#39; objects can be implicitly and explicitly cast to different
// types in the same way that native pointers can.
//
///Explicit Casting
/// - - - - - - - -
// Through &quot;aliasing&quot;, a managed pointer of any type can be explicitly cast to
// a managed pointer of any other type using any legal cast expression.  See
// example 4 on &#39;type casting&#39; below for more details.
//
///Implicit Casting
/// - - - - - - - -
// As with native pointers, a managed pointer of the type &#39;B&#39; that is derived
// from the type &#39;A&#39;, can be directly assigned to a &#39;ManagedPtr&#39; of &#39;A&#39;.
// Likewise a managed pointer of type &#39;B&#39; can be directly assigned to a
// &#39;ManagedPtr&#39; of &#39;const B&#39;.  However, the rules for construction are a little
// more subtle, and apply when passing a &#39;bslma::ManagedPtr&#39; by value into a
// function, or returning as the result of a function.
//..
//  class A {};
//
//  class B : public A {};
//
//  void test()
//  {
//      B *b_p = 0;
//      A *a_p = b_p;
//
//      bslma::ManagedPtr&lt;B&gt; b_mp1;
//      bslma::ManagedPtr&lt;A&gt; a_mp1(b_mp1);   // direct-initialization is valid
//      bslma::ManagedPtr&lt;A&gt; a_mp2 = b_mp1;  // copy-initialization should fail
//}
//..
// Note that &#39;std::auto_ptr&#39; has the same restriction, and this failure will
// occur only on compilers that strictly conform to the C++ standard, such as
// recent gcc compilers or (in this case) IBM xlC.
//
///Usage
///-----
// In this section we show intended usage of this component.
//
///Example 1: Implementing a Protocol
/// - - - - - - - - - - - - - - - - -
// We demonstrate using &#39;ManagedPtr&#39; to configure and return a managed object
// implementing an abstract protocol.
//
// First we define our protocol, &#39;Shape&#39;, a type of object that knows how to
// compute its &#39;area&#39;.  Note that for expository reasons only, we do *nor* give
// &#39;Shape&#39; a virtual destructor.
//..
//  struct Shape {
//      virtual double area() const = 0;
//          // Return the &#39;area&#39; of this shape.
//  };
//..
// Then we define a couple of classes that implement the &#39;Shape&#39; protocol, a
// &#39;Circle&#39; and a &#39;Square&#39;.
//..
//  class Circle : public Shape {
//    private:
//      // DATA
//      double d_radius;
//
//    public:
//      // CREATORS
//      explicit Circle(double radius);
//          // Create a &#39;Circle&#39; object having the specified &#39;radius&#39;.
//
//      // ACCESSORS
//      virtual double area() const;
//          // Return the area of this Circle, given by the formula pi*r*r.
//  };
//
//  class Square : public Shape {
//    private:
//      // DATA
//      double d_sideLength;
//
//    public:
//      // CREATORS
//      explicit Square(double side);
//          // Create a &#39;Square&#39; having sides of length &#39;side&#39;.
//
//      // ACCESSORS
//      virtual double area() const;
//          // Return the area of this Square, given by the formula side*side
//  };
//..
// Next we implement the methods for &#39;Circle&#39; and &#39;Square&#39;.
//..
//  Circle::Circle(double radius)
//  : d_radius(radius)
//  {
//  }
//
//  double Circle::area() const {
//      return 3.141592653589793238462 * d_radius * d_radius;
//  }
//
//  Square::Square(double side)
//  : d_sideLength(side)
//  {
//  }
//
//  double Square::area() const {
//      return d_sideLength * d_sideLength;
//  }
//..
// Then we define an enumeration that lists each implementation of the &#39;Shape&#39;
// protocol.
//..
//  struct Shapes {
//      enum VALUES { SHAPE_CIRCLE, SHAPE_SQUARE };
//  };
//..
// Now we can define a function that will return a &#39;Circle&#39; object or a
// &#39;Square&#39; object according to the specified &#39;kind&#39; parameter, and having its
// &#39;dimension&#39; specified by the caller.
//..
//  bslma::ManagedPtr&lt;Shape&gt; makeShape(Shapes::VALUES kind, double dimension)
//  {
//      bslma::Allocator *alloc = bslma::Default::defaultAllocator();
//      bslma::ManagedPtr&lt;Shape&gt; result;
//      switch (kind) {
//          case Shapes::SHAPE_CIRCLE : {
//              Circle *circ = new(*alloc)Circle(dimension);
//              result.load(circ);
//              break;
//          }
//          case Shapes::SHAPE_SQUARE : {
//              Square *sqr = new(*alloc)Square(dimension);
//              result.load(sqr);
//              break;
//          }
//      };
//      return result;
//  }
//..
// Then, we can use our function to create shapes of different kinds, and check
// that they report the correct area.  Note that are using a radius of &#39;1.0&#39;
// for the &#39;Circle&#39; and integral side-length for the &#39;Square&#39; to support an
// accurate &#39;operator==&#39; with floating-point quantities.  Also note that,
// despite the destructor for &#39;Shape&#39; being non-virtual, the correct destructor
// for the appropriate concrete &#39;Shape&#39; type is called.  This is because the
// destructor is captured when the &#39;ManagedPtr&#39; constructor is called, and has
// access to the complete type of each shape object.
//..
//  void testShapes()
//  {
//      bslma::ManagedPtr&lt;Shape&gt; shape = makeShape(Shapes::SHAPE_CIRCLE, 1.0);
//      assert(0 != shape);
//      assert(3.141592653589793238462 == shape-&gt;area());
//
//      shape = makeShape(Shapes::SHAPE_SQUARE, 2.0);
//      assert(0 != shape);
//      assert(4.0 == shape-&gt;area());
//  }
//..
// Next, we observe that as we are creating objects dynamically, we should pass
// an allocator to the &#39;makeShape&#39; function, rather than simply accepting the
// default allocator each time.  Note that when we do this, we pass the user&#39;s
// allocator to the &#39;ManagedPtr&#39; object as the &quot;factory&quot;.
//..
//  bslma::ManagedPtr&lt;Shape&gt; makeShape(Shapes::VALUES    kind,
//                                    double            dimension,
//                                    bslma::Allocator *allocator)
//  {
//      bslma::Allocator *alloc = bslma::Default::allocator(allocator);
//      bslma::ManagedPtr&lt;Shape&gt; result;
//      switch (kind) {
//      case Shapes::SHAPE_CIRCLE : {
//              Circle *circ = new(*alloc)Circle(dimension);
//              result.load(circ, alloc);
//              break;
//          }
//      case Shapes::SHAPE_SQUARE : {
//              Square *sqr = new(*alloc)Square(dimension);
//              result.load(sqr, alloc);
//              break;
//          }
//      };
//      return result;
//  }
//..
// Finally we repeat the earlier test, additionally passing a test allocator:
//..
//  void testShapesToo()
//  {
//      bslma::TestAllocator ta(&quot;object&quot;);
//
//      bslma::ManagedPtr&lt;Shape&gt; shape =
//                                   makeShape(Shapes::SHAPE_CIRCLE, 1.0, &amp;ta);
//      assert(0 != shape);
//      assert(3.141592653589793238462 == shape-&gt;area());
//
//      shape = makeShape(Shapes::SHAPE_SQUARE, 3.0, &amp;ta);
//      assert(0 != shape);
//      assert(9.0 == shape-&gt;area());
//  }
//..
//
///Example 2: Aliasing
///- - - - - - - - - -
// Suppose that we wish to give access to an item in a temporary array via a
// pointer which we&#39;ll call the &quot;finger&quot;.  The finger is the only pointer to
// the array or any part of the array, but the entire array must be valid until
// the finger is destroyed, at which time the entire array must be deleted.  We
// handle this situation by first creating a managed pointer to the entire
// array, then creating an alias of that pointer for the finger.  The finger
// takes ownership of the array instance, and when the finger is destroyed, it
// is the array&#39;s address, rather than the finger, that is passed to the
// deleter.
//
// First, let&#39;s say our array stores data acquired from a ticker plant
// accessible by a global &#39;getQuote&#39; function:
//..
//  struct Ticker {
//
//      static double getQuote() // From ticker plant.  Simulated here
//      {
//          static const double QUOTES[] = {
//          7.25, 12.25, 11.40, 12.00, 15.50, 16.25, 18.75, 20.25, 19.25, 21.00
//          };
//          static const int NUM_QUOTES = sizeof(QUOTES) / sizeof(QUOTES[0]);
//          static int index = 0;
//
//          double ret = QUOTES[index];
//          index = (index + 1) % NUM_QUOTES;
//          return ret;
//      }
//  };
//..
// Then, we want to find the first quote larger than a specified threshold, but
// would also like to keep the earlier and later quotes for possible
// examination.  Our &#39;getFirstQuoteLargerThan&#39; function must allocate memory
// for an array of quotes (the threshold and its neighbors).  It thus returns a
// managed pointer to the desired value:
//..
//  const double END_QUOTE = -1;
//
//  bslma::ManagedPtr&lt;double&gt;
//  getFirstQuoteLargerThan(double threshold, bslma::Allocator *allocator)
//  {
//      assert(END_QUOTE &lt; 0 &amp;&amp; 0 &lt;= threshold);
//..
// Next, we allocate our array with extra room to mark the beginning and end
// with a special &#39;END_QUOTE&#39; value:
//..
//      const int MAX_QUOTES = 100;
//      int numBytes = (MAX_QUOTES + 2) * sizeof(double);
//      double *quotes = (double*) allocator-&gt;allocate(numBytes);
//      quotes[0] = quotes[MAX_QUOTES + 1] = END_QUOTE;
//..
// Then, we create a managed pointer to the entire array:
//..
//      bslma::ManagedPtr&lt;double&gt; managedQuotes(quotes, allocator);
//..
// Next, we read quotes until the array is full, keeping track of the first
// quote that exceeds the threshold.
//..
//      double *finger = 0;
//
//      for (int i = 1; i &lt;= MAX_QUOTES; ++i) {
//          double quote = Ticker::getQuote();
//          quotes[i] = quote;
//          if (!finger &amp;&amp; quote &gt; threshold) {
//              finger = &amp;quotes[i];
//          }
//      }
//..
// Now, we use the alias constructor to create a managed pointer that points to
// the desired value (the finger) but manages the entire array:
//..
//      return bslma::ManagedPtr&lt;double&gt;(managedQuotes, finger);
//  }
//..
// Then, our main program calls &#39;getFirstQuoteLargerThan&#39; like this:
//..
//  int aliasExample()
//  {
//      bslma::TestAllocator ta;
//      bslma::ManagedPtr&lt;double&gt; result = getFirstQuoteLargerThan(16.00, &amp;ta);
//      assert(*result &gt; 16.00);
//      assert(1 == ta.numBlocksInUse());
//      if (g_verbose) bsl::cout &lt;&lt; &quot;Found quote: &quot; &lt;&lt; *result &lt;&lt; bsl::endl;
//..
// Next, We also print the preceding 5 quotes in last-to-first order:
//..
//      if (g_verbose) bsl::cout &lt;&lt; &quot;Preceded by:&quot;;
//      int i;
//      for (i = -1; i &gt;= -5; --i) {
//          double quote = result.get()[i];
//          if (END_QUOTE == quote) {
//              break;
//          }
//          assert(quote &lt; *result);
//          if (g_verbose) bsl::cout &lt;&lt; &#39; &#39; &lt;&lt; quote;
//      }
//      if (g_verbose) bsl::cout &lt;&lt; bsl::endl;
//..
// Then, to move the finger, e.g., to the last position printed, one must be
// careful to retain the ownership of the entire array.  Using the statement
// &#39;result.load(result.get()-i)&#39; would be an error, because it would first
// compute the pointer value &#39;result.get()-i&#39; of the argument, then release the
// entire array before starting to manage what has now become an invalid
// pointer.  Instead, &#39;result&#39; must retain its ownership to the entire array,
// which can be attained by:
//..
//      result.loadAlias(result, result.get()-i);
//..
// Finally, if we reset the result pointer, the entire array is deallocated:
//..
//      result.reset();
//      assert(0 == ta.numBlocksInUse());
//      assert(0 == ta.numBytesInUse());
//
//      return 0;
//  }
//..
//
///Example 3: Dynamic Objects and Factories
/// - - - - - - - - - - - - - - - - - - - -
// Suppose we want to track the number of objects currently managed by
// &#39;ManagedPtr&#39; objects.
//
// First we define a factory type, that holds an allocator and a usage-counter.
// Note that such a type cannot sensibly be copied, as the notion &#39;count&#39;
// becomes confused.
//..
//  class CountedFactory {
//      // DATA
//      int               d_count;
//      bslma::Allocator *d_allocator_p;
//
//      // NOT IMPLEMENTED
//      CountedFactory(const CountedFactory&amp;);
//      CountedFactory&amp; operator=(const CountedFactory&amp;);
//
//    public:
//      // CREATORS
//      explicit CountedFactory(bslma::Allocator *alloc = 0);
//          // Create a &#39;CountedFactory&#39; object which uses the supplied
//          // allocator &#39;alloc&#39;.
//
//      ~CountedFactory();
//          // Destroy this object.
//..
// Next, we provide the &#39;createObject&#39; and &#39;deleteObject&#39; functions that are
// standard for factory objects.  Note that the &#39;deleteObject&#39; function
// signature has the form required by &#39;bslma::ManagedPtr&#39; for a factory.
//..
//      // MANIPULATORS
//      template &lt;class TYPE&gt;
//      TYPE *createObject();
//          // Return a pointer to a newly allocated object of type &#39;TYPE&#39;
//          // created using its default constructor.  Memory for the object
//          // is supplied by the allocator supplied to this factory&#39;s
//          // constructor, and the count of valid object is incremented.
//
//      template &lt;class TYPE&gt;
//      void deleteObject(const TYPE *target);
//          // Destroy the object pointed to by &#39;target&#39; and reclaim the
//          // memory.  Decrement the count of currently valid objects.
//..
// Then, we round out the class with the ability to query the &#39;count&#39; of
// currently allocated objects.
//..
//      // ACCESSORS
//      int count() const;
//          // Return the number of currently valid objects allocated by this
//          // factory.
//  };
//..
// Next, we define the operations declared by the class.
//..
//  CountedFactory::CountedFactory(bslma::Allocator *alloc)
//  : d_count(0)
//  , d_allocator_p(bslma::Default::allocator(alloc))
//  {
//  }
//
//  CountedFactory::~CountedFactory()
//  {
//      assert(0 == d_count);
//  }
//
//  template &lt;class TYPE&gt;
//  TYPE *CountedFactory::createObject()
//  {
//      TYPE *result = new(*d_allocator_p)TYPE;
//      ++d_count;
//      return result;
//  }
//
//  template &lt;class TYPE&gt;
//  void CountedFactory::deleteObject(const TYPE *object)
//  {
//      d_allocator_p-&gt;deleteObject(object);
//      --d_count;
//  }
//
//  inline
//  int CountedFactory::count() const
//  {
//      return d_count;
//  }
//..
// Then, we can create a test function to illustrate how such a factory would
// be used with &#39;ManagedPtr&#39;.
//..
//  void testCountedFactory()
//  {
//..
// Next, we declare a test allocator, and an object of our &#39;CountedFactory&#39;
// type using that allocator.
//..
//      bslma::TestAllocator ta;
//      CountedFactory cf(&amp;ta);
//..
// Then, we open a new local scope and declare an array of managed pointers.
// We need a local scope in order to observe the behavior of the destructors at
// end of the scope, and use an array as an easy way to count more than one
// object.
//..
//      {
//          bslma::ManagedPtr&lt;int&gt; pData[4];
//..
// Next, we load each managed pointer in the array with a new &#39;int&#39; using our
// factory &#39;cf&#39; and assert that the factory &#39;count&#39; is correct after each new
// &#39;int&#39; is created.
//..
//          int i = 0;
//          while (i != 4) {
//              pData[i++].load(cf.createObject&lt;int&gt;(), &amp;cf);
//              assert(cf.count() == i);
//          }
//..
// Then, we &#39;reset&#39; the contents of a single managed pointer in the array, and
// assert that the factory &#39;count&#39; is appropriately reduced.
//..
//          pData[1].reset();
//          assert(3 == cf.count());
//..
// Next, we &#39;load&#39; a managed pointer with another new &#39;int&#39; value, again using
// &#39;cf&#39; as the factory, and assert that the &#39;count&#39; of valid objects remains
// the same (destroy one object and add another).
//..
//          pData[2].load(cf.createObject&lt;int&gt;(), &amp;cf);
//          assert(3 == cf.count());
//      }
//..
// Finally, we allow the array of managed pointers to go out of scope and
// confirm that when all managed objects are destroyed, the factory &#39;count&#39;
// falls to zero, and does not overshoot.
//..
//      assert(0 == cf.count());
//  }
//..
//
///Example 4: Type Casting
///- - - - - - - - - - - -
// &#39;ManagedPtr&#39; objects can be implicitly and explicitly cast to different
// types in the same way that native pointers can.
//
///Implicit Conversion
/// -  -  -  -  -  - -
// As with native pointers, a pointer of the type &#39;B&#39; that is publicly derived
// from the type &#39;A&#39;, can be directly assigned a &#39;ManagedPtr&#39; of &#39;A&#39;.
//
// First, consider the following code snippets:
//..
//  void implicitCastingExample()
//  {
//..
// If the statements:
//..
//      bslma::TestAllocator localDefaultTa;
//      bslma::TestAllocator localTa;
//
//      bslma::DefaultAllocatorGuard guard(&amp;localDefaultTa);
//
//      int numdels = 0;
//
//      {
//          B *b_p = 0;
//          A *a_p = b_p;
//..
// are legal expressions, then the statements
//..
//          bslma::ManagedPtr&lt;A&gt; a_mp1;
//          bslma::ManagedPtr&lt;B&gt; b_mp1;
//
//          assert(!a_mp1 &amp;&amp; !b_mp1);
//
//          a_mp1 = b_mp1;      // conversion assignment of nil ptr to nil
//          assert(!a_mp1 &amp;&amp; !b_mp1);
//
//          B *b_p2 = new (localDefaultTa) B(&amp;numdels);
//          bslma::ManagedPtr&lt;B&gt; b_mp2(b_p2);    // default allocator
//          assert(!a_mp1 &amp;&amp; b_mp2);
//
//          a_mp1 = b_mp2;      // conversion assignment of nonnil ptr to nil
//          assert(a_mp1 &amp;&amp; !b_mp2);
//
//          B *b_p3 = new (localTa) B(&amp;numdels);
//          bslma::ManagedPtr&lt;B&gt; b_mp3(b_p3, &amp;localTa);
//          assert(a_mp1 &amp;&amp; b_mp3);
//
//          a_mp1 = b_mp3;      // conversion assignment of nonnil to nonnil
//          assert(a_mp1 &amp;&amp; !b_mp3);
//
//          a_mp1 = b_mp3;      // conversion assignment of nil to nonnil
//          assert(!a_mp1 &amp;&amp; !b_mp3);
//
//          // constructor conversion init with nil
//          bslma::ManagedPtr&lt;A&gt; a_mp4(b_mp3, b_mp3.get());
//          assert(!a_mp4 &amp;&amp; !b_mp3);
//
//          // constructor conversion init with nonnil
//          B *p_b5 = new (localTa) B(&amp;numdels);
//          bslma::ManagedPtr&lt;B&gt; b_mp5(p_b5, &amp;localTa);
//          bslma::ManagedPtr&lt;A&gt; a_mp5(b_mp5, b_mp5.get());
//          assert(a_mp5 &amp;&amp; !b_mp5);
//          assert(a_mp5.get() == p_b5);
//
//          // constructor conversion init with nonnil
//          B *p_b6 = new (localTa) B(&amp;numdels);
//          bslma::ManagedPtr&lt;B&gt; b_mp6(p_b6, &amp;localTa);
//          bslma::ManagedPtr&lt;A&gt; a_mp6(b_mp6);
//          assert(a_mp6 &amp;&amp; !b_mp6);
//          assert(a_mp6.get() == p_b6);
//
//          struct S {
//              int d_i[10];
//          };
//
//          assert(200 == numdels);
//      }
//
//      assert(400 == numdels);
//  } // implicitCastingExample()
//..
//
///Explicit Conversion
/// -  -  -  -  -  - -
// Through &quot;aliasing&quot;, a managed pointer of any type can be explicitly
// converted to a managed pointer of any other type using any legal cast
// expression.  For example, to static-cast a managed pointer of type A to a
// managed pointer of type B, one can simply do the following:
//..
//  void explicitCastingExample() {
//
//      bslma::ManagedPtr&lt;A&gt; a_mp;
//      bslma::ManagedPtr&lt;B&gt; b_mp1(a_mp, static_cast&lt;B*&gt;(a_mp.get()));
//..
// or even use the less safe &quot;C&quot;-style casts:
//..
//      // bslma::ManagedPtr&lt;A&gt; a_mp;
//      bslma::ManagedPtr&lt;B&gt; b_mp2(a_mp, (B*)(a_mp.get()));
//
//  } // explicitCastingExample()
//..
// Note that when using dynamic cast, if the cast fails, the target managed
// pointer will be reset to an unset state, and the source will not be
// modified.  Consider for example the following snippet of code:
//..
//  void processPolymorphicObject(bslma::ManagedPtr&lt;A&gt; aPtr,
//                                bool *castSucceeded)
//  {
//      bslma::ManagedPtr&lt;B&gt; bPtr(aPtr, dynamic_cast&lt;B*&gt;(aPtr.get()));
//      if (bPtr) {
//          assert(!aPtr);
//          *castSucceeded = true;
//      }
//      else {
//          assert(aPtr);
//          *castSucceeded = false;
//      }
//  }
//..
// If the value of &#39;aPtr&#39; can be dynamically cast to &#39;B*&#39; then ownership is
// transferred to &#39;bPtr&#39;, otherwise &#39;aPtr&#39; is to be modified.  As previously
// stated, the managed object will be destroyed correctly regardless of how it
// is cast.

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEFAULT
#include &lt;bslma_default.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTR_FACTORYDELETER
#include &lt;bslma_managedptr_factorydeleter.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTR_MEMBERS
#include &lt;bslma_managedptr_members.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTR_PAIRPROXY
#include &lt;bslma_managedptr_pairproxy.h&gt;
#endif

#ifndef INCLUDED_BSLMA_MANAGEDPTRDELETER
#include &lt;bslma_managedptrdeleter.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ADDREFERENCE
#include &lt;bslmf_addreference.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ASSERT
#include &lt;bslmf_assert.h&gt;
#endif

#ifndef INCLUDED_BSLMF_HASPOINTERSEMANTICS
#include &lt;bslmf_haspointersemantics.h&gt;
#endif

#ifndef INCLUDED_BSLMF_IF
#include &lt;bslmf_if.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISCONVERTIBLE
#include &lt;bslmf_isconvertible.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISVOID
#include &lt;bslmf_isvoid.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_NULLPTR
#include &lt;bsls_nullptr.h&gt;
#endif

#ifndef INCLUDED_BSLS_UNSPECIFIEDBOOL
#include &lt;bsls_unspecifiedbool.h&gt;
#endif

namespace BloombergLP {

namespace bslma {

                    // ============================
                    // private class ManagedPtr_Ref
                    // ============================

template &lt;class TARGET_TYPE&gt;
class ManagedPtr_Ref {
    // This struct holds a managed pointer reference, returned by the implicit
    // conversion operator in the class &#39;ManagedPtr&#39;.  This struct is used to
    // allow the construction of managed pointers from temporary managed
    // pointer objects, since temporaries cannot bind to the reference to a
    // modifiable object used in the &quot;copy constructor&quot; and &quot;copy assignment
    // operator&quot; for &#39;ManagedPtr&#39;.  Note that while no members or methods of
    // this class template depend on the specified &#39;TARGET_TYPE&#39;, it is
    // important to carry this type into conversions to support passing
    // ownership of &#39;ManagedPtr_Members&#39; pointers when assigning or
    // constructing &#39;ManagedPtr&#39; objects.

    ManagedPtr_Members *d_base_p;  // non-null pointer to the managed state of
                                   // a &#39;ManagedPtr&#39; object.

    TARGET_TYPE        *d_cast_p;  // safely-cast pointer to the referenced
                                   // object.

  public:
    // CREATORS
    ManagedPtr_Ref(ManagedPtr_Members *base, TARGET_TYPE *target);
        // Create a &#39;ManagedPtr_Ref&#39; object having the specified &#39;base&#39; value
        // for its &#39;base&#39; attribute, and the specified &#39;target&#39; for its
        // &#39;target&#39; attribute.  Note that &#39;target&#39; (but not &#39;base&#39;) may be
        // null.


    //! ManagedPtr_Ref(const ManagedPtr_Ref&amp; original) = default;
        // Create a &#39;ManagedPtr_Ref&#39; object having the same &#39;d_base_p&#39; value as
        // the specified &#39;original&#39;.  Note that this trivial constructor&#39;s
        // definition is compiler generated.

    ~ManagedPtr_Ref();
        // Destroy this object.  Note that the referenced managed object is
        // *not* destroyed.

    //! ManagedPtr_Ref&amp; operator=(const ManagedPtr_Ref&amp; original) = default;
        // Create a &#39;ManagedPtr_Ref&#39; object having the same &#39;d_base_p&#39; as the
        // specified &#39;original&#39;.  Note that this trivial copy-assignment
        // operator&#39;s definition is compiler generated.

    // ACCESSORS
    ManagedPtr_Members *base() const;
        // Return a pointer to the managed state of a &#39;ManagedPtr&#39; object.

    TARGET_TYPE *target() const;
        // Return a pointer to the referenced object.
};

                           // ================
                           // class ManagedPtr
                           // ================

template &lt;class TARGET_TYPE&gt;
class ManagedPtr {
    // This class is a &quot;smart pointer&quot; that refers to a *target* object
    // accessed via a pointer to the specified parameter type, &#39;TARGET_TYPE&#39;,
    // and that supports sole ownership of a *managed* object that is
    // potentially of a different type, and may be an entirely different object
    // from the target object.  A managed pointer ensures that the object it
    // manages is destroyed when the managed pointer is destroyed (or
    // re-assigned), using the &quot;deleter&quot; supplied along with the managed
    // object.  The target object referenced by a managed pointer may be
    // accessed using either the &#39;-&gt;&#39; operator, or the dereference operator
    // (operator &#39;*&#39;).  The specified &#39;TARGET_TYPE&#39; may be &#39;const&#39;-qualified,
    // but may not be &#39;volatile&#39;-qualified, nor may it be a reference type.
    //
    // A managed pointer may be *empty*, in which case it neither refers to a
    // target object nor owns a managed object.  An empty managed pointer is
    // the equivalent of a null pointer: Such a managed pointer is not
    // de-referenceable, and tests as &#39;false&#39; in boolean expressions.
    //
    // A managed pointer for which the managed object is not the same object as
    // the target is said to *alias* the managed object (see the section
    // &quot;Aliasing&quot; in the component-level documentation).

  public:
    // INTERFACE TYPES
    typedef ManagedPtrDeleter::Deleter DeleterFunc;
        // Alias for a function-pointer type for functions used to destroy the
        // object managed by a &#39;ManagedPtr&#39; object.

  private:
    // PRIVATE TYPES
    typedef typename bsls::UnspecifiedBool&lt;ManagedPtr&gt;::BoolType BoolType;
        // &#39;BoolType&#39; is an alias for an unspecified type that is implicitly
        // convertible to &#39;bool&#39;, but will not promote to &#39;int&#39;.  This (opaque)
        // type can be used as an &quot;unspecified boolean type&quot; for converting a
        // managed pointer to &#39;bool&#39; in contexts such as &#39;if (mp) { ... }&#39;
        // without actually having a conversion to &#39;bool&#39; or being less-than
        // comparable (either of which would also enable undesirable implicit
        // comparisons of managed pointers to &#39;int&#39; and less-than comparisons).

    // DATA
    ManagedPtr_Members d_members;  // state managed by this object

    // PRIVATE CLASS METHODS
    static void *stripBasePointerType(TARGET_TYPE *ptr);
        // Return the value of the specified &#39;ptr&#39; as a &#39;void *&#39;, after
        // stripping all &#39;const&#39; and &#39;volatile&#39; qualifiers from &#39;TARGET_TYPE&#39;.
        // This function avoids accidental type-safety errors when performing
        // the necessary sequence of casts.  Note that calling this function
        // implies a conversion of the calling pointer to &#39;TARGET_TYPE *&#39;,
        // which, in rare cases, may involve some adjustment of the pointer
        // value, e.g., in the case of multiple inheritance where &#39;TARGET_TYPE&#39;
        // is not a left-most base of the complete object type.

    template &lt;class MANAGED_TYPE&gt;
    static void *stripCompletePointerType(MANAGED_TYPE *ptr);
        // Return the value of the specified &#39;ptr&#39; as a &#39;void *&#39;, after
        // stripping all &#39;const&#39; and &#39;volatile&#39; qualifiers from &#39;TARGET_TYPE&#39;.
        // This function avoids accidental type-safety errors when performing
        // the necessary sequence of casts.

    // PRIVATE MANIPULATORS
    template &lt;class MANAGED_TYPE&gt;
    void loadImp(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified &#39;ptr&#39;, take ownership of &#39;*ptr&#39; as the currently managed
        // object, and set a deleter that will invoke the specified &#39;deleter&#39;
        // with the address of the currently managed object, and with the
        // specified &#39;cookie&#39; (that the deleter can use for its own purposes),
        // unless &#39;0 == ptr&#39;, in which case reset this managed pointer as
        // empty.  The behavior is undefined if &#39;ptr&#39; is already managed by
        // another object, or if &#39;0 == deleter &amp;&amp; 0 != ptr&#39;.

  private:
    // NOT IMPLEMENTED
    template &lt;class MANAGED_TYPE&gt;
    ManagedPtr(MANAGED_TYPE *, bsl::nullptr_t);
        // It is never defined behavior to pass a null pointer literal as a
        // factory, unless the specified &#39;ptr&#39; is also a null pointer literal.

  private:
    // NOT IMPLEMENTED
    template &lt;class MANAGED_TYPE, class COOKIE_TYPE&gt;
    ManagedPtr(MANAGED_TYPE *, COOKIE_TYPE *, bsl::nullptr_t);
        // It is never defined behavior to pass a null literal as a deleter,
        // unless the &#39;object&#39; pointer is also a null pointer literal.

  private:
    // NOT IMPLEMENTED
    template &lt;class MANAGED_TYPE&gt;
    void load(MANAGED_TYPE *, bsl::nullptr_t, bsl::nullptr_t);
    template &lt;class COOKIE_TYPE&gt;
    void load(TARGET_TYPE *, COOKIE_TYPE *, bsl::nullptr_t);
        // It is never defined behavior to pass a null literal as a deleter,
        // unless the &#39;object&#39; pointer is also a null pointer literal.

  private:
    // NOT IMPLEMENTED
    void operator==(const ManagedPtr&amp;) const;
    void operator!=(const ManagedPtr&amp;) const;
        // These two operator overloads are declared as &#39;private&#39; but never
        // defined in order to eliminate accidental equality comparisons that
        // would occur through the implicit conversion to &#39;BoolType&#39;.  Note
        // that the return type of &#39;void&#39; is chosen as it will often produce a
        // clearer error message than relying on the &#39;private&#39; control failure.
        // Note that these private operators will not be needed with C++11,
        // where an &#39;explicit operator bool()&#39; conversion operator would be
        // preferred.

    // FRIENDS
    template &lt;class ALIASED_TYPE&gt;
    friend class ManagedPtr;  // required only for alias support

  public:
    // CREATORS
    explicit ManagedPtr(bsl::nullptr_t = 0, bsl::nullptr_t = 0);
        // Create an empty managed pointer.  Note that this constructor is
        // necessary to match null-pointer literal arguments, in order to break
        // ambiguities and provide valid type deduction with the other
        // constructor templates in this class.

    template &lt;class MANAGED_TYPE&gt;
    explicit ManagedPtr(MANAGED_TYPE *ptr);
        // Create a managed pointer having a target object referenced by the
        // specified &#39;ptr&#39;, owning the managed object &#39;*ptr&#39;, and having a
        // deleter that uses the currently installed default allocator to
        // destroy the managed object when invoked (e.g., when this managed
        // pointer object is destroyed), unless &#39;0 == ptr&#39;, in which case
        // create an empty managed pointer.  The deleter will invoke the
        // destructor of &#39;MANAGED_TYPE&#39; rather than the destructor of
        // &#39;TARGET_TYPE&#39;.  This constructor will not compile unless
        // &#39;MANAGED_TYPE *&#39; is convertible to &#39;TARGET_TYPE *&#39;.  The behavior is
        // undefined unless the managed object (if any) can be destroyed by the
        // currently installed default allocator, or if the the lifetime of the
        // managed object is already managed by another object.  Note that this
        // behavior allows &#39;ManagedPtr&#39; to be defined for &#39;void&#39; pointers, and
        // to call the correct destructor for the managed object, even if the
        // destructor for &#39;TARGET_TYPE&#39; is not declared as &#39;virtual&#39;.

    ManagedPtr(ManagedPtr&amp; original);
        // Create a managed pointer having the same target object as the
        // specified &#39;original&#39;, and transfer the ownership of the object
        // managed by the &#39;original&#39; (if any) to this managed pointer, then
        // reset &#39;original&#39; as empty.

    ManagedPtr(ManagedPtr_Ref&lt;TARGET_TYPE&gt; ref);                    // IMPLICIT
        // Create a managed pointer having the same target object as the
        // managed pointer referenced by the specified &#39;ref&#39;, and transfer
        // ownership of the managed object owned by the managed pointer
        // referenced by &#39;ref&#39;, then reset the managed pointer referenced by
        // &#39;ref&#39; as empty.  This constructor is used to create a managed
        // pointer from a managed pointer rvalue, or from a managed pointer to
        // a &quot;compatible&quot; type, where &quot;compatible&quot; means a built-in conversion
        // from &#39;COMPATIBLE_TYPE *&#39; to &#39;TARGET_TYPE *&#39; is defined, e.g.,
        // &#39;derived *&#39; -&gt; &#39;base *&#39;, &#39;int *&#39; -&gt; &#39;const int *&#39;, or
        // &#39;anyType *&#39; -&gt; &#39;void *&#39;.

    template &lt;class ALIASED_TYPE&gt;
    ManagedPtr(ManagedPtr&lt;ALIASED_TYPE&gt;&amp; alias, TARGET_TYPE *ptr);
        // Create a managed pointer that takes ownership of the object managed
        // by the specified &#39;alias&#39;, but which uses the specified &#39;ptr&#39; to
        // refer to its target object, unless &#39;0 == ptr&#39;, in which case create
        // an empty managed pointer.  Reset &#39;alias&#39; as empty if ownership of
        // its managed object is transferred.  The behavior is undefined if
        // &#39;alias&#39; is empty, but &#39;0 != ptr&#39;.  Note that destroying or
        // re-assigning a managed pointer created with this constructor will
        // destroy the object originally managed by &#39;alias&#39; (unless &#39;release&#39;
        // is called first); the destructor for &#39;*ptr&#39; is not called directly.

    template &lt;class MANAGED_TYPE, class FACTORY_TYPE&gt;
    ManagedPtr(MANAGED_TYPE *ptr, FACTORY_TYPE *factory);
        // Create a managed pointer having a target object referenced by the
        // specified &#39;ptr&#39;, owning the managed object &#39;*ptr&#39;, and having a
        // deleter that will call &#39;factory-&gt;deleteObject(ptr)&#39; to destroy the
        // managed object when invoked (e.g., when this managed pointer object
        // is destroyed), unless &#39;0 == ptr&#39;, in which case create an empty
        // managed pointer.  The deleter will invoke the destructor of
        // &#39;MANAGED_TYPE&#39; rather than the destructor of &#39;TARGET_TYPE&#39;.  This
        // constructor will not compile unless &#39;MANAGED_TYPE *&#39; is convertible
        // to &#39;TARGET_TYPE *&#39;.  The behavior is undefined unless the managed
        // object (if any) can be destroyed by the specified &#39;factory&#39;, or if
        // &#39;0 == factory &amp;&amp; 0 != ptr&#39;, or if the the lifetime of the managed
        // object is already managed by another object.  Note that
        // &#39;bslma::Allocator&#39;, and any class publicly and unambiguously derived
        // from &#39;bslma::Allocator&#39;, meets the requirements for &#39;FACTORY_TYPE&#39;.

    template &lt;class FACTORY_TYPE&gt;
    ManagedPtr(bsl::nullptr_t, FACTORY_TYPE *factory);
        // Create an empty managed pointer.  Note that the specified &#39;factory&#39;
        // is ignored, as an empty managed pointer does not call its deleter.

    ManagedPtr(TARGET_TYPE *ptr, void *cookie, DeleterFunc deleter);
        // Create a managed pointer having a target object referenced by the
        // specified &#39;ptr&#39;, owning the managed object &#39;*ptr&#39;, and having a
        // deleter that will invoke the specified &#39;deleter&#39; with the address of
        // the currently managed object, and with the specified &#39;cookie&#39; (that
        // the deleter can use for its own purposes), unless &#39;0 == ptr&#39;, in
        // which case create an empty managed pointer.  This constructor will
        // not compile unless &#39;MANAGED_TYPE*&#39; is convertible to &#39;TARGET_TYPE*&#39;.
        // The deleter will invoke the destructor of &#39;MANAGED_TYPE&#39; rather than
        // the destructor of &#39;TARGET_TYPE&#39;.  The behavior is undefined if &#39;ptr&#39;
        // is already managed by another object, or if
        // &#39;0 == deleter &amp;&amp; 0 != ptr&#39;.  Note that this declaration is required
        // only because the deprecated overloads create an ambiguity in this
        // case.  It should be removed when the deprecated overloads are
        // removed.

    template &lt;class MANAGED_TYPE&gt;
    ManagedPtr(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        // Create a managed pointer having a target object referenced by the
        // specified &#39;ptr&#39;, owning the managed object &#39;*ptr&#39;, and having a
        // deleter that will invoke the specified &#39;deleter&#39; with the address of
        // the currently managed object, and with the specified &#39;cookie&#39; (that
        // the deleter can use for its own purposes), unless &#39;0 == ptr&#39;, in
        // which case create an empty managed pointer.  This constructor will
        // not compile unless &#39;MANAGED_TYPE*&#39; is convertible to &#39;TARGET_TYPE*&#39;.
        // The deleter will invoke the destructor of &#39;MANAGED_TYPE&#39; rather than
        // the destructor of &#39;TARGET_TYPE&#39;.  The behavior is undefined if &#39;ptr&#39;
        // is already managed by another object, or if
        // &#39;0 == deleter &amp;&amp; 0 != ptr&#39;.


    ~ManagedPtr();
        // Destroy this managed pointer object.  Destroy the object managed by
        // this managed pointer by invoking the user-supplied deleter, unless
        // this managed pointer is empty, in which case the deleter will *not*
        // be called.

    // MANIPULATORS
    ManagedPtr&amp; operator=(ManagedPtr&amp; rhs);
        // If this object and the specified &#39;rhs&#39; manage the same object,
        // return a reference to this managed pointer; otherwise destroy the
        // manged object owned by this managed pointer, then transfer ownership
        // of the managed object owned by &#39;rhs&#39;, and set this managed pointer
        // to point to the target object currently referenced by &#39;rhs&#39;, then
        // reset &#39;rhs&#39; as empty, and return a reference to this managed
        // pointer.

    ManagedPtr&amp; operator=(ManagedPtr_Ref&lt;TARGET_TYPE&gt; ref);
        // If this object and the managed pointer reference by the specified
        // &#39;ref&#39; manage the same object, return a reference to this managed
        // pointer; otherwise destroy the manged object owned by this managed
        // pointer, then transfer ownership of the managed object owned by the
        // managed pointer referenced by &#39;ref&#39;, and set this managed pointer to
        // point to the target object currently referenced the managed pointer
        // referenced by &#39;ref&#39;; then reset the managed pointer referenced by
        // &#39;ref&#39; as empty, and return a reference to this managed pointer.
        // This operator is (implicitly) used to assign from a managed pointer
        // rvalue, or from a managed pointer to a &quot;compatible&quot; type, where
        // &quot;compatible&quot; means a built-in conversion from &#39;MANAGED_TYPE *&#39; to
        // &#39;TARGET_TYPE *&#39; is defined, e.g., &#39;derived *&#39; -&gt; &#39;base *&#39;,
        // &#39;T *&#39; -&gt; &#39;const T *&#39;, or &#39;T *&#39; -&gt; &#39;void *&#39;.

    ManagedPtr&amp; operator=(bsl::nullptr_t);
        // Destroy the current managed object (if any) and reset this managed
        // pointer as empty.

    template &lt;class REFERENCED_TYPE&gt;
    operator ManagedPtr_Ref&lt;REFERENCED_TYPE&gt;();
        // Return a managed pointer reference, referring to this object.  Note
        // that this conversion operator is used implicitly to allow the
        // construction of managed pointers from rvalues because temporaries
        // cannot be passed by references offering modifiable access.

    void clear();
        // [!DEPRECATED!] Use &#39;reset&#39; instead.
        //
        // Destroy the current managed object (if any) and reset this managed
        // pointer as empty.

    template &lt;class MANAGED_TYPE&gt;
    void load(MANAGED_TYPE *ptr);
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified &#39;ptr&#39;, take ownership of &#39;*ptr&#39; as the currently managed
        // object, and set a deleter that uses the currently installed default
        // allocator to destroy the managed object when invoked (e.g., when
        // this managed pointer object is destroyed), unless &#39;0 == ptr&#39;, in
        // which case reset this managed pointer as empty.  The deleter will
        // invoke the destructor of &#39;MANAGED_TYPE&#39; rather than the destructor
        // of &#39;TARGET_TYPE&#39;.  This function will not compile unless
        // &#39;MANAGED_TYPE *&#39; is convertible to &#39;TARGET_TYPE *&#39;.  The behavior is
        // undefined unless the managed object (if any) can be destroyed by the
        // currently installed default allocator, or if the the lifetime of the
        // managed object is already managed by another object.

    template &lt;class MANAGED_TYPE, class FACTORY_TYPE&gt;
    void load(MANAGED_TYPE *ptr, FACTORY_TYPE *factory);
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified &#39;ptr&#39;, take ownership of &#39;*ptr&#39; as the currently managed
        // object, and set a deleter that calls &#39;factory-&gt;deleteObject(ptr)&#39; to
        // destroy the managed object when invoked (e.g., when this managed
        // pointer object is destroyed), unless &#39;0 == ptr&#39;, in which case reset
        // this managed pointer as empty.  The deleter will invoke the
        // destructor of &#39;MANAGED_TYPE&#39; rather than the destructor of
        // &#39;TARGET_TYPE&#39;.  This function will not compile unless
        // &#39;MANAGED_TYPE *&#39; is convertible to &#39;TARGET_TYPE *&#39;.  The behavior is
        // undefined unless the managed object (if any) can be destroyed by the
        // specified &#39;factory&#39;,  or if &#39;0 == factory &amp;&amp; 0 != ptr&#39;, or if the
        // the lifetime of the managed object is already managed by another
        // object.  Note that &#39;bslma::Allocator&#39;, and any class publicly and
        // unambiguously derived from &#39;bslma::Allocator&#39;, meets the
        // requirements for &#39;FACTORY_TYPE&#39;.

    template &lt;class MANAGED_TYPE&gt;
    void load(MANAGED_TYPE *ptr, void *cookie, DeleterFunc deleter);
        // Destroy the currently managed object, if any.  Then, set the target
        // object of this managed pointer to be that referenced by the
        // specified &#39;ptr&#39;, take ownership of &#39;*ptr&#39; as the currently managed
        // object, and set a deleter that will invoke the specified &#39;deleter&#39;
        // with the address of the currently managed object, and with the
        // specified &#39;cookie&#39; (that the deleter can use for its own purposes),
        // unless &#39;0 == ptr&#39;, in which case reset this managed pointer as
        // empty.  The behavior is undefined if &#39;ptr&#39; is already managed by
        // another object, or if &#39;0 == deleter &amp;&amp; 0 != ptr&#39;.  Note that GCC 3.4
        // and earlier versions have a bug in template type deduction/overload
        // resolution that causes ambiguities if this signature is available.
        // This function will be restored on that platform once the deprecated
        // signatures are finally removed.

    void load(bsl::nullptr_t = 0, void *cookie = 0, DeleterFunc deleter = 0);
        // Destroy the current managed object (if any) and reset this managed
        // pointer as empty.  Note that the optionally specified &#39;cookie&#39; and
        // &#39;deleter&#39; will be ignored, as empty managed pointers do not invoke a
        // deleter.


    template &lt;class ALIASED_TYPE&gt;
    void loadAlias(ManagedPtr&lt;ALIASED_TYPE&gt;&amp; alias, TARGET_TYPE *ptr);
        // If the specified &#39;alias&#39; manages the same object as this managed
        // pointer, set the target object of this managed pointer to be that
        // referenced by the specified &#39;ptr&#39;; otherwise, destroy the currently
        // managed object (if any), and if &#39;alias&#39; is empty, reset this managed
        // pointer as empty, otherwise transfer ownership (and the deleter) of
        // the object managed by &#39;alias&#39;, and set the target object of this
        // managed pointer to be that referenced by &#39;ptr&#39;.  The behavior is
        // undefined if &#39;0 == ptr&#39; and &#39;alias&#39; is not empty, or if &#39;0 != ptr&#39;
        // and &#39;alias&#39; is empty, or if &#39;ptr&#39; is already managed by a managed
        // pointer other than &#39;alias&#39;.  Note that this establishes a managed
        // pointer where &#39;ptr&#39; aliases &#39;alias&#39;.  The managed object for &#39;alias&#39;
        // will ultimately be destroyed, and the destructor for &#39;ptr&#39; is not
        // called directly.

    ManagedPtr_PairProxy&lt;TARGET_TYPE, ManagedPtrDeleter&gt; release();
        // Return a raw pointer to the current target object (if any) and the
        // deleter for the currently managed object, and reset this managed
        // pointer as empty.  It is undefined behavior to run the returned
        // deleter unless the returned pointer to target object is not null.

    TARGET_TYPE *release(ManagedPtrDeleter *deleter);
        // Load the specified &#39;deleter&#39; for the currently managed object and
        // reset this managed pointer as empty.  Return a raw pointer to the
        // target object (if any) managed by this pointer.  It is undefined
        // behavior to run the returned deleter unless the returned pointer to
        // target object is not null.

    void reset();
        // Destroy the current managed object (if any) and reset this managed
        // pointer as empty.

    void swap(ManagedPtr&amp; other);
        // Exchange the value and ownership of this managed pointer with the
        // specified &#39;other&#39; managed pointer.

    // ACCESSORS
    operator BoolType() const;
        // Return a value of &quot;unspecified bool&quot; type that evaluates to &#39;false&#39;
        // if this managed pointer is empty, and &#39;true&#39; otherwise.  Note that
        // this conversion operator allows a managed pointer to be used within
        // a conditional context, such as within an &#39;if&#39; or &#39;while&#39; statement,
        // but does *not* allow managed pointers to be compared (e.g., via &#39;&lt;&#39;
        // or &#39;&gt;&#39;).  Note that a superior solution is available in C++11 using
        // the &#39;explicit operator bool()&#39; syntax, that removes the need for a
        // special boolean-like type and private equality-comparison operators.

    typename bslmf::AddReference&lt;TARGET_TYPE&gt;::Type operator*() const;
        // Return a reference to the target object.  The behavior is undefined
        // if this managed pointer is empty, or if &#39;TARGET_TYPE&#39; is &#39;void&#39; or
        // &#39;const void&#39;.

    TARGET_TYPE *operator-&gt;() const;
        // Return the address of the target object, or 0 if this managed
        // pointer is empty.

    const ManagedPtrDeleter&amp; deleter() const;
        // Return a reference to the non-modifiable deleter information
        // associated with this managed pointer.  Behavior is undefined if this
        // managed pointer is empty.

    TARGET_TYPE *get() const;
        // Return the address of the target object, or 0 if this managed
        // pointer is empty.

    TARGET_TYPE *ptr() const;
        // [!DEPRECATED!]: Use &#39;get&#39; instead.
        //
        // Return the address of the target object, or 0 if this managed
        // pointer is empty.

};

template &lt;class TARGET_TYPE&gt;
void swap(ManagedPtr&lt;TARGET_TYPE&gt;&amp; a, ManagedPtr&lt;TARGET_TYPE&gt;&amp; b);
    // Efficiently exchange the values of the specified &#39;a&#39; and &#39;b&#39; objects.
    // This function provides the no-throw exception-safety guarantee.

                        // =====================
                        // struct ManagedPtrUtil
                        // =====================

struct ManagedPtrUtil {
    // This utility class provides a general no-op deleter, which is useful
    // when creating managed pointers to stack-allocated objects.

    // CLASS METHODS
    static void noOpDeleter(void *, void *);
        // Deleter function that does nothing.
};

                     // ===========================
                     // struct ManagedPtrNilDeleter
                     // ===========================

template &lt;class TARGET_TYPE&gt;
struct ManagedPtrNilDeleter {
    // [!DEPRECATED!]: Use &#39;ManagedPtrUtil::noOpDeleter&#39; instead.
    //
    // This utility class provides a general no-op deleter, which is useful
    // when creating managed pointers to stack-allocated objects.  Note that
    // the non-template class &#39;ManagedPtrUtil&#39; should be used in preference to
    // this deprecated class, avoiding both template bloat and undefined
    // behavior.

    // CLASS METHODS
    static void deleter(void *, void *);
        // Deleter function that does nothing.
};

             // ===========================================
             // private class ManagedPtr_FactoryDeleterType
             // ===========================================

template &lt;class TARGET_TYPE, class FACTORY_TYPE&gt;
struct ManagedPtr_FactoryDeleterType
    : bslmf::If&lt;bsl::is_convertible&lt;FACTORY_TYPE*, Allocator*&gt;::value,
                ManagedPtr_FactoryDeleter&lt;TARGET_TYPE, Allocator&gt;,
                ManagedPtr_FactoryDeleter&lt;TARGET_TYPE, FACTORY_TYPE&gt; &gt; {
    // This metafunction class-template provides a means to compute the
    // preferred deleter function for a factory class for those methods of
    // &#39;ManagedPtr&#39; that supply only a factory, and no additional deleter
    // function.  The intent is to use a common deleter function for all
    // allocators that implement the &#39;bslma::Allocator&#39; protocol, rather than
    // create a special deleter function based on the complete type of each
    // allocator, each doing the same thing (invoking the virtual function
    // &#39;deleteObject&#39;).
};

              // ========================================
              // private struct ManagedPtr_DefaultDeleter
              // ========================================

template &lt;class MANAGED_TYPE&gt;
struct ManagedPtr_DefaultDeleter {
    // This &#39;struct&#39; provides a function-like managed pointer deleter that
    // invokes &#39;delete&#39; with the passed pointer.

    // CLASS METHODS
    static void deleter(void *ptr, void *);
        // Cast the specified &#39;ptr&#39; to (template parameter) type
        // &#39;MANAGED_TYPE *&#39;, and then call &#39;delete&#39; with the cast pointer.
};

                        // =================================
                        // private struct ManagedPtr_ImpUtil
                        // =================================

struct ManagedPtr_ImpUtil {
    // This &#39;struct&#39; provides a namespace for non-generic implementation
    // utilities shared by all instantiations of the &#39;ManagedPtr&#39; template.

    static void checkDefaultAllocatorIsNewDeleteAllocator();
        // If the currently installed default allocator is not the NewDelete
        // allocator singleton then, if this is the first such occurrence since
        // the current task was started, write a message to the console warning
        // about a pending change of behavior in the next BDE release.
};

// ============================================================================
//              INLINE FUNCTION AND FUNCTION TEMPLATE DEFINITIONS
// ============================================================================

                      // ----------------------------
                      // private class ManagedPtr_Ref
                      // ----------------------------

// CREATOR
template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr_Ref&lt;TARGET_TYPE&gt;::ManagedPtr_Ref(ManagedPtr_Members *base,
                                            TARGET_TYPE        *target)
: d_base_p(base)
, d_cast_p(target)
{
    BSLS_ASSERT_SAFE(0 != base);
}

template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr_Ref&lt;TARGET_TYPE&gt;::~ManagedPtr_Ref()
{
    BSLS_ASSERT_SAFE(0 != d_base_p);
}

// ACCESSORS
template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr_Members *ManagedPtr_Ref&lt;TARGET_TYPE&gt;::base() const
{
    return d_base_p;
}

template &lt;class TARGET_TYPE&gt;
inline
TARGET_TYPE *ManagedPtr_Ref&lt;TARGET_TYPE&gt;::target() const
{
    return d_cast_p;
}
                           // ----------------
                           // class ManagedPtr
                           // ----------------

template &lt;class TARGET_TYPE&gt;
class ManagedPtr&lt;volatile TARGET_TYPE&gt;;
    // This specialization is declared but not defined, in order to provide an
    // early compile-fail check to catch misuse of managed pointer to volatile
    // types, which is explicitly called out as not supported in the primary
    // class template contract.

template &lt;class TARGET_TYPE&gt;
class ManagedPtr&lt;TARGET_TYPE &amp;&gt;;
    // This specialization is declared but not defined, in order to provide an
    // early compile-fail check to catch misuse of managed pointer to reference
    // types, which is explicitly called out as not supported in the primary
    // class template contract.

template &lt;class TARGET_TYPE&gt;
inline
void *ManagedPtr&lt;TARGET_TYPE&gt;::stripBasePointerType(TARGET_TYPE *ptr)
{
    return const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(ptr));
}

template &lt;class TARGET_TYPE&gt;
template &lt;class MANAGED_TYPE&gt;
inline
void *
ManagedPtr&lt;TARGET_TYPE&gt;::stripCompletePointerType(MANAGED_TYPE *ptr)
{
    return const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(ptr));
}

// CREATORS
template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(bsl::nullptr_t, bsl::nullptr_t)
: d_members()
{
}

template &lt;class TARGET_TYPE&gt;
template &lt;class FACTORY_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(bsl::nullptr_t, FACTORY_TYPE *)
: d_members()
{
}

template &lt;class TARGET_TYPE&gt;
template &lt;class MANAGED_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(MANAGED_TYPE *ptr)
: d_members(stripCompletePointerType(ptr),
            0,
            &amp;ManagedPtr_DefaultDeleter&lt;MANAGED_TYPE&gt;::deleter,
            stripBasePointerType(ptr))
{
    BSLMF_ASSERT((bsl::is_convertible&lt;MANAGED_TYPE *, TARGET_TYPE *&gt;::VALUE));
}

template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(ManagedPtr_Ref&lt;TARGET_TYPE&gt; ref)
: d_members(*ref.base())
{
    d_members.setAliasPtr(stripBasePointerType(ref.target()));
}

template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(ManagedPtr&amp; original)
: d_members(original.d_members)
{
}

template &lt;class TARGET_TYPE&gt;
template &lt;class ALIASED_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(ManagedPtr&lt;ALIASED_TYPE&gt;&amp;  alias,
                                    TARGET_TYPE               *ptr)
: d_members()
{
    BSLS_ASSERT_SAFE(0 != alias.ptr() || 0 == ptr);

    if (0 != ptr) {
        d_members.move(&amp;alias.d_members);
        d_members.setAliasPtr(stripBasePointerType(ptr));
    }
}

template &lt;class TARGET_TYPE&gt;
template &lt;class MANAGED_TYPE, class FACTORY_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(MANAGED_TYPE *ptr, FACTORY_TYPE *factory)
: d_members(stripCompletePointerType(ptr),
            factory,
            &amp;ManagedPtr_FactoryDeleterType&lt;MANAGED_TYPE,
                                           FACTORY_TYPE&gt;::Type::deleter,
            stripBasePointerType(ptr))
{
    BSLMF_ASSERT((bsl::is_convertible&lt;MANAGED_TYPE *, TARGET_TYPE *&gt;::value));
    BSLS_ASSERT_SAFE(0 != factory || 0 == ptr);
}

template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(TARGET_TYPE *ptr,
                                    void        *cookie,
                                    DeleterFunc  deleter)
: d_members(stripBasePointerType(ptr), cookie, deleter)
{
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);
}

template &lt;class TARGET_TYPE&gt;
template &lt;class MANAGED_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::ManagedPtr(MANAGED_TYPE *ptr,
                                    void         *cookie,
                                    DeleterFunc   deleter)
: d_members(stripCompletePointerType(ptr),
            cookie,
            deleter,
            stripBasePointerType(ptr))
{
    BSLMF_ASSERT((bsl::is_convertible&lt;MANAGED_TYPE *, TARGET_TYPE *&gt;::value));

    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);
}


template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::~ManagedPtr()
{
    d_members.runDeleter();
}

// PRIVATE MANIPULATORS
template &lt;class TARGET_TYPE&gt;
template &lt;class MANAGED_TYPE&gt;
inline
void ManagedPtr&lt;TARGET_TYPE&gt;::loadImp(MANAGED_TYPE *ptr,
                                      void         *cookie,
                                      DeleterFunc   deleter)
{
    BSLMF_ASSERT((bsl::is_convertible&lt;MANAGED_TYPE *, TARGET_TYPE *&gt;::value));
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);

    d_members.runDeleter();
    d_members.set(stripCompletePointerType(ptr), cookie, deleter);
    d_members.setAliasPtr(stripBasePointerType(ptr));
}

// MANIPULATORS
template &lt;class TARGET_TYPE&gt;
inline
void ManagedPtr&lt;TARGET_TYPE&gt;::clear()
{
    reset();
}

template &lt;class TARGET_TYPE&gt;
template &lt;class MANAGED_TYPE&gt;
inline
void ManagedPtr&lt;TARGET_TYPE&gt;::load(MANAGED_TYPE *ptr,
                                   void         *cookie,
                                   DeleterFunc   deleter)
{
    BSLMF_ASSERT((bsl::is_convertible&lt;MANAGED_TYPE *, TARGET_TYPE *&gt;::value));
    BSLS_ASSERT_SAFE(0 != deleter || 0 == ptr);

    this-&gt;loadImp(ptr, cookie, deleter);
}

template &lt;class TARGET_TYPE&gt;
template &lt;class MANAGED_TYPE&gt;
inline
void ManagedPtr&lt;TARGET_TYPE&gt;::load(MANAGED_TYPE *ptr)
{
    BSLMF_ASSERT((bsl::is_convertible&lt;MANAGED_TYPE *, TARGET_TYPE *&gt;::value));
    typedef ManagedPtr_FactoryDeleter&lt;MANAGED_TYPE, Allocator&gt; DeleterFactory;
    this-&gt;loadImp(ptr,
                  static_cast&lt;void *&gt;(Default::allocator()),
                  &amp;DeleterFactory::deleter);
}

template &lt;class TARGET_TYPE&gt;
template &lt;class MANAGED_TYPE, class FACTORY_TYPE&gt;
inline
void ManagedPtr&lt;TARGET_TYPE&gt;::load(MANAGED_TYPE *ptr, FACTORY_TYPE *factory)
{
    BSLMF_ASSERT((bsl::is_convertible&lt;MANAGED_TYPE *, TARGET_TYPE *&gt;::value));
    BSLS_ASSERT_SAFE(0 != factory || 0 == ptr);

    typedef typename
    ManagedPtr_FactoryDeleterType&lt;MANAGED_TYPE, FACTORY_TYPE&gt;::Type
                                                                DeleterFactory;

    this-&gt;loadImp(ptr, static_cast&lt;void *&gt;(factory), &amp;DeleterFactory::deleter);
}

template &lt;class TARGET_TYPE&gt;
inline
void ManagedPtr&lt;TARGET_TYPE&gt;::load(bsl::nullptr_t, void *, DeleterFunc)
{
    this-&gt;clear();
}


template &lt;class TARGET_TYPE&gt;
template &lt;class ALIASED_TYPE&gt;
void ManagedPtr&lt;TARGET_TYPE&gt;::loadAlias(ManagedPtr&lt;ALIASED_TYPE&gt;&amp;  alias,
                                        TARGET_TYPE               *ptr)
{
    BSLS_ASSERT_SAFE((0 == ptr &amp;&amp; 0 == alias.ptr())
                   ||(0 != ptr &amp;&amp; 0 != alias.ptr()));

    if (ptr &amp;&amp; alias.d_members.pointer()) {
        d_members.moveAssign(&amp;alias.d_members);
        d_members.setAliasPtr(stripBasePointerType(ptr));
    }
    else {
        d_members.runDeleter();
        d_members.clear();
    }
}

template &lt;class TARGET_TYPE&gt;
ManagedPtr_PairProxy&lt;TARGET_TYPE, ManagedPtrDeleter&gt;
ManagedPtr&lt;TARGET_TYPE&gt;::release()
{
    typedef ManagedPtr_PairProxy&lt;TARGET_TYPE, ManagedPtrDeleter&gt; ResultType;

    TARGET_TYPE *p = ptr();

    // It is undefined behavior to call d_members.deleter() if &#39;p&#39; is null.

    if (p) {
        ResultType result = { p, d_members.deleter() };
        d_members.clear();
        return result;                                                // RETURN
    }
    ResultType result = { p, ManagedPtrDeleter() };
    return result;
}

template &lt;class TARGET_TYPE&gt;
TARGET_TYPE *ManagedPtr&lt;TARGET_TYPE&gt;::release(ManagedPtrDeleter *deleter)
{
    BSLS_ASSERT_SAFE(deleter);

    TARGET_TYPE *result = ptr();
    if (result) {
        // undefined behavior to call d_members.deleter() if &#39;result&#39; is null.

        *deleter = d_members.deleter();
        d_members.clear();
    }
    return result;
}

template &lt;class TARGET_TYPE&gt;
inline
void ManagedPtr&lt;TARGET_TYPE&gt;::reset()
{
    d_members.runDeleter();
    d_members.clear();
}

template &lt;class TARGET_TYPE&gt;
inline
void ManagedPtr&lt;TARGET_TYPE&gt;::swap(ManagedPtr&amp; other)
{
    d_members.swap(other.d_members);
}

template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;&amp;
ManagedPtr&lt;TARGET_TYPE&gt;::operator=(ManagedPtr&amp; rhs)
{
    d_members.moveAssign(&amp;rhs.d_members);
    return *this;
}

template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;&amp;
ManagedPtr&lt;TARGET_TYPE&gt;::operator=(ManagedPtr_Ref&lt;TARGET_TYPE&gt; ref)
{
    d_members.moveAssign(ref.base());
    d_members.setAliasPtr(stripBasePointerType(ref.target()));
    return *this;
}

template &lt;class TARGET_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;&amp;
ManagedPtr&lt;TARGET_TYPE&gt;::operator=(bsl::nullptr_t)
{
    this-&gt;clear();
    return *this;
}

template &lt;class TARGET_TYPE&gt;
template &lt;class REFERENCED_TYPE&gt;
inline
ManagedPtr&lt;TARGET_TYPE&gt;::operator ManagedPtr_Ref&lt;REFERENCED_TYPE&gt;()
{
    BSLMF_ASSERT((bsl::is_convertible&lt;TARGET_TYPE *,
                                      REFERENCED_TYPE *&gt;::VALUE));

    return ManagedPtr_Ref&lt;REFERENCED_TYPE&gt;(&amp;d_members,
                             static_cast&lt;REFERENCED_TYPE *&gt;(
                             static_cast&lt;TARGET_TYPE *&gt;(d_members.pointer())));
}

// ACCESSORS
template &lt;class TARGET_TYPE&gt;
inline
#if defined(BSLS_PLATFORM_CMP_IBM)
ManagedPtr&lt;TARGET_TYPE&gt;::operator typename ManagedPtr::BoolType() const
#else
ManagedPtr&lt;TARGET_TYPE&gt;::operator BoolType() const
#endif
{
    return d_members.pointer()
         ? bsls::UnspecifiedBool&lt;ManagedPtr&gt;::trueValue()
         : bsls::UnspecifiedBool&lt;ManagedPtr&gt;::falseValue();
}

template &lt;class TARGET_TYPE&gt;
inline
typename bslmf::AddReference&lt;TARGET_TYPE&gt;::Type
ManagedPtr&lt;TARGET_TYPE&gt;::operator*() const
{
    BSLS_ASSERT_SAFE(d_members.pointer());

    return *static_cast&lt;TARGET_TYPE*&gt;(d_members.pointer());
}

template &lt;class TARGET_TYPE&gt;
inline
TARGET_TYPE *ManagedPtr&lt;TARGET_TYPE&gt;::operator-&gt;() const
{
    return static_cast&lt;TARGET_TYPE*&gt;(d_members.pointer());
}

template &lt;class TARGET_TYPE&gt;
inline
const ManagedPtrDeleter&amp; ManagedPtr&lt;TARGET_TYPE&gt;::deleter() const
{
    BSLS_ASSERT_SAFE(d_members.pointer());

    return d_members.deleter();
}

template &lt;class TARGET_TYPE&gt;
inline
TARGET_TYPE *ManagedPtr&lt;TARGET_TYPE&gt;::get() const
{
    return static_cast&lt;TARGET_TYPE*&gt;(d_members.pointer());
}

template &lt;class TARGET_TYPE&gt;
inline
TARGET_TYPE *ManagedPtr&lt;TARGET_TYPE&gt;::ptr() const
{
    return get();
}


template &lt;class TARGET_TYPE&gt;
inline
void swap(ManagedPtr&lt;TARGET_TYPE&gt;&amp; a, ManagedPtr&lt;TARGET_TYPE&gt;&amp; b)
{
    a.swap(b);
}

                      // --------------------------
                      // class ManagedPtrNilDeleter
                      // --------------------------

template &lt;class TARGET_TYPE&gt;
inline
void ManagedPtrNilDeleter&lt;TARGET_TYPE&gt;::deleter(void *, void *)
{
}

              // ----------------------------------------
              // private struct ManagedPtr_DefaultDeleter
              // ----------------------------------------

// ACCESSORS
template &lt;class MANAGED_TYPE&gt;
inline
void ManagedPtr_DefaultDeleter&lt;MANAGED_TYPE&gt;::deleter(void *ptr, void *)
{
    delete reinterpret_cast&lt;MANAGED_TYPE *&gt;(ptr);
}

}  // close package namespace

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

namespace bslmf {

template &lt;class TARGET_TYPE&gt;
struct HasPointerSemantics&lt;bslma::ManagedPtr&lt;TARGET_TYPE&gt; &gt;
    : bsl::true_type {};

template &lt;class TARGET_TYPE&gt;
struct IsBitwiseMoveable&lt;bslma::ManagedPtr&lt;TARGET_TYPE&gt; &gt; : bsl::true_type {};

}  // close namespace bslmf
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
