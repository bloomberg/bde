<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdld_datummapowningkeysbuilder.h                                   -*-C++-*-
#ifndef INCLUDED_BDLD_DATUMMAPOWNINGKEYSBUILDER
#define INCLUDED_BDLD_DATUMMAPOWNINGKEYSBUILDER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide a utility to build a &#39;Datum&#39; object holding a map.
//
//@CLASSES:
//  bdld::DatumMapOwningKeysBuilder: utility to build a &#39;Datum&#39; map value
//
//@SEE ALSO: bdld_datum, bdld_datummapbuilder
//
//@DESCRIPTION: This component defines a mechanism,
// &#39;bdld::DatumMapOwningKeysBuilder&#39;, used to populate a &#39;Datum&#39; map value in
// an exception-safe manner.  In addition to providing exception safety, a
// &#39;DatumMapOwningKeysBuilder&#39; is particularly useful when the size of the map
// to be constructed is not known in advance.  The user can append elements to
// the datum map as needed, and when there are no more elements to append the
// user calls &#39;commit&#39; or &#39;sortAndCommit&#39; and ownership of the populated
// &#39;Datum&#39; object is transferred to the caller.  After calling &#39;commit&#39; or
// &#39;sortAndCommit&#39;, no additional elements can be appended to the &#39;Datum&#39; map
// value.  Note that &#39;sortAndCommit&#39; method will sort the populated map (by
// keys) and tag the resulting &#39;Datum&#39; map value as sorted.  Also note that the
// user can insert elements in a (ascending) sorted order and tag the map as
// sorted.  The behaviour is undefined if unsorted map is tagged sorted.
//
// The only difference between this component and &#39;bdld_datummapbuilder&#39; is
// that this component makes a copy of the map entries keys and the resulting
// &#39;Datum&#39; object owns memory for the map entries keys.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Basic Syntax
///- - - - - - - - - - - -
// Suppose we need a map for some personal data.  The values in that map can be
// different types and keys must be protected from destruction as this map
// object can be passed out of scope.  The following code illustrates how to
// use &#39;bdld::DatumMapOwningKeysBuilder&#39; to create such map easily.
//
// First, we need data to fill our map:
//..
//  bslma::TestAllocator ta(&quot;test&quot;, veryVeryVerbose);
//
//  bsl::string firstName = &quot;firstName&quot;;
//  bsl::string lastName  = &quot;lastName&quot;;
//  bsl::string gender    = &quot;gender&quot;;
//  bsl::string age       = &quot;age&quot;;
//
//  DatumMapEntry bartData[] = {
//      DatumMapEntry(firstName, Datum::createStringRef(&quot;Bart&quot;, &amp;ta)),
//      DatumMapEntry(lastName,  Datum::createStringRef(&quot;Simpson&quot;, &amp;ta)),
//      DatumMapEntry(gender,    Datum::createStringRef(&quot;male&quot;, &amp;ta)),
//      DatumMapEntry(age,       Datum::createInteger(10))
//  };
//
//  const size_t DATA_SIZE  = sizeof(bartData) / sizeof(DatumMapEntry);
//  const size_t KEYS_SIZE  = firstName.length()
//                          + lastName.length()
//                          + gender.length()
//                          + age.length();
//..
// Next, we create an object of &#39;DatumMapOwningKeysBuilder&#39; class with initial
// capacity sufficient for storing all our data:
//..
//  DatumMapOwningKeysBuilder builder(DATA_SIZE, KEYS_SIZE, &amp;ta);
//..
// Then, we load our builder with these data:
//..
//  for (size_t i = 0; i &lt; DATA_SIZE; ++i) {
//      builder.pushBack(bartData[i].key(), bartData[i].value());
//  }
//..
// Next, we adopt the map, held by our builder, by newly created &#39;Datum&#39;
// object:
//..
//  Datum bart = builder.commit();
//..
// Now, we can check that all data have been correctly added to the map at the
// required order:
//..
//  assert(true == bart.isMap());
//  assert(DATA_SIZE == bart.theMap().size());
//
//  assert(&quot;firstName&quot; == bart.theMap()[0].key());
//  assert(true        == bart.theMap()[0].value().isString());
//  assert(&quot;Bart&quot;      == bart.theMap()[0].value().theString());
//
//  assert(&quot;lastName&quot;  == bart.theMap()[1].key());
//  assert(true        == bart.theMap()[1].value().isString());
//  assert(&quot;Simpson&quot;   == bart.theMap()[1].value().theString());
//
//  assert(&quot;gender&quot;    == bart.theMap()[2].key());
//  assert(true        == bart.theMap()[2].value().isString());
//  assert(&quot;male&quot;      == bart.theMap()[2].value().theString());
//
//  assert(&quot;age&quot;       == bart.theMap()[3].key());
//  assert(true        == bart.theMap()[3].value().isInteger());
//  assert(10          == bart.theMap()[3].value().theInteger());
//..
// Finally, we destroy the &#39;Datum&#39; object to release all allocated memory
// correctly:
//..
//  Datum::destroy(bart, &amp;ta);
//  assert(0 == ta.numBytesInUse());
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLD_DATUM
#include &lt;bdld_datum.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

namespace BloombergLP {

namespace bslma { class Allocator; }

namespace bdld {

                      // ===============================
                      // class DatumMapOwningKeysBuilder
                      // ===============================

class DatumMapOwningKeysBuilder {
    // This &#39;class&#39; provides a mechanism to build a &#39;Datum&#39; object having a map
    // (owning keys) value in an exception-safe manner.

  public:
    // TYPES
    typedef Datum::SizeType SizeType;
        // &#39;SizeType&#39; is an alias for a signed value, representing the
        // capacity, *keys-capacity*, size or *keys-size* of a datum-key-owning
        // map.

  private:
    // DATA
    DatumMutableMapOwningKeysRef  d_mapping;      // mutable access to the
                                                  // datum-key-owning map

    SizeType                      d_capacity;     // capacity of the
                                                  // datum-key-owning map

    SizeType                      d_keysCapacity; // keys-capacity of the
                                                  // datum-key-owning map (in
                                                  // bytes)

    bool                          d_sorted;       // underlying map is sorted
                                                  // or not

    bslma::Allocator             *d_allocator_p;  // pointer to the allocator

  private:
    // NOT IMPLEMENTED
    DatumMapOwningKeysBuilder(const DatumMapOwningKeysBuilder&amp;);
    DatumMapOwningKeysBuilder&amp; operator=(const DatumMapOwningKeysBuilder&amp;);

  public:
    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION(DatumMapOwningKeysBuilder,
                                   bslma::UsesBslmaAllocator);
        // &#39;DatumMapOwningKeysBuilder&#39; objects use &#39;bslma::Allocator&#39;.

    // CREATORS
    explicit DatumMapOwningKeysBuilder(bslma::Allocator *basicAllocator);
        // Create a &#39;DatumMapOwningKeysBuilder&#39; object that will administer the
        // process of building a &#39;Datum&#39; map (owning keys) using the specified
        // &#39;basicAllocator&#39; to supply memory.  Note that no memory is allocated
        // until &#39;append&#39; or &#39;pushBack&#39; methods are called on this object.  The
        // behavior is undefined unless &#39;0 != basicAllocator&#39;.

    DatumMapOwningKeysBuilder(SizeType          initialCapacity,
                              SizeType          initialKeysCapacity,
                              bslma::Allocator *basicAllocator);
        // Create a &#39;DatumMapBuilder&#39; object managing the ownership of &#39;Datum&#39;
        // map (owning keys) having the specified &#39;initialCapacity&#39; and
        // &#39;initialKeysCapacity&#39; (in bytes) using the specified
        // &#39;basicAllocator&#39; to supply memory.  The behavior is undefined unless
        // &#39;0 != basicAllocator&#39;.

    ~DatumMapOwningKeysBuilder();
        // Destroy this object.  If this object is holding a datum-key-owning
        // map that has not been adopted, then the datum-key-owning map is
        // disposed after destroying each of its elements.

    // MANIPULATORS
    void append(const DatumMapEntry *entries, SizeType size);
        // Append the specified array &#39;entries&#39; having the specified &#39;size&#39; to
        // the &#39;Datum&#39; map (owning keys) being build by this object.  The
        // behavior is undefined unless and &#39;0 != entries &amp;&amp; 0 != size&#39;  and
        // each element in &#39;entries&#39; that needs dynamic memory, is allocated
        // with the same allocator that was used to construct this object.  The
        // behavior is undefined if &#39;commit&#39; or &#39;sortAndCommit&#39; has already
        // been called on this object.

    Datum commit();
        // Return a &#39;Datum&#39; map (owning keys) value holding the elements
        // supplied to &#39;pushBack&#39; or &#39;append&#39;.  The caller is responsible for
        // releasing the resources of the returned &#39;Datum&#39; object.  Calling
        // this method indicates that the caller is finished building the
        // &#39;Datum&#39; map (owning keys) and no further values shall be appended.
        // The behavior is undefined if any method of this object, other than
        // its destructor, is called after &#39;commit&#39; invocation.

    void pushBack(const bslstl::StringRef&amp; key, const Datum&amp; value);
        // Append the entry with the specified &#39;key&#39; and the specified &#39;value&#39;
        // to the &#39;Datum&#39; map being build by this object.  The behavior is
        // undefined if &#39;value&#39; needs dynamic memory and was allocated using a
        // different allocator than the one used to construct this object.  The
        // behavior is also undefined if &#39;commit&#39; or &#39;sortAndCommit&#39; has
        // already been called on this object.

    void setSorted(bool value);
        // Mark the Datum map (owning keys) being built by this object as
        // sorted if the specified &#39;value&#39; is &#39;true&#39; and mark it unsorted
        // otherwise.  This function does not sort the map entries, or mark
        // them to be sorted later; the function should be used to indicate if
        // the entries are being appended in sorted order.  The behavior is
        // undefined if &#39;commit&#39; or &#39;sortAndCommit&#39; has already been called on
        // this object.  The behavior is also undefined if the map being
        // constructed is marked sorted, but the entries are not appended in
        // sorted order.  Note also that the map being constructed is marked
        // unsorted by default.

    Datum sortAndCommit();
        // Return a &#39;Datum&#39; map (owning keys) value holding the elements
        // supplied to &#39;pushBack&#39; or &#39;append&#39; sorted by their keys.  The caller
        // is responsible for releasing the resources of the returned &#39;Datum&#39;
        // object.  Calling this method indicates that the caller is finished
        // building the &#39;Datum&#39; map (owning keys) and no further values shall
        // be appended.  The behavior is undefined if any method of this
        // object, other than its destructor, is called after &#39;sortAndCommit&#39;
        // invocation.

    // ACCESSORS
    SizeType capacity() const;
        // Return the capacity of the held &#39;Datum&#39; map (owning keys).  The
        // behavior is undefined if &#39;commit&#39; or &#39;sortAndCommit&#39; has already
        // been called on this object.  Note that similar to the capacity of a
        // &#39;vector&#39;, the returned capacity has no bearing on the value of the
        // &#39;Datum&#39; being constructed, but does indicate at which point
        // additional memory will be required to grow the &#39;Datum&#39; map being
        // built.

    SizeType keysCapacity() const;
        // Return the keys-capacity of the held &#39;Datum&#39; map (owning keys).  The
        // behavior is undefined if &#39;commit&#39; or &#39;sortAndCommit&#39; has already
        // been called on this object.  Note that similar to the capacity of a
        // &#39;vector&#39;, the returned capacity has no bearing on the value of the
        // &#39;Datum&#39; being constructed, but does indicate at which point
        // additional memory will be required to grow the &#39;Datum&#39; map being
        // built.

    SizeType size() const;
        // Return the size of the held &#39;Datum&#39; map (owning keys).  The behavior
        // is undefined if &#39;commit&#39; or &#39;sortAndCommit&#39; has already been called
        // on this object.
};

// ============================================================================
//                               INLINE DEFINITIONS
// ============================================================================

                      // -------------------------------
                      // class DatumMapOwningKeysBuilder
                      // -------------------------------

// ACCESSORS
inline
DatumMapOwningKeysBuilder::SizeType DatumMapOwningKeysBuilder::capacity() const
{
    return d_capacity;
}

inline
DatumMapOwningKeysBuilder::SizeType DatumMapOwningKeysBuilder::keysCapacity()
                                                                          const
{
    return d_keysCapacity;
}

inline
DatumMapOwningKeysBuilder::SizeType DatumMapOwningKeysBuilder::size() const
{
    if (d_capacity) {
        return *d_mapping.size();                                     // RETURN
    }
    return 0;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
