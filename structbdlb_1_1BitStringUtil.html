<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Struct bdlb::BitStringUtil</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebdlb.html">bdlb</a>      </li>
      <li><a class="el" href="structbdlb_1_1BitStringUtil.html">bdlb::BitStringUtil</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a>  </div>
  <div class="headertitle">
<h1>bdlb::BitStringUtil Struct Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bdlb::BitStringUtil" -->
<p><code>#include &lt;<a class="el" href="bdlb__bitstringutil_8h_source.html">bdlb_bitstringutil.h</a>&gt;</code></p>

<p><a href="structbdlb_1_1BitStringUtil-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="structbdlb_1_1BitStringUtil.html#ac261564de12da7cc3189261620a8a543ab3b8741a0d9b69224c6a10a555f39094">k_BITS_PER_UINT64</a> =  64
 }</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ade793368f0aa1d2da1be3e8d54c4e738">assign</a> (bsl::uint64_t *bitString, bsl::size_t index, bool value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ab1b9e0e50a581af72c233e2eddf081d5">assign</a> (bsl::uint64_t *bitString, bsl::size_t index, bool value, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#aba9d69144cf13c9b5818d0e6283429b1">assign0</a> (bsl::uint64_t *bitString, bsl::size_t index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#aa746d839f1f73d6128103881d0316d57">assign0</a> (bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ae2ec5a815d1229ef73fe137a78b29328">assign1</a> (bsl::uint64_t *bitString, bsl::size_t index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a6acc605a3c264d0a775647c449509b14">assign1</a> (bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a2b1551b43ab267e69f3901f9cc7a53f3">assignBits</a> (bsl::uint64_t *bitString, bsl::size_t index, bsl::uint64_t srcValue, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ab39ebdada49b473469e3e010375cc0c4">andEqual</a> (bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ab5300915895672cb33487af88d3a6f29">minusEqual</a> (bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a471f1b2d82bacb9d5ff2586e49324961">orEqual</a> (bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#aeccf36a3313d7578fdc2d3b88e12d044">xorEqual</a> (bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ac8d7d4820404bbd8ab3be85f263f22f6">copy</a> (bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a6000ea1eefd585616be9e5269c852b9d">copyRaw</a> (bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a10f721add274a71d312830f73dd4440b">insert</a> (bsl::uint64_t *bitString, bsl::size_t initialLength, bsl::size_t dstIndex, bool value, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ac4a0e87c86f788205419823888acd6fb">insert0</a> (bsl::uint64_t *bitString, bsl::size_t initialLength, bsl::size_t dstIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a48e8db488db636fb38409fb528ff41ac">insert1</a> (bsl::uint64_t *bitString, bsl::size_t initialLength, bsl::size_t dstIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a0a3e99e38abc277d6d429848d6488c20">insertRaw</a> (bsl::uint64_t *bitString, bsl::size_t initialLength, bsl::size_t dstIndex, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a81d26f6bbf193f263b04115aa08ca05d">remove</a> (bsl::uint64_t *bitString, bsl::size_t length, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a0f7b97610a871506667b98007a0f7003">removeAndFill0</a> (bsl::uint64_t *bitString, bsl::size_t length, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a6b594025a303b30c08a87bb132668010">removeAndFill1</a> (bsl::uint64_t *bitString, bsl::size_t length, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ae7fe64836e8b10aabbbee36fda887229">swapRaw</a> (bsl::uint64_t *bitString1, bsl::size_t index1, bsl::uint64_t *bitString2, bsl::size_t index2, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a1ba84710056c25a1a5ae3bc9bb441b28">toggle</a> (bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a503417d584e231ff2a968fae9807ec0c">areEqual</a> (const bsl::uint64_t *bitString1, const bsl::uint64_t *bitString2, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a36206fb1b1fa15d21ff2c6dc10aa4d0c">areEqual</a> (const bsl::uint64_t *bitString1, bsl::size_t index1, const bsl::uint64_t *bitString2, bsl::size_t index2, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a76808cd3621cd98609683f04231f4a7d">bit</a> (const bsl::uint64_t *bitString, bsl::size_t index)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a4fc6749e04de626599f403c175a7cf36">bits</a> (const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a777f065333f1cb6ecb67df292b17111e">find0AtMaxIndex</a> (const bsl::uint64_t *bitString, bsl::size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a6236292a2b3131c4a7d6eede1495971d">find0AtMaxIndex</a> (const bsl::uint64_t *bitString, bsl::size_t begin, bsl::size_t end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a0100249b8688c184adb2ae88bedba79a">find0AtMinIndex</a> (const bsl::uint64_t *bitString, bsl::size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ac8aac1ea366bd1c6f4500242aa8ba151">find0AtMinIndex</a> (const bsl::uint64_t *bitString, bsl::size_t begin, bsl::size_t end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a7d3055ee57d6d46d3a5e8299f0d62f99">find1AtMaxIndex</a> (const bsl::uint64_t *bitString, bsl::size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ae52c2846fa681d35e93b302edf61f5d6">find1AtMaxIndex</a> (const bsl::uint64_t *bitString, bsl::size_t begin, bsl::size_t end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ab8982e37ea8f8a9e484141da1c682cfc">find1AtMinIndex</a> (const bsl::uint64_t *bitString, bsl::size_t length)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a4ea1c78d0013e5b03baf25c7b896a3f8">find1AtMinIndex</a> (const bsl::uint64_t *bitString, bsl::size_t begin, bsl::size_t end)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#aa1074ac3b9adbb18f696884d26bf470c">isAny0</a> (const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ac5865b3f588c2bb175df2e5cbd2edc87">isAny1</a> (const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#ad5e2f8c3c880ee9a735bdc2f78df3b44">num0</a> (const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#aef3c6c002d6310416aefb65532179a49">num1</a> (const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#afbcbe0f9a90047c47335ea33d410c3af">print</a> (bsl::ostream &amp;stream, const bsl::uint64_t *bitString, bsl::size_t numBits, int level=1, int spacesPerLevel=4)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const bsl::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlb_1_1BitStringUtil.html#a47fbe07f0d06677c1724ee44b4b399a5">k_INVALID_INDEX</a> = ~static_cast&lt;bsl::size_t&gt;(0)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This <code>struct</code> provides a namespace for a suite of static functions to manipulate and access sequences of bits stored in an array of <code>uint64_t</code> (also known as a "bit string"; see <a href="group__bdlb__bitstringutil.html#the_~22bit_string~22_pseudo-type" class="el">The "Bit String" Pseudo-Type</a>). </p>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ac261564de12da7cc3189261620a8a543"></a><!-- doxytag: member="bdlb::BitStringUtil::@127" ref="ac261564de12da7cc3189261620a8a543" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>number of bits in a <code>uint64_t</code> </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ac261564de12da7cc3189261620a8a543ab3b8741a0d9b69224c6a10a555f39094"></a><!-- doxytag: member="k_BITS_PER_UINT64" ref="ac261564de12da7cc3189261620a8a543ab3b8741a0d9b69224c6a10a555f39094" args="" -->k_BITS_PER_UINT64</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ade793368f0aa1d2da1be3e8d54c4e738"></a><!-- doxytag: member="bdlb::BitStringUtil::assign" ref="ade793368f0aa1d2da1be3e8d54c4e738" args="(bsl::uint64_t *bitString, bsl::size_t index, bool value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::assign </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the bit at the specified <code>index</code> in the specified <code>bitString</code> to the specified <code>value</code>. The behavior is undefined unless <code>index</code> is less than the capacity of <code>bitString</code>. </p>

</div>
</div>
<a class="anchor" id="ab1b9e0e50a581af72c233e2eddf081d5"></a><!-- doxytag: member="bdlb::BitStringUtil::assign" ref="ab1b9e0e50a581af72c233e2eddf081d5" args="(bsl::uint64_t *bitString, bsl::size_t index, bool value, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::assign </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>numBits</code> beginning at the specified <code>index</code> in the specified <code>bitString</code> to the specified <code>value</code>. The behavior is undefined unless <code>bitString</code> has a capacity of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="aba9d69144cf13c9b5818d0e6283429b1"></a><!-- doxytag: member="bdlb::BitStringUtil::assign0" ref="aba9d69144cf13c9b5818d0e6283429b1" args="(bsl::uint64_t *bitString, bsl::size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::assign0 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the bit at the specified <code>index</code> in the specified <code>bitString</code> to <code>false</code>. The behavior is undefined unless <code>index</code> is less than the capacity of <code>bitString</code>. </p>

</div>
</div>
<a class="anchor" id="aa746d839f1f73d6128103881d0316d57"></a><!-- doxytag: member="bdlb::BitStringUtil::assign0" ref="aa746d839f1f73d6128103881d0316d57" args="(bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::assign0 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>numBits</code> beginning at the specified <code>index</code> in the specified <code>bitString</code> to <code>false</code>. The behavior is undefined unless <code>bitString</code> has a capacity of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="ae2ec5a815d1229ef73fe137a78b29328"></a><!-- doxytag: member="bdlb::BitStringUtil::assign1" ref="ae2ec5a815d1229ef73fe137a78b29328" args="(bsl::uint64_t *bitString, bsl::size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::assign1 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the bit at the specified <code>index</code> in the specified <code>bitString</code> to <code>true</code>. The behavior is undefined unless <code>index</code> is less than the capacity of <code>bitString</code>. </p>

</div>
</div>
<a class="anchor" id="a6acc605a3c264d0a775647c449509b14"></a><!-- doxytag: member="bdlb::BitStringUtil::assign1" ref="a6acc605a3c264d0a775647c449509b14" args="(bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::assign1 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>numBits</code> beginning at the specified <code>index</code> in the specified <code>bitString</code> to <code>true</code>. The behavior is undefined unless <code>bitString</code> has a capacity of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="a2b1551b43ab267e69f3901f9cc7a53f3"></a><!-- doxytag: member="bdlb::BitStringUtil::assignBits" ref="a2b1551b43ab267e69f3901f9cc7a53f3" args="(bsl::uint64_t *bitString, bsl::size_t index, bsl::uint64_t srcValue, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::assignBits </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64_t&nbsp;</td>
          <td class="paramname"> <em>srcValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign the low-order specified <code>numBits</code> from the specified <code>srcValue</code> to the <code>numBits</code> starting at the specified <code>index</code> in the specified <code>bitString</code>. The behavior is undefined unless <code>numBits &lt;= k_BITS_PER_UINT64</code> and <code>bitString</code> has a capacity of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="ab39ebdada49b473469e3e010375cc0c4"></a><!-- doxytag: member="bdlb::BitStringUtil::andEqual" ref="ab39ebdada49b473469e3e010375cc0c4" args="(bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::andEqual </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>dstBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>srcBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bitwise AND the specified <code>numBits</code> of the specified <code>dstBitString</code> starting at the specified <code>dstIndex</code> with the <code>numBits</code> of the specified <code>srcBitString</code> starting at the specified <code>srcIndex</code>, and write the result over the bits that were read from <code>dstBitString</code>. The behavior is undefined unless <code>dstBitString</code> has a length of at least <code>dstIndex + numBits</code> and <code>srcBitString</code> has a length of at least <code>srcIndex + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="ab5300915895672cb33487af88d3a6f29"></a><!-- doxytag: member="bdlb::BitStringUtil::minusEqual" ref="ab5300915895672cb33487af88d3a6f29" args="(bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::minusEqual </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>dstBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>srcBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bitwise MINUS the specified <code>numBits</code> of the specified <code>srcBitString</code> starting at the specified <code>srcIndex</code> from the <code>numBits</code> of the specified <code>dstBitString</code> starting at the specified <code>dstIndex</code>, and write the result over the bits that were read from <code>dstBitString</code>. The behavior is undefined unless <code>dstBitString</code> has a length of at least <code>dstIndex + numBits</code> and <code>srcBitString</code> has a length of at least <code>srcIndex + numBits</code>. Note that the logical difference <code>A - B</code> is defined to be <code>A &amp; !B</code>. </p>

</div>
</div>
<a class="anchor" id="a471f1b2d82bacb9d5ff2586e49324961"></a><!-- doxytag: member="bdlb::BitStringUtil::orEqual" ref="a471f1b2d82bacb9d5ff2586e49324961" args="(bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::orEqual </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>dstBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>srcBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bitwise OR the specified <code>numBits</code> of the specified <code>dstBitString</code> starting at the specified <code>dstIndex</code> with the <code>numBits</code> of the specified <code>srcBitString</code> starting at the specified <code>srcIndex</code>, and write the result over the bits that were read from <code>dstBitString</code>. The behavior is undefined unless <code>dstBitString</code> has a length of at least <code>dstIndex + numBits</code> and <code>srcBitString</code> has a length of at least <code>srcIndex + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="aeccf36a3313d7578fdc2d3b88e12d044"></a><!-- doxytag: member="bdlb::BitStringUtil::xorEqual" ref="aeccf36a3313d7578fdc2d3b88e12d044" args="(bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::xorEqual </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>dstBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>srcBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Bitwise XOR the specified <code>numBits</code> of the specified <code>dstBitString</code> starting at the specified <code>dstIndex</code> with the <code>numBits</code> of the specified <code>srcBitString</code> starting at the specified <code>srcIndex</code>, and write the result over the bits that were read from <code>dstBitString</code>. The behavior is undefined unless <code>dstBitString</code> has a length of at least <code>dstIndex + numBits</code> and <code>srcBitString</code> has a length of at least <code>srcIndex + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="ac8d7d4820404bbd8ab3be85f263f22f6"></a><!-- doxytag: member="bdlb::BitStringUtil::copy" ref="ac8d7d4820404bbd8ab3be85f263f22f6" args="(bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::copy </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>dstBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>srcBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy to the specified <code>dstBitString</code>, beginning at the specified <code>dstIndex</code>, the specified <code>numBits</code> beginning at the specified <code>srcIndex</code> in the specified <code>srcBitString</code>. This function works correctly regardless of whether the source and destination ranges overlap. The behavior is undefined unless <code>dstBitString</code> has a capacity of at least <code>dstIndex + numBits</code> and <code>srcBitString</code> has a length of at least <code>srcIndex + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="a6000ea1eefd585616be9e5269c852b9d"></a><!-- doxytag: member="bdlb::BitStringUtil::copyRaw" ref="a6000ea1eefd585616be9e5269c852b9d" args="(bsl::uint64_t *dstBitString, bsl::size_t dstIndex, const bsl::uint64_t *srcBitString, bsl::size_t srcIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::copyRaw </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>dstBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>srcBitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>srcIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy to the specified <code>dstBitString</code>, beginning at the specified <code>dstIndex</code>, the specified <code>numBits</code> beginning at the specified <code>srcIndex</code> in the specified <code>srcBitString</code>. The behavior is undefined unless <code>dstBitString</code> has a capacity of at least <code>dstIndex + numBits</code>, <code>srcBitString</code> has a length of at least <code>srcIndex + numBits</code>, and the source and destination ranges either do not overlap, or the destination range is equal to the source range, or the start of the destination range is below the start of the source range. </p>

</div>
</div>
<a class="anchor" id="a10f721add274a71d312830f73dd4440b"></a><!-- doxytag: member="bdlb::BitStringUtil::insert" ref="a10f721add274a71d312830f73dd4440b" args="(bsl::uint64_t *bitString, bsl::size_t initialLength, bsl::size_t dstIndex, bool value, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::insert </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>initialLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>numBits</code>, each having the specified <code>value</code>, into the specified <code>bitString</code> having the specified <code>initialLength</code>, beginning at the specified <code>dstIndex</code>. Bits at or above <code>dstIndex</code> are shifted up by <code>numBits</code> index positions and the length of <code>bitString</code> is increased by <code>numBits</code>. The behavior is undefined unless <code>dstIndex &lt;= initialLength</code> and <code>bitString</code> has a capacity of at least <code>initialLength + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="ac4a0e87c86f788205419823888acd6fb"></a><!-- doxytag: member="bdlb::BitStringUtil::insert0" ref="ac4a0e87c86f788205419823888acd6fb" args="(bsl::uint64_t *bitString, bsl::size_t initialLength, bsl::size_t dstIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::insert0 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>initialLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>numBits</code> 0 bits into the specified <code>bitString</code> having the specified <code>initialLength</code> beginning at the specified <code>dstIndex</code>. Bits at or above <code>dstIndex</code> are shifted up by <code>numBits</code> index positions and the length of <code>bitString</code> is increased by <code>numBits</code>. The behavior is undefined unless <code>dstIndex &lt;= initialLength</code> and <code>bitString</code> has a capacity of at least <code>initialLength + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="a48e8db488db636fb38409fb528ff41ac"></a><!-- doxytag: member="bdlb::BitStringUtil::insert1" ref="a48e8db488db636fb38409fb528ff41ac" args="(bsl::uint64_t *bitString, bsl::size_t initialLength, bsl::size_t dstIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::insert1 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>initialLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>numBits</code> 1 bits into the specified <code>bitString</code> having the specified <code>initialLength</code> beginning at the specified <code>dstIndex</code>. Bits at or above <code>dstIndex</code> are shifted up by <code>numBits</code> index positions and the length of <code>bitString</code> is increased by <code>numBits</code>. The behavior is undefined unless <code>dstIndex &lt;= initialLength</code> and <code>bitString</code> has a capacity of at least <code>initialLength + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="a0a3e99e38abc277d6d429848d6488c20"></a><!-- doxytag: member="bdlb::BitStringUtil::insertRaw" ref="a0a3e99e38abc277d6d429848d6488c20" args="(bsl::uint64_t *bitString, bsl::size_t initialLength, bsl::size_t dstIndex, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::insertRaw </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>initialLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>dstIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert the specified <code>numBits</code> into the specified <code>bitString</code> having the specified <code>initialLength</code> beginning at the specified <code>dstIndex</code>. Bits at or above <code>dstIndex</code> are shifted up by <code>numBits</code> index positions and the length of <code>bitString</code> is increased by <code>numBits</code>. The values of the inserted bits are undefined. The behavior is undefined unless <code>dstIndex &lt;= initialLength</code> and <code>bitString</code> has a capacity of at least <code>initialLength + numBits</code>. Note that the inserted bits are not assigned any value. </p>

</div>
</div>
<a class="anchor" id="a81d26f6bbf193f263b04115aa08ca05d"></a><!-- doxytag: member="bdlb::BitStringUtil::remove" ref="a81d26f6bbf193f263b04115aa08ca05d" args="(bsl::uint64_t *bitString, bsl::size_t length, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::remove </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the specified <code>numBits</code> from the specified <code>bitString</code> of the specified <code>length</code> beginning at the specified <code>index</code>. Bits above <code>index + numBits</code> are shifted down by <code>numBits</code> index positions and the length of <code>bitString</code> is reduced by <code>numBits</code>. The values of the vacated high-order bits are not modified. The behavior is undefined unless <code>index + numBits &lt;= length</code>. </p>

</div>
</div>
<a class="anchor" id="a0f7b97610a871506667b98007a0f7003"></a><!-- doxytag: member="bdlb::BitStringUtil::removeAndFill0" ref="a0f7b97610a871506667b98007a0f7003" args="(bsl::uint64_t *bitString, bsl::size_t length, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::removeAndFill0 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the specified <code>numBits</code> from the specified <code>bitString</code> having the specified <code>length</code> beginning at the specified <code>index</code>. Bits above <code>index + numBits</code> are shifted down by <code>numBits</code> index positions and the last <code>numBits</code> of <code>bitString</code> are set to 0. The length of <code>bitString</code> is not changed. The behavior is undefined unless <code>index + numBits &lt;= length</code>. </p>

</div>
</div>
<a class="anchor" id="a6b594025a303b30c08a87bb132668010"></a><!-- doxytag: member="bdlb::BitStringUtil::removeAndFill1" ref="a6b594025a303b30c08a87bb132668010" args="(bsl::uint64_t *bitString, bsl::size_t length, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::removeAndFill1 </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove the specified <code>numBits</code> from the specified <code>bitString</code> having the specified <code>length</code> beginning at the specified <code>index</code>. Bits above <code>index + numBits</code> are shifted down by <code>numBits</code> index positions and the last <code>numBits</code> of <code>bitString</code> are set to 1. The length of <code>bitString</code> is not changed. The behavior is undefined unless <code>index + numBits &lt;= length</code>. </p>

</div>
</div>
<a class="anchor" id="ae7fe64836e8b10aabbbee36fda887229"></a><!-- doxytag: member="bdlb::BitStringUtil::swapRaw" ref="ae7fe64836e8b10aabbbee36fda887229" args="(bsl::uint64_t *bitString1, bsl::size_t index1, bsl::uint64_t *bitString2, bsl::size_t index2, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::swapRaw </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the specified <code>numBits</code> beginning at the specified <code>index1</code> in the specified <code>bitString1</code> with the <code>numBits</code> beginning at the specified <code>index2</code> in the specified <code>bitString2</code>. The behavior is undefined unless <code>bitString1</code> has a length of at least <code>index1 + numBits</code>, <code>bitString2</code> has a length of at least <code>index2 + numBits</code>, and there is <em>no</em> overlap between the swapped ranges of bits. </p>

</div>
</div>
<a class="anchor" id="a1ba84710056c25a1a5ae3bc9bb441b28"></a><!-- doxytag: member="bdlb::BitStringUtil::toggle" ref="a1ba84710056c25a1a5ae3bc9bb441b28" args="(bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void bdlb::BitStringUtil::toggle </td>
          <td>(</td>
          <td class="paramtype">bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Invert the values of the specified <code>numBits</code> in the specified <code>bitString</code> beginning at the specified <code>index</code>. The behavior is undefined unless <code>bitString</code> has a length of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="a503417d584e231ff2a968fae9807ec0c"></a><!-- doxytag: member="bdlb::BitStringUtil::areEqual" ref="a503417d584e231ff2a968fae9807ec0c" args="(const bsl::uint64_t *bitString1, const bsl::uint64_t *bitString2, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdlb::BitStringUtil::areEqual </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified low-order <code>numBits</code> in the specified <code>bitString1</code> are bitwise equal to the corresponding bits in the specified <code>bitString2</code>, and <code>false</code> otherwise. The behavior is undefined unless both <code>bitString1</code> and <code>bitString2</code> have a length of at least <code>numBits</code>. </p>

</div>
</div>
<a class="anchor" id="a36206fb1b1fa15d21ff2c6dc10aa4d0c"></a><!-- doxytag: member="bdlb::BitStringUtil::areEqual" ref="a36206fb1b1fa15d21ff2c6dc10aa4d0c" args="(const bsl::uint64_t *bitString1, bsl::size_t index1, const bsl::uint64_t *bitString2, bsl::size_t index2, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdlb::BitStringUtil::areEqual </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>numBits</code> beginning at the specified <code>index1</code> in the specified <code>bitString1</code> are bitwise equal to the <code>numBits</code> beginning at the specified <code>index2</code> in the specified <code>bitString2</code>, and <code>false</code> otherwise. The behavior is undefined unless <code>bitString1</code> has a length of at least <code>index1 + numBits</code> and <code>bitString2</code> has a length of at least <code>index2 + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="a76808cd3621cd98609683f04231f4a7d"></a><!-- doxytag: member="bdlb::BitStringUtil::bit" ref="a76808cd3621cd98609683f04231f4a7d" args="(const bsl::uint64_t *bitString, bsl::size_t index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdlb::BitStringUtil::bit </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the bit value at the specified <code>index</code> in the specified <code>bitString</code>. The behavior is undefined unless <code>index</code> is less than the length of <code>bitString</code>. </p>

</div>
</div>
<a class="anchor" id="a4fc6749e04de626599f403c175a7cf36"></a><!-- doxytag: member="bdlb::BitStringUtil::bits" ref="a4fc6749e04de626599f403c175a7cf36" args="(const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::uint64_t bdlb::BitStringUtil::bits </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the specified <code>numBits</code> beginning at the specified <code>index</code> in the specified <code>bitString</code> as the low-order bits of the returned value. The behavior is undefined unless <code>numBits &lt;= k_BITS_PER_UINT64</code> and <code>bitString</code> has a length of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="a777f065333f1cb6ecb67df292b17111e"></a><!-- doxytag: member="bdlb::BitStringUtil::find0AtMaxIndex" ref="a777f065333f1cb6ecb67df292b17111e" args="(const bsl::uint64_t *bitString, bsl::size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::find0AtMaxIndex </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the most-significant 0 bit in the specified <code>bitString</code> having the specified <code>length</code>, if such a bit exists, and <code>k_INVALID_INDEX</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a6236292a2b3131c4a7d6eede1495971d"></a><!-- doxytag: member="bdlb::BitStringUtil::find0AtMaxIndex" ref="a6236292a2b3131c4a7d6eede1495971d" args="(const bsl::uint64_t *bitString, bsl::size_t begin, bsl::size_t end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::find0AtMaxIndex </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the most-significant 0 bit in the specified <code>bitString</code> in the specified range <code>[begin .. end)</code>, if such a bit exists, and <code>k_INVALID_INDEX</code> otherwise. The behavior is undefined unless <code>begin &lt;= end</code> and <code>end</code> is less than or equal to the length of <code>bitString</code>. </p>

</div>
</div>
<a class="anchor" id="a0100249b8688c184adb2ae88bedba79a"></a><!-- doxytag: member="bdlb::BitStringUtil::find0AtMinIndex" ref="a0100249b8688c184adb2ae88bedba79a" args="(const bsl::uint64_t *bitString, bsl::size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::find0AtMinIndex </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the least-significant 0 bit in the specified <code>bitString</code> having the specified <code>length</code>, if such a bit exists, and <code>k_INVALID_INDEX</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ac8aac1ea366bd1c6f4500242aa8ba151"></a><!-- doxytag: member="bdlb::BitStringUtil::find0AtMinIndex" ref="ac8aac1ea366bd1c6f4500242aa8ba151" args="(const bsl::uint64_t *bitString, bsl::size_t begin, bsl::size_t end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::find0AtMinIndex </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the least-significant 0 bit in the specified <code>bitString</code> in the specified range <code>[begin .. end)</code>, if such a bit exists, and <code>k_INVALID_INDEX</code> otherwise. The behavior is undefined unless <code>begin &lt;= end</code> and <code>end</code> is less than or equal to the length of <code>bitString</code>. </p>

</div>
</div>
<a class="anchor" id="a7d3055ee57d6d46d3a5e8299f0d62f99"></a><!-- doxytag: member="bdlb::BitStringUtil::find1AtMaxIndex" ref="a7d3055ee57d6d46d3a5e8299f0d62f99" args="(const bsl::uint64_t *bitString, bsl::size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::find1AtMaxIndex </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the most-significant 1 bit in the specified <code>bitString</code> having the specified <code>length</code>, if such a bit exists, and <code>k_INVALID_INDEX</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ae52c2846fa681d35e93b302edf61f5d6"></a><!-- doxytag: member="bdlb::BitStringUtil::find1AtMaxIndex" ref="ae52c2846fa681d35e93b302edf61f5d6" args="(const bsl::uint64_t *bitString, bsl::size_t begin, bsl::size_t end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::find1AtMaxIndex </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the most-significant 1 bit in the specified <code>bitString</code> in the specified range <code>[begin .. end)</code>, if such a bit exists, and <code>k_INVALID_INDEX</code> otherwise. The behavior is undefined unless <code>begin &lt;= end</code> and <code>end</code> is less than or equal to the length of <code>bitString</code>. </p>

</div>
</div>
<a class="anchor" id="ab8982e37ea8f8a9e484141da1c682cfc"></a><!-- doxytag: member="bdlb::BitStringUtil::find1AtMinIndex" ref="ab8982e37ea8f8a9e484141da1c682cfc" args="(const bsl::uint64_t *bitString, bsl::size_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::find1AtMinIndex </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the least-significant 1 bit in the specified <code>bitString</code> having the specified <code>length</code>, if such a bit exists, and <code>k_INVALID_INDEX</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a4ea1c78d0013e5b03baf25c7b896a3f8"></a><!-- doxytag: member="bdlb::BitStringUtil::find1AtMinIndex" ref="a4ea1c78d0013e5b03baf25c7b896a3f8" args="(const bsl::uint64_t *bitString, bsl::size_t begin, bsl::size_t end)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::find1AtMinIndex </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>end</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the index of the least-significant 1 bit in the specified <code>bitString</code> in the specified range <code>[begin .. end)</code>, if such a bit exists, and <code>k_INVALID_INDEX</code> otherwise. The behavior is undefined unless <code>begin &lt;= end</code> and <code>end</code> is less than or equal to the length of <code>bitString</code>. </p>

</div>
</div>
<a class="anchor" id="aa1074ac3b9adbb18f696884d26bf470c"></a><!-- doxytag: member="bdlb::BitStringUtil::isAny0" ref="aa1074ac3b9adbb18f696884d26bf470c" args="(const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdlb::BitStringUtil::isAny0 </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if any of the specified <code>numBits</code> beginning at the specified <code>index</code> in the specified <code>bitString</code> are 0, and <code>false</code> otherwise. The behavior is undefined unless <code>bitString</code> has a length of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="ac5865b3f588c2bb175df2e5cbd2edc87"></a><!-- doxytag: member="bdlb::BitStringUtil::isAny1" ref="ac5865b3f588c2bb175df2e5cbd2edc87" args="(const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bool bdlb::BitStringUtil::isAny1 </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if any of the specified <code>numBits</code> beginning at the specified <code>index</code> in the specified <code>bitString</code> are 1, and <code>false</code> otherwise. The behavior is undefined unless <code>bitString</code> has a length of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="ad5e2f8c3c880ee9a735bdc2f78df3b44"></a><!-- doxytag: member="bdlb::BitStringUtil::num0" ref="ad5e2f8c3c880ee9a735bdc2f78df3b44" args="(const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::num0 </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of 0 bits in the specified <code>numBits</code> beginning at the specified <code>index</code> in the specified <code>bitString</code>. The behavior is undefined unless <code>bitString</code> has a length of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="aef3c6c002d6310416aefb65532179a49"></a><!-- doxytag: member="bdlb::BitStringUtil::num1" ref="aef3c6c002d6310416aefb65532179a49" args="(const bsl::uint64_t *bitString, bsl::size_t index, bsl::size_t numBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::size_t bdlb::BitStringUtil::num1 </td>
          <td>(</td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of 1 bits in the specified <code>numBits</code> beginning at the specified <code>index</code> in the specified <code>bitString</code>. The behavior is undefined unless <code>bitString</code> has a length of at least <code>index + numBits</code>. </p>

</div>
</div>
<a class="anchor" id="afbcbe0f9a90047c47335ea33d410c3af"></a><!-- doxytag: member="bdlb::BitStringUtil::print" ref="afbcbe0f9a90047c47335ea33d410c3af" args="(bsl::ostream &amp;stream, const bsl::uint64_t *bitString, bsl::size_t numBits, int level=1, int spacesPerLevel=4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static bsl::ostream&amp; bdlb::BitStringUtil::print </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bsl::uint64_t *&nbsp;</td>
          <td class="paramname"> <em>bitString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bsl::size_t&nbsp;</td>
          <td class="paramname"> <em>numBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spacesPerLevel</em> = <code>4</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Format to the specified output <code>stream</code> the specified low-order <code>numBits</code> in the specified <code>bitString</code> in hexadecimal, and return a reference to <code>stream</code>. The highest order bits are printed first, in groups of 16 nibbles, 64 nibbles per line (in the case of multi-line output). Optionally specify <code>level</code>, the indentation level for each line output. Optionally specify <code>spacesPerLevel</code>, the number of spaces per indentation level. Each line is indented by the absolute value of <code>level * spacesPerLevel</code>. If <code>spacesPerLevel</code> is negative, suppress line breaks and format the entire output on one line. If <code>stream</code> is initially invalid, this operation has no effect. Note that a trailing newline is provided in multiline mode only. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a47fbe07f0d06677c1724ee44b4b399a5"></a><!-- doxytag: member="bdlb::BitStringUtil::k_INVALID_INDEX" ref="a47fbe07f0d06677c1724ee44b4b399a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const bsl::size_t <a class="el" href="structbdlb_1_1BitStringUtil.html#a47fbe07f0d06677c1724ee44b4b399a5">bdlb::BitStringUtil::k_INVALID_INDEX</a> = ~static_cast&lt;bsl::size_t&gt;(0)<code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="bdlb__bitstringutil_8h_source.html">bdlb_bitstringutil.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:34:33 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
