<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: Class bslalg::ContainerBase</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslalg.html">bslalg</a>      </li>
      <li><a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase&lt; ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>bslalg::ContainerBase&lt; ALLOCATOR &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslalg::ContainerBase" -->
<p><code>#include &lt;<a class="el" href="bslalg__containerbase_8h_source.html">bslalg_containerbase.h</a>&gt;</code></p>

<p><a href="classbslalg_1_1ContainerBase-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef Base::AllocatorType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a4e22d7ef983482034ca84cbff676bdd5">AllocatorType</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorType::size_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorType::difference_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a9117abb1365fde8ac0cc13f096b67577">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorType::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorType::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#ad12530e124f2c383cb3885c6e3446734">const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorType::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#ad089e9aec7423c38937242053b2c6707">reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
AllocatorType::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a43e5b3ae8346bb61417f16af29c53e51">const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef AllocatorType::value_type&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a161acd8494184bb050eccbce703a96e4">value_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a9c697e6bb24c41df81f0313143fbbd3e">ContainerBase</a> (const ALLOCATOR &amp;allocator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a0e9208d8eb059074406991d9807becfc">ContainerBase</a> (const <a class="el" href="classbslalg_1_1ContainerBase.html">ContainerBase</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a29cada82c07b67ac02b881e2cfbd97f9">~ContainerBase</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a038a902bcad2fa10041b5d2b72b628ab">allocate</a> (<a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a> n, const void *hint=0)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a430814b4124c907945b6ec40c0fd22ef">allocateN</a> (T *p, <a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a> n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a05f903b809e5feddbcc119aa148457c4">construct</a> (<a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a> p, const <a class="el" href="classbslalg_1_1ContainerBase.html#a161acd8494184bb050eccbce703a96e4">value_type</a> &amp;val)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a745d7a6cf92b0e7109c8aa7295e5f5ea">deallocate</a> (<a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a> p, <a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a> n=1)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#a4636172aec440dc1adf9d42592eed2b7">deallocateN</a> (T *p, <a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a> n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#ada8cb29a7f7c9aff617388a601184f2f">destroy</a> (<a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a> p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslalg_1_1ContainerBase.html#adccff83d03dd9d49fe929d0351f5c90a">equalAllocator</a> (const <a class="el" href="classbslalg_1_1ContainerBase.html">ContainerBase</a> &amp;rhs) const </td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class ALLOCATOR&gt;<br/>
 class bslalg::ContainerBase&lt; ALLOCATOR &gt;</h3>

<p>Allocator proxy class for STL-style containers. Provides access to the allocator. Implements the entire STL allocator interface, redirecting allocation and deallocation calls to the proxied allocator. One of two possible base classes is chosen depending on whether <code>ALLOCATOR</code> is constructed from <code><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a>*</code>. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a4e22d7ef983482034ca84cbff676bdd5"></a><!-- doxytag: member="bslalg::ContainerBase::AllocatorType" ref="a4e22d7ef983482034ca84cbff676bdd5" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Base::AllocatorType <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html#a4e22d7ef983482034ca84cbff676bdd5">AllocatorType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a75da70e72603a708de9336c2cfa4acf4"></a><!-- doxytag: member="bslalg::ContainerBase::size_type" ref="a75da70e72603a708de9336c2cfa4acf4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorType::size_type <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a9117abb1365fde8ac0cc13f096b67577"></a><!-- doxytag: member="bslalg::ContainerBase::difference_type" ref="a9117abb1365fde8ac0cc13f096b67577" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorType::difference_type <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html#a9117abb1365fde8ac0cc13f096b67577">difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a74db958c3235f22b2e53dfaca8209ad9"></a><!-- doxytag: member="bslalg::ContainerBase::pointer" ref="a74db958c3235f22b2e53dfaca8209ad9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorType::pointer <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad12530e124f2c383cb3885c6e3446734"></a><!-- doxytag: member="bslalg::ContainerBase::const_pointer" ref="ad12530e124f2c383cb3885c6e3446734" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorType::const_pointer <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html#ad12530e124f2c383cb3885c6e3446734">const_pointer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad089e9aec7423c38937242053b2c6707"></a><!-- doxytag: member="bslalg::ContainerBase::reference" ref="ad089e9aec7423c38937242053b2c6707" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorType::reference <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html#ad089e9aec7423c38937242053b2c6707">reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a43e5b3ae8346bb61417f16af29c53e51"></a><!-- doxytag: member="bslalg::ContainerBase::const_reference" ref="a43e5b3ae8346bb61417f16af29c53e51" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorType::const_reference <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html#a43e5b3ae8346bb61417f16af29c53e51">const_reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a161acd8494184bb050eccbce703a96e4"></a><!-- doxytag: member="bslalg::ContainerBase::value_type" ref="a161acd8494184bb050eccbce703a96e4" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef AllocatorType::value_type <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html#a161acd8494184bb050eccbce703a96e4">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9c697e6bb24c41df81f0313143fbbd3e"></a><!-- doxytag: member="bslalg::ContainerBase::ContainerBase" ref="a9c697e6bb24c41df81f0313143fbbd3e" args="(const ALLOCATOR &amp;allocator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html">ContainerBase</a> </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR &amp;&nbsp;</td>
          <td class="paramname"> <em>allocator</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Construct this object using the specified <code>allocator</code> of the parameterized <code>ALLOCATOR</code> type. </p>

</div>
</div>
<a class="anchor" id="a0e9208d8eb059074406991d9807becfc"></a><!-- doxytag: member="bslalg::ContainerBase::ContainerBase" ref="a0e9208d8eb059074406991d9807becfc" args="(const ContainerBase &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::<a class="el" href="classbslalg_1_1ContainerBase.html">ContainerBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1ContainerBase.html">ContainerBase</a>&lt; ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initialize this container base with rhs. NOTE: This is not a true copy constructor. The allocator does not get copied if the allocator is <code>bslma</code>-based. Using BSL allocator semantics, the <code>bslma</code>-style allocator must be supplied explicitly (i.e., not copied from rhs) or else it is given a default value. Non-'bslma' allocators ARE copied because that is the way the ISO standard is currently written. </p>

</div>
</div>
<a class="anchor" id="a29cada82c07b67ac02b881e2cfbd97f9"></a><!-- doxytag: member="bslalg::ContainerBase::~ContainerBase" ref="a29cada82c07b67ac02b881e2cfbd97f9" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::~<a class="el" href="classbslalg_1_1ContainerBase.html">ContainerBase</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a038a902bcad2fa10041b5d2b72b628ab"></a><!-- doxytag: member="bslalg::ContainerBase::allocate" ref="a038a902bcad2fa10041b5d2b72b628ab" args="(size_type n, const void *hint=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a> <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::allocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>hint</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Allocate enough (properly aligned) space for <code>n</code> objects of type <code>T</code> by calling <code>allocate</code> on the mechanism object. The <code>hint</code> argument is ignored by this allocator type. </p>

</div>
</div>
<a class="anchor" id="a430814b4124c907945b6ec40c0fd22ef"></a><!-- doxytag: member="bslalg::ContainerBase::allocateN" ref="a430814b4124c907945b6ec40c0fd22ef" args="(T *p, size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::allocateN </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Allocate (but do not initialize) <code>n</code> objects of type <code>T</code> using the allocator returned by <code>allocator</code>. Return a pointer to the raw memory that was allocated. The <code>p</code> argument is used only to determine the type of object being allocated; its value (usually null) is not used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a05f903b809e5feddbcc119aa148457c4"></a><!-- doxytag: member="bslalg::ContainerBase::construct" ref="a05f903b809e5feddbcc119aa148457c4" args="(pointer p, const value_type &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1ContainerBase.html#a161acd8494184bb050eccbce703a96e4">value_type</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>val</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy-construct a <code>T</code> object at the memory address specified by <code>p</code>. Do not directly allocate memory. The behavior is undefined if <code>p</code> is not properly aligned for <code>T</code>. </p>

</div>
</div>
<a class="anchor" id="a745d7a6cf92b0e7109c8aa7295e5f5ea"></a><!-- doxytag: member="bslalg::ContainerBase::deallocate" ref="a745d7a6cf92b0e7109c8aa7295e5f5ea" args="(pointer p, size_type n=1)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::deallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em> = <code>1</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return memory previously allocated with <code>allocate</code> to the underlying mechanism object by calling <code>deallocate</code> on the mechanism object. The <code>n</code> argument is ignored by this allocator type. </p>

</div>
</div>
<a class="anchor" id="a4636172aec440dc1adf9d42592eed2b7"></a><!-- doxytag: member="bslalg::ContainerBase::deallocateN" ref="a4636172aec440dc1adf9d42592eed2b7" args="(T *p, size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::deallocateN </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1ContainerBase.html#a75da70e72603a708de9336c2cfa4acf4">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>n</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>n</em>&nbsp;</td><td>Return <code>n</code> objects of type <code>T</code>, starting at <code>p</code> to the allocator returned by <code>allocator</code>. Does not call destructors on the deallocated objects. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ada8cb29a7f7c9aff617388a601184f2f"></a><!-- doxytag: member="bslalg::ContainerBase::destroy" ref="ada8cb29a7f7c9aff617388a601184f2f" args="(pointer p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslalg_1_1ContainerBase.html#a74db958c3235f22b2e53dfaca8209ad9">pointer</a>&nbsp;</td>
          <td class="paramname"> <em>p</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call the <code>T</code> destructor for the object pointed to by <code>p</code>. Do not directly deallocate any memory. </p>

</div>
</div>
<a class="anchor" id="adccff83d03dd9d49fe929d0351f5c90a"></a><!-- doxytag: member="bslalg::ContainerBase::equalAllocator" ref="adccff83d03dd9d49fe929d0351f5c90a" args="(const ContainerBase &amp;rhs) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ALLOCATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbslalg_1_1ContainerBase.html">bslalg::ContainerBase</a>&lt; ALLOCATOR &gt;::equalAllocator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1ContainerBase.html">ContainerBase</a>&lt; ALLOCATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Returns <code>this-&gt;allocator() == rhs.allocator()</code>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslalg__containerbase_8h_source.html">bslalg_containerbase.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:51 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
