<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlt_packedcalendar Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlt_packedcalendar<br/>
<small>
[<a class="el" href="group__bdlt.html">Package bdlt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a compact repository for weekend/holiday information.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html">bdlt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Weekend Days and Weekend-Days Transitions</a> </li>
<li>
<a href="#3.2">Nested Iterators</a> </li>
<li>
<a href="#3.3">Iterator Invalidation</a> </li>
<li>
<a href="#3.4">Performance and Exception-Safety Guarantees</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example 1: Populating Packed Calendars</a> </li>
<li>
<a href="#3.5.2">Example 2: Using Packed Calendars</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a compact repository for weekend/holiday information. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a> </td><td>compact repository of weekend/holiday information  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlt__calendar.html" title="Provide fast repository for accessing weekend/holiday information.">Component bdlt_calendar</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a value-semantic class, <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code>, that represents weekend and holiday information over a <em>valid</em> <em>range</em> of dates. A <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> is an approximation to the same <em>mathematical</em> type, and is capable of representing the same subset of <em>mathematical</em> values, as a <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>But unlike <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code>, which is optimized for runtime efficiency, <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> is designed to minimize the amount of in-process memory required to represent that information. For example, a packed calendar storing 250 holidays and holiday codes can consume as little as approximately 0.75K bytes (e.g., 2 bytes per holiday plus 1 byte per holiday code) to as much as approximately 3K bytes (e.g., 8 bytes per holiday plus 4 bytes per holiday code) depending upon the data of the calendar. For typical calendars having a range of 40 years and 10 holidays per year, the expected size of the packed calendar is about half that of a similar implementation using a non-packed structure. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Default-constructed calendars are empty, and have an empty valid range. Calendars can also be constructed with an initial (non-empty) valid range, implying that all dates within that range are business days. The <code>setValidRange</code> and <code>addDay</code> methods modify the valid range of a calendar, and a suite of "add" methods can be used to populate a calendar with weekend days and holidays. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>addHolidayCode</code> method associates an integer "holiday code" with a specific date, and can be called repeatedly with different integers and the same date to build up a set of holiday codes for that date. Note that holiday codes are unique integers that, from the perspective of the calendar, have no particular meaning. Typically, the user will choose holiday code values that are indices into an auxiliary collection (such as a <code><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt;bsl::string&gt;</code>) to identify holiday names for end-user display. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Once a calendar is populated, a rich set of accessor methods can be used to determine, e.g., if a given date is a business day, or the number of non-business days within some subrange of the calendar. The holidays within a calendar can be obtained in increasing (chronological) order using an iterator identified by the nested <code>HolidayConstIterator</code> <code>typedef</code>. The set of holiday codes associated with an arbitrary date in a <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> (or the current holiday referred to by a <code>HolidayConstIterator</code>) can be obtained in increasing (numerical) order using an iterator identified by the nested <code>HolidayCodeConstIterator</code> <code>typedef</code> (see below). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Calendars are value-semantic objects, and, as such, necessarily support all of the standard value-semantic operations, such as default construction, copy construction and copy assignment, equality comparison, and externalization (BDEX streaming, in particular). Calendars also support the notions of both union and intersection merging operations, whereby a calendar can change its value to contain the union or intersection of its own contained weekend days, holidays, and holiday codes with those of another calendar object. Such merging operations will, in general, also alter the valid range of the resulting calendar. Note that merged calendars can be significantly more efficient for certain repeated "is-common-business-day" determinations among two or more calendars. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="weekend_days_and_weekend-days_transitions"></a> <a class="anchor" id="description.weekend_days_and_weekend-days_transitions"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Weekend Days and Weekend-Days Transitions: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A calendar maintains a set of dates considered to be weekend days. Typically, a calendar's weekend days fall on the same days of the week for the entire range of a calendar. For example, the weekend for United States has consisted of Saturday and Sunday since the year 1940. The <code>addWeekendDay</code> and <code>addWeekendDays</code> methods can be used to specify the weekend days for these calendars. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>However, sometimes a calendar's weekend days changes over time. For example, Bangladesh's weekend consisted of Friday until June 1, 1997 when Bangladesh changed its weekends to contain both Friday and Saturday. Later, on October 1, 2001, Bangladesh reverted to a weekend of only Friday, until on September 9, 2009, Bangladesh again changed its weekends to include both Friday and Saturday. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To optimize for space allocation while supporting both consistent and changing weekend days, a calendar represents weekend information using a sequence of "weekend-days transitions", each of which comprises a date and a set of days of the week considered to be the weekend on and after that date. To represent the weekend days of Bangladesh, a calendar can use a sequence of four weekend-days transitions: (1) a transition on January 1, 0001 having a weekend day set containing only Friday, (2) a transition at June 1, 1997 having a weekend day set containing Friday and Saturday, (3) a transition at October 1, 2001 having a weekend day set containing only Friday, and (4) a transition at September 9, 2009 having a weekend day set containing Friday and Saturday. To represent the weekend days of the United States, a calendar having a range after 1940 can use a single weekend-days transition on January 1, 0001 containing Saturday and Sunday. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>On construction, a calendar does not contain any weekend-days transitions. The <code>addWeekendDaysTransition</code> method adds a new weekend-days transition or replaces an existing weekend-days transition. The <code>addWeekendDay</code> and <code>addWeekendDays</code> methods create a weekend-days transition at January 1, 0001, if one doesn't already exist, and update the set of weekend days for that transition. <code>addWeekendDay</code> and <code>addWeekendDays</code> should only be used for calendars having a consistent set of weekend days throughout their entire range. The use of <code>addWeekendDay</code> and <code>addWeekendDays</code> is intended to be <em>mutually</em> <em>exclusive</em> to the use of <code>addWeekendDaysTransition</code>. As such, the behavior of using these two methods together with <code>addWeekendDaysTransition</code> is undefined. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="nested_iterators"></a> <a class="anchor" id="description.nested_iterators"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Nested Iterators: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Also provided are several STL-style <code>const</code> bidirectional iterators accessible as nested <code>typedef</code>s. <code>HolidayConstIterator</code>, <code>HolidayCodeConstIterator</code>, <code>WeekendDaysTransitionConstIterator</code>, and <code>BusinessDayConstIterator</code>, respectively, iterate over a chronologically ordered sequence of holidays, a numerically ordered sequence of holiday codes, a sequence of chronologically ordered weekend-days transitions, and a sequence of chronologically ordered business days. Reverse iterators are also provided for each of these (forward) iterators. As a general rule, calling a <code>const</code> method will not invalidate any iterators, and calling a non-'const' method might invalidate all of them; it is, however, guaranteed that attempting to add <em>duplicate</em> holidays or holiday codes will have no effect, and therefore will not invalidate any iterators. It is also guaranteed that adding a new code for an existing holiday will not invalidate any <code>HolidayConstIterator</code> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that these iterators do <em>not</em> meet the requirements for a <code>bsl::forward_iterator</code> and should not be used in standard algorithms (e.g., <code>bsl::lower_bound</code>). </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="iterator_invalidation"></a> <a class="anchor" id="description.iterator_invalidation"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Iterator Invalidation: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The modification of a <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> will invalidate iterators referring to the calendar. The following table shows the relationship between a calendar manipulator and the types of iterators it will invalidate if the invocation of the manipulator modified the calendar (e.g., using <code>addHoliday</code> with a date that is not currently a holiday in the calendar): <br/>
<br/>
<div class="fragment"><pre class="fragment">          Manipulator                         Invalidates
    --------------------------            --------------------
    <span class="stringliteral">&#39;operator=&#39;</span>                           H    HC    WDT    BD
    <span class="stringliteral">&#39;addHoliday&#39;</span>                          H    HC           BD
    <span class="stringliteral">&#39;addHolidayCode&#39;</span>                           HC
    <span class="stringliteral">&#39;addHolidayCodeIfInRange&#39;</span>                  HC
    <span class="stringliteral">&#39;addHolidayIfInRange&#39;</span>                 H    HC           BD
    <span class="stringliteral">&#39;addWeekendDay&#39;</span>                                  WDT    BD
    <span class="stringliteral">&#39;addWeekendDays&#39;</span>                                 WDT    BD
    <span class="stringliteral">&#39;addWeekendDaysTransition&#39;</span>                       WDT    BD
    <span class="stringliteral">&#39;intersectBusinessDays&#39;</span>               H    HC    WDT    BD
    <span class="stringliteral">&#39;intersectNonBusinessDays&#39;</span>            H    HC    WDT    BD
    <span class="stringliteral">&#39;removeAll&#39;</span>                           H    HC    WDT    BD
    <span class="stringliteral">&#39;removeHoliday&#39;</span>                       H    HC           BD
    <span class="stringliteral">&#39;removeHolidayCode&#39;</span>                        HC
    <span class="stringliteral">&#39;setValidRange&#39;</span>                       H    HC           BD
    <span class="stringliteral">&#39;unionBusinessDays&#39;</span>                   H    HC    WDT    BD
    <span class="stringliteral">&#39;unionNonBusinessDays&#39;</span>                H    HC    WDT    BD

 where <span class="stringliteral">&quot;H&quot;</span> represents the holiday iterators (<span class="stringliteral">&#39;HolidayConstIterator&#39;</span> and
 <span class="stringliteral">&#39;HolidayConstReverseIterator&#39;</span>), <span class="stringliteral">&quot;HC&quot;</span> represents the holiday code iterators
 (<span class="stringliteral">&#39;HolidayCodeConstIterator&#39;</span> and <span class="stringliteral">&#39;HolidayCodeConstReverseIterator&#39;</span>), <span class="stringliteral">&quot;WDT&quot;</span>
 represents the weekend-days transition iterators
 (<span class="stringliteral">&#39;WeekendDaysTransitionConstIterator&#39;</span> and
 <span class="stringliteral">&#39;WeekendDaysTransitionConstReverseIterator&#39;</span>), and <span class="stringliteral">&quot;BD&quot;</span> represents the
 business day iterators (<span class="stringliteral">&#39;BusinessDayConstIterator&#39;</span> and
 <span class="stringliteral">&#39;BusinessDayConstReverseIterator&#39;</span>).
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance_and_exception-safety_guarantees"></a> <a class="anchor" id="description.performance_and_exception-safety_guarantees"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Performance and Exception-Safety Guarantees: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The asymptotic worst-case performance of representative operations is characterized using big-O notation, <code>O[f(N,M,W,V)]</code>. <code>N</code> and <code>M</code> each refer to the combined number (<code>H + C</code>) of holidays <code>H</code> (i.e., method <code>numHolidays</code>) and holiday codes <code>C</code> (i.e., <code>numHolidayCodesTotal</code>) in the respective packed calendars. <code>W</code> and <code>V</code> each refer to the (likely small) number of weekend-days transitions in the respective packed calendars. For clarity, the methods have abbreviated arguments: <code>b</code>, <code>e</code>, and <code>d</code> are dates, <code>c</code> is a holiday code, <code>u</code> is a weekday, and <code>w</code> is a set of weekdays. Here, <em>Best</em> <em>Case</em> complexity, denoted by <code>B[f(N)]</code>, is loosely defined (for manipulators) as the worst-case cost, provided that (1) no additional internal capacity is required, (2) the start of the valid range does not change, and (3) that if a holiday (or holiday code) is being added, it is being appended <em>to</em> <em>the</em> <em>end</em> of the current sequence (of the latest holiday). <br/>
<br/>
<div class="fragment"><pre class="fragment">                                    Worst       Best    Exception-Safety
  Operation                          Case       Case      Guarantee
  ---------                         -----       ----    ----------------
  DEFAULT CTOR                      O[1]                No-Throw
  COPY CTOR(N)                      O[N]                Exception-Safe
  N.DTOR()                          O[1]                No-Throw

  N.OP=(M)                          O[M]                Basic &lt;*&gt;

  N.reserveCapacity(H, C)           O[N]                Strong &lt;*&gt;

  N.setValidRange(b, e)             O[N]        O[1]    Basic &lt;*&gt;
  N.addDay(d)                       O[N]        O[1]    Basic &lt;*&gt;
  N.addHoliday(d)                   O[N]        O[1]    Basic &lt;*&gt;
  N.addHolidayCode(d,c)             O[N]        O[1]    Basic &lt;*&gt;

  N.addWeekendDay(u)                O[1]                No-Throw
  N.addWeekendDaysTransition(d,w)   O[W]                Basic &lt;*&gt;

  N.intersectBusinessDays(M)        O[N+M+W+V]          Basic &lt;*&gt;
  N.intersectNonBusinessDays(M)     O[N+M+W+V]          Basic &lt;*&gt;
  N.unionBusinessDays(M)            O[N+M+W+V]          Basic &lt;*&gt;
  N.unionNonBusinessDays(M)         O[N+M+W+V]          Basic &lt;*&gt;

  N.removeHoliday(d)                O[N]                No-Throw
  N.removeHolidayCode(d, c)         O[N]                No-Throw
  N.removeAll();                    O[1]                No-Throw

  N.<a class="code" href="namespaceball.html#a4f1ef43d8e35464e858a25f9cbe03dec">swap</a>(M)                         O[1]                No-Throw

  N.firstDate()                     O[1]                No-Throw
  N.lastDate()                      O[1]                No-Throw
  N.length()                        O[1]                No-Throw

  N.numHolidays()                   O[1]                No-Throw

  N.numHolidayCodesTotal()          O[1]                No-Throw
  N.numWeekendDaysInRange()         O[1]                No-Throw

  N.isInRange(d);                   O[1]                No-Throw
  N.isWeekendDay(w);                O[1]                No-Throw
  N.isWeekendDay(d)                 O[log(W)]           No-Throw

  N.isHoliday(d);                   O[log(N)]           No_Throw
  N.isBusinessDay(d);               O[log(N)]           No_Throw
  N.isNonBusinessDay(d);            O[log(N)]           No_Throw

  N.numHolidayCodes(d)              O[log(N)]           No-Throw

  N.numBusinessDays()               O[N]                No-Throw
  N.numNonBusinessDays()            O[N]                No-Throw

  other &#39;const&#39; methods             O[1] .. O[N]        No-Throw

  OP==(N,M)                         O[min(N,M)+min(W+V) No-Throw
  OP!=(N,M)                         O[min(N,M)+min(W+V) No-Throw

                          &lt;*&gt; No-Throw guarantee when capacity is sufficient.
</pre></div><br/>
<br/>
 Note that <em>all</em> of the non-creator methods of <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> provide the <em>No-Throw</em> guarantee whenever sufficient capacity is already available. Also note that these are largely the same as <code><a class="el" href="classbdlt_1_1Calendar.html">bdlt::Calendar</a></code> <em>except</em> that the accessors <code>isBusinessDay</code> and <code>isNonBusinessDay</code> are logarithmic in the number of holidays in <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The two subsections below illustrate various aspects of populating and using packed calendars. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1~3A_populating_packed_calendars"></a> <a class="anchor" id="usage.example_1~3A_populating_packed_calendars"></a> <a class="anchor" id="description.usage.example_1~3A_populating_packed_calendars"></a> <a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: Populating Packed Calendars: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Packed calendars will typically be populated from a database or flat file. The user should employ an appropriate population mechanism that provides the desired holiday dates and associated holiday codes within some desired range. For example, suppose we have created the following flat-file format that encodes calendar information, including holidays and holiday codes (we assume, for the simplicity of this example, that "Weekend Days" (i.e., recurring non-business days) are always just Saturdays and Sundays): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// HOLIDAY DATE   HOLIDAY CODES</span>
  <span class="comment">// ------------   -------------</span>
  <span class="comment">// Year Mon Day    #    Codes     Comments, separated by Semicolons (;)</span>
  <span class="comment">// ---- --- ---   --- ---------   -------------------------------------</span>
     2010  1  18     1   57         ;Martin Luther King, Jr. Day
     2010  2  15     1   51         ;Presidents Day
     2010  4   2     2   9 105      ;Easter Sunday (Observed); Good Friday
     2010  5  31     1   16         ;Memorial Day
     2010  7   5     1   28         ;Independence Day (Observed)
     2010  9   6     1   44         ;Labor Day
     2010 10  11     1   19         ;Columbus Day
     2010 11   2     0              ;Election Day
     2010 11  25     1   14         ;Thanksgiving Day
     2010 12  25     1    4         ;Christmas Day (Observed)
     2010 12  31     1   22         ;New Year<span class="stringliteral">&#39;s Day (Observed)</span>
</pre></div><br/>
<br/>
 Let's now create a couple of primitive helper functions to extract holiday and holiday-code counts from a given input stream. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we'll create a helper function to get a holiday record: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> getNextHoliday(bsl::istream&amp; input, <a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a> *holiday, <span class="keywordtype">int</span> *numCodes)
      <span class="comment">// Load into the specified &#39;holiday&#39; the date of the next holiday, and</span>
      <span class="comment">// into the specified &#39;numCodes&#39; the associated number of holiday codes</span>
      <span class="comment">// for the holiday read from the specified &#39;input&#39; stream.  Return 0 on</span>
      <span class="comment">// success, and a non-zero value (with no effect on &#39;*holiday&#39; and</span>
      <span class="comment">// &#39;*numCodes&#39;) otherwise.</span>
  {
      <span class="keyword">enum</span> { SUCCESS = 0, FAILURE = 1 };

      <span class="keywordtype">int</span> year, month, day, codes;

      <span class="keywordflow">if</span> (input.good()) {
          input &gt;&gt; year;
      }
      <span class="keywordflow">if</span> (input.good()) {
          input &gt;&gt; month;
      }
      <span class="keywordflow">if</span> (input.good()) {
          input &gt;&gt; day;
      }
      <span class="keywordflow">if</span> (input.good()) {
          input &gt;&gt; codes;
      }

      <span class="keywordflow">if</span> (input.good()
       &amp;&amp; <a class="code" href="classbdlt_1_1Date.html#a1faa7073957a832565240d5f7b7821ec">bdlt::Date::isValidYearMonthDay</a>(year, month, day)) {
          *holiday  = <a class="code" href="namespacebdet.html#afaf7185f28d8d6122ae4fe36a6b88ba5">bdlt::Date</a>(year, month, day);
          *numCodes = codes;
          <span class="keywordflow">return</span> SUCCESS;                                           <span class="comment">// RETURN</span>
      }

      <span class="keywordflow">return</span> FAILURE;                                               <span class="comment">// RETURN</span>
  }
</pre></div><br/>
<br/>
 Then, we'll write a function that gets us an integer holiday code, or invalidates the stream if it cannot (note that negative holiday codes are not supported by this function, but negative holiday codes <em>are</em> supported by <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code>): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> getNextHolidayCode(bsl::istream&amp; input, <span class="keywordtype">int</span> *result)
      <span class="comment">// Load, into the specified &#39;result&#39;, the value read from the specified</span>
      <span class="comment">// &#39;input&#39; stream.  If the next token is not an integer, invalidate the</span>
      <span class="comment">// stream with no effect on &#39;result&#39;.</span>
  {
      <span class="keywordtype">int</span> holidayCode;

      <span class="keywordflow">if</span> (input.good()) {
          input &gt;&gt; holidayCode;
      }

      <span class="keywordflow">if</span> (input.good()) {
          *result = holidayCode;
      }
  }
</pre></div><br/>
<br/>
 Now, with these helper functions, it is a simple matter to write a calendar loader function, <code>load</code>, that populates a given calendar with data in this "proprietary" format: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> load(bsl::istream&amp; input, <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a> *calendar)
      <span class="comment">// Populate the specified &#39;calendar&#39; with holidays and corresponding</span>
      <span class="comment">// codes read from the specified &#39;input&#39; stream in our &quot;proprietary&quot;</span>
      <span class="comment">// format (see above).  On success, &#39;input&#39; will be empty, but valid;</span>
      <span class="comment">// otherwise &#39;input&#39; will be invalid.</span>
  {
      <a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a> holiday;
      <span class="keywordtype">int</span>        numCodes;

      <span class="keywordflow">while</span> (0 == getNextHoliday(input, &amp;holiday, &amp;numCodes)) {
          calendar-&gt;<a class="code" href="classbdlt_1_1PackedCalendar.html#a121f798a3b009183806f3bb115534f36">addHoliday</a>(holiday);                       <span class="comment">// add date</span>
          <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numCodes; ++i) {
              <span class="keywordtype">int</span> holidayCode;
              getNextHolidayCode(input, &amp;holidayCode);
              <span class="keywordflow">if</span> (input.good()) {
                  <span class="comment">// add codes</span>

                  calendar-&gt;<a class="code" href="classbdlt_1_1PackedCalendar.html#a44cec92a5e894061d49dcd0975f1b6e6">addHolidayCode</a>(holiday, holidayCode);
              }
          }
          input.ignore(256, <span class="charliteral">&#39;\n&#39;</span>);  <span class="comment">// skip comments</span>
      }
  }
</pre></div><br/>
<br/>
 Finally, we load a <code><a class="el" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a></code> and verify some values from the calendar. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__stringstream.html">bsl::stringstream</a> stream;
  {
      stream &lt;&lt; <span class="stringliteral">&quot;2010  9   6     1   44         ;Labor Day\n&quot;</span>
             &lt;&lt; <span class="stringliteral">&quot;2010 10  11     1   19         ;Columbus Day\n&quot;</span>
             &lt;&lt; <span class="stringliteral">&quot;2010 11   2     0              ;Election Day\n&quot;</span>
             &lt;&lt; <span class="stringliteral">&quot;2010 11  25     1   14         ;Thanksgiving Day\n&quot;</span>;
  }

  <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a> calendar;
  load(stream, &amp;calendar);

  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2010,  9,  6) == calendar.<a class="code" href="classbdlt_1_1PackedCalendar.html#abe3fc981b52c0a791732d17f4775d2bf">firstDate</a>());
  assert(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2010, 11, 25) == calendar.<a class="code" href="classbdlt_1_1PackedCalendar.html#acd3d4ed6c66a3bf86b71b7829f318a47">lastDate</a>());
  assert(<span class="keyword">true</span>  == calendar.<a class="code" href="classbdlt_1_1PackedCalendar.html#a849898999f5061145a37cdda8492872d">isBusinessDay</a>(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2010, 10, 12)));
  assert(<span class="keyword">false</span> == calendar.<a class="code" href="classbdlt_1_1PackedCalendar.html#a849898999f5061145a37cdda8492872d">isBusinessDay</a>(<a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>(2010, 11,  2)));
</pre></div><br/>
<br/>
 Note that different formats can easily be accommodated, while still using the same basic population strategy. Also note that it may be substantially more efficient to populate calendars in increasing date order, compared to either reverse or random order. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_2~3A_using_packed_calendars"></a> <a class="anchor" id="usage.example_2~3A_using_packed_calendars"></a> <a class="anchor" id="description.usage.example_2~3A_using_packed_calendars"></a> <a class="anchor" id="example_2"></a> <a class="anchor" id="usage.example_2"></a> <a class="anchor" id="description.usage.example_2"></a> <a class="anchor" id="3.5.2"></a> </dd></dl>
<dl class="user"><dt><b>Example 2: Using Packed Calendars: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Higher-level clients (e.g., a GUI) may need to extract the holiday codes for a particular date, use them to look up their corresponding string names in a separate repository (e.g., a vector of strings), and to display these names to end users. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, let's create a function that prints the names of holidays for a given date: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span>
  printHolidayNamesForGivenDate(bsl::ostream&amp;                   output,
                                <span class="keyword">const</span> <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a>&amp;     calendar,
                                <span class="keyword">const</span> <a class="code" href="classbdlt_1_1Date.html">bdlt::Date</a>&amp;               date,
                                <span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp; holidayNames)
      <span class="comment">// Write, to the specified &#39;output&#39; stream, the elements in the</span>
      <span class="comment">// specified &#39;holidayNames&#39; associated, via holiday codes in the</span>
      <span class="comment">// specified &#39;calendar&#39;, to the specified &#39;date&#39;.  Each holiday name</span>
      <span class="comment">// emitted is followed by a newline (&#39;\n&#39;).  The behavior is undefined</span>
      <span class="comment">// unless &#39;date&#39; is within the valid range of &#39;calendar&#39;.</span>
  {
      <span class="keywordflow">for</span> (<a class="code" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">bdlt::PackedCalendar::HolidayCodeConstIterator</a>
                                       it = calendar.beginHolidayCodes(date);
                                       it != calendar.endHolidayCodes(date);
                                     ++it) {
          output &lt;&lt; holidayNames[*it] &lt;&lt; bsl::endl;
      }
  }
</pre></div><br/>
<br/>
 Then, since we can write the names of holidays for a given date, let's write a function that can write out all of the names associated with each holiday in the calendar: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span>
  printHolidayDatesAndNames(bsl::ostream&amp;                   output,
                            <span class="keyword">const</span> <a class="code" href="classbdlt_1_1PackedCalendar.html">bdlt::PackedCalendar</a>&amp;     calendar,
                            <span class="keyword">const</span> <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a>&amp; holidayNames)
      <span class="comment">// Write, to the specified &#39;output&#39; stream, each date associated with</span>
      <span class="comment">// a holiday in the specified &#39;calendar&#39; followed by any elements in</span>
      <span class="comment">// the specified &#39;holidayNames&#39; (associated via holiday codes in</span>
      <span class="comment">// &#39;calendar&#39;) corresponding to that date.  Each date emitted is</span>
      <span class="comment">// preceded and followed by a newline (&#39;\n&#39;).  Each holiday name</span>
      <span class="comment">// emitted is followed by a newline (&#39;\n&#39;).</span>
  {
      <span class="keywordflow">for</span> (<a class="code" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">bdlt::PackedCalendar::HolidayConstIterator</a>
                        it = calendar.<a class="code" href="classbdlt_1_1PackedCalendar.html#a6dc629cc8b8be488b664c2f8c8439aba">beginHolidays</a>();
                                      it != calendar.<a class="code" href="classbdlt_1_1PackedCalendar.html#ab17c337f196cf8637e155802f2cbeb12">endHolidays</a>(); ++it) {
          output &lt;&lt; <span class="charliteral">&#39;\n&#39;</span> &lt;&lt; *it &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>;
          printHolidayNamesForGivenDate(output,
                                        calendar,
                                        *it,
                                        holidayNames);
      }
  }
</pre></div><br/>
<br/>
 Next, we populate the <code>holidayNames</code> vector: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1vector.html">bsl::vector&lt;bsl::string&gt;</a> holidayNames;
  {
      holidayNames.<a class="code" href="group__bslstl__vector.html#gac5203d4410a4c7c3d1d2014d5542e0d9">resize</a>(45);

      holidayNames[44] = <span class="stringliteral">&quot;Labor Day&quot;</span>;         <span class="comment">// holiday code 44 is for</span>
                                              <span class="comment">// Labor Day</span>

      holidayNames[14] = <span class="stringliteral">&quot;Thanksgiving Day&quot;</span>;  <span class="comment">// holiday code 14 is for</span>
                                              <span class="comment">// Thanksgiving Day</span>
  }
</pre></div><br/>
<br/>
 Now, using the <code>calendar</code> populated in the previous example, we print the holiday information to a new <code>bsl::stringstream</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <a class="code" href="classbsl_1_1basic__stringstream.html">bsl::stringstream</a> printStream;

  printHolidayDatesAndNames(printStream, calendar, holidayNames);
</pre></div><br/>
<br/>
 Finally, we verify the output: <br/>
<br/>
<div class="fragment"><pre class="fragment">  assert(printStream.<a class="code" href="group__bslstl__stringstream.html#gabc665fb8f263f6c87fe5709fb2b03176">str</a>() == <span class="stringliteral">&quot;\n06SEP2010\nLabor Day\n\n11OCT2010\n\n\n&quot;</span>
                               <span class="stringliteral">&quot;02NOV2010\n\n25NOV2010\nThanksgiving Day\n&quot;</span>);
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Oct 15 2015 14:33:47 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
