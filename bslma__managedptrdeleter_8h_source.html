<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslma_managedptrdeleter.h                                          -*-C++-*-
#ifndef INCLUDED_BSLMA_MANAGEDPTRDELETER
#define INCLUDED_BSLMA_MANAGEDPTRDELETER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide an in-core value semantic class to call a delete function.
//
//@CLASSES:
//  bslma::ManagedPtrDeleter: in-core value semantic class storing a deleter
//
//@SEE_ALSO: bslma_managedptr
//
//@DESCRIPTION: This component provides a single, complex-constrained in-core
// value-semantic attribute class, &#39;bslma::ManagedPtrDeleter&#39;, that is used to
// store a bound function call for a &quot;factory&quot; to destroy an &quot;object&quot;.
//
///Attributes
///----------
//..
//  Name              Type                      Default
//  ----------------  ------------------------  -------
//  object            void *                    0
//  factory           void *                    0
//  deleter           void (*)(void *, void *)  0
//
//  Complex Constraints
//  -----------------------------------------------------------------
//  &#39;0 == deleter&#39; or &#39;deleter(object, factory)&#39; has defined behavior.
//..
//: o object  address of the object to be destroyed by the factory.
//:
//: o factory  address of the factory object that is responsible for destroying
//:            &#39;object&#39;
//:
//: o deleter  address of the function that knows how to restore the erased
//:            types of &#39;object&#39; and &#39;factory&#39;, and how to invoke the &#39;factory&#39;
//:            method to destroy object.


#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

namespace BloombergLP {
namespace bslma {

                       // =======================
                       // class ManagedPtrDeleter
                       // =======================

class ManagedPtrDeleter {
    // This complex constrained in-core value-semantic class holds the
    // information necessary for &#39;ManagedPtr&#39; correctly manage its underlying
    // object, namely the addresses of &#39;object&#39; and &#39;factory&#39;, and the
    // &#39;deleter&#39; function, optionally supplied through the constructors or
    // through the &#39;set&#39; method.  It is stored in a sub-structure to allow the
    // compiler to copy it more efficiently.

    // See the Attributes section under @DESCRIPTION in the component-level
    // documentation.  Note that the class invariants are identically the
    // constraints on the individual attributes.
    //
    // This class:
    //: o supports a complete set of *value-semantic* operations
    //: o is *exception-safe*
    //: o is *alias-safe*
    //: o is &#39;const&#39; *thread-safe*
    // For terminology see &#39;bsldoc_glossary&#39;.

  public:
    // PUBLIC TYPES
    typedef void(*Deleter)(void *managedObject, void *cookie);
        // Deleter function prototype used to destroy the managed pointer.

  private:
    // DATA
    void    *d_object_p;   // pointer to the actual managed object
    void    *d_factory_p;  // optional factory to be specified to the deleter
    Deleter  d_deleter;    // deleter used to destroy the managed object

  public:
    // CREATORS
    ManagedPtrDeleter();
        // Create an uninitialized &#39;ManagedPtrDeleter&#39; object that does not
        // refer to any object or factory instance.

    //! ManagedPtrDeleter(const ManagedPtrDeleter&amp; original);
        // Create a &#39;ManagedPtrDeleter&#39; object having the same value as the
        // specified &#39;original&#39; object.  Note that this trivial copy
        // constructor&#39;s definition is compiler generated.

    ManagedPtrDeleter(void *object, void *factory, Deleter deleter);
        // Create a &#39;ManagedPtrDeleter&#39; struct that refers to the object and
        // factory instance located at the specified &#39;object&#39; and &#39;factory&#39;
        // memory locations, and the specified &#39;deleter&#39;.  The behavior is
        // undefined unless &#39;deleter&#39; is either 0, or points to a function
        // whose behavior is also defined if called once with &#39;object&#39; and
        // &#39;factory&#39; as arguments.

    //! ~ManagedPtrDeleter() = default;
        // Destroy this object.  Note that this trivial destructor&#39;s definition
        // is compiler generated.

    // MANIPULATORS
    //! ManagedPtrDeleter&amp; operator=(const ManagedPtrDeleter&amp; rhs);
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that this trivial copy-assignment operator&#39;s definition is compiler
        // generated.

    void clear();
        // Reset this &#39;ManagedPtrDeleter&#39; to its uninitialized state.

    void set(void *object, void *factory, Deleter deleter);
        // Set this &#39;ManagedPtrDeleter&#39; to refer to the specified &#39;object&#39;, to
        // the specified &#39;factory&#39;, and to the specified &#39;deleter&#39;.  The
        // behavior is undefined unless &#39;deleter&#39; is either 0, or points to a
        // function whose behavior is also defined if called once with &#39;object&#39;
        // and &#39;factory&#39; as arguments.

    // ACCESSORS
    void deleteManagedObject() const;
        // Invoke the deleter object.  The behavior is undefined unless
        // &#39;deleter&#39; is not 0.

    Deleter deleter() const;
        // Return the deleter function associated with this deleter.

    void *factory() const;
        // Return a pointer to the factory instance associated with this
        // deleter.

    void *object() const;
        // Return a pointer to the managed object associated with this deleter.
};

// FREE OPERATORS
bool operator==(const ManagedPtrDeleter&amp; lhs, const ManagedPtrDeleter&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;ManagedPtrDeleter&#39; objects have the
    // same value if the corresponding values of their &#39;object&#39;, &#39;factory&#39; and
    // &#39;deleter&#39; attributes are the same.

bool operator!=(const ManagedPtrDeleter&amp; lhs, const ManagedPtrDeleter&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;ManagedPtrDeleter&#39; objects do
    // not have the same value if any of the corresponding values of their
    // &#39;object&#39;, &#39;factory&#39; and &#39;deleter&#39; attributes are not the same.

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                       // -----------------------
                       // class ManagedPtrDeleter
                       // -----------------------

// CREATORS
inline
ManagedPtrDeleter::ManagedPtrDeleter()
: d_object_p(0)
, d_factory_p(0)
, d_deleter(0)
{
}

inline
ManagedPtrDeleter::ManagedPtrDeleter(void    *object,
                                     void    *factory,
                                     Deleter  deleter)
: d_object_p(object)
, d_factory_p(factory)
, d_deleter(deleter)
{
}

// MANIPULATORS
inline
void ManagedPtrDeleter::clear()
{
    d_object_p  = 0;
    d_factory_p = 0;
    d_deleter   = 0;
}

inline
void ManagedPtrDeleter::set(void *object, void *factory, Deleter deleter)
{
    d_object_p  = object;
    d_factory_p = factory;
    d_deleter   = deleter;
}

// ACCESSORS
inline
void ManagedPtrDeleter::deleteManagedObject() const
{
    BSLS_ASSERT_SAFE(0 != d_deleter);

    d_deleter(d_object_p, d_factory_p);
}

inline
ManagedPtrDeleter::Deleter
ManagedPtrDeleter::deleter() const
{
    return d_deleter;
}

inline
void *ManagedPtrDeleter::factory() const
{
    return d_factory_p;
}

inline
void *ManagedPtrDeleter::object() const
{
    return d_object_p;
}

}  // close package namespace

// FREE OPERATORS
inline
bool bslma::operator==(const ManagedPtrDeleter&amp; lhs,
                       const ManagedPtrDeleter&amp; rhs)
{
    return lhs.object()  == rhs.object()
        &amp;&amp; lhs.factory() == rhs.factory()
        &amp;&amp; lhs.deleter() == rhs.deleter();
}

inline
bool bslma::operator!=(const ManagedPtrDeleter&amp; lhs,
                       const ManagedPtrDeleter&amp; rhs)
{
    return lhs.object()  != rhs.object()
        || lhs.factory() != rhs.factory()
        || lhs.deleter() != rhs.deleter();
}

// TYPE TRAITS
namespace bslmf {

template &lt;&gt;
struct IsBitwiseMoveable&lt;bslma::ManagedPtrDeleter&gt;
    : bsl::integral_constant&lt;bool, true&gt; {};

}  // close package namespace
}  // close enterprise namespace
#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
