<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bdlma_sequentialallocator.h                                        -*-C++-*-
#ifndef INCLUDED_BDLMA_SEQUENTIALALLOCATOR
#define INCLUDED_BDLMA_SEQUENTIALALLOCATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a managed allocator using dynamically-allocated buffers.
//
//@CLASSES:
//   bdlma::SequentialAllocator: managed allocator using dynamic buffers
//
//@SEE_ALSO: bdlma_infrequentdeleteblocklist, bdlma_sequentialpool
//
//@DESCRIPTION: This component provides a concrete mechanism,
// &#39;bdlma::SequentialAllocator&#39;, that implements the &#39;bdlma::ManagedAllocator&#39;
// protocol and efficiently allocates heterogeneous memory blocks (of varying,
// user-specified sizes) from a dynamically-allocated internal buffer:
//..
//   ,--------------------------.
//  ( bdlma::SequentialAllocator )
//   `--------------------------&#39;
//                |         ctor/dtor
//                |         allocateAndExpand
//                |         reserveCapacity
//                |         truncate
//                V
//    ,-----------------------.
//   ( bdlma::ManagedAllocator )
//    `-----------------------&#39;
//                |         release
//                V
//       ,----------------.
//      ( bslma::Allocator )
//       `----------------&#39;
//                          allocate
//                          deallocate
//..
// If an allocation request exceeds the remaining free memory space in the
// internal buffer, the allocator either replenishes its buffer with new memory
// to satisfy the request, or returns a separate memory block, depending on
// whether the request size exceeds an optionally-specified maximum buffer
// size.  The &#39;release&#39; method releases all memory allocated through the
// allocator, as does the destructor.  Note that individually allocated memory
// blocks cannot be separately deallocated.
//
// The main difference between a &#39;bdlma::SequentialAllocator&#39; and a
// &#39;bdlma::SequentialPool&#39; is that, very often, a &#39;bdlma::SequentialAllocator&#39;
// is managed through a &#39;bslma::Allocator&#39; pointer.  Hence, every call to the
// &#39;allocate&#39; method invokes a virtual function call, which is slower than
// invoking the non-virtual &#39;allocate&#39; method on a &#39;bdlma::SequentialPool&#39;.
// However, since &#39;bslma::Allocator *&#39; is widely used across BDE interfaces,
// &#39;bdlma::SequentialAllocator&#39; is more general purpose than a
// &#39;bdlma::SequentialPool&#39;.
//
///Optional &#39;initialSize&#39; Parameter
///--------------------------------
// An optional &#39;initialSize&#39; parameter can be supplied at construction to
// specify the initial size of the internal buffer.  If &#39;initialSize&#39; is not
// supplied, an implementation-defined value is used for the initial size of
// the internal buffer.
//
///Optional &#39;maxBufferSize&#39; Parameter
/// - - - - - - - - - - - - - - - - -
// If &#39;initialSize&#39; is specified, an optional &#39;maxBufferSize&#39; parameter can be
// supplied at construction to specify the maximum buffer size for geometric
// growth.  Once the internal buffer grows up to the &#39;maxBufferSize&#39;, further
// requests that exceed this size will be served by a separate memory block
// instead of the internal buffer.  The behavior is undefined unless
// &#39;maxBufferSize &gt;= initialSize&#39;.  Note that &#39;reserveCapacity&#39; always ensures
// that the requested number of bytes is available (allocating a new internal
// buffer if necessary) regardless of whether the size of the request exceeds
// &#39;maxBufferSize&#39;.
//
///Optional &#39;growthStrategy&#39; Parameter
///-----------------------------------
// An optional &#39;growthStrategy&#39; parameter can be supplied at construction to
// specify the growth rate of the dynamically-allocated buffers.  The buffers
// can grow either geometrically or remain constant in size.  If
// &#39;growthStrategy&#39; is not specified, geometric growth is used.  See
// &#39;bsls_blockgrowth&#39; for more details.
//
///Optional &#39;alignmentStrategy&#39; Parameter
///--------------------------------------
// An optional &#39;alignmentStrategy&#39; parameter can be supplied at construction to
// specify the memory alignment strategy.  Allocated memory blocks can either
// follow maximum alignment, natural alignment, or 1-byte alignment.  If
// &#39;alignmentStrategy&#39; is not specified, natural alignment is used.  See
// &#39;bsls_alignment&#39; for more details.
//
///Usage
///-----
// Allocators are often supplied, at construction, to objects requiring
// dynamically-allocated memory.  For example, consider the following
// &#39;my_DoubleStack&#39; class whose constructor takes a &#39;bslma::Allocator *&#39;:
//..
//  // my_doublestack.h
//  // ...
//
//  class my_DoubleStack {
//      // This class implements a stack that stores &#39;double&#39; values.
//
//      // DATA
//      double           *d_stack_p;      // dynamically-allocated array
//      int               d_size;         // physical capacity of stack
//      int               d_length;       // next available index in stack
//      bslma::Allocator *d_allocator_p;  // memory allocator (held, not owned)
//
//    private:
//      // PRIVATE MANIPULATORS
//      void increaseCapacity();
//          // Increase the capacity of this stack by at least one element.
//
//    public:
//      // CREATORS
//      explicit my_DoubleStack(bslma::Allocator *basicAllocator = 0);
//          // Create a stack that stores &#39;double&#39; values.  Optionally specify
//          // a &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39;
//          // is 0, the currently installed default allocator is used.
//
//      ~my_DoubleStack();
//          // Destroy this stack and all elements held by it.
//
//      // ...
//
//      // MANIPULATORS
//      void push(double value);
//          // Push the specified &#39;value&#39; onto this stack.
//
//      // ...
//  };
//
//  // ...
//
//  // MANIPULATORS
//  inline
//  void my_DoubleStack::push(double value)
//  {
//      if (d_length &gt;= d_size) {
//          increaseCapacity();
//      }
//      d_stack_p[d_length++] = value;
//  }
//
//  // ...
//
//  // my_doublestack.cpp
//  #include &lt;my_doublestack.h&gt;
//
//  #include &lt;bslma_allocator.h&gt;
//  #include &lt;bslma_default.h&gt;
//
//  // PRIVATE MANIPULATORS
//  void my_DoubleStack::increaseCapacity()
//  {
//      // Implementation elided.
//      // ...
//  }
//
//  // CREATORS
//  my_DoubleStack::my_DoubleStack(bslma::Allocator *basicAllocator)
//  : d_size(1)
//  , d_length(0)
//  , d_allocator_p(bslma::Default::allocator(basicAllocator))
//  {
//      d_stack_p = static_cast&lt;double *&gt;(
//                        d_allocator_p-&gt;allocate(d_size * sizeof *d_stack_p));
//  }
//..
// Note that, when the allocator passed in is a &#39;bdlma::SequentialAllocator&#39;,
// the &#39;deallocate&#39; method is a no-op, and all memory is reclaimed during the
// destruction of the allocator:
//..
//  my_DoubleStack::~my_DoubleStack()
//  {
//      // CLASS INVARIANTS
//      assert(d_allocator_p);
//      assert(d_stack_p);
//      assert(0 &lt;= d_length);
//      assert(0 &lt;= d_size);
//      assert(d_length &lt;= d_size);
//
//      d_allocator_p-&gt;deallocate(d_stack_p);
//  }
//
//  // ...
//..
// In &#39;main&#39;, users can create a &#39;bdlma::SequentialAllocator&#39; and pass it to
// the constructor of &#39;my_DoubleStack&#39;:
//..
//  int main()
//  {
//      bdlma::SequentialAllocator sequentialAlloc;
//      my_DoubleStack dstack(&amp;sequentialAlloc);
//      // ...
//  }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLMA_MANAGEDALLOCATOR
#include &lt;bdlma_managedallocator.h&gt;
#endif

#ifndef INCLUDED_BDLMA_SEQUENTIALPOOL
#include &lt;bdlma_sequentialpool.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_ALIGNMENT
#include &lt;bsls_alignment.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_BSLS_BLOCKGROWTH
#include &lt;bsls_blockgrowth.h&gt;
#endif

namespace BloombergLP {
namespace bdlma {

                      // =========================
                      // class SequentialAllocator
                      // =========================

class SequentialAllocator : public ManagedAllocator {
    // This class implements the &#39;ManagedAllocator&#39; protocol to provide
    // a fast allocator that dispenses heterogeneous blocks of memory (of
    // varying, user-specified sizes) from a sequence of dynamically-allocated
    // buffers.  Memory for the internal buffers is supplied by an (optional)
    // allocator supplied at construction; if no allocator is supplied, the
    // currently installed default allocator is used.  If an allocation exceeds
    // the remaining free memory space in the current buffer, the allocator
    // replenishes its internal buffer with new memory to satisfy the request.
    // This class is *exception* *neutral*: If memory cannot be allocated, the
    // behavior is defined by the (optional) allocator specified at
    // construction.

    // DATA
    SequentialPool d_sequentialPool;  // manager for allocated memory blocks

  private:
    // NOT IMPLEMENTED
    SequentialAllocator(const SequentialAllocator&amp;);
    SequentialAllocator&amp; operator=(const SequentialAllocator&amp;);

  public:
    // CREATORS
    explicit
    SequentialAllocator(bslma::Allocator            *basicAllocator = 0);
    explicit
    SequentialAllocator(bsls::BlockGrowth::Strategy  growthStrategy,
                        bslma::Allocator            *basicAllocator = 0);
    explicit
    SequentialAllocator(bsls::Alignment::Strategy    alignmentStrategy,
                        bslma::Allocator            *basicAllocator = 0);
    SequentialAllocator(bsls::BlockGrowth::Strategy  growthStrategy,
                        bsls::Alignment::Strategy    alignmentStrategy,
                        bslma::Allocator            *basicAllocator = 0);
        // Create a sequential allocator for allocating memory blocks from a
        // sequence of dynamically-allocated buffers.  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory for the dynamically-allocated
        // buffers.  If &#39;basicAllocator&#39; is 0, the currently installed default
        // allocator is used.  Optionally specify a &#39;growthStrategy&#39; used to
        // control buffer growth.  If no &#39;growthStrategy&#39; is specified,
        // geometric growth is used.  Optionally specify an &#39;alignmentStrategy&#39;
        // used to control alignment of allocated memory blocks.  If no
        // &#39;alignmentStrategy&#39; is specified, natural alignment is used.  Note
        // that no limit is imposed on the size of the internal buffers when
        // geometric growth is used.

    explicit
    SequentialAllocator(int                          initialSize,
                        bslma::Allocator            *basicAllocator = 0);
    SequentialAllocator(int                          initialSize,
                        bsls::BlockGrowth::Strategy  growthStrategy,
                        bslma::Allocator            *basicAllocator = 0);
    SequentialAllocator(int                          initialSize,
                        bsls::Alignment::Strategy    alignmentStrategy,
                        bslma::Allocator            *basicAllocator = 0);
    SequentialAllocator(int                          initialSize,
                        bsls::BlockGrowth::Strategy  growthStrategy,
                        bsls::Alignment::Strategy    alignmentStrategy,
                        bslma::Allocator            *basicAllocator = 0);
        // Create a sequential allocator for allocating memory blocks from a
        // sequence of dynamically-allocated buffers, of which the initial
        // buffer has the specified &#39;initialSize&#39; (in bytes).  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory for the
        // dynamically-allocated buffers.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.  Optionally specify a
        // &#39;growthStrategy&#39; used to control buffer growth.  If no
        // &#39;growthStrategy&#39; is specified, geometric growth is used.  Optionally
        // specify an &#39;alignmentStrategy&#39; used to control alignment of
        // allocated memory blocks.  If no &#39;alignmentStrategy&#39; is specified,
        // natural alignment is used.  An implementation-defined value is used
        // as the initial size of the internal buffer.  The behavior is
        // undefined unless &#39;0 &lt; initialSize&#39;.  Note that no limit is imposed
        // on the size of the internal buffers when geometric growth is used.
        // Also note that when constant growth is used, the size of the
        // internal buffers will always be the same as the
        // implementation-defined value.


    SequentialAllocator(int                          initialSize,
                        int                          maxBufferSize,
                        bslma::Allocator            *basicAllocator = 0);
    SequentialAllocator(int                          initialSize,
                        int                          maxBufferSize,
                        bsls::BlockGrowth::Strategy  growthStrategy,
                        bslma::Allocator            *basicAllocator = 0);
    SequentialAllocator(int                          initialSize,
                        int                          maxBufferSize,
                        bsls::Alignment::Strategy    alignmentStrategy,
                        bslma::Allocator            *basicAllocator = 0);
    SequentialAllocator(int                          initialSize,
                        int                          maxBufferSize,
                        bsls::BlockGrowth::Strategy  growthStrategy,
                        bsls::Alignment::Strategy    alignmentStrategy,
                        bslma::Allocator            *basicAllocator = 0);
        // Create a sequential allocator for allocating memory blocks from a
        // sequence of dynamically-allocated buffers, of which the initial
        // buffer has the specified &#39;initialSize&#39; (in bytes), and the buffer
        // growth is limited to the specified &#39;maxBufferSize&#39;.  Optionally
        // specify a &#39;basicAllocator&#39; used to supply memory for the
        // dynamically-allocated buffers.  If &#39;basicAllocator&#39; is 0, the
        // currently installed default allocator is used.  Optionally specify a
        // &#39;growthStrategy&#39; used to control buffer growth.  If no
        // &#39;growthStrategy&#39; is specified, geometric growth is used.  Optionally
        // specify an &#39;alignmentStrategy&#39; used to control alignment of
        // allocated memory blocks.  If no &#39;alignmentStrategy&#39; is specified,
        // natural alignment is used.  The behavior is undefined unless
        // &#39;0 &lt; initialSize&#39; and &#39;initialSize &lt;= maxBufferSize&#39;.  Note that
        // when constant growth is used, the size of the internal buffers will
        // always be the same as &#39;initialSize&#39;.

    virtual ~SequentialAllocator();
        // Destroy this sequential allocator.  All memory allocated from this
        // allocator is released.

    // MANIPULATORS
    virtual void *allocate(size_type size);
        // Return the address of a contiguous block of memory of the specified
        // &#39;size&#39; (in bytes) according to the alignment strategy specified at
        // construction.  If &#39;size&#39; is 0, no memory is allocated and 0 is
        // returned.  If the allocation request exceeds the remaining free
        // memory space in the current internal buffer, use the allocator
        // supplied at construction to allocate a new internal buffer, then
        // allocate memory from the new buffer.

    void *allocateAndExpand(size_type *size);
        // Return the address of a contiguous block of memory of at least the
        // specified &#39;*size&#39; (in bytes), and load the actual amount of memory
        // allocated into &#39;*size&#39;.  If &#39;*size&#39; is 0, return 0 with no effect.
        // If the allocation request exceeds the remaining free memory space in
        // the current internal buffer, use the allocator supplied at
        // construction to allocate a new internal buffer, then allocate memory
        // from the new buffer.

    virtual void deallocate(void *address);
        // This method has no effect on the memory block at the specified
        // &#39;address&#39; as all memory allocated by this allocator is managed.  The
        // behavior is undefined unless &#39;address&#39; is 0, or was allocated by
        // this allocator and has not already been deallocated.

    virtual void release();
        // Release all memory allocated through this allocator.  The allocator
        // is reset to its default constructed state, retaining the alignment
        // and growth strategy supplied at construction (if any) after this
        // call.

    void reserveCapacity(int numBytes);
        // Reserve sufficient memory to satisfy allocation requests for at
        // least the specified &#39;numBytes&#39; without replenishment (i.e., without
        // dynamic allocation).  If &#39;numBytes&#39; is 0, no memory is reserved.
        // This method ignores &#39;maxBufferSize&#39; even if it is supplied at
        // construction.  The behavior is undefined unless &#39;0 &lt;= numBytes&#39;.
        // Note that, due to alignment effects, it is possible that not all
        // &#39;numBytes&#39; of memory will be used for allocation before triggering
        // dynamic allocation.

    int truncate(void *address, int originalSize, int newSize);
        // Reduce the amount of memory allocated at the specified &#39;address&#39;
        // of the specified &#39;originalSize&#39; (in bytes) to the specified
        // &#39;newSize&#39;.  Return &#39;newSize&#39; after truncating, or &#39;originalSize&#39; if
        // the memory at &#39;address&#39; cannot be truncated.  This method can only
        // &#39;truncate&#39; the memory block returned by the most recent &#39;allocate&#39;
        // request from this allocator, and otherwise has no effect.  The
        // behavior is undefined unless the memory at &#39;address&#39; was originally
        // allocated by this allocator, the size of the memory block at
        // &#39;address&#39; is &#39;originalSize&#39;, &#39;newSize &lt;= originalSize&#39;,
        // &#39;0 &lt;= newSize&#39;, and &#39;release&#39; was not called after allocating the
        // memory block at &#39;address&#39;.
};

// ============================================================================
//                      INLINE FUNCTION DEFINITIONS
// ============================================================================

                      // -------------------------
                      // class SequentialAllocator
                      // -------------------------

// CREATORS
inline
SequentialAllocator::
SequentialAllocator(bslma::Allocator *basicAllocator)
: d_sequentialPool(basicAllocator)
{
}

inline
SequentialAllocator::
SequentialAllocator(bsls::BlockGrowth::Strategy  growthStrategy,
                    bslma::Allocator            *basicAllocator)
: d_sequentialPool(growthStrategy, basicAllocator)
{
}

inline
SequentialAllocator::
SequentialAllocator(bsls::Alignment::Strategy  alignmentStrategy,
                    bslma::Allocator          *basicAllocator)
: d_sequentialPool(alignmentStrategy, basicAllocator)
{
}

inline
SequentialAllocator::
SequentialAllocator(bsls::BlockGrowth::Strategy  growthStrategy,
                    bsls::Alignment::Strategy    alignmentStrategy,
                    bslma::Allocator            *basicAllocator)
: d_sequentialPool(growthStrategy, alignmentStrategy, basicAllocator)
{
}

inline
SequentialAllocator::
SequentialAllocator(int               initialSize,
                    bslma::Allocator *basicAllocator)
: d_sequentialPool(initialSize, basicAllocator)
{
    BSLS_ASSERT_SAFE(0 &lt; initialSize);
}

inline
SequentialAllocator::
SequentialAllocator(int                          initialSize,
                    bsls::BlockGrowth::Strategy  growthStrategy,
                    bslma::Allocator            *basicAllocator)
: d_sequentialPool(initialSize, growthStrategy, basicAllocator)
{
    BSLS_ASSERT_SAFE(0 &lt; initialSize);
}

inline
SequentialAllocator::
SequentialAllocator(int                        initialSize,
                    bsls::Alignment::Strategy  alignmentStrategy,
                    bslma::Allocator          *basicAllocator)
: d_sequentialPool(initialSize, alignmentStrategy, basicAllocator)
{
    BSLS_ASSERT_SAFE(0 &lt; initialSize);
}

inline
SequentialAllocator::
SequentialAllocator(int                          initialSize,
                    bsls::BlockGrowth::Strategy  growthStrategy,
                    bsls::Alignment::Strategy    alignmentStrategy,
                    bslma::Allocator            *basicAllocator)
: d_sequentialPool(initialSize,
                   growthStrategy,
                   alignmentStrategy,
                   basicAllocator)
{
    BSLS_ASSERT_SAFE(0 &lt; initialSize);
}

inline
SequentialAllocator::
SequentialAllocator(int               initialSize,
                    int               maxBufferSize,
                    bslma::Allocator *basicAllocator)
: d_sequentialPool(initialSize, maxBufferSize, basicAllocator)
{
    BSLS_ASSERT_SAFE(0 &lt; initialSize);
    BSLS_ASSERT_SAFE(initialSize &lt;= maxBufferSize);
}

inline
SequentialAllocator::
SequentialAllocator(int                          initialSize,
                    int                          maxBufferSize,
                    bsls::BlockGrowth::Strategy  growthStrategy,
                    bslma::Allocator            *basicAllocator)
: d_sequentialPool(initialSize, maxBufferSize, growthStrategy, basicAllocator)
{
    BSLS_ASSERT_SAFE(0 &lt; initialSize);
    BSLS_ASSERT_SAFE(initialSize &lt;= maxBufferSize);
}

inline
SequentialAllocator::
SequentialAllocator(int                        initialSize,
                    int                        maxBufferSize,
                    bsls::Alignment::Strategy  alignmentStrategy,
                    bslma::Allocator          *basicAllocator)
: d_sequentialPool(initialSize,
                   maxBufferSize,
                   alignmentStrategy,
                   basicAllocator)
{
    BSLS_ASSERT_SAFE(0 &lt; initialSize);
    BSLS_ASSERT_SAFE(initialSize &lt;= maxBufferSize);
}

inline
SequentialAllocator::
SequentialAllocator(int                          initialSize,
                    int                          maxBufferSize,
                    bsls::BlockGrowth::Strategy  growthStrategy,
                    bsls::Alignment::Strategy    alignmentStrategy,
                    bslma::Allocator            *basicAllocator)
: d_sequentialPool(initialSize,
                   maxBufferSize,
                   growthStrategy,
                   alignmentStrategy,
                   basicAllocator)
{
    BSLS_ASSERT_SAFE(0 &lt; initialSize);
    BSLS_ASSERT_SAFE(initialSize &lt;= maxBufferSize);
}

// MANIPULATORS
inline
void SequentialAllocator::deallocate(void *)
{
}

inline
void SequentialAllocator::release()
{
    d_sequentialPool.release();
}

inline
int SequentialAllocator::truncate(void *address,
                                  int   originalSize,
                                  int   newSize)
{
    return d_sequentialPool.truncate(address, originalSize, newSize);
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2012 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
