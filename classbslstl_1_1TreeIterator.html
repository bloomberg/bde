<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Class bslstl::TreeIterator</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebslstl.html">bslstl</a>      </li>
      <li><a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>bslstl::TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bslstl::TreeIterator" -->
<p><code>#include &lt;<a class="el" href="bslstl__treeiterator_8h_source.html">bslstl_treeiterator.h</a>&gt;</code></p>

<p><a href="classbslstl_1_1TreeIterator-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
bsl::bidirectional_iterator_tag&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a4a367bf35d2907e8b137ea55d36700de">iterator_category</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef NcType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a0bf603865eb5024001272455a000464d">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef DIFFERENCE_TYPE&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a0f3ceb6e6b6f1f74d6e75120a1c1d0a9">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a742bcb1f1e36056c5769c5dc16782432">pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef VALUE &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a6ab68b3863fcb8adb3da361026e572e7">reference</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a659ebeeff399d4407cabefc5f4f0501e">TreeIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a20979792f5266e86ebf7d95563c17dda">TreeIterator</a> (const <a class="el" href="classbslalg_1_1RbTreeNode.html">bslalg::RbTreeNode</a> *node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a0b817522244fb78c044cb78020099e90">TreeIterator</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">NcIter</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#ad33ac6fc880278c8eeff6d3ca9284f52">TreeIterator</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a5698ee3cabfa3aa647b9003403ca6269">~TreeIterator</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a90f6c9543cc73d9819f72653eed3a61d">operator=</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a453f76eedbfa576af927625a1ef9508b">operator++</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a0569f42e89e398138006472699c07c79">operator--</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html#a6ab68b3863fcb8adb3da361026e572e7">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a4fc97306f472b15a58c6b015cdd32730">operator*</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbslstl_1_1TreeIterator.html#a742bcb1f1e36056c5769c5dc16782432">pointer</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#aaf51fec221240046db0166d9c1719a5f">operator-&gt;</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbslalg_1_1RbTreeNode.html">bslalg::RbTreeNode</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#ac5a4f33c029d2a43be89a05cdb6d31f3">node</a> () const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#a925e5a7f5dc110e63f7062d0e6898af9">TreeIterator</a></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#ade18ee6a59dd58ccc0755a0bebb48566">operator==</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE1, NODEPTR, DIFF &gt; &amp;, const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE2, NODEPTR, DIFF &gt; &amp;)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classbslstl_1_1TreeIterator.html#ac8177572c792a72291a8ebefcf67aaf6">operator!=</a> (const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE1, NODEPTR, DIFF &gt; &amp;, const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE2, NODEPTR, DIFF &gt; &amp;)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt;<br/>
 class bslstl::TreeIterator&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;</h3>

<p>This class provides an STL-conforming bidirectional iterator over the ordered <code><a class="el" href="classbslalg_1_1RbTreeNode.html">bslalg::RbTreeNode</a></code> objects in a binary tree (see section [24.2.6 bidirectional.iterators] of the C++11 standard). A <code><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a></code> provides access to values of the parameterized <code>VALUE</code>, over a binary tree composed of nodes of the parameterized <code>NODE</code> (which must derive from <code><a class="el" href="classbslalg_1_1RbTreeNode.html">bslalg::RbTreeNode</a></code>). The parameterized <code>DIFFERENCE_TYPE</code> determines the standard required <code>difference_type</code> of the iterator, without requiring access to the allocator-traits for the node. The behavior of the <code>operator*</code> method is undefined unless the iterator is at a valid position in the tree (i.e., not the <code>end</code>) and the referenced element has not been removed since the iterator was constructed. <code>NODE</code> must derives from <code><a class="el" href="classbslalg_1_1RbTreeNode.html">bslalg::RbTreeNode</a></code>, and contains a <code>value</code> method that returns a reference providing modifiable access to a type that is convertible to the parameterized <code>VALUE</code> (e.g., a <code><a class="el" href="classbslstl_1_1TreeNode.html">bslstl::TreeNode</a></code> object). </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a4a367bf35d2907e8b137ea55d36700de"></a><!-- doxytag: member="bslstl::TreeIterator::iterator_category" ref="a4a367bf35d2907e8b137ea55d36700de" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::bidirectional_iterator_tag <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html#a4a367bf35d2907e8b137ea55d36700de">iterator_category</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0bf603865eb5024001272455a000464d"></a><!-- doxytag: member="bslstl::TreeIterator::value_type" ref="a0bf603865eb5024001272455a000464d" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef NcType <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html#a0bf603865eb5024001272455a000464d">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f3ceb6e6b6f1f74d6e75120a1c1d0a9"></a><!-- doxytag: member="bslstl::TreeIterator::difference_type" ref="a0f3ceb6e6b6f1f74d6e75120a1c1d0a9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef DIFFERENCE_TYPE <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html#a0f3ceb6e6b6f1f74d6e75120a1c1d0a9">difference_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a742bcb1f1e36056c5769c5dc16782432"></a><!-- doxytag: member="bslstl::TreeIterator::pointer" ref="a742bcb1f1e36056c5769c5dc16782432" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE* <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html#a742bcb1f1e36056c5769c5dc16782432">pointer</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a6ab68b3863fcb8adb3da361026e572e7"></a><!-- doxytag: member="bslstl::TreeIterator::reference" ref="a6ab68b3863fcb8adb3da361026e572e7" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef VALUE&amp; <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html#a6ab68b3863fcb8adb3da361026e572e7">reference</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a659ebeeff399d4407cabefc5f4f0501e"></a><!-- doxytag: member="bslstl::TreeIterator::TreeIterator" ref="a659ebeeff399d4407cabefc5f4f0501e" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an uninitialized iterator. </p>

</div>
</div>
<a class="anchor" id="a20979792f5266e86ebf7d95563c17dda"></a><!-- doxytag: member="bslstl::TreeIterator::TreeIterator" ref="a20979792f5266e86ebf7d95563c17dda" args="(const bslalg::RbTreeNode *node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslalg_1_1RbTreeNode.html">bslalg::RbTreeNode</a> *&nbsp;</td>
          <td class="paramname"> <em>node</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator at the specified <code>position</code>. The behavior is undefined unless <code>node</code> is of the parameterized <code>NODE</code>, which is derived from 'bslalgRbTreeNode. Note that this constructor is an implementation detail and is not part of the C++ standard. </p>

</div>
</div>
<a class="anchor" id="a0b817522244fb78c044cb78020099e90"></a><!-- doxytag: member="bslstl::TreeIterator::TreeIterator" ref="a0b817522244fb78c044cb78020099e90" args="(const NcIter &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1TreeIterator.html">NcIter</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator at the same position as the specified <code>original</code> iterator. Note that this constructor enables converting from modifiable to const iterator types. </p>

</div>
</div>
<a class="anchor" id="ad33ac6fc880278c8eeff6d3ca9284f52"></a><!-- doxytag: member="bslstl::TreeIterator::TreeIterator" ref="ad33ac6fc880278c8eeff6d3ca9284f52" args="(const TreeIterator &amp;original)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>original</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an iterator having the same value as the specified <code>original</code>. Note that this operation is either defined by the constructor taking <code>NcIter</code> (if <code>NcType</code> is the same as <code>VALUE</code>), or generated automatically by the compiler. Also note that this construct cannot be defined explicitly (without using <code>bsls_enableif</code>) to avoid a duplicate declaration when <code>NcType</code> is the same as <code>VALUE</code>. </p>

</div>
</div>
<a class="anchor" id="a5698ee3cabfa3aa647b9003403ca6269"></a><!-- doxytag: member="bslstl::TreeIterator::~TreeIterator" ref="a5698ee3cabfa3aa647b9003403ca6269" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::~<a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this object. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a90f6c9543cc73d9819f72653eed3a61d"></a><!-- doxytag: member="bslstl::TreeIterator::operator=" ref="a90f6c9543cc73d9819f72653eed3a61d" args="(const TreeIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&amp; <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this object the value of the specified <code>rhs</code> object, and a return a reference providing modifiable access to this object. </p>

</div>
</div>
<a class="anchor" id="a453f76eedbfa576af927625a1ef9508b"></a><!-- doxytag: member="bslstl::TreeIterator::operator++" ref="a453f76eedbfa576af927625a1ef9508b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&amp; <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the next element in the tree and return a reference providing modifiable access to this iterator. The behavior is undefined unless the iterator refers to an element in the tree. </p>

</div>
</div>
<a class="anchor" id="a0569f42e89e398138006472699c07c79"></a><!-- doxytag: member="bslstl::TreeIterator::operator&#45;&#45;" ref="a0569f42e89e398138006472699c07c79" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&amp; <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move this iterator to the previous element in the tree and return a reference providing modifiable access to this iterator. The behavior is undefined unless the iterator refers to the past-the-end address or the non-leftmost element in the tree. </p>

</div>
</div>
<a class="anchor" id="a4fc97306f472b15a58c6b015cdd32730"></a><!-- doxytag: member="bslstl::TreeIterator::operator*" ref="a4fc97306f472b15a58c6b015cdd32730" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html#a6ab68b3863fcb8adb3da361026e572e7">reference</a> <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference providing modifiable access to the value (of the parameterized <code>VALUE</code>) of the element at which this iterator is positioned. The behavior is undefined unless this iterator is at a valid position in the tree. </p>

</div>
</div>
<a class="anchor" id="aaf51fec221240046db0166d9c1719a5f"></a><!-- doxytag: member="bslstl::TreeIterator::operator&#45;&gt;" ref="aaf51fec221240046db0166d9c1719a5f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbslstl_1_1TreeIterator.html#a742bcb1f1e36056c5769c5dc16782432">pointer</a> <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the value (of the parameterized <code>VALUE</code>) of the element at which this iterator is positioned. The behavior is undefined unless this iterator is at a valid position in the tree. </p>

</div>
</div>
<a class="anchor" id="ac5a4f33c029d2a43be89a05cdb6d31f3"></a><!-- doxytag: member="bslstl::TreeIterator::node" ref="ac5a4f33c029d2a43be89a05cdb6d31f3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbslalg_1_1RbTreeNode.html">bslalg::RbTreeNode</a>* <a class="el" href="classbslstl_1_1TreeIterator.html">bslstl::TreeIterator</a>&lt; VALUE, NODE, DIFFERENCE_TYPE &gt;::node </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the non-modifiable tree node at which this iterator is positioned, or 0 if this iterator is not at a valid position in the tree. Note that this method is an implementation detail and is not part of the C++ standard. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="a925e5a7f5dc110e63f7062d0e6898af9"></a><!-- doxytag: member="bslstl::TreeIterator::TreeIterator" ref="a925e5a7f5dc110e63f7062d0e6898af9" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ade18ee6a59dd58ccc0755a0bebb48566"></a><!-- doxytag: member="bslstl::TreeIterator::operator==" ref="ade18ee6a59dd58ccc0755a0bebb48566" args="(const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;, const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE1, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE2, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators have the same value and <code>false</code> otherwise. Two iterators have the same value if they refer to the same position in the same tree, or if both iterators are at an invalid position in the tree (i.e., the <code>end</code> of the tree, or the default constructed value). </p>

</div>
</div>
<a class="anchor" id="ac8177572c792a72291a8ebefcf67aaf6"></a><!-- doxytag: member="bslstl::TreeIterator::operator!=" ref="ac8177572c792a72291a8ebefcf67aaf6" args="(const TreeIterator&lt; VALUE1, NODEPTR, DIFF &gt; &amp;, const TreeIterator&lt; VALUE2, NODEPTR, DIFF &gt; &amp;)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class VALUE, class NODE, class DIFFERENCE_TYPE&gt; </div>
<div class="memtemplate">
template&lt;class VALUE1 , class VALUE2 , class NODEPTR , class DIFF &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE1, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbslstl_1_1TreeIterator.html">TreeIterator</a>&lt; VALUE2, NODEPTR, DIFF &gt; &amp;&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and the specified <code>rhs</code> iterators do not have the same value and <code>false</code> otherwise. Two iterators do not have the same value if they differ in either the tree to which they refer or the position in that tree. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslstl__treeiterator_8h_source.html">bslstl_treeiterator.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:45 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
