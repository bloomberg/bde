<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Namespace bdlt</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bdlt Namespace Reference<br/>
<small>
[<a class="el" href="group__balber__berutil.html">Component balber_berutil</a>,&nbsp;<a class="el" href="group__bbldc__basicbasicdaycountadapter.html">Component bbldc_basicbasicdaycountadapter</a>,&nbsp;<a class="el" href="group__bbldc__basicdaycount.html">Component bbldc_basicdaycount</a>,&nbsp;<a class="el" href="group__bbldc__basicdaycountutil.html">Component bbldc_basicdaycountutil</a>,&nbsp;<a class="el" href="group__bbldc__basicisma30360.html">Component bbldc_basicisma30360</a>,&nbsp;<a class="el" href="group__bbldc__basicpsa30360eom.html">Component bbldc_basicpsa30360eom</a>,&nbsp;<a class="el" href="group__bbldc__basicsia30360eom.html">Component bbldc_basicsia30360eom</a>,&nbsp;<a class="el" href="group__bbldc__basicsia30360neom.html">Component bbldc_basicsia30360neom</a>,&nbsp;<a class="el" href="group__bbldc__calendardaycountutil.html">Component bbldc_calendardaycountutil</a>,&nbsp;<a class="el" href="group__bbldc__daterangedaycount.html">Component bbldc_daterangedaycount</a>,&nbsp;<a class="el" href="group__bbldc__perioddaycountutil.html">Component bbldc_perioddaycountutil</a>,&nbsp;<a class="el" href="group__bdlt__calendar.html">Component bdlt_calendar</a>,&nbsp;<a class="el" href="group__bdlt__calendarcache.html">Component bdlt_calendarcache</a>,&nbsp;<a class="el" href="group__bdlt__calendarloader.html">Component bdlt_calendarloader</a>,&nbsp;<a class="el" href="group__bdlt__calendarreverseiteratoradapter.html">Component bdlt_calendarreverseiteratoradapter</a>,&nbsp;<a class="el" href="group__bdlt__currenttime.html">Component bdlt_currenttime</a>,&nbsp;<a class="el" href="group__bdlt__date.html">Component bdlt_date</a>,&nbsp;<a class="el" href="group__bdlt__datetime.html">Component bdlt_datetime</a>,&nbsp;<a class="el" href="group__bdlt__datetimeinterval.html">Component bdlt_datetimeinterval</a>,&nbsp;<a class="el" href="group__bdlt__datetimetz.html">Component bdlt_datetimetz</a>,&nbsp;<a class="el" href="group__bdlt__datetimeutil.html">Component bdlt_datetimeutil</a>,&nbsp;<a class="el" href="group__bdlt__datetz.html">Component bdlt_datetz</a>,&nbsp;<a class="el" href="group__bdlt__dateutil.html">Component bdlt_dateutil</a>,&nbsp;<a class="el" href="group__bdlt__dayofweek.html">Component bdlt_dayofweek</a>,&nbsp;<a class="el" href="group__bdlt__dayofweekset.html">Component bdlt_dayofweekset</a>,&nbsp;<a class="el" href="group__bdlt__defaultcalendarcache.html">Component bdlt_defaultcalendarcache</a>,&nbsp;<a class="el" href="group__bdlt__epochutil.html">Component bdlt_epochutil</a>,&nbsp;<a class="el" href="group__bdlt__intervalconversionutil.html">Component bdlt_intervalconversionutil</a>,&nbsp;<a class="el" href="group__bdlt__iso8601util.html">Component bdlt_iso8601util</a>,&nbsp;<a class="el" href="group__bdlt__iso8601utilconfiguration.html">Component bdlt_iso8601utilconfiguration</a>,&nbsp;<a class="el" href="group__bdlt__localtimeoffset.html">Component bdlt_localtimeoffset</a>,&nbsp;<a class="el" href="group__bdlt__monthofyear.html">Component bdlt_monthofyear</a>,&nbsp;<a class="el" href="group__bdlt__packedcalendar.html">Component bdlt_packedcalendar</a>,&nbsp;<a class="el" href="group__bdlt__posixdateimputil.html">Component bdlt_posixdateimputil</a>,&nbsp;<a class="el" href="group__bdlt__prolepticdateimputil.html">Component bdlt_prolepticdateimputil</a>,&nbsp;<a class="el" href="group__bdlt__serialdateimputil.html">Component bdlt_serialdateimputil</a>,&nbsp;<a class="el" href="group__bdlt__time.html">Component bdlt_time</a>,&nbsp;<a class="el" href="group__bdlt__timetz.html">Component bdlt_timetz</a>,&nbsp;<a class="el" href="group__bdlt__timeunitratio.html">Component bdlt_timeunitratio</a>,&nbsp;<a class="el" href="group__bdlt__timeutil.html">Component bdlt_timeutil</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Calendar.html">Calendar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1CalendarCache.html">CalendarCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1CalendarLoader.html">CalendarLoader</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1CurrentTime.html">CurrentTime</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Date.html">Date</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1DatetimeUtil.html">DatetimeUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1DateUtil.html">DateUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1DayOfWeek.html">DayOfWeek</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1DefaultCalendarCache.html">DefaultCalendarCache</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1EpochUtil.html">EpochUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1IntervalConversionUtil.html">IntervalConversionUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1Iso8601Util.html">Iso8601Util</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Iso8601UtilConfiguration.html">Iso8601UtilConfiguration</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1LocalTimeOffset.html">LocalTimeOffset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1MonthOfYear.html">MonthOfYear</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1PackedCalendar.html">PackedCalendar</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1PackedCalendar__DateProxy.html">PackedCalendar_DateProxy</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1PackedCalendar__DateRef.html">PackedCalendar_DateRef</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1PosixDateImpUtil.html">PosixDateImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1ProlepticDateImpUtil.html">ProlepticDateImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Time.html">Time</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1TimeUnitRatio.html">TimeUnitRatio</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1TimeUtil.html">TimeUtil</a></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structbdlt_1_1PosixDateImpUtil.html">PosixDateImpUtil</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a39d3e4190d5d831962152f7f196cb248">SerialDateImpUtil</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a53413c9c7fd48836e6d0c8c76ff0198e">operator==</a> (const <a class="el" href="classbdlt_1_1Calendar.html">Calendar</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Calendar.html">Calendar</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#adda52a5fd65c8996b2056aeb52ab70b1">operator!=</a> (const <a class="el" href="classbdlt_1_1Calendar.html">Calendar</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Calendar.html">Calendar</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ace9e9a68a5e083ce6ca00ce630b667bf">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1Calendar.html">Calendar</a> &amp;calendar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aaecf67b7552a64b1899f9d969a2309db">swap</a> (<a class="el" href="classbdlt_1_1Calendar.html">Calendar</a> &amp;a, <a class="el" href="classbdlt_1_1Calendar.html">Calendar</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#adf89a0a55bea26ad4f20bb75589a98a4">operator==</a> (const <a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a3b15c6a752715ceff3e1190752d8705a">operator!=</a> (const <a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a3f3d2ba846de33df501a4283779eb085">operator++</a> (<a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a> &amp;iterator, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#af966fdcf80e9904580cd52a3418b34f1">operator--</a> (<a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a> &amp;iterator, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a2c32d324b9f19b399cae0455bcb92027">operator==</a> (const <a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a>&lt; ITERATOR &gt; &amp;lhs, const <a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a>&lt; ITERATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#af13859820ff5270235757e8ffc566550">operator!=</a> (const <a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a>&lt; ITERATOR &gt; &amp;lhs, const <a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a>&lt; ITERATOR &gt; &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a><br class="typebreak"/>
&lt; ITERATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a82c408a6202ecc7107ff567a24d684fa">operator++</a> (<a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a>&lt; ITERATOR &gt; &amp;iterator, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class ITERATOR &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a><br class="typebreak"/>
&lt; ITERATOR &gt;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a1589c5040cc306a48c56b95c6a78cefb">operator--</a> (<a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a>&lt; ITERATOR &gt; &amp;iterator, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a0ec35f2cc29136ed6d2b66fd13b555e4">operator==</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ac705681a5d9979b0e193b9f057a4fb78">operator!=</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abeee7c1493f32c20d88de35621b4897b">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a2bc9ec2a06c5807f768293f8127fe1e5">operator&lt;</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abc73a4cbaf8d3da470d31aa33220314e">operator&lt;=</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a1a3cb249a27fbf19b173896b3a5b5c27">operator&gt;</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a86c04ddf8f13bdabcb0373d88f9351b0">operator&gt;=</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a49dbb017bac6819fd634adf28c73bfc6">operator++</a> (<a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a0fc43ceb7179c7af22909f66e02a3350">operator--</a> (<a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aa2d88ce9a9249f9ae9b35ac1dce3bede">operator+</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date, int numDays)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ab66a081421c981594be6d5f313310d2f">operator+</a> (int numDays, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a596fc180f7f9f0e4e4bb585e26d7517e">operator-</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date, int numDays)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#afc48c336d4232852121d3f7873829119">operator-</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class HASHALG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a407f244b8b748911b4cd05859b2c3f94">hashAppend</a> (HASHALG &amp;hashAlg, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a87dae07ed0f513c3bcd5e85bc4ccda7c">operator+</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a301e7055d0f31579de2b38c79f775f12">operator+</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ab08128a744e786dbf5493e78522021f1">operator-</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a30df660dbc2372391b19ddbf479194d9">operator-</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a213cd6bc42c4cec13528a1c831bdcf26">operator==</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a4eb84423be540857ea9d53aec0774a80">operator!=</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aeb391ec18b3add2e35ef8c5bc97ce36e">operator&lt;</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a8452d0f7b5c51f594e2ae6099a1c099e">operator&lt;=</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a635a8d64b2fa6917451defc4249da85f">operator&gt;</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a2e8273cc1f906b7b0eb386341a1b0f75">operator&gt;=</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abeedb0b000fa4ad1e219bf570ad8afac">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a92a32b7e56231cae8d6c79ace30312a9">operator+</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#addcfed615ab66de5740d6cc1a03fc4c3">operator-</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a58bd4269d0c2b901e564a327f0a2b033">operator-</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#addc4bd05840b52ddb181ed871ac3df8e">operator==</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a2eb359385d0b377e259abe583531508b">operator!=</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a52d0e0f383b0a6336314f538e8c01852">operator&lt;</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ad64ee5c0db952721eeb8f3e794b320a8">operator&lt;=</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ade6868a3fa95bc24ae09cb5e2547de47">operator&gt;</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a4820d7f25799d2d4c1eb22a0a850d55a">operator&gt;=</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a06c921c9fea95a004bfaf1b638b0bc84">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a70c449b04114c08e6a9b24b21383faf9">operator==</a> (const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a9b8feb08f678addedc5d1c392ebec18f">operator!=</a> (const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a327897c0cc2850341571fa935dc0e27d">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a19bfcd014a9cf8ca63178f353f0b3241">operator==</a> (const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a23a509c6ef18abc3d44841d4257db84d">operator!=</a> (const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a91385ac498bd1014020a65c6c6dc3f8a">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a25dfb4d5103b40f0552e3ecaad67b484">operator&lt;&lt;</a> (bsl::ostream &amp;stream, <a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573">DayOfWeek::Enum</a> value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a> (STREAM &amp;stream, <a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573">DayOfWeek::Enum</a> &amp;variable, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a9cf1c829a8cb75604972fa47826d2dda">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573">DayOfWeek::Enum</a> &amp;value, int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a939d0f2f7d5823be26b17d3c1e9371d5">maxSupportedBdexVersion</a> (const <a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573">DayOfWeek::Enum</a> *, int versionSelector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a1474adde66538699353253639a6732e7">operator==</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a8b026d031d58fad1a60e282c8b72f73e">operator!=</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ae9da41d3f95b3f159d75653154677407">operator~</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a93ded80bbde497f532cabc23f9c91701">operator|</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a65b523b18113f0bb0a7146311e456b4d">operator&amp;</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ab1e47b13331c7843ba7b1451eb298504">operator^</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abda0ca1acb2d07f61acecf8789b8486a">operator-</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ad5332804659034011308da81c615658f">operator==</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a56e69bd581ae4fb5186d7b4a410bbb83">operator!=</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a21500c97ab5edb7d6c12194a6d28788c">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ada67f8636ca95e65b5f424786d1ad111">operator==</a> (const <a class="el" href="classbdlt_1_1Iso8601UtilConfiguration.html">Iso8601UtilConfiguration</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Iso8601UtilConfiguration.html">Iso8601UtilConfiguration</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a0ede9f938f7317463d9c4769e2bcb100">operator!=</a> (const <a class="el" href="classbdlt_1_1Iso8601UtilConfiguration.html">Iso8601UtilConfiguration</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Iso8601UtilConfiguration.html">Iso8601UtilConfiguration</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a6da926b5406c71f06094e68e5c334c76">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1Iso8601UtilConfiguration.html">Iso8601UtilConfiguration</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a71626d77b2e1ecdaa823711ead4a376e">operator&lt;&lt;</a> (bsl::ostream &amp;stream, <a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f">MonthOfYear::Enum</a> value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#afb8fea6c03f1b65c18f16fb460da1376">bdexStreamIn</a> (STREAM &amp;stream, <a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f">MonthOfYear::Enum</a> &amp;variable, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#adcc16797804c9d73ad7d4b732d52e7dd">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f">MonthOfYear::Enum</a> &amp;value, int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a9c8c6e0fc572fb4d863b8ac9b6fbb0c9">maxSupportedBdexVersion</a> (const <a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f">MonthOfYear::Enum</a> *, int versionSelector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a6cb708e834ebff2c1c0a139f98a9c333">operator==</a> (const <a class="el" href="classbdlt_1_1PackedCalendar.html">PackedCalendar</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar.html">PackedCalendar</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a98db920b28ae83834d80926311bf314c">operator!=</a> (const <a class="el" href="classbdlt_1_1PackedCalendar.html">PackedCalendar</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar.html">PackedCalendar</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a1fc254e089c5993798a256e09f573480">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1PackedCalendar.html">PackedCalendar</a> &amp;calendar)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a95555873bb3c8af8d13c22785a2ae8ea">swap</a> (<a class="el" href="classbdlt_1_1PackedCalendar.html">PackedCalendar</a> &amp;a, <a class="el" href="classbdlt_1_1PackedCalendar.html">PackedCalendar</a> &amp;b)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a92caa76cd8458e03e1ed5e117f36dcd7">operator==</a> (const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a52878a5b37cc6845810e57b2b2ec02e7">operator!=</a> (const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a5dc934e6c9d82f9fdd1118c0dd988084">operator++</a> (<a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a> &amp;iterator, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#af68cfea2437a1468c1416e71eff019fe">operator--</a> (<a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a> &amp;iterator, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a303ac95c653be12c0802607ae025f4e7">operator==</a> (const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a6a253507c52cc3a7cdc92991ee2d5e28">operator!=</a> (const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ac3ffd2e982057bf4dbb5fc743ff9d34c">operator++</a> (<a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> &amp;iterator, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aa5e953be20134cee337546502c3b00cc">operator--</a> (<a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> &amp;iterator, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a892cca5118120cb29c753ad51d14b365">operator-</a> (const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a8ea631005a01a14e15296e95ed44dc80">operator==</a> (const <a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ae37d1c9a7e53361c10f657fa6a0411a2">operator!=</a> (const <a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a> &amp;lhs, const <a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abe43046a15ada232e8a6d2fbad79db88">operator++</a> (<a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a> &amp;iterator, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a27e62aeeab211b0c920fad46cdf91fc5">operator--</a> (<a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a> &amp;iterator, int)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class HASHALG &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aff5321aa8ea6fcfd34521699d322dd13">hashAppend</a> (HASHALG &amp;hashAlg, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Time.html">Time</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a9794878bbdcd61e4138deaf260a334b4">operator+</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Time.html">Time</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aa0c65cf88d46d2febcc381c37d31ab6f">operator+</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Time.html">Time</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a74f975f7ef5c21a24e90c7d852e38092">operator-</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a431a275fa8109e57b74539683c730a02">operator-</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a10af834f9ed8ff734d1f3229e5285454">operator==</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a5d1a8f5aa2222647c9ecc10485ad18fc">operator!=</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#af28d85878757594415a1790427bc5461">operator&lt;</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ac9993a2679b7a3f33fb6d67a7e6f0231">operator&lt;=</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ae394a2cba7d4f53c079becbf72810351">operator&gt;</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a06febab83d9493baf3bf62d503eea80b">operator&gt;=</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a10e3f5cc7c434b2b8afb6cb95c7657d6">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a78660751d5f19e902d70f341458e8bfa">operator==</a> (const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a4f0f3ef5e936b2a5b6245eb2b9e80ffa">operator!=</a> (const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a1a1b2ea118a8e05dc38dbd8fbbc088d0">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;object)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>bdet -&gt; bdlt </p>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a39d3e4190d5d831962152f7f196cb248"></a><!-- doxytag: member="bdlt::SerialDateImpUtil" ref="a39d3e4190d5d831962152f7f196cb248" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structbdlt_1_1PosixDateImpUtil.html">PosixDateImpUtil</a> <a class="el" href="structbdlt_1_1PosixDateImpUtil.html">bdlt::SerialDateImpUtil</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a53413c9c7fd48836e6d0c8c76ff0198e"></a><!-- doxytag: member="bdlt::operator==" ref="a53413c9c7fd48836e6d0c8c76ff0198e" args="(const Calendar &amp;lhs, const Calendar &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Calendar &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Calendar &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> calendars have the same value, and <code>false</code> otherwise. Two calendars have the same value if they have the same valid range (or are both empty), the same weekend days, the same holidays, and each corresponding pair of holidays has the same (ordered) set of associated holiday codes. </p>

</div>
</div>
<a class="anchor" id="adda52a5fd65c8996b2056aeb52ab70b1"></a><!-- doxytag: member="bdlt::operator!=" ref="adda52a5fd65c8996b2056aeb52ab70b1" args="(const Calendar &amp;lhs, const Calendar &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Calendar &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Calendar &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> calendars do not have the same value, and <code>false</code> otherwise. Two calendars do not have the same value if they do not have the same valid range (and are not both empty), do not have the same weekend days, do not have the same holidays, or, for at least one corresponding pair of holidays, do not have the same (ordered) set of associated holiday codes. </p>

</div>
</div>
<a class="anchor" id="ace9e9a68a5e083ce6ca00ce630b667bf"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="ace9e9a68a5e083ce6ca00ce630b667bf" args="(bsl::ostream &amp;stream, const Calendar &amp;calendar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Calendar &amp;&nbsp;</td>
          <td class="paramname"> <em>calendar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>calendar</code> to the specified output <code>stream</code>, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="aaecf67b7552a64b1899f9d969a2309db"></a><!-- doxytag: member="bdlt::swap" ref="aaecf67b7552a64b1899f9d969a2309db" args="(Calendar &amp;a, Calendar &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlt::swap </td>
          <td>(</td>
          <td class="paramtype">Calendar &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Calendar &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This function provides the no-throw exception-safety guarantee. The behavior is undefined unless the two objects were created with the same allocator. </p>

</div>
</div>
<a class="anchor" id="adf89a0a55bea26ad4f20bb75589a98a4"></a><!-- doxytag: member="bdlt::operator==" ref="adf89a0a55bea26ad4f20bb75589a98a4" args="(const Calendar_BusinessDayConstIter &amp;lhs, const Calendar_BusinessDayConstIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Calendar_BusinessDayConstIter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Calendar_BusinessDayConstIter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators refer to the same element in the same calendar, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both iterate over the same calendar. </p>

</div>
</div>
<a class="anchor" id="a3b15c6a752715ceff3e1190752d8705a"></a><!-- doxytag: member="bdlt::operator!=" ref="a3b15c6a752715ceff3e1190752d8705a" args="(const Calendar_BusinessDayConstIter &amp;lhs, const Calendar_BusinessDayConstIter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Calendar_BusinessDayConstIter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Calendar_BusinessDayConstIter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators do not refer to the same element in the same calendar, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both iterate over the same calendar. </p>

</div>
</div>
<a class="anchor" id="a3f3d2ba846de33df501a4283779eb085"></a><!-- doxytag: member="bdlt::operator++" ref="a3f3d2ba846de33df501a4283779eb085" args="(Calendar_BusinessDayConstIter &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a> bdlt::operator++ </td>
          <td>(</td>
          <td class="paramtype">Calendar_BusinessDayConstIter &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the specified <code>iterator</code> to refer to the next business day in the associated calendar, and return the previous value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> references a valid business day. </p>

</div>
</div>
<a class="anchor" id="af966fdcf80e9904580cd52a3418b34f1"></a><!-- doxytag: member="bdlt::operator&#45;&#45;" ref="af966fdcf80e9904580cd52a3418b34f1" args="(Calendar_BusinessDayConstIter &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Calendar__BusinessDayConstIter.html">Calendar_BusinessDayConstIter</a> bdlt::operator-- </td>
          <td>(</td>
          <td class="paramtype">Calendar_BusinessDayConstIter &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Regress the specified <code>iterator</code> to refer to the previous business day in the associated calendar, and return the previous value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> references a valid business day that is not the first business day for the associated calendar. </p>

</div>
</div>
<a class="anchor" id="a2c32d324b9f19b399cae0455bcb92027"></a><!-- doxytag: member="bdlt::operator==" ref="a2c32d324b9f19b399cae0455bcb92027" args="(const CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;lhs, const CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> reverse iterator has the same value as the specified <code>rhs</code> reverse iterator, and <code>false</code> otherwise. Two reverse iterators have the same value if they refer to the same element, or both have the past-the-end value for a reverse iterator over the underlying reverse iteration sequence. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="af13859820ff5270235757e8ffc566550"></a><!-- doxytag: member="bdlt::operator!=" ref="af13859820ff5270235757e8ffc566550" args="(const CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;lhs, const CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> reverse iterator does not have the same value as the specified <code>rhs</code> reverse iterator, and <code>false</code> otherwise. Two reverse iterators do not have the same value if (1) they do not refer to the same element and (2) both do not have the past-the-end value for a reverse iterator over the underlying reverse iteration sequence. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to the same underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a82c408a6202ecc7107ff567a24d684fa"></a><!-- doxytag: member="bdlt::operator++" ref="a82c408a6202ecc7107ff567a24d684fa" args="(CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a>&lt;ITERATOR&gt; bdlt::operator++ </td>
          <td>(</td>
          <td class="paramtype">CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the specified <code>iterator</code> to refer to the next element in the reverse iteration sequence, and return a reverse iterator having the pre-increment value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> does not have the past-the-end value for a reverse iterator over the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a1589c5040cc306a48c56b95c6a78cefb"></a><!-- doxytag: member="bdlt::operator&#45;&#45;" ref="a1589c5040cc306a48c56b95c6a78cefb" args="(CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1CalendarReverseIteratorAdapter.html">CalendarReverseIteratorAdapter</a>&lt;ITERATOR&gt; bdlt::operator-- </td>
          <td>(</td>
          <td class="paramtype">CalendarReverseIteratorAdapter&lt; ITERATOR &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Modify the specified <code>iterator</code> to refer to the previous element in the reverse iteration sequence, and return a reverse iterator having the pre-decrement value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> does not have the same value as a reverse iterator to the start of the underlying sequence. </p>

</div>
</div>
<a class="anchor" id="a0ec35f2cc29136ed6d2b66fd13b555e4"></a><!-- doxytag: member="bdlt::operator==" ref="a0ec35f2cc29136ed6d2b66fd13b555e4" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Date.html">Date</a></code> objects have the same value if each of their <code>year</code>, <code>month</code>, and <code>day</code> attributes (respectively) have the same value. </p>

</div>
</div>
<a class="anchor" id="ac705681a5d9979b0e193b9f057a4fb78"></a><!-- doxytag: member="bdlt::operator!=" ref="ac705681a5d9979b0e193b9f057a4fb78" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Date.html">Date</a></code> objects do not have the same value if any of their <code>year</code>, <code>month</code>, and <code>day</code> attributes (respectively) do not have the same value. </p>

</div>
</div>
<a class="anchor" id="abeee7c1493f32c20d88de35621b4897b"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="abeee7c1493f32c20d88de35621b4897b" args="(bsl::ostream &amp;stream, const Date &amp;date)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>date</code> object to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a2bc9ec2a06c5807f768293f8127fe1e5"></a><!-- doxytag: member="bdlt::operator&lt;" ref="a2bc9ec2a06c5807f768293f8127fe1e5" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> date is earlier than the specified <code>rhs</code> date, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="abc73a4cbaf8d3da470d31aa33220314e"></a><!-- doxytag: member="bdlt::operator&lt;=" ref="abc73a4cbaf8d3da470d31aa33220314e" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> date is earlier than or the same as the specified <code>rhs</code> date, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a1a3cb249a27fbf19b173896b3a5b5c27"></a><!-- doxytag: member="bdlt::operator&gt;" ref="a1a3cb249a27fbf19b173896b3a5b5c27" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> date is later than the specified <code>rhs</code> date, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a86c04ddf8f13bdabcb0373d88f9351b0"></a><!-- doxytag: member="bdlt::operator&gt;=" ref="a86c04ddf8f13bdabcb0373d88f9351b0" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> date is later than or the same as the specified <code>rhs</code> date, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a49dbb017bac6819fd634adf28c73bfc6"></a><!-- doxytag: member="bdlt::operator++" ref="a49dbb017bac6819fd634adf28c73bfc6" args="(Date &amp;date, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator++ </td>
          <td>(</td>
          <td class="paramtype">Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>date</code> object to have the value that is one day later than its current value, and return the value of <code>date</code> on entry. The behavior is undefined if the value of <code>date</code> on entry is <code>9999/12/31</code>. </p>

</div>
</div>
<a class="anchor" id="a0fc43ceb7179c7af22909f66e02a3350"></a><!-- doxytag: member="bdlt::operator&#45;&#45;" ref="a0fc43ceb7179c7af22909f66e02a3350" args="(Date &amp;date, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator-- </td>
          <td>(</td>
          <td class="paramtype">Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>date</code> object to have the value that is one day earlier than its current value, and return the value of <code>date</code> on entry. The behavior is undefined if the value of <code>date</code> on entry is <code>0001/01/01</code>. </p>

</div>
</div>
<a class="anchor" id="aa2d88ce9a9249f9ae9b35ac1dce3bede"></a><!-- doxytag: member="bdlt::operator+" ref="aa2d88ce9a9249f9ae9b35ac1dce3bede" args="(const Date &amp;date, int numDays)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numDays</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab66a081421c981594be6d5f313310d2f"></a><!-- doxytag: member="bdlt::operator+" ref="ab66a081421c981594be6d5f313310d2f" args="(int numDays, const Date &amp;date)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numDays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the date value that is later by the specified (signed) <code>numDays</code> from the specified <code>date</code>. The behavior is undefined unless the resulting value falls within the range of dates supported by this class (see <code>isValidYearMonthDay</code>). Note that <code>numDays</code> may be negative. </p>

</div>
</div>
<a class="anchor" id="a596fc180f7f9f0e4e4bb585e26d7517e"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a596fc180f7f9f0e4e4bb585e26d7517e" args="(const Date &amp;date, int numDays)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numDays</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the date value that is earlier by the specified (signed) <code>numDays</code> from the specified <code>date</code>. The behavior is undefined unless the resulting value falls within the range of dates supported by this class (see <code>isValidYearMonthDay</code>). Note that <code>numDays</code> may be negative. </p>

</div>
</div>
<a class="anchor" id="afc48c336d4232852121d3f7873829119"></a><!-- doxytag: member="bdlt::operator&#45;" ref="afc48c336d4232852121d3f7873829119" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (signed) number of days between the specified <code>lhs</code> and <code>rhs</code> dates. Note that if <code>lhs &lt; rhs</code> the result will be negative. </p>

</div>
</div>
<a class="anchor" id="a407f244b8b748911b4cd05859b2c3f94"></a><!-- doxytag: member="bdlt::hashAppend" ref="a407f244b8b748911b4cd05859b2c3f94" args="(HASHALG &amp;hashAlg, const Date &amp;date)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HASHALG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlt::hashAppend </td>
          <td>(</td>
          <td class="paramtype">HASHALG &amp;&nbsp;</td>
          <td class="paramname"> <em>hashAlg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass the specified <code>date</code> to the specified <code>hashAlg</code>. Note that this function is intended to integrate with the <code>bslh</code> modular hashing system, and effectively provides a <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code> specialization for <code>date</code>. </p>

</div>
</div>
<a class="anchor" id="a87dae07ed0f513c3bcd5e85bc4ccda7c"></a><!-- doxytag: member="bdlt::operator+" ref="a87dae07ed0f513c3bcd5e85bc4ccda7c" args="(const Datetime &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object having a value that is the sum of the specified <code>lhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>) and the specified <code>rhs</code> (<code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code>). If <code>24 == lhs.hour()</code>, the result is the same as if the <code>hour</code> attribute of <code>lhs</code> is 0. The behavior is undefined unless the resulting value is in the valid range for a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a301e7055d0f31579de2b38c79f775f12"></a><!-- doxytag: member="bdlt::operator+" ref="a301e7055d0f31579de2b38c79f775f12" args="(const DatetimeInterval &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object having a value that is the sum of the specified <code>lhs</code> (<code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code>) and the specified <code>rhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>). If <code>24 == rhs.hour()</code>, the result is the same as if the <code>hour</code> attribute of <code>rhs</code> is 0. The behavior is undefined unless the resulting value is in the valid range for a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object. </p>

</div>
</div>
<a class="anchor" id="ab08128a744e786dbf5493e78522021f1"></a><!-- doxytag: member="bdlt::operator&#45;" ref="ab08128a744e786dbf5493e78522021f1" args="(const Datetime &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object having a value that is the difference between the specified <code>lhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>) and the specified <code>rhs</code> (<code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code>). If <code>24 == lhs.hour()</code>, the result is the same as if the <code>hour</code> attribute of <code>lhs</code> is 0. The behavior is undefined unless the resulting value is in the valid range for a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a30df660dbc2372391b19ddbf479194d9"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a30df660dbc2372391b19ddbf479194d9" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object having a value that is the difference between the specified <code>lhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>) and the specified <code>rhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>). If the <code>hour</code> attribute of either operand is 24, the result is the same as if that <code>hour</code> attribute is 0. The behavior is undefined unless the resulting value is in the valid range for a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a213cd6bc42c4cec13528a1c831bdcf26"></a><!-- doxytag: member="bdlt::operator==" ref="a213cd6bc42c4cec13528a1c831bdcf26" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> objects have the same value if they have the same values for their "date" and "time" parts, respectively (i.e., <code>lhs.date() == rhs.date() &amp;&amp; lhs.time() == rhs.time()</code>). </p>

</div>
</div>
<a class="anchor" id="a4eb84423be540857ea9d53aec0774a80"></a><!-- doxytag: member="bdlt::operator!=" ref="a4eb84423be540857ea9d53aec0774a80" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> objects do not have the same value if they do not have the same values for either of their "date" or "time" parts, respectively (i.e., <code>lhs.date() != rhs.date() || lhs.time() != rhs.time()</code>). </p>

</div>
</div>
<a class="anchor" id="aeb391ec18b3add2e35ef8c5bc97ce36e"></a><!-- doxytag: member="bdlt::operator&lt;" ref="aeb391ec18b3add2e35ef8c5bc97ce36e" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> object is less than the value of the specified <code>rhs</code> object, and <code>false</code> otherwise. A <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object <code>a</code> is less than a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object <code>b</code> if <code>a.date() &lt; b.date()</code>, or if <code>a.date() == b.date() &amp;&amp; a.time() &lt; b.time()</code>. The behavior is undefined unless <code>24 != lhs.hour() &amp;&amp; 24 != rhs.hour()</code>. </p>

</div>
</div>
<a class="anchor" id="a8452d0f7b5c51f594e2ae6099a1c099e"></a><!-- doxytag: member="bdlt::operator&lt;=" ref="a8452d0f7b5c51f594e2ae6099a1c099e" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> object is less than or equal to the value of the specified <code>rhs</code> object, and <code>false</code> otherwise. The behavior is undefined unless <code>24 != lhs.hour() &amp;&amp; 24 != rhs.hour()</code>. </p>

</div>
</div>
<a class="anchor" id="a635a8d64b2fa6917451defc4249da85f"></a><!-- doxytag: member="bdlt::operator&gt;" ref="a635a8d64b2fa6917451defc4249da85f" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> object is greater than the value of the specified <code>rhs</code> object, and <code>false</code> otherwise. A <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object <code>a</code> is greater than a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object <code>b</code> if <code>a.date() &gt; b.date()</code>, or if <code>a.date() == b.date() &amp;&amp; a.time() &gt; b.time()</code>. The behavior is undefined unless <code>24 != lhs.hour() &amp;&amp; 24 != rhs.hour()</code>. </p>

</div>
</div>
<a class="anchor" id="a2e8273cc1f906b7b0eb386341a1b0f75"></a><!-- doxytag: member="bdlt::operator&gt;=" ref="a2e8273cc1f906b7b0eb386341a1b0f75" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> object is greater than or equal to the value of the specified <code>rhs</code> object, and <code>false</code> otherwise. The behavior is undefined unless <code>24 != lhs.hour() &amp;&amp; 24 != rhs.hour()</code>. </p>

</div>
</div>
<a class="anchor" id="abeedb0b000fa4ad1e219bf570ad8afac"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="abeedb0b000fa4ad1e219bf570ad8afac" args="(bsl::ostream &amp;stream, const Datetime &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> object to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a92a32b7e56231cae8d6c79ace30312a9"></a><!-- doxytag: member="bdlt::operator+" ref="a92a32b7e56231cae8d6c79ace30312a9" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object whose value is the sum of the specified <code>lhs</code> and <code>rhs</code> time intervals. The behavior is undefined unless the resulting time interval value is valid (i.e., the days field must not overflow a 32-bit integer). </p>

</div>
</div>
<a class="anchor" id="addcfed615ab66de5740d6cc1a03fc4c3"></a><!-- doxytag: member="bdlt::operator&#45;" ref="addcfed615ab66de5740d6cc1a03fc4c3" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object whose value is the difference between the specified <code>lhs</code> and <code>rhs</code> time intervals. The behavior is undefined unless the resulting time interval value is valid (i.e., the days field must not overflow a 32-bit integer). </p>

</div>
</div>
<a class="anchor" id="a58bd4269d0c2b901e564a327f0a2b033"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a58bd4269d0c2b901e564a327f0a2b033" args="(const DatetimeInterval &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object whose value is the negative of the specified time interval <code>value</code>. The behavior is undefined unless <code>INT_MIN &lt; value.days()</code>. </p>

</div>
</div>
<a class="anchor" id="addc4bd05840b52ddb181ed871ac3df8e"></a><!-- doxytag: member="bdlt::operator==" ref="addc4bd05840b52ddb181ed871ac3df8e" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> time intervals have the same value, and <code>false</code> otherwise. Two time intervals have the same value if all of the corresponding values of their days, hours, minutes, seconds, and milliseconds fields are the same. </p>

</div>
</div>
<a class="anchor" id="a2eb359385d0b377e259abe583531508b"></a><!-- doxytag: member="bdlt::operator!=" ref="a2eb359385d0b377e259abe583531508b" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> time intervals do not have the same value, and <code>false</code> otherwise. Two time intervals do not have the same value if any of the corresponding values of their days, hours, minutes, seconds, or milliseconds fields is not the same. </p>

</div>
</div>
<a class="anchor" id="a52d0e0f383b0a6336314f538e8c01852"></a><!-- doxytag: member="bdlt::operator&lt;" ref="a52d0e0f383b0a6336314f538e8c01852" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad64ee5c0db952721eeb8f3e794b320a8"></a><!-- doxytag: member="bdlt::operator&lt;=" ref="ad64ee5c0db952721eeb8f3e794b320a8" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ade6868a3fa95bc24ae09cb5e2547de47"></a><!-- doxytag: member="bdlt::operator&gt;" ref="ade6868a3fa95bc24ae09cb5e2547de47" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4820d7f25799d2d4c1eb22a0a850d55a"></a><!-- doxytag: member="bdlt::operator&gt;=" ref="a4820d7f25799d2d4c1eb22a0a850d55a" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the nominal relation between the specified <code>lhs</code> and <code>rhs</code> time interval values holds, and <code>false</code> otherwise. <code>lhs</code> is less than <code>rhs</code> if the following expression evaluates to <code>true</code>: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      lhs.totalMilliseconds() &lt; rhs.totalMilliseconds()
</pre></div><p><br/>
<br/>
 The other relationships are defined similarly. </p>

</div>
</div>
<a class="anchor" id="a06c921c9fea95a004bfaf1b638b0bc84"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a06c921c9fea95a004bfaf1b638b0bc84" args="(bsl::ostream &amp;stream, const DatetimeInterval &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>. </p>

</div>
</div>
<a class="anchor" id="a70c449b04114c08e6a9b24b21383faf9"></a><!-- doxytag: member="bdlt::operator==" ref="a70c449b04114c08e6a9b24b21383faf9" args="(const DatetimeTz &amp;lhs, const DatetimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></code> objects have the same value if they have the same local datetime value and the same time zone offset value. </p>

</div>
</div>
<a class="anchor" id="a9b8feb08f678addedc5d1c392ebec18f"></a><!-- doxytag: member="bdlt::operator!=" ref="a9b8feb08f678addedc5d1c392ebec18f" args="(const DatetimeTz &amp;lhs, const DatetimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></code> objects do not have the same value if they do not have the same local datetime value or the same time zone offset value. </p>

</div>
</div>
<a class="anchor" id="a327897c0cc2850341571fa935dc0e27d"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a327897c0cc2850341571fa935dc0e27d" args="(bsl::ostream &amp;stream, const DatetimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>rhs</code> object to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>, but with the attribute names elided. </p>

</div>
</div>
<a class="anchor" id="a19bfcd014a9cf8ca63178f353f0b3241"></a><!-- doxytag: member="bdlt::operator==" ref="a19bfcd014a9cf8ca63178f353f0b3241" args="(const DateTz &amp;lhs, const DateTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></code> objects have the same value if they have the same local date value and the same time zone offset value. </p>

</div>
</div>
<a class="anchor" id="a23a509c6ef18abc3d44841d4257db84d"></a><!-- doxytag: member="bdlt::operator!=" ref="a23a509c6ef18abc3d44841d4257db84d" args="(const DateTz &amp;lhs, const DateTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></code> objects do not have the same value if they do not have the same local date values or the same time zone offset values. </p>

</div>
</div>
<a class="anchor" id="a91385ac498bd1014020a65c6c6dc3f8a"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a91385ac498bd1014020a65c6c6dc3f8a" args="(bsl::ostream &amp;stream, const DateTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>rhs</code> object to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>, but with the attribute names elided. </p>

</div>
</div>
<a class="anchor" id="a25dfb4d5103b40f0552e3ecaad67b484"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a25dfb4d5103b40f0552e3ecaad67b484" args="(bsl::ostream &amp;stream, DayOfWeek::Enum value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DayOfWeek::Enum&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the string representation of the specified enumeration <code>value</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. See <code>toAscii</code> for what constitutes the string representation of a <code><a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573" title="Enumerated day-of-week values.">bdlt::DayOfWeek::Enum</a></code> value. Note that this method has the same behavior as <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">bdlt::DayOfWeek::print</a>(stream, value, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="afc51da85db916b88828707653e987140"></a><!-- doxytag: member="bdlt::bdexStreamIn" ref="afc51da85db916b88828707653e987140" args="(STREAM &amp;stream, DayOfWeek::Enum &amp;variable, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdlt::bdexStreamIn </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DayOfWeek::Enum &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>variable</code> the <code><a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573" title="Enumerated day-of-week values.">DayOfWeek::Enum</a></code> value read from the specified input <code>stream</code> using the specified <code>version</code> format, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code><a class="el" href="structbdlt_1_1DayOfWeek.html">DayOfWeek</a></code>, <code>variable</code> is unaltered and <code>stream</code> is invalidated, but otherwise unmodified. If <code>version</code> is supported by <code><a class="el" href="structbdlt_1_1DayOfWeek.html">DayOfWeek</a></code> but <code>stream</code> becomes invalid during this operation, <code>variable</code> has an undefined, but valid, state. The behavior is undefined unless <code>STREAM</code> is BDEX-compliant. Note that no version is read from <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a9cf1c829a8cb75604972fa47826d2dda"></a><!-- doxytag: member="bdlt::bdexStreamOut" ref="a9cf1c829a8cb75604972fa47826d2dda" args="(STREAM &amp;stream, const DayOfWeek::Enum &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdlt::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeek::Enum &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>value</code>, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code><a class="el" href="structbdlt_1_1DayOfWeek.html">DayOfWeek</a></code>, <code>stream</code> is invalidated, but otherwise unmodified. The behavior is undefined unless <code>STREAM</code> is BDEX-compliant. Note that <code>version</code> is not written to <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a939d0f2f7d5823be26b17d3c1e9371d5"></a><!-- doxytag: member="bdlt::maxSupportedBdexVersion" ref="a939d0f2f7d5823be26b17d3c1e9371d5" args="(const DayOfWeek::Enum *, int versionSelector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlt::maxSupportedBdexVersion </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeek::Enum *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum valid BDEX format version, as indicated by the specified <code>versionSelector</code>, to be passed to the <code>bdexStreamOut</code> method while streaming an object of the type <code><a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573" title="Enumerated day-of-week values.">DayOfWeek::Enum</a></code>. Note that it is highly recommended that <code>versionSelector</code> be formatted as "YYYYMMDD", a date representation. Also note that <code>versionSelector</code> should be a <em>compile</em>-time-chosen value that selects a format version supported by both externalizer and unexternalizer. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a1474adde66538699353253639a6732e7"></a><!-- doxytag: member="bdlt::operator==" ref="a1474adde66538699353253639a6732e7" args="(const DayOfWeekSet_Iter &amp;lhs, const DayOfWeekSet_Iter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet_Iter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet_Iter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators have the same value, and <code>false</code> otherwise. Two iterators have the same value if they refer to data at the same index position. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both reference into the same set of data. </p>

</div>
</div>
<a class="anchor" id="a8b026d031d58fad1a60e282c8b72f73e"></a><!-- doxytag: member="bdlt::operator!=" ref="a8b026d031d58fad1a60e282c8b72f73e" args="(const DayOfWeekSet_Iter &amp;lhs, const DayOfWeekSet_Iter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet_Iter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet_Iter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators do not have the same value, and <code>false</code> otherwise. Two iterators do not have the same value if they do not refer to data at the same index position. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both reference into the same set of data. </p>

</div>
</div>
<a class="anchor" id="ae9da41d3f95b3f159d75653154677407"></a><!-- doxytag: member="bdlt::operator~" ref="ae9da41d3f95b3f159d75653154677407" args="(const DayOfWeekSet &amp;set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator~ </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the complement of the specified <code>set</code> (i.e., those members <em>not</em> contained in <code>set</code>). </p>

</div>
</div>
<a class="anchor" id="a93ded80bbde497f532cabc23f9c91701"></a><!-- doxytag: member="bdlt::operator|" ref="a93ded80bbde497f532cabc23f9c91701" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator| </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the union of the specified <code>lhs</code> and <code>rhs</code> sets (i.e., a set containing elements that are in either <code>lhs</code> or <code>rhs</code> or both). </p>

</div>
</div>
<a class="anchor" id="a65b523b18113f0bb0a7146311e456b4d"></a><!-- doxytag: member="bdlt::operator&amp;" ref="a65b523b18113f0bb0a7146311e456b4d" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the intersection of the specified <code>lhs</code> and <code>rhs</code> sets (i.e., a set containing elements that are in both <code>lhs</code> and <code>rhs</code>). </p>

</div>
</div>
<a class="anchor" id="ab1e47b13331c7843ba7b1451eb298504"></a><!-- doxytag: member="bdlt::operator^" ref="ab1e47b13331c7843ba7b1451eb298504" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator^ </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the exclusive-or of the specified <code>lhs</code> and <code>rhs</code> sets (i.e., a set containing elements that are either in <code>lhs</code>, but not <code>rhs</code>, or in <code>rhs</code>, but not <code>lhs</code>). </p>

</div>
</div>
<a class="anchor" id="abda0ca1acb2d07f61acecf8789b8486a"></a><!-- doxytag: member="bdlt::operator&#45;" ref="abda0ca1acb2d07f61acecf8789b8486a" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the subtraction of the specified <code>rhs</code> set from the specified <code>lhs</code> set (i.e., a set containing elements that are in <code>lhs</code>, but not in <code>rhs</code>). </p>

</div>
</div>
<a class="anchor" id="ad5332804659034011308da81c615658f"></a><!-- doxytag: member="bdlt::operator==" ref="ad5332804659034011308da81c615658f" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> sets have the same value, and <code>false</code> otherwise. Two sets have the same value if they have the same length and all the elements of one set are members of the other set. </p>

</div>
</div>
<a class="anchor" id="a56e69bd581ae4fb5186d7b4a410bbb83"></a><!-- doxytag: member="bdlt::operator!=" ref="a56e69bd581ae4fb5186d7b4a410bbb83" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> sets do not have the same value, and <code>false</code> otherwise. Two sets do not have the same value if they differ in length or there exists an element of one set that is not a member of the other set. </p>

</div>
</div>
<a class="anchor" id="a21500c97ab5edb7d6c12194a6d28788c"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a21500c97ab5edb7d6c12194a6d28788c" args="(bsl::ostream &amp;stream, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>rhs</code> set to the specified output <code>stream</code> in some reasonable (single-line) format, and return a reference to <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="ada67f8636ca95e65b5f424786d1ad111"></a><!-- doxytag: member="bdlt::operator==" ref="ada67f8636ca95e65b5f424786d1ad111" args="(const Iso8601UtilConfiguration &amp;lhs, const Iso8601UtilConfiguration &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Iso8601UtilConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iso8601UtilConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Iso8601UtilConfiguration.html">Iso8601UtilConfiguration</a></code> objects have the same value if each of their <code>omitColonInZoneDesignator</code>, <code>useCommaForDecimalSign</code>, and <code>useZAbbreviationForUtc</code> attributes (respectively) have the same value. </p>

</div>
</div>
<a class="anchor" id="a0ede9f938f7317463d9c4769e2bcb100"></a><!-- doxytag: member="bdlt::operator!=" ref="a0ede9f938f7317463d9c4769e2bcb100" args="(const Iso8601UtilConfiguration &amp;lhs, const Iso8601UtilConfiguration &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Iso8601UtilConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iso8601UtilConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Iso8601UtilConfiguration.html">Iso8601UtilConfiguration</a></code> objects do not have the same value if any of their <code>omitColonInZoneDesignator</code>, <code>useCommaForDecimalSign</code>, or <code>useZAbbreviationForUtc</code> attributes (respectively) do not have the same value. </p>

</div>
</div>
<a class="anchor" id="a6da926b5406c71f06094e68e5c334c76"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a6da926b5406c71f06094e68e5c334c76" args="(bsl::ostream &amp;stream, const Iso8601UtilConfiguration &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iso8601UtilConfiguration &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>, but with the attribute names elided. </p>

</div>
</div>
<a class="anchor" id="a71626d77b2e1ecdaa823711ead4a376e"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a71626d77b2e1ecdaa823711ead4a376e" args="(bsl::ostream &amp;stream, MonthOfYear::Enum value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MonthOfYear::Enum&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the string representation of the specified enumeration <code>value</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. See <code>toAscii</code> for what constitutes the string representation of a <code><a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f" title="Define the list of month-of-year values.">bdlt::MonthOfYear::Enum</a></code> value. Note that this method has the same behavior as <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">bdlt::MonthOfYear::print</a>(stream, value, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="afb8fea6c03f1b65c18f16fb460da1376"></a><!-- doxytag: member="bdlt::bdexStreamIn" ref="afb8fea6c03f1b65c18f16fb460da1376" args="(STREAM &amp;stream, MonthOfYear::Enum &amp;variable, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdlt::bdexStreamIn </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MonthOfYear::Enum &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>variable</code> the <code><a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f" title="Define the list of month-of-year values.">MonthOfYear::Enum</a></code> value read from the specified input <code>stream</code> using the specified <code>version</code> format, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code><a class="el" href="structbdlt_1_1MonthOfYear.html">MonthOfYear</a></code>, <code>variable</code> is unaltered and <code>stream</code> is invalidated, but otherwise unmodified. If <code>version</code> is supported by <code><a class="el" href="structbdlt_1_1MonthOfYear.html">MonthOfYear</a></code> but <code>stream</code> becomes invalid during this operation, <code>variable</code> has an undefined, but valid, state. The behavior is undefined unless <code>STREAM</code> is BDEX-compliant. Note that no version is read from <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="adcc16797804c9d73ad7d4b732d52e7dd"></a><!-- doxytag: member="bdlt::bdexStreamOut" ref="adcc16797804c9d73ad7d4b732d52e7dd" args="(STREAM &amp;stream, const MonthOfYear::Enum &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdlt::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MonthOfYear::Enum &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>value</code>, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code><a class="el" href="structbdlt_1_1MonthOfYear.html">MonthOfYear</a></code>, <code>stream</code> is invalidated, but otherwise unmodified. The behavior is undefined unless <code>STREAM</code> is BDEX-compliant. Note that <code>version</code> is not written to <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a9c8c6e0fc572fb4d863b8ac9b6fbb0c9"></a><!-- doxytag: member="bdlt::maxSupportedBdexVersion" ref="a9c8c6e0fc572fb4d863b8ac9b6fbb0c9" args="(const MonthOfYear::Enum *, int versionSelector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlt::maxSupportedBdexVersion </td>
          <td>(</td>
          <td class="paramtype">const MonthOfYear::Enum *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum valid BDEX format version, as indicated by the specified <code>versionSelector</code>, to be passed to the <code>bdexStreamOut</code> method while streaming an object of the type <code><a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f" title="Define the list of month-of-year values.">MonthOfYear::Enum</a></code>. Note that it is highly recommended that <code>versionSelector</code> be formatted as "YYYYMMDD", a date representation. Also note that <code>versionSelector</code> should be a <em>compile</em>-time-chosen value that selects a format version supported by both externalizer and unexternalizer. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a6cb708e834ebff2c1c0a139f98a9c333"></a><!-- doxytag: member="bdlt::operator==" ref="a6cb708e834ebff2c1c0a139f98a9c333" args="(const PackedCalendar &amp;lhs, const PackedCalendar &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> calendars have the same value, and <code>false</code> otherwise. Two calendars have the same value if they have the same valid range (or are both empty), the same weekend days, the same holidays, and each corresponding pair of holidays has the same (ordered) set of associated holiday codes. </p>

</div>
</div>
<a class="anchor" id="a98db920b28ae83834d80926311bf314c"></a><!-- doxytag: member="bdlt::operator!=" ref="a98db920b28ae83834d80926311bf314c" args="(const PackedCalendar &amp;lhs, const PackedCalendar &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> calendars do not have the same value, and <code>false</code> otherwise. Two calendars do not have the same value if they do not have the same valid range (and are not both empty), do not have the same weekend days, do not have the same holidays, or, for at least one corresponding pair of holidays, do not have the same (ordered) set of associated holiday codes. </p>

</div>
</div>
<a class="anchor" id="a1fc254e089c5993798a256e09f573480"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a1fc254e089c5993798a256e09f573480" args="(bsl::ostream &amp;stream, const PackedCalendar &amp;calendar)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar &amp;&nbsp;</td>
          <td class="paramname"> <em>calendar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>calendar</code> to the specified output <code>stream</code>, and return a reference to the modifiable <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a95555873bb3c8af8d13c22785a2ae8ea"></a><!-- doxytag: member="bdlt::swap" ref="a95555873bb3c8af8d13c22785a2ae8ea" args="(PackedCalendar &amp;a, PackedCalendar &amp;b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bdlt::swap </td>
          <td>(</td>
          <td class="paramtype">PackedCalendar &amp;&nbsp;</td>
          <td class="paramname"> <em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PackedCalendar &amp;&nbsp;</td>
          <td class="paramname"> <em>b</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Efficiently exchange the values of the specified <code>a</code> and <code>b</code> objects. This function provides the no-throw exception-safety guarantee. The behavior is undefined unless the two objects were created with the same allocator. </p>

</div>
</div>
<a class="anchor" id="a92caa76cd8458e03e1ed5e117f36dcd7"></a><!-- doxytag: member="bdlt::operator==" ref="a92caa76cd8458e03e1ed5e117f36dcd7" args="(const PackedCalendar_HolidayConstIterator &amp;lhs, const PackedCalendar_HolidayConstIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar_HolidayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar_HolidayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators refer to the same element in the same calendar, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both iterate over the same calendar. </p>

</div>
</div>
<a class="anchor" id="a52878a5b37cc6845810e57b2b2ec02e7"></a><!-- doxytag: member="bdlt::operator!=" ref="a52878a5b37cc6845810e57b2b2ec02e7" args="(const PackedCalendar_HolidayConstIterator &amp;lhs, const PackedCalendar_HolidayConstIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar_HolidayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar_HolidayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators do not refer to the same element in the same calendar, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both iterate over the same calendar. </p>

</div>
</div>
<a class="anchor" id="a5dc934e6c9d82f9fdd1118c0dd988084"></a><!-- doxytag: member="bdlt::operator++" ref="a5dc934e6c9d82f9fdd1118c0dd988084" args="(PackedCalendar_HolidayConstIterator &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a> bdlt::operator++ </td>
          <td>(</td>
          <td class="paramtype">PackedCalendar_HolidayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the specified <code>iterator</code> to refer to the next holiday in the associated calendar, and return the previous value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> references a valid holiday. </p>

</div>
</div>
<a class="anchor" id="af68cfea2437a1468c1416e71eff019fe"></a><!-- doxytag: member="bdlt::operator&#45;&#45;" ref="af68cfea2437a1468c1416e71eff019fe" args="(PackedCalendar_HolidayConstIterator &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayConstIterator.html">PackedCalendar_HolidayConstIterator</a> bdlt::operator-- </td>
          <td>(</td>
          <td class="paramtype">PackedCalendar_HolidayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Regress the specified <code>iterator</code> to refer to the previous holiday in the associated calendar, and return the previous value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> references a valid holiday that is not the first holiday in the associated calendar. </p>

</div>
</div>
<a class="anchor" id="a303ac95c653be12c0802607ae025f4e7"></a><!-- doxytag: member="bdlt::operator==" ref="a303ac95c653be12c0802607ae025f4e7" args="(const PackedCalendar_HolidayCodeConstIterator &amp;lhs, const PackedCalendar_HolidayCodeConstIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar_HolidayCodeConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar_HolidayCodeConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators refers to the same element, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both reference the same holiday in the same calendar. </p>

</div>
</div>
<a class="anchor" id="a6a253507c52cc3a7cdc92991ee2d5e28"></a><!-- doxytag: member="bdlt::operator!=" ref="a6a253507c52cc3a7cdc92991ee2d5e28" args="(const PackedCalendar_HolidayCodeConstIterator &amp;lhs, const PackedCalendar_HolidayCodeConstIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar_HolidayCodeConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar_HolidayCodeConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators do not refer to the same element, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both reference the same holiday in the same calendar. </p>

</div>
</div>
<a class="anchor" id="ac3ffd2e982057bf4dbb5fc743ff9d34c"></a><!-- doxytag: member="bdlt::operator++" ref="ac3ffd2e982057bf4dbb5fc743ff9d34c" args="(PackedCalendar_HolidayCodeConstIterator &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> bdlt::operator++ </td>
          <td>(</td>
          <td class="paramtype">PackedCalendar_HolidayCodeConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the specified <code>iterator</code> to refer to the next holiday code for the associated date in the associated calendar, and return the previous value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> references a valid holiday code. </p>

</div>
</div>
<a class="anchor" id="aa5e953be20134cee337546502c3b00cc"></a><!-- doxytag: member="bdlt::operator&#45;&#45;" ref="aa5e953be20134cee337546502c3b00cc" args="(PackedCalendar_HolidayCodeConstIterator &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1PackedCalendar__HolidayCodeConstIterator.html">PackedCalendar_HolidayCodeConstIterator</a> bdlt::operator-- </td>
          <td>(</td>
          <td class="paramtype">PackedCalendar_HolidayCodeConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Regress the specified <code>iterator</code> to refer to the previous holiday code for the associated date in the associated calendar, and return the previous value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> references a valid holiday code that is not the first holiday code for the associated date in the calendar. </p>

</div>
</div>
<a class="anchor" id="a892cca5118120cb29c753ad51d14b365"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a892cca5118120cb29c753ad51d14b365" args="(const PackedCalendar_HolidayCodeConstIterator &amp;lhs, const PackedCalendar_HolidayCodeConstIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ptrdiff_t bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar_HolidayCodeConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar_HolidayCodeConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements between specified <code>lhs</code> and <code>rhs</code>. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> refer to codes associated with the same holiday in the same calendar. </p>

</div>
</div>
<a class="anchor" id="a8ea631005a01a14e15296e95ed44dc80"></a><!-- doxytag: member="bdlt::operator==" ref="a8ea631005a01a14e15296e95ed44dc80" args="(const PackedCalendar_BusinessDayConstIterator &amp;lhs, const PackedCalendar_BusinessDayConstIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar_BusinessDayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar_BusinessDayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators refer to the same element in the same calendar, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both iterate over the same calendar. </p>

</div>
</div>
<a class="anchor" id="ae37d1c9a7e53361c10f657fa6a0411a2"></a><!-- doxytag: member="bdlt::operator!=" ref="ae37d1c9a7e53361c10f657fa6a0411a2" args="(const PackedCalendar_BusinessDayConstIterator &amp;lhs, const PackedCalendar_BusinessDayConstIterator &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const PackedCalendar_BusinessDayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PackedCalendar_BusinessDayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators do not refer to the same element in the same calendar, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both iterate over the same calendar. </p>

</div>
</div>
<a class="anchor" id="abe43046a15ada232e8a6d2fbad79db88"></a><!-- doxytag: member="bdlt::operator++" ref="abe43046a15ada232e8a6d2fbad79db88" args="(PackedCalendar_BusinessDayConstIterator &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a> bdlt::operator++ </td>
          <td>(</td>
          <td class="paramtype">PackedCalendar_BusinessDayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Advance the specified <code>iterator</code> to refer to the next business day in the associated calendar, and return the previous value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> references a valid business day. </p>

</div>
</div>
<a class="anchor" id="a27e62aeeab211b0c920fad46cdf91fc5"></a><!-- doxytag: member="bdlt::operator&#45;&#45;" ref="a27e62aeeab211b0c920fad46cdf91fc5" args="(PackedCalendar_BusinessDayConstIterator &amp;iterator, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1PackedCalendar__BusinessDayConstIterator.html">PackedCalendar_BusinessDayConstIterator</a> bdlt::operator-- </td>
          <td>(</td>
          <td class="paramtype">PackedCalendar_BusinessDayConstIterator &amp;&nbsp;</td>
          <td class="paramname"> <em>iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Regress the specified <code>iterator</code> to refer to the previous business day in the associated calendar, and return the previous value of <code>iterator</code>. The behavior is undefined unless, on entry, <code>iterator</code> references a valid business day that is not the first business day for the associated calendar. </p>

</div>
</div>
<a class="anchor" id="aff5321aa8ea6fcfd34521699d322dd13"></a><!-- doxytag: member="bdlt::hashAppend" ref="aff5321aa8ea6fcfd34521699d322dd13" args="(HASHALG &amp;hashAlg, const Time &amp;time)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class HASHALG &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bdlt::hashAppend </td>
          <td>(</td>
          <td class="paramtype">HASHALG &amp;&nbsp;</td>
          <td class="paramname"> <em>hashAlg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass the specified <code>time</code> to the specified <code>hashAlg</code>. Note that this function is intended to integrate with the <code>bslh</code> modular hashing system, and effectively provides a <code><a class="el" href="structbsl_1_1hash.html">bsl::hash</a></code> specialization for <code>time</code>. </p>

</div>
</div>
<a class="anchor" id="a9794878bbdcd61e4138deaf260a334b4"></a><!-- doxytag: member="bdlt::operator+" ref="a9794878bbdcd61e4138deaf260a334b4" args="(const Time &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Time.html">Time</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Time.html">Time</a></code> value that is the sum of the specified <code>lhs</code> time and the specified <code>rhs</code> datetime interval. </p>

</div>
</div>
<a class="anchor" id="aa0c65cf88d46d2febcc381c37d31ab6f"></a><!-- doxytag: member="bdlt::operator+" ref="aa0c65cf88d46d2febcc381c37d31ab6f" args="(const DatetimeInterval &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Time.html">Time</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Time.html">Time</a></code> value that is the sum of the specified <code>lhs</code> datetime interval and the specified <code>rhs</code> time. </p>

</div>
</div>
<a class="anchor" id="a74f975f7ef5c21a24e90c7d852e38092"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a74f975f7ef5c21a24e90c7d852e38092" args="(const Time &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Time.html">Time</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Time.html">Time</a></code> value that is the difference between the specified <code>lhs</code> time and the specified <code>rhs</code> datetime interval. </p>

</div>
</div>
<a class="anchor" id="a431a275fa8109e57b74539683c730a02"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a431a275fa8109e57b74539683c730a02" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object initialized with the difference between the specified <code>lhs</code> and <code>rhs</code> time values. </p>

</div>
</div>
<a class="anchor" id="a10af834f9ed8ff734d1f3229e5285454"></a><!-- doxytag: member="bdlt::operator==" ref="a10af834f9ed8ff734d1f3229e5285454" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> time objects have the same value, and <code>false</code> otherwise. Two time objects have the same value if each of their corresponding <code>hour</code>, <code>minute</code>, <code>second</code>, and <code>millisecond</code> attributes respectively have the same value. </p>

</div>
</div>
<a class="anchor" id="a5d1a8f5aa2222647c9ecc10485ad18fc"></a><!-- doxytag: member="bdlt::operator!=" ref="a5d1a8f5aa2222647c9ecc10485ad18fc" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> time objects do not have the same value, and <code>false</code> otherwise. Two time objects do not have the same value if any of their corresponding <code>hour</code>, <code>minute</code>, <code>second</code>, and <code>millisecond</code> attributes respectively do not have the same value. </p>

</div>
</div>
<a class="anchor" id="af28d85878757594415a1790427bc5461"></a><!-- doxytag: member="bdlt::operator&lt;" ref="af28d85878757594415a1790427bc5461" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> time value is less than the specified <code>rhs</code> time value, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs != <a class="el" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time()</a></code> and <code>rhs != <a class="el" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time()</a></code> (i.e., they do not have the, default, value 24:00:00.000). </p>

</div>
</div>
<a class="anchor" id="ac9993a2679b7a3f33fb6d67a7e6f0231"></a><!-- doxytag: member="bdlt::operator&lt;=" ref="ac9993a2679b7a3f33fb6d67a7e6f0231" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> time value is less than or equal to the specified <code>rhs</code> time value, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs != <a class="el" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time()</a></code> and <code>rhs != <a class="el" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time()</a></code> (i.e., they do not have the, default, value 24:00:00.000). </p>

</div>
</div>
<a class="anchor" id="ae394a2cba7d4f53c079becbf72810351"></a><!-- doxytag: member="bdlt::operator&gt;" ref="ae394a2cba7d4f53c079becbf72810351" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> time value is greater than the specified <code>rhs</code> time value, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs != <a class="el" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time()</a></code> and <code>rhs != <a class="el" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time()</a></code> (i.e., they do not have the, default, value 24:00:00.000). </p>

</div>
</div>
<a class="anchor" id="a06febab83d9493baf3bf62d503eea80b"></a><!-- doxytag: member="bdlt::operator&gt;=" ref="a06febab83d9493baf3bf62d503eea80b" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> time value is greater than or equal to the specified <code>rhs</code> time value, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs != <a class="el" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time()</a></code> and <code>rhs != <a class="el" href="namespacebdet.html#aac65e816e68f5285b127a9071544c5c1">Time()</a></code> (i.e., they do not have the, default, value 24:00:00.000). </p>

</div>
</div>
<a class="anchor" id="a10e3f5cc7c434b2b8afb6cb95c7657d6"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a10e3f5cc7c434b2b8afb6cb95c7657d6" args="(bsl::ostream &amp;stream, const Time &amp;time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>time</code> object to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="namespacebdlb_1_1PrintMethods.html#a26513ec0b5c4fa7a532923b7bc41ce0b">print</a>(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a78660751d5f19e902d70f341458e8bfa"></a><!-- doxytag: member="bdlt::operator==" ref="a78660751d5f19e902d70f341458e8bfa" args="(const TimeTz &amp;lhs, const TimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a></code> objects have the same value if their corresponding <code>localTime</code> and <code>offset</code> attributes have the same values. </p>

</div>
</div>
<a class="anchor" id="a4f0f3ef5e936b2a5b6245eb2b9e80ffa"></a><!-- doxytag: member="bdlt::operator!=" ref="a4f0f3ef5e936b2a5b6245eb2b9e80ffa" args="(const TimeTz &amp;lhs, const TimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a></code> objects do not have the same value if any of their corresponding <code>localTime</code> and <code>offset</code> attributes have different values. </p>

</div>
</div>
<a class="anchor" id="a1a1b2ea118a8e05dc38dbd8fbbc088d0"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a1a1b2ea118a8e05dc38dbd8fbbc088d0" args="(bsl::ostream &amp;stream, const TimeTz &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>, but with the attribute names elided. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:34 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
