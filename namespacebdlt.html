<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: Namespace bdlt</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&nbsp;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>bdlt Namespace Reference<br/>
<small>
[<a class="el" href="group__bdlt__currenttime.html">Component bdlt_currenttime</a>,&nbsp;<a class="el" href="group__bdlt__date.html">Component bdlt_date</a>,&nbsp;<a class="el" href="group__bdlt__datetime.html">Component bdlt_datetime</a>,&nbsp;<a class="el" href="group__bdlt__datetimeinterval.html">Component bdlt_datetimeinterval</a>,&nbsp;<a class="el" href="group__bdlt__datetimetz.html">Component bdlt_datetimetz</a>,&nbsp;<a class="el" href="group__bdlt__datetimeutil.html">Component bdlt_datetimeutil</a>,&nbsp;<a class="el" href="group__bdlt__datetz.html">Component bdlt_datetz</a>,&nbsp;<a class="el" href="group__bdlt__dateutil.html">Component bdlt_dateutil</a>,&nbsp;<a class="el" href="group__bdlt__dayofweek.html">Component bdlt_dayofweek</a>,&nbsp;<a class="el" href="group__bdlt__dayofweekset.html">Component bdlt_dayofweekset</a>,&nbsp;<a class="el" href="group__bdlt__epochutil.html">Component bdlt_epochutil</a>,&nbsp;<a class="el" href="group__bdlt__intervalconversionutil.html">Component bdlt_intervalconversionutil</a>,&nbsp;<a class="el" href="group__bdlt__localtimeoffset.html">Component bdlt_localtimeoffset</a>,&nbsp;<a class="el" href="group__bdlt__monthofyear.html">Component bdlt_monthofyear</a>,&nbsp;<a class="el" href="group__bdlt__serialdateimputil.html">Component bdlt_serialdateimputil</a>,&nbsp;<a class="el" href="group__bdlt__time.html">Component bdlt_time</a>,&nbsp;<a class="el" href="group__bdlt__timetz.html">Component bdlt_timetz</a>,&nbsp;<a class="el" href="group__bdlt__timeunitratio.html">Component bdlt_timeunitratio</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1CurrentTime.html">CurrentTime</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Date.html">Date</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1DatetimeUtil.html">DatetimeUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1DateUtil.html">DateUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1DayOfWeek.html">DayOfWeek</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1EpochUtil.html">EpochUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1IntervalConversionUtil.html">IntervalConversionUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1LocalTimeOffset.html">LocalTimeOffset</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1MonthOfYear.html">MonthOfYear</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1SerialDateImpUtil.html">SerialDateImpUtil</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1Time.html">Time</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbdlt_1_1TimeUnitRatio.html">TimeUnitRatio</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a0ec35f2cc29136ed6d2b66fd13b555e4">operator==</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ac705681a5d9979b0e193b9f057a4fb78">operator!=</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abeee7c1493f32c20d88de35621b4897b">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a2bc9ec2a06c5807f768293f8127fe1e5">operator&lt;</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abc73a4cbaf8d3da470d31aa33220314e">operator&lt;=</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a1a3cb249a27fbf19b173896b3a5b5c27">operator&gt;</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a86c04ddf8f13bdabcb0373d88f9351b0">operator&gt;=</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a49dbb017bac6819fd634adf28c73bfc6">operator++</a> (<a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a0fc43ceb7179c7af22909f66e02a3350">operator--</a> (<a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date, int)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aa2d88ce9a9249f9ae9b35ac1dce3bede">operator+</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date, int numDays)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ab66a081421c981594be6d5f313310d2f">operator+</a> (int numDays, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Date.html">Date</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a596fc180f7f9f0e4e4bb585e26d7517e">operator-</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;date, int numDays)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#afc48c336d4232852121d3f7873829119">operator-</a> (const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Date.html">Date</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a87dae07ed0f513c3bcd5e85bc4ccda7c">operator+</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a301e7055d0f31579de2b38c79f775f12">operator+</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ab08128a744e786dbf5493e78522021f1">operator-</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a30df660dbc2372391b19ddbf479194d9">operator-</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a213cd6bc42c4cec13528a1c831bdcf26">operator==</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a4eb84423be540857ea9d53aec0774a80">operator!=</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aeb391ec18b3add2e35ef8c5bc97ce36e">operator&lt;</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a8452d0f7b5c51f594e2ae6099a1c099e">operator&lt;=</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a635a8d64b2fa6917451defc4249da85f">operator&gt;</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a2e8273cc1f906b7b0eb386341a1b0f75">operator&gt;=</a> (const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abeedb0b000fa4ad1e219bf570ad8afac">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a92a32b7e56231cae8d6c79ace30312a9">operator+</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#addcfed615ab66de5740d6cc1a03fc4c3">operator-</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a58bd4269d0c2b901e564a327f0a2b033">operator-</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#addc4bd05840b52ddb181ed871ac3df8e">operator==</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a2eb359385d0b377e259abe583531508b">operator!=</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a52d0e0f383b0a6336314f538e8c01852">operator&lt;</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ad64ee5c0db952721eeb8f3e794b320a8">operator&lt;=</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ade6868a3fa95bc24ae09cb5e2547de47">operator&gt;</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a4820d7f25799d2d4c1eb22a0a850d55a">operator&gt;=</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a06c921c9fea95a004bfaf1b638b0bc84">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;object)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a70c449b04114c08e6a9b24b21383faf9">operator==</a> (const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a9b8feb08f678addedc5d1c392ebec18f">operator!=</a> (const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a327897c0cc2850341571fa935dc0e27d">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a19bfcd014a9cf8ca63178f353f0b3241">operator==</a> (const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a23a509c6ef18abc3d44841d4257db84d">operator!=</a> (const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a91385ac498bd1014020a65c6c6dc3f8a">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1DateTz.html">DateTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a25dfb4d5103b40f0552e3ecaad67b484">operator&lt;&lt;</a> (bsl::ostream &amp;stream, <a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573">DayOfWeek::Enum</a> value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#afc51da85db916b88828707653e987140">bdexStreamIn</a> (STREAM &amp;stream, <a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573">DayOfWeek::Enum</a> &amp;variable, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a9cf1c829a8cb75604972fa47826d2dda">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573">DayOfWeek::Enum</a> &amp;value, int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a939d0f2f7d5823be26b17d3c1e9371d5">maxSupportedBdexVersion</a> (const <a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573">DayOfWeek::Enum</a> *, int versionSelector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a1474adde66538699353253639a6732e7">operator==</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a8b026d031d58fad1a60e282c8b72f73e">operator!=</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet__Iter.html">DayOfWeekSet_Iter</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ae9da41d3f95b3f159d75653154677407">operator~</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;set)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a93ded80bbde497f532cabc23f9c91701">operator|</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a65b523b18113f0bb0a7146311e456b4d">operator&amp;</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ab1e47b13331c7843ba7b1451eb298504">operator^</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#abda0ca1acb2d07f61acecf8789b8486a">operator-</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ad5332804659034011308da81c615658f">operator==</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a56e69bd581ae4fb5186d7b4a410bbb83">operator!=</a> (const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a21500c97ab5edb7d6c12194a6d28788c">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a71626d77b2e1ecdaa823711ead4a376e">operator&lt;&lt;</a> (bsl::ostream &amp;stream, <a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f">MonthOfYear::Enum</a> value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#afb8fea6c03f1b65c18f16fb460da1376">bdexStreamIn</a> (STREAM &amp;stream, <a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f">MonthOfYear::Enum</a> &amp;variable, int version)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class STREAM &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">STREAM &amp;&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#adcc16797804c9d73ad7d4b732d52e7dd">bdexStreamOut</a> (STREAM &amp;stream, const <a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f">MonthOfYear::Enum</a> &amp;value, int version)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a9c8c6e0fc572fb4d863b8ac9b6fbb0c9">maxSupportedBdexVersion</a> (const <a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f">MonthOfYear::Enum</a> *, int versionSelector)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Time.html">Time</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a9794878bbdcd61e4138deaf260a334b4">operator+</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Time.html">Time</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#aa0c65cf88d46d2febcc381c37d31ab6f">operator+</a> (const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1Time.html">Time</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a74f975f7ef5c21a24e90c7d852e38092">operator-</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a431a275fa8109e57b74539683c730a02">operator-</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a10af834f9ed8ff734d1f3229e5285454">operator==</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a5d1a8f5aa2222647c9ecc10485ad18fc">operator!=</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#af28d85878757594415a1790427bc5461">operator&lt;</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ac9993a2679b7a3f33fb6d67a7e6f0231">operator&lt;=</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#ae394a2cba7d4f53c079becbf72810351">operator&gt;</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a06febab83d9493baf3bf62d503eea80b">operator&gt;=</a> (const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;lhs, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a10e3f5cc7c434b2b8afb6cb95c7657d6">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1Time.html">Time</a> &amp;time)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a78660751d5f19e902d70f341458e8bfa">operator==</a> (const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a4f0f3ef5e936b2a5b6245eb2b9e80ffa">operator!=</a> (const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;lhs, const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;rhs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bsl::ostream &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlt.html#a1a1b2ea118a8e05dc38dbd8fbbc088d0">operator&lt;&lt;</a> (bsl::ostream &amp;stream, const <a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a> &amp;object)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a0ec35f2cc29136ed6d2b66fd13b555e4"></a><!-- doxytag: member="bdlt::operator==" ref="a0ec35f2cc29136ed6d2b66fd13b555e4" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Date.html">Date</a></code> objects have the same value if each of their <code>year</code>, <code>month</code>, and <code>day</code> attributes (respectively) have the same value. </p>

</div>
</div>
<a class="anchor" id="ac705681a5d9979b0e193b9f057a4fb78"></a><!-- doxytag: member="bdlt::operator!=" ref="ac705681a5d9979b0e193b9f057a4fb78" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Date.html">Date</a></code> objects do not have the same value if any of their <code>year</code>, <code>month</code>, and <code>day</code> attributes (respectively) do not have the same value. </p>

</div>
</div>
<a class="anchor" id="abeee7c1493f32c20d88de35621b4897b"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="abeee7c1493f32c20d88de35621b4897b" args="(bsl::ostream &amp;stream, const Date &amp;date)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>date</code> object to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      print(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a2bc9ec2a06c5807f768293f8127fe1e5"></a><!-- doxytag: member="bdlt::operator&lt;" ref="a2bc9ec2a06c5807f768293f8127fe1e5" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> date is earlier than the specified <code>rhs</code> date, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="abc73a4cbaf8d3da470d31aa33220314e"></a><!-- doxytag: member="bdlt::operator&lt;=" ref="abc73a4cbaf8d3da470d31aa33220314e" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> date is earlier than or the same as the specified <code>rhs</code> date, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a1a3cb249a27fbf19b173896b3a5b5c27"></a><!-- doxytag: member="bdlt::operator&gt;" ref="a1a3cb249a27fbf19b173896b3a5b5c27" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> date is later than the specified <code>rhs</code> date, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a86c04ddf8f13bdabcb0373d88f9351b0"></a><!-- doxytag: member="bdlt::operator&gt;=" ref="a86c04ddf8f13bdabcb0373d88f9351b0" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> date is later than or the same as the specified <code>rhs</code> date, and <code>false</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a49dbb017bac6819fd634adf28c73bfc6"></a><!-- doxytag: member="bdlt::operator++" ref="a49dbb017bac6819fd634adf28c73bfc6" args="(Date &amp;date, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator++ </td>
          <td>(</td>
          <td class="paramtype">Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>date</code> object to have the value that is one day later than its current value, and return the value of <code>date</code> on entry. The behavior is undefined if the value of <code>date</code> on entry is <code>9999/12/31</code>. </p>

</div>
</div>
<a class="anchor" id="a0fc43ceb7179c7af22909f66e02a3350"></a><!-- doxytag: member="bdlt::operator&#45;&#45;" ref="a0fc43ceb7179c7af22909f66e02a3350" args="(Date &amp;date, int)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator-- </td>
          <td>(</td>
          <td class="paramtype">Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>date</code> object to have the value that is one day earlier than its current value, and return the value of <code>date</code> on entry. The behavior is undefined if the value of <code>date</code> on entry is <code>0001/01/01</code>. </p>

</div>
</div>
<a class="anchor" id="aa2d88ce9a9249f9ae9b35ac1dce3bede"></a><!-- doxytag: member="bdlt::operator+" ref="aa2d88ce9a9249f9ae9b35ac1dce3bede" args="(const Date &amp;date, int numDays)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numDays</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ab66a081421c981594be6d5f313310d2f"></a><!-- doxytag: member="bdlt::operator+" ref="ab66a081421c981594be6d5f313310d2f" args="(int numDays, const Date &amp;date)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numDays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the date value that is later by the specified (signed) <code>numDays</code> from the specified <code>date</code>. The behavior is undefined unless the resulting value falls within the range of dates supported by this class (see <code>isValidYearMonthDay</code>). Note that <code>numDays</code> may be negative. </p>

</div>
</div>
<a class="anchor" id="a596fc180f7f9f0e4e4bb585e26d7517e"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a596fc180f7f9f0e4e4bb585e26d7517e" args="(const Date &amp;date, int numDays)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Date.html">Date</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>date</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numDays</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the date value that is earlier by the specified (signed) <code>numDays</code> from the specified <code>date</code>. The behavior is undefined unless the resulting value falls within the range of dates supported by this class (see <code>isValidYearMonthDay</code>). Note that <code>numDays</code> may be negative. </p>

</div>
</div>
<a class="anchor" id="afc48c336d4232852121d3f7873829119"></a><!-- doxytag: member="bdlt::operator&#45;" ref="afc48c336d4232852121d3f7873829119" args="(const Date &amp;lhs, const Date &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Date &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (signed) number of days between the specified <code>lhs</code> and <code>rhs</code> dates. Note that if <code>lhs &lt; rhs</code> the result will be negative. </p>

</div>
</div>
<a class="anchor" id="a87dae07ed0f513c3bcd5e85bc4ccda7c"></a><!-- doxytag: member="bdlt::operator+" ref="a87dae07ed0f513c3bcd5e85bc4ccda7c" args="(const Datetime &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object having a value that is the sum of the specified <code>lhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>) and the specified <code>rhs</code> (<code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code>). If <code>24 == lhs.hour()</code>, the result is the same as if the <code>hour</code> attribute of <code>lhs</code> is 0. The behavior is undefined unless the resulting value is in the valid range for a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a301e7055d0f31579de2b38c79f775f12"></a><!-- doxytag: member="bdlt::operator+" ref="a301e7055d0f31579de2b38c79f775f12" args="(const DatetimeInterval &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object having a value that is the sum of the specified <code>lhs</code> (<code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code>) and the specified <code>rhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>). If <code>24 == rhs.hour()</code>, the result is the same as if the <code>hour</code> attribute of <code>rhs</code> is 0. The behavior is undefined unless the resulting value is in the valid range for a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object. </p>

</div>
</div>
<a class="anchor" id="ab08128a744e786dbf5493e78522021f1"></a><!-- doxytag: member="bdlt::operator&#45;" ref="ab08128a744e786dbf5493e78522021f1" args="(const Datetime &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object having a value that is the difference between the specified <code>lhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>) and the specified <code>rhs</code> (<code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code>). If <code>24 == lhs.hour()</code>, the result is the same as if the <code>hour</code> attribute of <code>lhs</code> is 0. The behavior is undefined unless the resulting value is in the valid range for a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a30df660dbc2372391b19ddbf479194d9"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a30df660dbc2372391b19ddbf479194d9" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object having a value that is the difference between the specified <code>lhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>) and the specified <code>rhs</code> (<code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code>). If the <code>hour</code> attribute of either operand is 24, the result is the same as if that <code>hour</code> attribute is 0. The behavior is undefined unless the resulting value is in the valid range for a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object. </p>

</div>
</div>
<a class="anchor" id="a213cd6bc42c4cec13528a1c831bdcf26"></a><!-- doxytag: member="bdlt::operator==" ref="a213cd6bc42c4cec13528a1c831bdcf26" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> objects have the same value if they have the same values for their "date" and "time" parts, respectively (i.e., <code>lhs.date() == rhs.date() &amp;&amp; lhs.time() == rhs.time()</code>). </p>

</div>
</div>
<a class="anchor" id="a4eb84423be540857ea9d53aec0774a80"></a><!-- doxytag: member="bdlt::operator!=" ref="a4eb84423be540857ea9d53aec0774a80" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> objects do not have the same value if they do not have the same values for either of their "date" or "time" parts, respectively (i.e., <code>lhs.date() != rhs.date() || lhs.time() != rhs.time()</code>). </p>

</div>
</div>
<a class="anchor" id="aeb391ec18b3add2e35ef8c5bc97ce36e"></a><!-- doxytag: member="bdlt::operator&lt;" ref="aeb391ec18b3add2e35ef8c5bc97ce36e" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> object is less than the value of the specified <code>rhs</code> object, and <code>false</code> otherwise. A <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object <code>a</code> is less than a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object <code>b</code> if <code>a.date() &lt; b.date()</code>, or if <code>a.date() == b.date() &amp;&amp; a.time() &lt; b.time()</code>. The behavior is undefined unless <code>24 != lhs.hour() &amp;&amp; 24 != rhs.hour()</code>. </p>

</div>
</div>
<a class="anchor" id="a8452d0f7b5c51f594e2ae6099a1c099e"></a><!-- doxytag: member="bdlt::operator&lt;=" ref="a8452d0f7b5c51f594e2ae6099a1c099e" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> object is less than or equal to the value of the specified <code>rhs</code> object, and <code>false</code> otherwise. The behavior is undefined unless <code>24 != lhs.hour() &amp;&amp; 24 != rhs.hour()</code>. </p>

</div>
</div>
<a class="anchor" id="a635a8d64b2fa6917451defc4249da85f"></a><!-- doxytag: member="bdlt::operator&gt;" ref="a635a8d64b2fa6917451defc4249da85f" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> object is greater than the value of the specified <code>rhs</code> object, and <code>false</code> otherwise. A <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object <code>a</code> is greater than a <code><a class="el" href="classbdlt_1_1Datetime.html">Datetime</a></code> object <code>b</code> if <code>a.date() &gt; b.date()</code>, or if <code>a.date() == b.date() &amp;&amp; a.time() &gt; b.time()</code>. The behavior is undefined unless <code>24 != lhs.hour() &amp;&amp; 24 != rhs.hour()</code>. </p>

</div>
</div>
<a class="anchor" id="a2e8273cc1f906b7b0eb386341a1b0f75"></a><!-- doxytag: member="bdlt::operator&gt;=" ref="a2e8273cc1f906b7b0eb386341a1b0f75" args="(const Datetime &amp;lhs, const Datetime &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the value of the specified <code>lhs</code> object is greater than or equal to the value of the specified <code>rhs</code> object, and <code>false</code> otherwise. The behavior is undefined unless <code>24 != lhs.hour() &amp;&amp; 24 != rhs.hour()</code>. </p>

</div>
</div>
<a class="anchor" id="abeedb0b000fa4ad1e219bf570ad8afac"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="abeedb0b000fa4ad1e219bf570ad8afac" args="(bsl::ostream &amp;stream, const Datetime &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Datetime &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> object to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      print(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a92a32b7e56231cae8d6c79ace30312a9"></a><!-- doxytag: member="bdlt::operator+" ref="a92a32b7e56231cae8d6c79ace30312a9" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object whose value is the sum of the specified <code>lhs</code> and <code>rhs</code> time intervals. The behavior is undefined unless the resulting time interval value is valid (i.e., the days field must not overflow a 32-bit integer). </p>

</div>
</div>
<a class="anchor" id="addcfed615ab66de5740d6cc1a03fc4c3"></a><!-- doxytag: member="bdlt::operator&#45;" ref="addcfed615ab66de5740d6cc1a03fc4c3" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object whose value is the difference between the specified <code>lhs</code> and <code>rhs</code> time intervals. The behavior is undefined unless the resulting time interval value is valid (i.e., the days field must not overflow a 32-bit integer). </p>

</div>
</div>
<a class="anchor" id="a58bd4269d0c2b901e564a327f0a2b033"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a58bd4269d0c2b901e564a327f0a2b033" args="(const DatetimeInterval &amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object whose value is the negative of the specified time interval <code>value</code>. The behavior is undefined unless <code>INT_MIN &lt; value.days()</code>. </p>

</div>
</div>
<a class="anchor" id="addc4bd05840b52ddb181ed871ac3df8e"></a><!-- doxytag: member="bdlt::operator==" ref="addc4bd05840b52ddb181ed871ac3df8e" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> time intervals have the same value, and <code>false</code> otherwise. Two time intervals have the same value if all of the corresponding values of their days, hours, minutes, seconds, and milliseconds fields are the same. </p>

</div>
</div>
<a class="anchor" id="a2eb359385d0b377e259abe583531508b"></a><!-- doxytag: member="bdlt::operator!=" ref="a2eb359385d0b377e259abe583531508b" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> time intervals do not have the same value, and <code>false</code> otherwise. Two time intervals do not have the same value if any of the corresponding values of their days, hours, minutes, seconds, or milliseconds fields is not the same. </p>

</div>
</div>
<a class="anchor" id="a52d0e0f383b0a6336314f538e8c01852"></a><!-- doxytag: member="bdlt::operator&lt;" ref="a52d0e0f383b0a6336314f538e8c01852" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ad64ee5c0db952721eeb8f3e794b320a8"></a><!-- doxytag: member="bdlt::operator&lt;=" ref="ad64ee5c0db952721eeb8f3e794b320a8" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ade6868a3fa95bc24ae09cb5e2547de47"></a><!-- doxytag: member="bdlt::operator&gt;" ref="ade6868a3fa95bc24ae09cb5e2547de47" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a4820d7f25799d2d4c1eb22a0a850d55a"></a><!-- doxytag: member="bdlt::operator&gt;=" ref="a4820d7f25799d2d4c1eb22a0a850d55a" args="(const DatetimeInterval &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the nominal relation between the specified <code>lhs</code> and <code>rhs</code> time interval values holds, and <code>false</code> otherwise. <code>lhs</code> is less than <code>rhs</code> if the following expression evaluates to <code>true</code>: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      lhs.totalMilliseconds() &lt; rhs.totalMilliseconds()
</pre></div><p><br/>
<br/>
 The other relationships are defined similarly. </p>

</div>
</div>
<a class="anchor" id="a06c921c9fea95a004bfaf1b638b0bc84"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a06c921c9fea95a004bfaf1b638b0bc84" args="(bsl::ostream &amp;stream, const DatetimeInterval &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>. </p>

</div>
</div>
<a class="anchor" id="a70c449b04114c08e6a9b24b21383faf9"></a><!-- doxytag: member="bdlt::operator==" ref="a70c449b04114c08e6a9b24b21383faf9" args="(const DatetimeTz &amp;lhs, const DatetimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></code> objects have the same value if they have the same local datetime value and the same time zone offset value. </p>

</div>
</div>
<a class="anchor" id="a9b8feb08f678addedc5d1c392ebec18f"></a><!-- doxytag: member="bdlt::operator!=" ref="a9b8feb08f678addedc5d1c392ebec18f" args="(const DatetimeTz &amp;lhs, const DatetimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1DatetimeTz.html">DatetimeTz</a></code> objects do not have the same value if they do not have the same local datetime value or the same time zone offset value. </p>

</div>
</div>
<a class="anchor" id="a327897c0cc2850341571fa935dc0e27d"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a327897c0cc2850341571fa935dc0e27d" args="(bsl::ostream &amp;stream, const DatetimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>rhs</code> object to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>, but with the attribute names elided. </p>

</div>
</div>
<a class="anchor" id="a19bfcd014a9cf8ca63178f353f0b3241"></a><!-- doxytag: member="bdlt::operator==" ref="a19bfcd014a9cf8ca63178f353f0b3241" args="(const DateTz &amp;lhs, const DateTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></code> objects have the same value if they have the same local date value and the same time zone offset value. </p>

</div>
</div>
<a class="anchor" id="a23a509c6ef18abc3d44841d4257db84d"></a><!-- doxytag: member="bdlt::operator!=" ref="a23a509c6ef18abc3d44841d4257db84d" args="(const DateTz &amp;lhs, const DateTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> <code><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1DateTz.html">DateTz</a></code> objects do not have the same value if they do not have the same local date values or the same time zone offset values. </p>

</div>
</div>
<a class="anchor" id="a91385ac498bd1014020a65c6c6dc3f8a"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a91385ac498bd1014020a65c6c6dc3f8a" args="(bsl::ostream &amp;stream, const DateTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DateTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>rhs</code> object to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>, but with the attribute names elided. </p>

</div>
</div>
<a class="anchor" id="a25dfb4d5103b40f0552e3ecaad67b484"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a25dfb4d5103b40f0552e3ecaad67b484" args="(bsl::ostream &amp;stream, DayOfWeek::Enum value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DayOfWeek::Enum&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the string representation of the specified enumeration <code>value</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. See <code>toAscii</code> for what constitutes the string representation of a <code><a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573" title="Enumerated day-of-week values.">bdlt::DayOfWeek::Enum</a></code> value. Note that this method has the same behavior as <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="structbdlt_1_1DayOfWeek.html#acb7d2d81ba27a2c8ecfe68a6413c90f4">bdlt::DayOfWeek::print</a>(stream, value, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="afc51da85db916b88828707653e987140"></a><!-- doxytag: member="bdlt::bdexStreamIn" ref="afc51da85db916b88828707653e987140" args="(STREAM &amp;stream, DayOfWeek::Enum &amp;variable, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdlt::bdexStreamIn </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DayOfWeek::Enum &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>variable</code> the <code><a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573" title="Enumerated day-of-week values.">DayOfWeek::Enum</a></code> value read from the specified input <code>stream</code> using the specified <code>version</code> format, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code><a class="el" href="structbdlt_1_1DayOfWeek.html">DayOfWeek</a></code>, <code>variable</code> is unaltered and <code>stream</code> is invalidated, but otherwise unmodified. If <code>version</code> is supported by <code><a class="el" href="structbdlt_1_1DayOfWeek.html">DayOfWeek</a></code> but <code>stream</code> becomes invalid during this operation, <code>variable</code> has an undefined, but valid, state. The behavior is undefined unless <code>STREAM</code> is BDEX-compliant. Note that no version is read from <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a9cf1c829a8cb75604972fa47826d2dda"></a><!-- doxytag: member="bdlt::bdexStreamOut" ref="a9cf1c829a8cb75604972fa47826d2dda" args="(STREAM &amp;stream, const DayOfWeek::Enum &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdlt::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeek::Enum &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>value</code>, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code><a class="el" href="structbdlt_1_1DayOfWeek.html">DayOfWeek</a></code>, <code>stream</code> is invalidated, but otherwise unmodified. The behavior is undefined unless <code>STREAM</code> is BDEX-compliant. Note that <code>version</code> is not written to <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a939d0f2f7d5823be26b17d3c1e9371d5"></a><!-- doxytag: member="bdlt::maxSupportedBdexVersion" ref="a939d0f2f7d5823be26b17d3c1e9371d5" args="(const DayOfWeek::Enum *, int versionSelector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlt::maxSupportedBdexVersion </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeek::Enum *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum valid BDEX format version, as indicated by the specified <code>versionSelector</code>, to be passed to the <code>bdexStreamOut</code> method while streaming an object of the type <code><a class="el" href="structbdlt_1_1DayOfWeek.html#a09b33959b12014fe88ddd8d0d692f573" title="Enumerated day-of-week values.">DayOfWeek::Enum</a></code>. Note that it is highly recommended that <code>versionSelector</code> be formatted as "YYYYMMDD", a date representation. Also note that <code>versionSelector</code> should be a <em>compile</em>-time-chosen value that selects a format version supported by both externalizer and unexternalizer. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a1474adde66538699353253639a6732e7"></a><!-- doxytag: member="bdlt::operator==" ref="a1474adde66538699353253639a6732e7" args="(const DayOfWeekSet_Iter &amp;lhs, const DayOfWeekSet_Iter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet_Iter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet_Iter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators have the same value, and <code>false</code> otherwise. Two iterators have the same value if they refer to data at the same index position. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both reference into the same set of data. </p>

</div>
</div>
<a class="anchor" id="a8b026d031d58fad1a60e282c8b72f73e"></a><!-- doxytag: member="bdlt::operator!=" ref="a8b026d031d58fad1a60e282c8b72f73e" args="(const DayOfWeekSet_Iter &amp;lhs, const DayOfWeekSet_Iter &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet_Iter &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet_Iter &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> iterators do not have the same value, and <code>false</code> otherwise. Two iterators do not have the same value if they do not refer to data at the same index position. The behavior is undefined unless <code>lhs</code> and <code>rhs</code> both reference into the same set of data. </p>

</div>
</div>
<a class="anchor" id="ae9da41d3f95b3f159d75653154677407"></a><!-- doxytag: member="bdlt::operator~" ref="ae9da41d3f95b3f159d75653154677407" args="(const DayOfWeekSet &amp;set)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator~ </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>set</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the complement of the specified <code>set</code> (i.e., those members <em>not</em> contained in <code>set</code>). </p>

</div>
</div>
<a class="anchor" id="a93ded80bbde497f532cabc23f9c91701"></a><!-- doxytag: member="bdlt::operator|" ref="a93ded80bbde497f532cabc23f9c91701" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator| </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the union of the specified <code>lhs</code> and <code>rhs</code> sets (i.e., a set containing elements that are in either <code>lhs</code> or <code>rhs</code> or both). </p>

</div>
</div>
<a class="anchor" id="a65b523b18113f0bb0a7146311e456b4d"></a><!-- doxytag: member="bdlt::operator&amp;" ref="a65b523b18113f0bb0a7146311e456b4d" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator&amp; </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the intersection of the specified <code>lhs</code> and <code>rhs</code> sets (i.e., a set containing elements that are in both <code>lhs</code> and <code>rhs</code>). </p>

</div>
</div>
<a class="anchor" id="ab1e47b13331c7843ba7b1451eb298504"></a><!-- doxytag: member="bdlt::operator^" ref="ab1e47b13331c7843ba7b1451eb298504" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator^ </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the exclusive-or of the specified <code>lhs</code> and <code>rhs</code> sets (i.e., a set containing elements that are either in <code>lhs</code>, but not <code>rhs</code>, or in <code>rhs</code>, but not <code>lhs</code>). </p>

</div>
</div>
<a class="anchor" id="abda0ca1acb2d07f61acecf8789b8486a"></a><!-- doxytag: member="bdlt::operator&#45;" ref="abda0ca1acb2d07f61acecf8789b8486a" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DayOfWeekSet.html">DayOfWeekSet</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a set containing the subtraction of the specified <code>rhs</code> set from the specified <code>lhs</code> set (i.e., a set containing elements that are in <code>lhs</code>, but not in <code>rhs</code>). </p>

</div>
</div>
<a class="anchor" id="ad5332804659034011308da81c615658f"></a><!-- doxytag: member="bdlt::operator==" ref="ad5332804659034011308da81c615658f" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> sets have the same value, and <code>false</code> otherwise. Two sets have the same value if they have the same length and all the elements of one set are members of the other set. </p>

</div>
</div>
<a class="anchor" id="a56e69bd581ae4fb5186d7b4a410bbb83"></a><!-- doxytag: member="bdlt::operator!=" ref="a56e69bd581ae4fb5186d7b4a410bbb83" args="(const DayOfWeekSet &amp;lhs, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> sets do not have the same value, and <code>false</code> otherwise. Two sets do not have the same value if they differ in length or there exists an element of one set that is not a member of the other set. </p>

</div>
</div>
<a class="anchor" id="a21500c97ab5edb7d6c12194a6d28788c"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a21500c97ab5edb7d6c12194a6d28788c" args="(bsl::ostream &amp;stream, const DayOfWeekSet &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DayOfWeekSet &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>rhs</code> set to the specified output <code>stream</code> in some reasonable (single-line) format, and return a reference to <code>stream</code>. </p>

</div>
</div>
<a class="anchor" id="a71626d77b2e1ecdaa823711ead4a376e"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a71626d77b2e1ecdaa823711ead4a376e" args="(bsl::ostream &amp;stream, MonthOfYear::Enum value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MonthOfYear::Enum&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the string representation of the specified enumeration <code>value</code> to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. See <code>toAscii</code> for what constitutes the string representation of a <code><a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f" title="Define the list of month-of-year values.">bdlt::MonthOfYear::Enum</a></code> value. Note that this method has the same behavior as <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      <a class="code" href="structbdlt_1_1MonthOfYear.html#a77f10ca3532d9773e15e9d070288c251">bdlt::MonthOfYear::print</a>(stream, value, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="afb8fea6c03f1b65c18f16fb460da1376"></a><!-- doxytag: member="bdlt::bdexStreamIn" ref="afb8fea6c03f1b65c18f16fb460da1376" args="(STREAM &amp;stream, MonthOfYear::Enum &amp;variable, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdlt::bdexStreamIn </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MonthOfYear::Enum &amp;&nbsp;</td>
          <td class="paramname"> <em>variable</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>variable</code> the <code><a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f" title="Define the list of month-of-year values.">MonthOfYear::Enum</a></code> value read from the specified input <code>stream</code> using the specified <code>version</code> format, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code><a class="el" href="structbdlt_1_1MonthOfYear.html">MonthOfYear</a></code>, <code>variable</code> is unaltered and <code>stream</code> is invalidated, but otherwise unmodified. If <code>version</code> is supported by <code><a class="el" href="structbdlt_1_1MonthOfYear.html">MonthOfYear</a></code> but <code>stream</code> becomes invalid during this operation, <code>variable</code> has an undefined, but valid, state. The behavior is undefined unless <code>STREAM</code> is BDEX-compliant. Note that no version is read from <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="adcc16797804c9d73ad7d4b732d52e7dd"></a><!-- doxytag: member="bdlt::bdexStreamOut" ref="adcc16797804c9d73ad7d4b732d52e7dd" args="(STREAM &amp;stream, const MonthOfYear::Enum &amp;value, int version)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class STREAM &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">STREAM&amp; bdlt::bdexStreamOut </td>
          <td>(</td>
          <td class="paramtype">STREAM &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MonthOfYear::Enum &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>version</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the specified <code>value</code>, using the specified <code>version</code> format, to the specified output <code>stream</code>, and return a reference to <code>stream</code>. If <code>stream</code> is initially invalid, this operation has no effect. If <code>version</code> is not supported by <code><a class="el" href="structbdlt_1_1MonthOfYear.html">MonthOfYear</a></code>, <code>stream</code> is invalidated, but otherwise unmodified. The behavior is undefined unless <code>STREAM</code> is BDEX-compliant. Note that <code>version</code> is not written to <code>stream</code>. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a9c8c6e0fc572fb4d863b8ac9b6fbb0c9"></a><!-- doxytag: member="bdlt::maxSupportedBdexVersion" ref="a9c8c6e0fc572fb4d863b8ac9b6fbb0c9" args="(const MonthOfYear::Enum *, int versionSelector)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int bdlt::maxSupportedBdexVersion </td>
          <td>(</td>
          <td class="paramtype">const MonthOfYear::Enum *&nbsp;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>versionSelector</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum valid BDEX format version, as indicated by the specified <code>versionSelector</code>, to be passed to the <code>bdexStreamOut</code> method while streaming an object of the type <code><a class="el" href="structbdlt_1_1MonthOfYear.html#a743de0a20be2d1b54c441de247cc280f" title="Define the list of month-of-year values.">MonthOfYear::Enum</a></code>. Note that it is highly recommended that <code>versionSelector</code> be formatted as "YYYYMMDD", a date representation. Also note that <code>versionSelector</code> should be a <em>compile</em>-time-chosen value that selects a format version supported by both externalizer and unexternalizer. See the <code>bslx</code> package-level documentation for more information on BDEX streaming of value-semantic types and containers. </p>

</div>
</div>
<a class="anchor" id="a9794878bbdcd61e4138deaf260a334b4"></a><!-- doxytag: member="bdlt::operator+" ref="a9794878bbdcd61e4138deaf260a334b4" args="(const Time &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Time.html">Time</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Time.html">Time</a></code> value that is the sum of the specified <code>lhs</code> time and the specified <code>rhs</code> datetime interval. </p>

</div>
</div>
<a class="anchor" id="aa0c65cf88d46d2febcc381c37d31ab6f"></a><!-- doxytag: member="bdlt::operator+" ref="aa0c65cf88d46d2febcc381c37d31ab6f" args="(const DatetimeInterval &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Time.html">Time</a> bdlt::operator+ </td>
          <td>(</td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Time.html">Time</a></code> value that is the sum of the specified <code>lhs</code> datetime interval and the specified <code>rhs</code> time. </p>

</div>
</div>
<a class="anchor" id="a74f975f7ef5c21a24e90c7d852e38092"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a74f975f7ef5c21a24e90c7d852e38092" args="(const Time &amp;lhs, const DatetimeInterval &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1Time.html">Time</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DatetimeInterval &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1Time.html">Time</a></code> value that is the difference between the specified <code>lhs</code> time and the specified <code>rhs</code> datetime interval. </p>

</div>
</div>
<a class="anchor" id="a431a275fa8109e57b74539683c730a02"></a><!-- doxytag: member="bdlt::operator&#45;" ref="a431a275fa8109e57b74539683c730a02" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a> bdlt::operator- </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a <code><a class="el" href="classbdlt_1_1DatetimeInterval.html">DatetimeInterval</a></code> object initialized with the difference between the specified <code>lhs</code> and <code>rhs</code> time values. </p>

</div>
</div>
<a class="anchor" id="a10af834f9ed8ff734d1f3229e5285454"></a><!-- doxytag: member="bdlt::operator==" ref="a10af834f9ed8ff734d1f3229e5285454" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> time objects have the same value, and <code>false</code> otherwise. Two time objects have the same value if each of their corresponding <code>hour</code>, <code>minute</code>, <code>second</code>, and <code>millisecond</code> attributes respectively have the same value. </p>

</div>
</div>
<a class="anchor" id="a5d1a8f5aa2222647c9ecc10485ad18fc"></a><!-- doxytag: member="bdlt::operator!=" ref="a5d1a8f5aa2222647c9ecc10485ad18fc" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> time objects do not have the same value, and <code>false</code> otherwise. Two time objects do not have the same value if any of their corresponding <code>hour</code>, <code>minute</code>, <code>second</code>, and <code>millisecond</code> attributes respectively do not have the same value. </p>

</div>
</div>
<a class="anchor" id="af28d85878757594415a1790427bc5461"></a><!-- doxytag: member="bdlt::operator&lt;" ref="af28d85878757594415a1790427bc5461" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> time value is less than the specified <code>rhs</code> time value, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs != Time()</code> and <code>rhs != Time()</code> (i.e., they do not have the, default, value 24:00:00.000). </p>

</div>
</div>
<a class="anchor" id="ac9993a2679b7a3f33fb6d67a7e6f0231"></a><!-- doxytag: member="bdlt::operator&lt;=" ref="ac9993a2679b7a3f33fb6d67a7e6f0231" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> time value is less than or equal to the specified <code>rhs</code> time value, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs != Time()</code> and <code>rhs != Time()</code> (i.e., they do not have the, default, value 24:00:00.000). </p>

</div>
</div>
<a class="anchor" id="ae394a2cba7d4f53c079becbf72810351"></a><!-- doxytag: member="bdlt::operator&gt;" ref="ae394a2cba7d4f53c079becbf72810351" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> time value is greater than the specified <code>rhs</code> time value, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs != Time()</code> and <code>rhs != Time()</code> (i.e., they do not have the, default, value 24:00:00.000). </p>

</div>
</div>
<a class="anchor" id="a06febab83d9493baf3bf62d503eea80b"></a><!-- doxytag: member="bdlt::operator&gt;=" ref="a06febab83d9493baf3bf62d503eea80b" args="(const Time &amp;lhs, const Time &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> time value is greater than or equal to the specified <code>rhs</code> time value, and <code>false</code> otherwise. The behavior is undefined unless <code>lhs != Time()</code> and <code>rhs != Time()</code> (i.e., they do not have the, default, value 24:00:00.000). </p>

</div>
</div>
<a class="anchor" id="a10e3f5cc7c434b2b8afb6cb95c7657d6"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a10e3f5cc7c434b2b8afb6cb95c7657d6" args="(bsl::ostream &amp;stream, const Time &amp;time)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Time &amp;&nbsp;</td>
          <td class="paramname"> <em>time</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>time</code> object to the specified output <code>stream</code> in a single-line format, and return a reference to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified, can change without notice, and is logically equivalent to: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">      print(stream, 0, -1);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a78660751d5f19e902d70f341458e8bfa"></a><!-- doxytag: member="bdlt::operator==" ref="a78660751d5f19e902d70f341458e8bfa" args="(const TimeTz &amp;lhs, const TimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator== </td>
          <td>(</td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a></code> objects have the same value if their corresponding <code>localTime</code> and <code>offset</code> attributes have the same values. </p>

</div>
</div>
<a class="anchor" id="a4f0f3ef5e936b2a5b6245eb2b9e80ffa"></a><!-- doxytag: member="bdlt::operator!=" ref="a4f0f3ef5e936b2a5b6245eb2b9e80ffa" args="(const TimeTz &amp;lhs, const TimeTz &amp;rhs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool bdlt::operator!= </td>
          <td>(</td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>rhs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if the specified <code>lhs</code> and <code>rhs</code> objects do not have the same value, and <code>false</code> otherwise. Two <code><a class="el" href="classbdlt_1_1TimeTz.html">TimeTz</a></code> objects do not have the same value if any of their corresponding <code>localTime</code> and <code>offset</code> attributes have different values. </p>

</div>
</div>
<a class="anchor" id="a1a1b2ea118a8e05dc38dbd8fbbc088d0"></a><!-- doxytag: member="bdlt::operator&lt;&lt;" ref="a1a1b2ea118a8e05dc38dbd8fbbc088d0" args="(bsl::ostream &amp;stream, const TimeTz &amp;object)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bsl::ostream&amp; bdlt::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">bsl::ostream &amp;&nbsp;</td>
          <td class="paramname"> <em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TimeTz &amp;&nbsp;</td>
          <td class="paramname"> <em>object</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Write the value of the specified <code>object</code> to the specified output <code>stream</code> in a single-line format, and return a reference providing modifiable access to <code>stream</code>. If <code>stream</code> is not valid on entry, this operation has no effect. Note that this human-readable format is not fully specified and can change without notice. Also note that this method has the same behavior as <code>object.print(stream, 0, -1)</code>, but with the attribute names elided. </p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:26 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
