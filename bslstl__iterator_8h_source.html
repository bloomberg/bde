<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.16 BETA</title>
<html>
<pre>
// bslstl_iterator.h                                                  -*-C++-*-
#ifndef INCLUDED_BSLSTL_ITERATOR
#define INCLUDED_BSLSTL_ITERATOR

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide basic iterator traits, adaptors, and utilities.
//
//@CLASSES:
//  bsl::iterator_traits: information about iterator associated types
//  bsl::reverse_iterator: bring in &#39;std::reverse_iterator&#39;
//  bsl::distance: global function to calculate iterator distance
//
//@SEE_ALSO: bslstl_forwarditerator, bslstl_bidirectionaliterator,
//           bslstl_randomaccessiterator, C++ Standard
//
//@DESCRIPTION: This component is for internal use only.  Please include
// &#39;&lt;bsl_iterator.h&gt;&#39; directly.  This component provides the facilities of the
// iterators library from the C++ Standard, including iterator primitives
// (24.4), iterator adaptors (24.5), and stream iterators (24.6).
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Using Iterators to Traverse a Container
/// - - - - - - - - - - - - - - - - - - - - - - - - -
// In this example, we will use the &#39;bsl::iterator&#39; and &#39;bsl::reverse_iterator&#39;
// to traverse an iterable container type.
//
// Suppose that we have an iterable container template type &#39;MyFixedSizeArray&#39;.
// An instantiation of &#39;MyFixedSizeArray&#39; represents an array having fixed
// number of elements, which is a parameter passed to the class constructor
// during construction.  A traversal of &#39;MyFixedSizeArray&#39; can be accomplished
// using basic iterators (pointers) as well as reverse iterators.
//
// First, we create a elided definition of the template container class,
// &#39;MyFixedSizeArray&#39;, which provides mutable and constant iterators of
// template type &#39;bsl::iterator&#39; and &#39;reverse_iterator&#39;:
//..
//  template &lt;class VALUE, int SIZE&gt;
//  class MyFixedSizeArray
//      // This is a container that contains a fixed number of elements.  The
//      // number of elements is specified upon construction and can not be
//      // changed afterwards.
//  {
//      // DATA
//      VALUE  d_array[SIZE];  // storage of the container
//
//    public:
//      // PUBLIC TYPES
//      typedef VALUE value_type;
//..
// Here, we define mutable and constant iterators and reverse iterators:
//..
//      typedef VALUE                                  *iterator;
//      typedef VALUE const                            *const_iterator;
//      typedef bsl::reverse_iterator&lt;iterator&gt;         reverse_iterator;
//      typedef bsl::reverse_iterator&lt;const_iterator&gt;   const_reverse_iterator;
//
//      // CREATORS
//      //! MyFixedSizeArray() = default;
//          // Create a &#39;MyFixedSizeArray&#39; object having the parameterized
//          // &#39;SIZE&#39; elements of the parameterized type &#39;VALUE&#39;.
//
//      //! MyFixedSizeArray(const MyFixedSizeArray&amp; original) = default;
//          // Create a &#39;MyFixedSizeArray&#39; object having same number of
//          // elements as that of the specified &#39;rhs&#39;, and the same value of
//          // each element as that of corresponding element in &#39;rhs&#39;.
//
//      //! ~MyFixedSizeArray() = default;
//          // Destroy this object.
//..
// Now, we define the &#39;begin&#39; and &#39;end&#39; methods to return basic iterators
// (&#39;VALUE*&#39; and &#39;const VALUE*&#39;), and the &#39;rbegin&#39; and &#39;rend&#39; methods to return
// reverse iterators (&#39;bsl::reverse_iterator&lt;VALUE*&gt;&#39; and
// &#39;bsl::reverse_iterator&lt;const VALUE*&gt;) type:
//..
//      // MANIPULATORS
//      iterator begin();
//          // Return the basic iterator providing modifiable access to the
//          // first valid element of this object.
//
//      iterator end();
//          // Return the basic iterator providing modifiable access to the
//          // position one after the last valid element of this object.
//
//      reverse_iterator rbegin();
//          // Return the reverse iterator providing modifiable access to the
//          // last valid element of this object.
//
//      reverse_iterator rend();
//          // Return the reverse iterator providing modifiable access to the
//          // position one before the first valid element of this object.
//
//      VALUE&amp; operator[](int i);
//          // Return the reference providing modifiable access of the
//          // specified &#39;i&#39;th element of this object.
//
//      // ACCESSORS
//      const_iterator begin() const;
//          // Return the basic iterator providing non-modifiable access to the
//          // first valid element of this object.
//
//      const_iterator end() const;
//          // Return the basic iterator providing non-modifiable access to the
//          // position one after the last valid element of this object.
//
//      const_reverse_iterator rbegin() const;
//          // Return the reverse iterator providing non-modifiable access to
//          // the last valid element of this object.
//
//      const_reverse_iterator rend() const;
//          // Return the reverse iterator providing non-modifiable access to
//          // the position one before the first valid element of this object.
//
//      int size() const;
//          // Return the number of elements contained in this object.
//
//      const VALUE&amp; operator[](int i) const;
//          // Return the reference providing non-modifiable access of the
//          // specified &#39;i&#39;th element of this object.
//  };
//
//  // ...
//..
// Then, we create a &#39;MyFixedSizeArray&#39; and initialize its elements:
//..
//  // Create a fixed array having five elements.
//
//  MyFixedSizeArray&lt;int, 5&gt; fixedArray;
//
//  // Initialize the values of each element in the fixed array.
//
//  for (int i = 0; i &lt; fixedArray.size(); ++i) {
//      fixedArray[i] = i + 1;
//  }
//..
// Now, we generate reverse iterators using the &#39;rbegin&#39; and &#39;rend&#39; methods of
// the fixed array object:
//..
//  MyFixedSizeArray&lt;int, 5&gt;::reverse_iterator rstart  = fixedArray.rbegin();
//  MyFixedSizeArray&lt;int, 5&gt;::reverse_iterator rfinish = fixedArray.rend();
//..
// Finally, we traverse the fixed array again in reverse order using the two
// generated reverse iterators:
//..
//  printf(&quot;Traverse array using reverse iterator:\n&quot;);
//  while (rstart != rfinish) {
//      printf(&quot;\tElement: %d\n&quot;, *rstart);
//      ++rstart;
//  }
//..
// The preceding loop produces the following output on &#39;stdout&#39;:
//..
//  Traverse array using reverse iterator:
//       Element: 5
//       Element: 4
//       Element: 3
//       Element: 2
//       Element: 1
//..

// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
#error &quot;include &lt;bsl_iterator.h&gt; instead of &lt;bslstl_iterator.h&gt; in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_ITERATOR
#include &lt;iterator&gt;
#define INCLUDED_ITERATOR
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;
#define INCLUDED_CSTDDEF
#endif

namespace bsl {

// 24.3 primitives
using native_std::input_iterator_tag;
using native_std::output_iterator_tag;
using native_std::forward_iterator_tag;
using native_std::bidirectional_iterator_tag;
using native_std::random_access_iterator_tag;
using native_std::iterator;

// 24.3.4 iterator operations
using native_std::advance;

// 24.3.4 predefined iterators
using native_std::back_insert_iterator;
using native_std::back_inserter;
using native_std::front_insert_iterator;
using native_std::front_inserter;
using native_std::insert_iterator;
using native_std::inserter;

// 24.5 stream iterators
using native_std::istream_iterator;
using native_std::ostream_iterator;
using native_std::istreambuf_iterator;
using native_std::ostreambuf_iterator;

#if defined(BSLS_PLATFORM_CMP_SUN) &amp;&amp; !defined(BDE_BUILD_TARGET_STLPORT)

// Sun does not provide &#39;std::iterator_traits&#39; at all.  We will provide our own
// in namespace &#39;bsl&#39;.

                        // =========================
                        // class bsl::IteratorTraits
                        // =========================

template &lt;class ITER&gt;
struct iterator_traits {
    // This &#39;struct&#39; will provide access to iterator traits.

    // TYPES
    typedef typename ITER::iterator_category iterator_category;
    typedef typename ITER::value_type        value_type;
    typedef typename ITER::difference_type   difference_type;
    typedef typename ITER::pointer           pointer;
    typedef typename ITER::reference         reference;
};

// SPECIALIZATIONS
template &lt;class TYPE&gt;
struct iterator_traits&lt;const TYPE *&gt; {
    // This specialization of &#39;iterator_traits&#39; will match pointer types to a
    // parameterized non-modifiable &#39;TYPE&#39;.

    // TYPES
    typedef std::random_access_iterator_tag iterator_category;
    typedef TYPE                            value_type;
    typedef std::ptrdiff_t                  difference_type;
    typedef const TYPE*                     pointer;
    typedef const TYPE&amp;                     reference;
};

template &lt;class TYPE&gt;
struct iterator_traits&lt;TYPE *&gt; {
    // This specialization of &#39;iterator_traits&#39; will match pointer types to a
    // parameterized modifiable &#39;TYPE&#39;.

    // TYPES
    typedef std::random_access_iterator_tag iterator_category;
    typedef TYPE                            value_type;
    typedef std::ptrdiff_t                  difference_type;
    typedef TYPE*                           pointer;
    typedef TYPE&amp;                           reference;
};

// Working around a sun compiler bug where &#39;std::reverse_iterator&#39; takes 6
// (with 3 default) template arguments instead of 1, which is not standard
// compliant.  Inherit from &#39;std::reverse_iterator&#39;.  For reference, the
// signature of sun&#39;s &#39;std::reverse_iterator&#39; is:
//..
//  template &lt;class Iterator,
//            class Category,
//            class T,
//            class Reference = T &amp;,
//            class Pointer = T *,
//            class Distance = ptrdiff_t&gt;
//  class reverse_iterator;
//..

                        // ===========================
                        // class bsl::reverse_iterator
                        // ===========================

template &lt;class ITER&gt;
class reverse_iterator :
    public native_std::reverse_iterator&lt;
                             ITER,
                             typename iterator_traits&lt;ITER&gt;::iterator_category,
                             typename iterator_traits&lt;ITER&gt;::value_type,
                             typename iterator_traits&lt;ITER&gt;::reference,
                             typename iterator_traits&lt;ITER&gt;::pointer&gt; {
    // This class provides a template iterator adaptor that iterates from the
    // end of the sequence defined by the (template parameter) type &#39;ITER&#39; to
    // the beginning of that sequence.  The type &#39;ITER&#39; shall meet all the
    // requirements of a bidirectional iterator [24.2.6]. The elements sequence
    // generated in this reversed iteration is referred as
    // &#39;reverse iteration sequence&#39; in the following class level documentation.
    // The fundamental relation between a reverse iterator and its
    // corresponding iterator &#39;i&#39; of type &#39;ITER&#39; is established by the identity
    // &#39;&amp;*(reverse_iterator(i)) == &amp;*(i - 1)&#39;.  This template meets the
    // requirement of reverse iterator adaptor defined in C++11 standard
    // [24.5.1].

    // PRIVATE TYPES
    typedef native_std::reverse_iterator&lt;
                 ITER,
                 typename iterator_traits&lt;ITER&gt;::iterator_category,
                 typename iterator_traits&lt;ITER&gt;::value_type,
                 typename iterator_traits&lt;ITER&gt;::reference,
                 typename iterator_traits&lt;ITER&gt;::pointer&gt;                 Base;

  public:
    // For convenience:

    typedef typename reverse_iterator::difference_type difference_type;

    // CREATORS
    reverse_iterator();
        // Create the default value for this reverse iterator.  The
        // default-constructed reverse iterator does not have a singular value
        // unless an object of the type specified by the template parameter
        // &#39;ITER&#39; has a singular value after default construction.

    explicit reverse_iterator(ITER base);
        // Create a reverse iterator using the specified &#39;base&#39; of the
        // (template parameter) type &#39;ITER&#39;.

    template &lt;class OTHER_ITER&gt;
    reverse_iterator(const reverse_iterator&lt;OTHER_ITER&gt;&amp; original);
        // Create a reverse iterator having the same value as the specified
        // &#39;original&#39;.

    // MANIPULATORS
    reverse_iterator&amp; operator++();
        // Increment to the next element in the reverse iteration sequence and
        // return a reference providing modifiable access to this reverse
        // iterator.  The behavior is undefined if, on entry, this reverse
        // iterator has the past-the-end value for a reverse iterator over the
        // underlying sequence.

    reverse_iterator  operator++(int);
        // Increment to the next element in the reverse iteration sequence and
        // return a reverse iterator having the pre-increment value of this
        // reverse iterator.  The behavior is undefined if, on entry, this
        // reverse iterator has the past-the-end value for a reverse iterator
        // over the underlying sequence.

    reverse_iterator&amp; operator+=(difference_type n);
        // Increment by the specified &#39;n&#39; number of elements in the reverse
        // iteration sequence and return a reference providing modifiable
        // access to this reverse iterator.  The behavior is undefined unless
        // this reverse iterator, after incrementing by &#39;n&#39;, is within the
        // bounds of the underlying sequence.  Note that the (template
        // parameter) type &#39;ITER&#39; shall meet the requirements of a random
        // access iterator.

    reverse_iterator&amp; operator--();
        // Decrement to the previous element in the reverse iteration sequence
        // and return a reference providing modifiable access to this reverse
        // iterator.  The behavior is undefined if, on entry, this reverse
        // iterator has the same value as a reverse iterator to the start of
        // the underlying sequence.

    reverse_iterator  operator--(int);
        // Decrement to the previous element in the reverse iteration sequence
        // and return a reverse iterator having the pre-decrement value of this
        // reverse iterator.  The behavior is undefined if, on entry, this
        // reverse iterator has the same value as a reverse iterator to the
        // start of the underlying sequence.

    reverse_iterator&amp; operator-=(difference_type n);
        // Decrement by the specified &#39;n&#39; number of elements in the reverse
        // iteration sequence and return a reference providing modifiable
        // access to this reverse iterator.  The behavior is undefined unless
        // this reverse iterator, after decrementing by &#39;n&#39;, is within the
        // bounds of the underlying sequence.  Note that the (template
        // parameter) type &#39;ITER&#39; shall meet the requirements of a random
        // access iterator.

    // ACCESSORS
    reverse_iterator operator+(difference_type n) const;
        // Return a reverse iterator having the same value as that of
        // incrementing this reverse iterator by the specified &#39;n&#39; number of
        // elements in the reverse iteration sequence.  The behavior is
        // undefined unless this reverse iterator, if increments by &#39;n&#39;, would
        // be within the bounds of the underlying sequence.  Note that the
        // (template parameter) type &#39;ITER&#39; shall meet the requirements of a
        // random access iterator.

    reverse_iterator operator-(difference_type n) const;
        // Return a reverse iterator having the same value as that of
        // decrementing this reverse iterator by the specified &#39;n&#39; number of
        // elements in the reverse iteration sequence.  The behavior is
        // undefined unless this reverse iterator, if decrements by &#39;n&#39;, would
        // be within the bounds of the underlying sequence.  Note that the
        // (template parameter) type &#39;ITER&#39; shall meet the requirements of a
        // random access iterator.
};

// FREE OPERATORS
template &lt;class ITER&gt;
inline
bool operator==(const reverse_iterator&lt;ITER&gt;&amp; lhs,
                const reverse_iterator&lt;ITER&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; reverse iterator has the same value
    // as the specified &#39;rhs&#39; reverse iterator, and &#39;false&#39; otherwise.  Two
    // reverse iterators have the same value if they refer to the same element,
    // or both have the past-the-end value for a reverse iterator over the
    // underlying reverse iteration sequence.  The behavior is undefined unless
    // both reverse iterators refer to the same underlying sequence.

template &lt;class ITER1, class ITER2&gt;
inline
bool operator==(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
                const reverse_iterator&lt;ITER2&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; reverse iterator of the (template
    // parameter) type &#39;ITER1&#39; has the same value as the specified &#39;rhs&#39;
    // reverse iterator of the (template parameter) type &#39;ITER2&#39;, and &#39;false&#39;
    // otherwise.  Two reverse iterators have the same value if they refer to
    // the same element, or both have the past-the-end value for a reverse
    // iterator over the underlying reverse iteration sequence.  The behavior
    // is undefined unless both reverse iterators refer to the same underlying
    // sequence.

template &lt;class ITER&gt;
inline
bool operator!=(const reverse_iterator&lt;ITER&gt;&amp; lhs,
                const reverse_iterator&lt;ITER&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; reverse iterator does not have the
    // same value as the specified &#39;rhs&#39; reverse iterator, and &#39;false&#39;
    // otherwise.  Two reverse iterators do not have the same value if (1) they
    // do not refer to the same element and (2) both do not have the
    // past-the-end value for a reverse iterator over the underlying reverse
    // iteration sequence.  The behavior is undefined unless both reverse
    // iterators refer to the same underlying sequence.

template &lt;class ITER1, class ITER2&gt;
inline
bool operator!=(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
                const reverse_iterator&lt;ITER2&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; reverse iterator of the (template
    // parameter) type &#39;ITER1&#39; does not have the same value as the specified
    // &#39;rhs&#39; reverse iterator of the (template parameter) type &#39;ITER2&#39;, and
    // &#39;false&#39; otherwise.  Two reverse iterators do not have the same value if
    // (1) they do not refer to the same element and (2) both do not have the
    // past-the-end value for a reverse iterator over the underlying reverse
    // iteration sequence.  The behavior is undefined unless both reverse
    // iterators refer to the same underlying sequence.

template &lt;class ITER&gt;
inline
bool operator&lt;(const reverse_iterator&lt;ITER&gt;&amp; lhs,
               const reverse_iterator&lt;ITER&gt;&amp; rhs);
    // Return &#39;true&#39; if (1) the specified &#39;lhs&#39; reverse iterator refers to an
    // element before the specified &#39;rhs&#39; reverse iterator in the reverse
    // iteration sequence, or (2) &#39;rhs&#39; (and not &#39;lhs&#39;) has the past-the-end
    // value for a reverse iterator over this sequence, and &#39;false&#39; otherwise.
    // The behavior is undefined unless both reverse iterators refer to the
    // same underlying sequence.  Note that the (template parameter) type
    // &#39;ITER&#39; shall meet the requirements of random access iterator.

template &lt;class ITER1, class ITER2&gt;
inline
bool operator&lt;(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
               const reverse_iterator&lt;ITER2&gt;&amp; rhs);
    // Return &#39;true&#39; if (1) the specified &#39;lhs&#39; reverse iterator of the
    // (template parameter) type &#39;ITER1&#39; refers to an element before the
    // specified &#39;rhs&#39; reverse iterator of the (template parameter) type
    // &#39;ITER2&#39; in the reverse iteration sequence, or (2) &#39;rhs&#39; (and not &#39;lhs&#39;)
    // has the past-the-end value for a reverse iterator over this sequence,
    // and &#39;false&#39; otherwise.  The behavior is undefined unless both reverse
    // iterators refer to the same underlying sequence.  Note that both &#39;ITER1&#39;
    // and &#39;ITER2&#39; shall meet the requirements of random access iterator.

template &lt;class ITER&gt;
inline
bool operator&gt;(const reverse_iterator&lt;ITER&gt;&amp; lhs,
               const reverse_iterator&lt;ITER&gt;&amp; rhs);
    // Return &#39;true&#39; if (1) the specified &#39;lhs&#39; reverse iterator refers to an
    // element after the specified &#39;rhs&#39; reverse iterator in the reverse
    // iteration sequence, or (2) &#39;lhs&#39; (and not &#39;rhs&#39;) has the past-the-front
    // value of an reverse iterator over this sequence, and &#39;false&#39; otherwise.
    // The behavior is undefined unless both reverse iterators refer to the
    // same underlying sequence.  Note that the (template parameter) type
    // &#39;ITER&#39; shall meet the requirements of random access iterator.

template &lt;class ITER1, class ITER2&gt;
inline
bool operator&gt;(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
               const reverse_iterator&lt;ITER2&gt;&amp; rhs);
    // Return &#39;true&#39; if (1) the specified &#39;lhs&#39; reverse iterator of the
    // (template parameter) type &#39;ITER1&#39; refers to an element after the
    // specified &#39;rhs&#39; reverse iterator of the (template parameter) type
    // &#39;ITER2&#39; in the reverse iteration sequence, or (2) &#39;lhs&#39; (and not &#39;rhs&#39;)
    // has the past-the-front value of an reverse iterator over this sequence,
    // and &#39;false&#39; otherwise.  The behavior is undefined unless both reverse
    // iterators refer to the same underlying sequence.  Note that both &#39;ITER1&#39;
    // and &#39;ITER2&#39; shall meet the requirements of random access iterator.

template &lt;class ITER&gt;
inline
bool operator&lt;=(const reverse_iterator&lt;ITER&gt;&amp; lhs,
                const reverse_iterator&lt;ITER&gt;&amp; rhs);
    // Return &#39;true&#39; if (1) the specified &#39;lhs&#39; reverse iterator has the same
    // value as the specified &#39;rhs&#39; reverse iterator, or (2) &#39;lhs&#39; refers to an
    // element before &#39;rhs&#39; in the reverse iteration sequence, or (3) &#39;rhs&#39; has
    // the past-the-end value for a reverse iterator over this sequence, and
    // &#39;false&#39; otherwise.  The behavior is undefined unless both reverse
    // iterators refer to the same underlying sequence.  Note that the
    // (template parameter) type &#39;ITER&#39; shall meet the requirements of a random
    // access iterator.

template &lt;class ITER1, class ITER2&gt;
inline
bool operator&lt;=(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
                const reverse_iterator&lt;ITER2&gt;&amp; rhs);
    // Return &#39;true&#39; if (1) the specified &#39;lhs&#39; reverse iterator of the
    // (template parameter) type &#39;ITER1&#39; has the same value as the specified
    // &#39;rhs&#39; reverse iterator of the (template parameter) type &#39;ITER2&#39;, or (2)
    // &#39;lhs&#39; refers to an element before &#39;rhs&#39; in the reverse iteration
    // sequence, or (3) &#39;rhs&#39; has the past-the-end value for a reverse iterator
    // over this sequence, and &#39;false&#39; otherwise.  The behavior is undefined
    // unless both reverse iterators refer to the same underlying sequence.
    // Note that both &#39;ITER1&#39; and &#39;ITER2&#39; shall meet the requirements of a
    // random access iterator.

template &lt;class ITER&gt;
inline
bool operator&gt;=(const reverse_iterator&lt;ITER&gt;&amp; lhs,
                const reverse_iterator&lt;ITER&gt;&amp; rhs);
    // Return &#39;true&#39; if (1) the specified &#39;lhs&#39; reverse iterator has the same
    // value as the specified &#39;rhs&#39; reverse iterator, or (2) &#39;lhs&#39; has the
    // past-the-end value for a reverse iterator over the underlying reverse
    // iteration sequence, or (3) &#39;lhs&#39; refers to an element after &#39;rhs&#39; in
    // this sequence, and &#39;false&#39; otherwise.  The behavior is undefined unless
    // both reverse iterators refer to the same underlying sequence.  Note that
    // the (template parameter) type &#39;ITER&#39; shall meet the requirements of
    // random access iterator.

template &lt;class ITER1, class ITER2&gt;
inline
bool operator&gt;=(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
                const reverse_iterator&lt;ITER2&gt;&amp; rhs);
    // Return &#39;true&#39; if (1) the specified &#39;lhs&#39; reverse iterator of the
    // (template parameter) type &#39;ITER1&#39; has the same value as the specified
    // &#39;rhs&#39; reverse iterator of the (template parameter) type &#39;ITER2&#39;, or (2)
    // &#39;lhs&#39; has the past-the-end value for a reverse iterator over the
    // underlying reverse iteration sequence, or (3) &#39;lhs&#39; refers to an element
    // after &#39;rhs&#39; in this sequence, and &#39;false&#39; otherwise.  The behavior is
    // undefined unless both reverse iterators refer to the same underlying
    // sequence.  Note that both type &#39;ITER1&#39; and type &#39;ITER2&#39; shall meet the
    // requirements of random access iterator.

template &lt;class ITER&gt;
inline
typename reverse_iterator&lt;ITER&gt;::difference_type
operator-(const reverse_iterator&lt;ITER&gt;&amp; lhs,
          const reverse_iterator&lt;ITER&gt;&amp; rhs);
    // Return the distance from the specified &#39;rhs&#39; reverse iterator to the
    // specified &#39;lhs&#39; reverse iterator.  The behavior is undefined unless
    // &#39;lhs&#39; and &#39;rhs&#39; are reverse iterators into the same underlying sequence.
    // Note that the (template parameter) type &#39;ITER&#39; shall meet the
    // requirements of random access iterator.  Also note that the result might
    // be negative.

template &lt;class ITER, class DIFF_TYPE&gt;
inline
reverse_iterator&lt;ITER&gt;
operator+(DIFF_TYPE n, const reverse_iterator&lt;ITER&gt;&amp; rhs);
    // Return a reverse iterator to the element at the specified &#39;n&#39; positions
    // past the specified &#39;rhs&#39; reverse iterator.  The behavior is undefined
    // unless &#39;rhs&#39;, after incrementing by &#39;n&#39;, is within the bounds of the
    // underlying sequence.  Note that the (template parameter) type &#39;ITER&#39;
    // shall meet the requirements of random access iterator.

                        // ==========================
                        // struct IteratorDistanceImp
                        // ==========================

struct IteratorDistanceImp {
    // This utility class provides a namespace for functions that operate on
    // iterators.

    template &lt;class FWD_ITER, class DIFFERENCE_TYPE&gt;
    static void getDistance(DIFFERENCE_TYPE *ret,
                            FWD_ITER         start,
                            FWD_ITER         finish,
                            input_iterator_tag);
        // Return in the specified &#39;*ret&#39; the distance from the specified
        // &#39;start&#39; iterator to the specified &#39;finish&#39; iterator.  The behavior
        // is undefined unless &#39;start&#39; and &#39;finish&#39; both have the
        // &#39;input_iterator_tag&#39; into the same underlying sequence, and &#39;start&#39;
        // is before &#39;finish&#39; in that sequence.

    template &lt;class FWD_ITER, class DIFFERENCE_TYPE&gt;
    static void getDistance(DIFFERENCE_TYPE *ret,
                            FWD_ITER         start,
                            FWD_ITER         finish,
                            forward_iterator_tag);
        // Return in the specified &#39;*ret&#39; the distance from the specified
        // &#39;start&#39; iterator to the specified &#39;finish&#39; iterator.  The behavior
        // is undefined unless &#39;start&#39; and &#39;finish&#39; both have the
        // &#39;forward_iterator_tag&#39; into the same underlying sequence, and
        // &#39;start&#39; is before &#39;finish&#39; in that sequence.

    template &lt;class RANDOM_ITER, class DIFFERENCE_TYPE&gt;
    static void getDistance(DIFFERENCE_TYPE *ret,
                            RANDOM_ITER      start,
                            RANDOM_ITER      finish,
                            random_access_iterator_tag);
        // Return in the specified &#39;*ret&#39; the distance from the specified
        // &#39;start&#39; iterator to the specified &#39;finish&#39; iterator.  The behavior
        // is undefined unless &#39;start&#39; and &#39;finish&#39; both have the
        // &#39;random_access_iterator_tag&#39; into the same underlying sequence.
        // Note that the result might be negative.
};

template &lt;class ITER&gt;
typename iterator_traits&lt;ITER&gt;::difference_type
distance(ITER start, ITER finish);
    // Return the distance from the specified &#39;start&#39; iterator to the specified
    // &#39;finish&#39; iterator.  The behavior is undefined unless &#39;start&#39; and
    // &#39;finish&#39; are both into the same underlying sequence, and &#39;start&#39; is
    // before &#39;finish&#39; in that sequence.  Note that the (template parameter)
    // type &#39;ITER&#39; shall meet the requirements of input iterator.
#else

// Just use the native version
using native_std::reverse_iterator;
using native_std::iterator_traits;
using native_std::distance;

#endif

// ===========================================================================
//                      INLINE FUNCTION DEFINITIONS
// ===========================================================================

                        // ---------------------------
                        // class bsl::reverse_iterator
                        // ---------------------------

#if defined(BSLS_PLATFORM_CMP_SUN) &amp;&amp; !defined(BDE_BUILD_TARGET_STLPORT)

// CREATORS
template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;::reverse_iterator()
: Base()
{
}

template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;::reverse_iterator(ITER base)
: Base(base)
{
}

template &lt;class ITER&gt;
template &lt;class OTHER_ITER&gt;
inline
reverse_iterator&lt;ITER&gt;::reverse_iterator(
                                  const reverse_iterator&lt;OTHER_ITER&gt;&amp; original)
: Base(original.base())
{
}

// MANIPULATORS
template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;&amp;
reverse_iterator&lt;ITER&gt;::operator++()
{
    Base::operator++();
    return *this;
}

template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;
reverse_iterator&lt;ITER&gt;::operator++(int)
{
    const reverse_iterator tmp(*this);
    this-&gt;operator++();
    return tmp;
}

template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;&amp;
reverse_iterator&lt;ITER&gt;::operator+=(difference_type n)
{
    Base::operator+=(n);
    return *this;
}

template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;&amp;
reverse_iterator&lt;ITER&gt;::operator--()
{
    Base::operator--();
    return *this;
}

template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;
reverse_iterator&lt;ITER&gt;::operator--(int)
{
    reverse_iterator tmp(*this);
    this-&gt;operator--();
    return tmp;
}

template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;&amp;
reverse_iterator&lt;ITER&gt;::operator-=(difference_type n)
{
    Base::operator-=(n);
    return *this;
}

// ACCESSORS
template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;
reverse_iterator&lt;ITER&gt;::operator+(difference_type n) const
{
    reverse_iterator tmp(*this);
    tmp += n;
    return tmp;
}

template &lt;class ITER&gt;
inline
reverse_iterator&lt;ITER&gt;
reverse_iterator&lt;ITER&gt;::operator-(difference_type n) const
{
    reverse_iterator tmp(*this);
    tmp -= n;
    return tmp;
}

// FREE OPERATORS
template &lt;class ITER&gt;
inline
bool operator==(const reverse_iterator&lt;ITER&gt;&amp; lhs,
                const reverse_iterator&lt;ITER&gt;&amp; rhs)
{
    typedef native_std::reverse_iterator&lt;
                 ITER,
                 typename iterator_traits&lt;ITER&gt;::iterator_category,
                 typename iterator_traits&lt;ITER&gt;::value_type,
                 typename iterator_traits&lt;ITER&gt;::reference,
                 typename iterator_traits&lt;ITER&gt;::pointer&gt;                 Base;

    return std::operator==(static_cast&lt;const Base&amp;&gt;(lhs),
                           static_cast&lt;const Base&amp;&gt;(rhs));
}

template &lt;class ITER1, class ITER2&gt;
inline
bool operator==(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
                const reverse_iterator&lt;ITER2&gt;&amp; rhs)
{
    // this is to compare reverse_iterator with const_reverse_iterator

    return lhs.base() == rhs.base();
}

template &lt;class ITER&gt;
inline
bool operator!=(const reverse_iterator&lt;ITER&gt;&amp; lhs,
                const reverse_iterator&lt;ITER&gt;&amp; rhs)
{
    return ! (lhs == rhs);
}

template &lt;class ITER1, class ITER2&gt;
inline
bool operator!=(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
                const reverse_iterator&lt;ITER2&gt;&amp; rhs)
{
    // this is to compare reverse_iterator with const_reverse_iterator

    return ! (lhs == rhs);
}

template &lt;class ITER&gt;
inline
bool operator&lt;(const reverse_iterator&lt;ITER&gt;&amp; lhs,
               const reverse_iterator&lt;ITER&gt;&amp; rhs)
{
    typedef native_std::reverse_iterator&lt;
                 ITER,
                 typename iterator_traits&lt;ITER&gt;::iterator_category,
                 typename iterator_traits&lt;ITER&gt;::value_type,
                 typename iterator_traits&lt;ITER&gt;::reference,
                 typename iterator_traits&lt;ITER&gt;::pointer&gt;                 Base;

    return std::operator&lt;(static_cast&lt;const Base&amp;&gt;(lhs),
                          static_cast&lt;const Base&amp;&gt;(rhs));
}

template &lt;class ITER1, class ITER2&gt;
inline
bool operator&lt;(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
               const reverse_iterator&lt;ITER2&gt;&amp; rhs)
{
    // this is to compare reverse_iterator with const_reverse_iterator

    return lhs.base() &lt; rhs.base();
}

template &lt;class ITER&gt;
inline
bool operator&gt;(const reverse_iterator&lt;ITER&gt;&amp; lhs,
               const reverse_iterator&lt;ITER&gt;&amp; rhs)
{
    return rhs &lt; lhs;
}

template &lt;class ITER1, class ITER2&gt;
inline
bool operator&gt;(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
               const reverse_iterator&lt;ITER2&gt;&amp; rhs)
{
    return rhs &lt; lhs;
}

template &lt;class ITER&gt;
inline
bool operator&lt;=(const reverse_iterator&lt;ITER&gt;&amp; lhs,
                const reverse_iterator&lt;ITER&gt;&amp; rhs)
{
    return !(rhs &lt; lhs);
}

template &lt;class ITER1, class ITER2&gt;
inline
bool operator&lt;=(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
                const reverse_iterator&lt;ITER2&gt;&amp; rhs)
{
    return !(rhs &lt; lhs);
}

template &lt;class ITER&gt;
inline
bool operator&gt;=(const reverse_iterator&lt;ITER&gt;&amp; lhs,
                const reverse_iterator&lt;ITER&gt;&amp; rhs)
{
    return !(lhs &lt; rhs);
}

template &lt;class ITER1, class ITER2&gt;
inline
bool operator&gt;=(const reverse_iterator&lt;ITER1&gt;&amp; lhs,
                const reverse_iterator&lt;ITER2&gt;&amp; rhs)
{
    return !(lhs &lt; rhs);
}

template &lt;class ITER&gt;
inline
typename reverse_iterator&lt;ITER&gt;::difference_type
operator-(const reverse_iterator&lt;ITER&gt;&amp; lhs,
          const reverse_iterator&lt;ITER&gt;&amp; rhs)
{
    typedef native_std::reverse_iterator&lt;
                 ITER,
                 typename iterator_traits&lt;ITER&gt;::iterator_category,
                 typename iterator_traits&lt;ITER&gt;::value_type,
                 typename iterator_traits&lt;ITER&gt;::reference,
                 typename iterator_traits&lt;ITER&gt;::pointer&gt;                 Base;

    return std::operator-(static_cast&lt;const Base&amp;&gt;(lhs),
                          static_cast&lt;const Base&amp;&gt;(rhs));
}

template &lt;class ITER, class DIFF_TYPE&gt;
inline
reverse_iterator&lt;ITER&gt;
operator+(DIFF_TYPE n, const reverse_iterator&lt;ITER&gt;&amp; rhs)
{
    return rhs.operator+(n);
}

                         // --------------------------
                         // struct IteratorDistanceImp
                         // --------------------------

template &lt;class FWD_ITER, class DIFFERENCE_TYPE&gt;
void IteratorDistanceImp::getDistance(DIFFERENCE_TYPE *ret,
                                      FWD_ITER         start,
                                      FWD_ITER         finish,
                                      input_iterator_tag)
{
    DIFFERENCE_TYPE count = 0;
    for ( ; start != finish; ++start) {
        ++count;
    }

    *ret = count;
}

template &lt;class FWD_ITER, class DIFFERENCE_TYPE&gt;
void IteratorDistanceImp::getDistance(DIFFERENCE_TYPE *ret,
                                      FWD_ITER         start,
                                      FWD_ITER         finish,
                                      forward_iterator_tag)
{
    DIFFERENCE_TYPE count = 0;
    for ( ; start != finish; ++start) {
        ++count;
    }

    *ret = count;
}

template &lt;class RANDOM_ITER, class DIFFERENCE_TYPE&gt;
inline
void IteratorDistanceImp::getDistance(DIFFERENCE_TYPE *ret,
                                      RANDOM_ITER      start,
                                      RANDOM_ITER      finish,
                                      random_access_iterator_tag)
{
    *ret = DIFFERENCE_TYPE(finish - start);
}

template &lt;class ITER&gt;
inline
typename iterator_traits&lt;ITER&gt;::difference_type
distance(ITER start, ITER finish)
{
    typedef typename bsl::iterator_traits&lt;ITER&gt;::iterator_category tag;

    typename iterator_traits&lt;ITER&gt;::difference_type ret;
    IteratorDistanceImp::getDistance(&amp;ret, start, finish, tag());
    return ret;
}

#endif  // BSLS_PLATFORM_CMP_SUN &amp;&amp; !BDE_BUILD_TARGET_STLPORT

}  // close namespace bsl

#endif

// ----------------------------------------------------------------------------
// Copyright (C) 2012 Bloomberg L.P.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the &quot;Software&quot;), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
