<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 2.23.1 OSS</title>
<html>
<pre>
// bslstl_bidirectionalnodepool.h                                     -*-C++-*-
#ifndef INCLUDED_BSLSTL_BIDIRECTIONALNODEPOOL
#define INCLUDED_BSLSTL_BIDIRECTIONALNODEPOOL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide efficient creation of nodes used in a node-based container.
//
//@CLASSES:
//   bslstl::BidirectionalNodePool: memory manager to allocate hash table nodes
//
//@SEE_ALSO: bslstl_simplepool
//
//@DESCRIPTION: This component implements a mechanism, &#39;BidirectionalNodePool&#39;,
// that creates and destroys &#39;bslalg::BidirectionalListNode&#39; objects holding
// objects of a (template parameter) type &#39;VALUE&#39; for use in hash-table-based
// containers.
//
// A &#39;BidirectionalNodePool&#39; uses a memory pool provided by the
// &#39;bslstl_simplepool&#39; component in its implementation to provide memory for
// the nodes (see &#39;bslstl_simplepool&#39;).
//
///Memory Allocation
///-----------------
// &#39;BidirectionalNodePool&#39; uses an allocator of the (template parameter) type
// &#39;ALLOCATOR&#39; specified at construction to allocate memory.
// &#39;BidirectionalNodePool&#39; supports allocators meeting the requirements of the
// C++ standard allocator requirements ([allocator.requirements], C++11
// 17.6.3.5).
//
// If &#39;ALLOCATOR&#39; is &#39;bsl::allocator&#39; and the (template parameter) type &#39;VALUE&#39;
// defines the &#39;bslma::UsesBslmaAllocator&#39; trait, then the &#39;bslma::Allocator&#39;
// object specified at construction will be supplied to constructors of the
// (template parameter) type &#39;VALUE&#39; in the &#39;cloneNode&#39; method and &#39;createNode&#39;
// method overloads.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Creating a Linked List Container
///- - - - - - - - - - - - - - - - - - - - - -
// Suppose that we want to define a bidirectional linked list that can hold
// elements of a template parameter type.  &#39;bslstl::BidirectionalNodePool&#39; can
// be used to create and destroy nodes that make up a linked list.
//
// First, we create an elided definition of the class template &#39;MyList&#39;:
//..
// #include &lt;bslalg_bidirectionallinklistutil.h&gt;
//
//  template &lt;class VALUE, class ALLOCATOR&gt;
//  class MyList {
//      // This class template implements a bidirectional linked list of
//      // element of the (template parameter) type &#39;VALUE&#39;.  The memory used
//      // will be allocated from an allocator of the (template parameter) type
//      // &#39;ALLOCATOR&#39; specified at construction.
//
//    public:
//      // TYPES
//      typedef bslalg::BidirectionalNode&lt;VALUE&gt; Node;
//          // This &#39;typedef&#39; is an alias to the type of the linked list node.
//
//    private:
//      // TYPES
//      typedef bslstl::BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt; Pool;
//          // This &#39;typedef&#39; is an alias to the type of the memory pool.
//
//      typedef bslalg::BidirectionalLinkListUtil               Util;
//          // This &#39;typedef&#39; is an alias to the utility &#39;struct&#39; providing
//          // functions for constructing and manipulating linked lists.
//
//      typedef bslalg::BidirectionalLink                       Link;
//          // This &#39;typedef&#39; is an alis to the type of the linked list link.
//
//      // DATA
//      Node *d_head_p;  // pointer to the head of the linked list
//      Node *d_tail_p;  // pointer to the tail of the linked list
//      Pool  d_pool;    // memory pool used to allocate memory
//
//
//    public:
//      // CREATORS
//      MyList(const ALLOCATOR&amp; allocator = ALLOCATOR());
//          // Create an empty linked list that allocate memory using the
//          // specified &#39;allocator&#39;.
//
//      ~MyList();
//          // Destroy this linked list by calling destructor for each element
//          // and deallocate all allocated storage.
//
//      // MANIPULATORS
//      void pushFront(const VALUE&amp; value);
//          // Insert the specified &#39;value&#39; at the front of this linked list.
//
//      void pushBack(const VALUE&amp; value);
//          // Insert the specified &#39;value&#39; at the end of this linked list.
//
//      //...
//  };
//..
// Now, we define the methods of &#39;MyMatrix&#39;:
//..
// CREATORS
//  template &lt;class VALUE, class ALLOCATOR&gt;
//  MyList&lt;VALUE, ALLOCATOR&gt;::MyList(const ALLOCATOR&amp; allocator)
//  : d_head_p(0)
//  , d_tail_p(0)
//  , d_pool(allocator)
//  {
//  }
//
//  template &lt;class VALUE, class ALLOCATOR&gt;
//  MyList&lt;VALUE, ALLOCATOR&gt;::~MyList()
//  {
//      Link *link = d_head_p;
//      while (link) {
//          Link *next = link-&gt;nextLink();
//..
// Here, we call the memory pool&#39;s &#39;deleteNode&#39; method to destroy the &#39;value&#39;
// attribute of the node and return its memory footprint back to the pool:
//..
//          d_pool.deleteNode(static_cast&lt;Node*&gt;(link));
//          link = next;
//      }
//  }
//
// MANIPULATORS
//  template &lt;class VALUE, class ALLOCATOR&gt;
//  void
//  MyList&lt;VALUE, ALLOCATOR&gt;::pushFront(const VALUE&amp; value)
//  {
//..
// Here, we call the memory pool&#39;s &#39;createNode&#39; method to allocate a node and
// copy-construct the specified &#39;value&#39; at the &#39;value&#39; attribute of the node:
//..
//      Node *node = static_cast&lt;Node *&gt;(d_pool.createNode(value));
//..
// Note that the memory pool will allocate the footprint of the node using the
// allocator specified at construction.  If the (template parameter) type
// &#39;ALLOCATOR&#39; is an instance of &#39;bsl::allocator&#39; and the (template parameter)
// type &#39;VALUE&#39; has the &#39;bslma::UsesBslmaAllocator&#39; trait, then the allocator
// specified at construction will also be supplied to the copy-constructor of
// &#39;VALUE&#39;.
//..
//      if (!d_head_p) {
//          d_tail_p = node;
//          node-&gt;setNextLink(0);
//          node-&gt;setPreviousLink(0);
//      }
//      else {
//          Util::insertLinkBeforeTarget(node, d_head_p);
//      }
//      d_head_p = node;
//  }
//
//  template &lt;class VALUE, class ALLOCATOR&gt;
//  void
//  MyList&lt;VALUE, ALLOCATOR&gt;::pushBack(const VALUE&amp; value)
//  {
//..
// Here, just like how we implemented the &#39;pushFront&#39; method, we call the
// pool&#39;s &#39;createNode&#39; method to allocate a node and copy-construct the
// specified &#39;value&#39; at the &#39;value&#39; attribute of the node:
//..
//      Node *node = static_cast&lt;Node *&gt;(d_pool.createNode(value));
//      if (!d_head_p) {
//          d_head_p = node;
//          node-&gt;setNextLink(0);
//          node-&gt;setPreviousLink(0);
//      }
//      else {
//          Util::insertLinkAfterTarget(node, d_tail_p);
//      }
//      d_tail_p = node;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATORTRAITS
#include &lt;bslstl_allocatortraits.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_SIMPLEPOOL
#include &lt;bslstl_simplepool.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALNODE
#include &lt;bslalg_bidirectionalnode.h&gt;
#endif

#ifndef INCLUDED_BSLMA_DEALLOCATORPROCTOR
#include &lt;bslma_deallocatorproctor.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLS_NATIVESTD
#include &lt;bsls_nativestd.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

namespace BloombergLP {
namespace bslstl {

                       // ===========================
                       // class BidirectionalNodePool
                       // ===========================

template &lt;class VALUE, class ALLOCATOR&gt;
class BidirectionalNodePool {
    // This class provides methods for creating and destroying nodes using the
    // appropriate allocator-traits of the (template parameter) type
    // &#39;ALLOCATOR&#39;.

    typedef SimplePool&lt;bslalg::BidirectionalNode&lt;VALUE&gt;, ALLOCATOR&gt;       Pool;
        // This &#39;typedef&#39; is an alias for the memory pool allocator.

    typedef typename Pool::AllocatorTraits AllocatorTraits;
        // This &#39;typedef&#39; is an alias for the allocator traits defined by
        // &#39;SimplePool&#39;.

    // DATA
    Pool d_pool;  // pool for allocating memory

  private:
    // NOT IMPLEMENTED
    BidirectionalNodePool&amp; operator=(const BidirectionalNodePool&amp;);
    BidirectionalNodePool(const BidirectionalNodePool&amp;);

  public:
    // PUBLIC TYPE
    typedef typename Pool::AllocatorType AllocatorType;
        // Alias for the allocator type defined by &#39;SimplePool&#39;.

    typedef typename AllocatorTraits::size_type size_type;
        // Alias for the &#39;size_type&#39; of the allocator defined by &#39;SimplePool&#39;.

  public:
    // CREATORS
    explicit BidirectionalNodePool(const ALLOCATOR&amp; allocator);
        // Create a &#39;BidirectionalNodePool&#39; object that will use the specified
        // &#39;allocator&#39; to supply memory for allocated node objects.  If the
        // (template parameter) &#39;ALLOCATOR&#39; is &#39;bsl::allocator&#39;, then
        // &#39;allocator&#39; shall be convertible to &#39;bslma::Allocator *&#39;.

    // ~BidirectionalNodePool() = default;
        // Destroy the memory pool maintained by this object, releasing all
        // memory used by the nodes of the type &#39;BidirectionalNode&lt;VALUE&gt;&#39; in
        // the pool.  Any memory allocated for the nodes&#39; &#39;value&#39; attribute of
        // the (template parameter) type &#39;VALUE&#39; will be leaked unless the
        // nodes are explicitly destroyed via the &#39;destroyNode&#39; method.

    // MANIPULATORS
    AllocatorType&amp; allocator();
        // Return a reference providing modifiable access to the allocator
        // supplying memory for the memory pool maintained by this object.  The
        // behavior is undefined if the allocator used by this object is
        // changed with this method.  Note that this method provides modifiable
        // access to enable a client to call non-&#39;const&#39; methods on the
        // allocator.

    bslalg::BidirectionalLink *createNode();
        // Allocate a node of the type &#39;BidirectionalNode&lt;VALUE&gt;&#39;, and default
        // construct an object of the (template parameter) type &#39;VALUE&#39; at the
        // &#39;value&#39; attribute of the node.  Return the address of the Node.
        // Note that the &#39;next&#39; and &#39;prev&#39; attributes of the returned node will
        // be uninitialized.

    template &lt;class SOURCE&gt;
    bslalg::BidirectionalLink *createNode(const SOURCE&amp; value);
        // Allocate a node of the type &#39;BidirectionalNode&lt;VALUE&gt;&#39;, and
        // construct an object of the (template parameter) type &#39;VALUE&#39;, using
        // its single-argument constructor passing the specified &#39;value&#39; as the
        // argument, at the &#39;value&#39; attribute of the node.  Return the address
        // of the node.  Note that the &#39;next&#39; and &#39;prev&#39; attributes of the
        // returned node will be uninitialized.

    template &lt;class FIRST_ARG, class SECOND_ARG&gt;
    bslalg::BidirectionalLink *createNode(const FIRST_ARG&amp;  first,
                                          const SECOND_ARG&amp; second);
        // Allocate a node of the type &#39;BidirectionalNode&lt;VALUE&gt;&#39;, and
        // construct an object of the (template parameter) type &#39;VALUE&#39;, using
        // its two-arguments constructor passing the specified &#39;first&#39; as the
        // first argument and the specified &#39;second&#39; as the second argument, at
        // the &#39;value&#39; attribute of the node.  Return the address of the node.
        // Note that the &#39;next&#39; and &#39;prev&#39; attributes of the returned node will
        // be uninitialized.

    bslalg::BidirectionalLink *cloneNode(
                                    const bslalg::BidirectionalLink&amp; original);
        // Allocate a node of the type &#39;BidirectionalNode&lt;VALUE&gt;&#39;, and
        // copy-construct an object of the (template parameter) type &#39;VALUE&#39;
        // having the same value as the specified &#39;original&#39; at the &#39;value&#39;
        // attribute of the node.  Return the address of the node.  Note that
        // the &#39;next&#39; and &#39;prev&#39; attributes of the returned node will be
        // uninitialized.

    void deleteNode(bslalg::BidirectionalLink *linkNode);
        // Destroy the &#39;VALUE&#39; attribute of the specified &#39;linkNode&#39; and return
        // the memory footprint of &#39;linkNode&#39; to this pool for potential reuse.
        // The behavior is undefined unless &#39;node&#39; refers to a
        // &#39;bslalg::BidirectionalNode&lt;VALUE&gt;&#39; that was allocated by this pool.

    void reserveNodes(size_type numNodes);
        // Reserve memory from this pool to satisfy memory requests for at
        // least the specified &#39;numNodes&#39; before the pool replenishes.  The
        // behavior is undefined unless &#39;0 &lt; numNodes&#39;.

    void swapRetainAllocators(BidirectionalNodePool&amp; other);
        // Efficiently exchange the nodes of this object with those of the
        // specified &#39;other&#39; object.  This method provides the no-throw
        // exception-safety guarantee.  The behavior is undefined unless
        // &#39;allocator() == other.allocator()&#39;.

    void swapExchangeAllocators(BidirectionalNodePool&amp; other);
        // Efficiently exchange the nodes and the allocator of this object with
        // those of the specified &#39;other&#39; object.  This method provides the
        // no-throw exception-safety guarantee.

    void release() { d_pool.release(); }

    // ACCESSORS
    const AllocatorType&amp; allocator() const;
        // Return a reference providing non-modifiable access to the allocator
        // supplying memory for the memory pool maintained by this object.
};

// FREE FUNCTIONS
template &lt;class VALUE, class ALLOCATOR&gt;
void swap(BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;&amp; a,
          BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;&amp; b);
        // Efficiently exchange the nodes of the specified &#39;a&#39; object with
        // those of the specified &#39;b&#39; object.  This method provides the
        // no-throw exception-safety guarantee.  The behavior is undefined
        // unless &#39;a.allocator() == b.allocator()&#39;.

}  // close namespace bslstl


// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for HashTable:
//: o A HashTable is bitwise moveable if the allocator is bitwise moveable.

namespace bslmf {

template &lt;class VALUE, class ALLOCATOR&gt;
struct IsBitwiseMoveable&lt;bslstl::BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt; &gt;
: bsl::integral_constant&lt;bool, bslmf::IsBitwiseMoveable&lt;ALLOCATOR&gt;::value&gt;
{};

}  // close namespace bslmf

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

namespace bslstl {

// CREATORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::BidirectionalNodePool(
                                                    const ALLOCATOR&amp; allocator)
: d_pool(allocator)
{
}

// MANIPULATORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
typename SimplePool&lt;bslalg::BidirectionalNode&lt;VALUE&gt;, ALLOCATOR&gt;::
                                                                 AllocatorType&amp;
BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::allocator()
{
    return d_pool.allocator();
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
bslalg::BidirectionalLink *
BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::createNode()
{
    bslalg::BidirectionalNode&lt;VALUE&gt; *node = d_pool.allocate();
    bslma::DeallocatorProctor&lt;Pool&gt; proctor(node, &amp;d_pool);

    AllocatorTraits::construct(allocator(),
                               bsls::Util::addressOf(node-&gt;value()));

    proctor.release();
    return node;
}

template &lt;class VALUE, class ALLOCATOR&gt;
template &lt;class SOURCE&gt;
inline
bslalg::BidirectionalLink *
BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::createNode(const SOURCE&amp; value)
{
    bslalg::BidirectionalNode&lt;VALUE&gt; *node = d_pool.allocate();
    bslma::DeallocatorProctor&lt;Pool&gt; proctor(node, &amp;d_pool);

    AllocatorTraits::construct(allocator(),
                               bsls::Util::addressOf(node-&gt;value()),
                               value);
    proctor.release();
    return node;
}

template &lt;class VALUE, class ALLOCATOR&gt;
template &lt;class FIRST_ARG, class SECOND_ARG&gt;
inline
bslalg::BidirectionalLink *
BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::createNode(const FIRST_ARG&amp;  first,
                                                    const SECOND_ARG&amp; second)
{
    bslalg::BidirectionalNode&lt;VALUE&gt; *node = d_pool.allocate();
    bslma::DeallocatorProctor&lt;Pool&gt; proctor(node, &amp;d_pool);

    AllocatorTraits::construct(allocator(),
                               bsls::Util::addressOf(node-&gt;value()),
                               first,
                               second);
    proctor.release();
    return node;
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
bslalg::BidirectionalLink *
BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::cloneNode(
                                     const bslalg::BidirectionalLink&amp; original)
{
    return createNode(static_cast&lt;const bslalg::BidirectionalNode&lt;VALUE&gt;&amp;&gt;
                                                           (original).value());
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::deleteNode(
                                           bslalg::BidirectionalLink *linkNode)
{
    BSLS_ASSERT(linkNode);

    bslalg::BidirectionalNode&lt;VALUE&gt; *node =
                     static_cast&lt;bslalg::BidirectionalNode&lt;VALUE&gt; *&gt;(linkNode);
    AllocatorTraits::destroy(allocator(),
                             bsls::Util::addressOf(node-&gt;value()));
    d_pool.deallocate(node);
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::reserveNodes(size_type numNodes)
{
    BSLS_ASSERT_SAFE(0 &lt; numNodes);

    d_pool.reserve(numNodes);
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::swapRetainAllocators(
                                BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;&amp; other)
{
    BSLS_ASSERT_SAFE(allocator() == other.allocator());

    d_pool.quickSwapRetainAllocators(other.d_pool);
}

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::swapExchangeAllocators(
                                BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;&amp; other)
{
    d_pool.quickSwapExchangeAllocators(other.d_pool);
}

// ACCESSORS
template &lt;class VALUE, class ALLOCATOR&gt;
inline
const typename
              SimplePool&lt;bslalg::BidirectionalNode&lt;VALUE&gt;, ALLOCATOR&gt;::
                                                                 AllocatorType&amp;
BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;::allocator() const
{
    return d_pool.allocator();
}

}  // close namespace bslstl

template &lt;class VALUE, class ALLOCATOR&gt;
inline
void bslstl::swap(bslstl::BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;&amp; a,
                  bslstl::BidirectionalNodePool&lt;VALUE, ALLOCATOR&gt;&amp; b)
{
    a.swapRetainAllocators(b);
}

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
