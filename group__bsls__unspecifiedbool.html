<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.16 BETA: bsls_unspecifiedbool Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=0 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bsl__P__bslhdrs.html">bsl+bslhdrs</a> | <a class="qindex" href="group__bsl__P__stdhdrs.html">bsl+stdhdrs</a> | <a class="qindex" href="group__bslalg.html">bslalg</a> | <a class="qindex" href="group__bsldoc.html">bsldoc</a> | <a class="qindex" href="group__bslim.html">bslim</a> | <a class="qindex" href="group__bslma.html">bslma</a> | <a class="qindex" href="group__bslmf.html">bslmf</a> | <a class="qindex" href="group__bsls.html">bsls</a> | <a class="qindex" href="group__bslscm.html">bslscm</a> | <a class="qindex" href="group__bslstl.html">bslstl</a> | <a class="qindex" href="group__bsltf.html">bsltf</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bsls_unspecifiedbool<br/>
<small>
[<a class="el" href="group__bsls.html">Package bsls</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a class supporting the <code>unspecified bool</code> idiom.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebsls.html">bsls</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Usage</a> <ul>
<li>
<a href="#3.1.1">Example 1: A Simple Smart Pointer</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a class supporting the <code>unspecified bool</code> idiom. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbsls_1_1UnspecifiedBool.html">bsls::UnspecifiedBool</a> </td><td>class template for the <code>unspecified bool</code> idiom.  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component should <em>not</em> be used outside of the <code>bsl</code> package at this time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class template that can be used to manufacture an "unspecified boolean type" that is distinct for each class that instantiates it. Note that classes supplying an implicit conversion to an unspecified bool type will be equality comparable (using <code>operator==</code> and <code>operator!=</code>) through this conversion. Private equality and inequality operators should be added to the class definition unless this comparison is desired. It is important that each class produces a distinct unspecified bool type, as otherwise objects of different class types would compare equal through this same conversion. Note that this component should become redundant when all of our compilers support "explicit conversion operators", a new feature of C++11. An <code>explicit operator bool()</code> conversion operator is superior to this C++98 idiom in all ways. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended use of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example_1"></a> <a class="anchor" id="usage.example_1"></a> <a class="anchor" id="description.usage.example_1"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Example 1: A Simple Smart Pointer: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A common requirement for "smart pointer" types is to emulate the native pointer types and, in particular, support testing for "null" or "empty" pointer values as a simple boolean conversion in <code>if</code> and <code>while</code> clauses. We here demonstrate how to create a simple smart pointer type, <code>SimplePtr</code>, using this component to implement a safe the boolean conversion. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>An object of type <code>SimplePtr</code> holds a pointer value, but does not claim ownership or any responsibility for the lifetime of the referenced object. A <code>SimplePtr</code> object acts as a "simple" native pointer. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we create the <code>SimplePtr</code> class, define its data members, creators and manipulators: <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE&gt;
  <span class="keyword">class </span>SimplePtr
  {
      <span class="comment">// This class holds a pointer to a single object, and provides a subset</span>
      <span class="comment">// of the regular pointer operators.  For example, objects of this</span>
      <span class="comment">// class can be dereferenced with &#39;operator*&#39; and tested as a boolean</span>
      <span class="comment">// value to determine if null.  Conversely, this class does not support</span>
      <span class="comment">// pointer arithmetic.</span>

    <span class="keyword">private</span>:
      <span class="comment">// DATA</span>
      TYPE *d_ptr_p;  <span class="comment">// address of the referenced object</span>

      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#aed5308d4f7d1542d6eeb8acedec974d3">operator==</a>(<span class="keyword">const</span> SimplePtr &amp;);  <span class="comment">// = delete;</span>
      <span class="keywordtype">bool</span> <a class="code" href="namespacebslalg.html#acf8107f12ec28380f11b968856544276">operator!=</a>(<span class="keyword">const</span> SimplePtr &amp;);  <span class="comment">// = delete;</span>
          <span class="comment">// Suppress equality comparison operations on objects of this</span>
          <span class="comment">// class.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      <span class="keyword">explicit</span> SimplePtr(TYPE *ptr = 0) : d_ptr_p(ptr) {}
          <span class="comment">// Create a &#39;SimplePtr&#39; having the value of the specified &#39;ptr&#39;.</span>

          <span class="comment">// Destroy this object.</span>

      <span class="comment">// ACCESSORS</span>
      TYPE&amp; operator*()<span class="keyword"> const  </span>{ <span class="keywordflow">return</span> *d_ptr_p; }
          <span class="comment">// Return a reference to the object pointed to by this</span>
          <span class="comment">// &#39;SimplePtr&#39;.</span>

      TYPE *operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> d_ptr_p; }
          <span class="comment">// Return the held &#39;d_ptr_p&#39;.</span>
</pre></div><br/>
<br/>
 Next, we define, for convenience, an alias for a unique type that is implicitly convertible to <code>bool</code> (note that we pass the current template instantiation to the <code><a class="el" href="classbsls_1_1UnspecifiedBool.html">bsls::UnspecifiedBool</a></code> template to guarantee a unique name, even for different instantiations of this same <code>SimplePtr</code> template): <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="comment">// TYPES</span>
  <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classbsls_1_1UnspecifiedBool.html#a6e61cdb775ce1e3cb46e1605b289254e">bsls::UnspecifiedBool&lt;SimplePtr&gt;::BoolType</a> BoolType;
</pre></div><br/>
<br/>
 Now, we can define a boolean conversion operator that tests whether or not this <code>SimplePtr</code> object is holding a null pointer, or a valid address: <br/>
<br/>
<div class="fragment"><pre class="fragment">      operator BoolType()<span class="keyword"> const </span>{
          <span class="keywordflow">return</span> <a class="code" href="classbsls_1_1UnspecifiedBool.html#a33b0aff3136e2ad716f5af7d6f7412b5">bsls::UnspecifiedBool&lt;SimplePtr&gt;::makeValue</a>(d_ptr_p);
      }
  }; <span class="comment">// class SimplePtr</span>
</pre></div><br/>
<br/>
 Note that we do not need to define <code>operator!</code> as this single boolean conversion operator is invoked with the correct semantics when the user tries that operator. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Finally, we write a simple test function, creating a couple of <code>SimplePtr</code> objects, one "null", and the other with a well-defined address. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">void</span> runTests() {
      SimplePtr&lt;int&gt; p1;  <span class="comment">// default ctor sets to null</span>
      assert(!p1);

      <span class="keywordtype">int</span>            i = 3;
      SimplePtr&lt;int&gt; p2(&amp;i);

      <span class="keywordflow">if</span> (p2) {
          assert(3 == *p2);
      }
  }
</pre></div><br/>
<br/>
 Notice that <code>SimplePtr</code> objects behave as native pointers. They should be tested before dereferencing (as they could be null). </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Mon Nov 12 2012 13:19:43 for BDE Release 2.16 Open Source "BETA" by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
