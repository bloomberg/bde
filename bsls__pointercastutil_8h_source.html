<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bsls_pointercastutil.h                                             -*-C++-*-
#ifndef INCLUDED_BSLS_POINTERCASTUTIL
#define INCLUDED_BSLS_POINTERCASTUTIL

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//#ifndef INCLUDED_BSLS_ASSERT
//#include &lt;bsls_assert.h&gt;
//#endif

//@PURPOSE: Provide function to cast between function and data pointers.
//
//@CLASSES:
//  bsls::PointerCastUtil: namespace for pointer-casting function
//
//@DESCRIPTION: This component, &#39;bsls::PointerCastUtil&#39;, provides a utility
// function to allow casting between function and data pointers without
// triggering compiler warnings.  Such casts are legal in the latest C++
// standard, but were not always so.
//
///Usage
//------
// This section illustrates intended use of this component.
//
///Example 1: Using a function pointer as a closure parameter
/// - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose there is an event-handling service that requires registration of a
// combination of object and closure value, and that invokes a method on the
// object, passing back the closure.
//
// First we define the service and its handler:
//..
//  struct Handler { virtual void handle(void *closure) = 0; };
//  class Service {
//      Handler *d_handler_p;
//      void    *d_closure_p;
//    public:
//      void registerHandler(Handler *handler, void *closure = 0) {
//          d_handler_p = handler;
//          d_closure_p = closure;
//      }
//      void eventOccurred() { d_handler_p-&gt;handle(d_closure_p); }
//  };
//..
// Then, we want to define a handler that will receive a function pointer as
// the closure object and invoke it.  In order to do that, we must cast it to a
// function pointer, but some compilers may not allow it.  We can use
// &#39;bsls::PointerCastUtil::cast&#39; to accomplish this:
//..
//  struct MyHandler : Handler {
//      void handle(void *closure) {
//           bsls::PointerCastUtil::cast&lt;void(*)()&gt;(closure)();
//      }
//  };
//..
// Next, we will set up a sample service and our handler function:
//..
//  Service aService;
//  static int counter = 0;
//  void event() { ++counter; }
//..
// Finally, we will register our handler and then trigger events to verify that
// our handler is recording them correctly.  To register the function pointer
// as a closure object, we must cast it to a data pointer.  Again, we can use
// &#39;bsls::PointerCastUtil::cast&#39; to accomplish this:
//..
//  MyHandler ah;
//  aService.registerHandler(&amp;ah, bsls::PointerCastUtil::cast&lt;void *&gt;(event));
//  aService.eventOccurred();
//  aService.eventOccurred();
//  assert(counter == 2);
//..

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

namespace BloombergLP {
namespace bsls {

                        //=======================
                        // struct PointerCastUtil
                        //=======================

struct PointerCastUtil {
    // This &#39;struct&#39; provides a namespace for a &#39;static&#39; utility function that
    // allows casting between function and data pointers.

    // CLASS METHODS
    template &lt;class TO, class FROM&gt;
    static TO cast(FROM from);
        // Return the specified &#39;from&#39; cast to type &#39;TO&#39;, casting it in two
        // steps, first to an integer type the size of a pointer and then to
        // the target type.  This function is intended to be used to cast
        // between function and data pointers, as doing such a cast directly
        // was once not legal.  The behavior is undefined if either the &#39;FROM&#39;
        // or &#39;TO&#39; types are larger than the intermediate integer type.
};

}  // close package namespace

template &lt;class TO, class FROM&gt;
inline
TO bsls::PointerCastUtil::cast(FROM from)
{
    //BSLS_ASSERT_SAFE(sizeof(bsls::Types::IntPtr) &gt;= sizeof(FROM));
    //BSLS_ASSERT_SAFE(sizeof(bsls::Types::IntPtr) &gt;= sizeof(TO));

    return reinterpret_cast&lt;TO&gt;(reinterpret_cast&lt;bsls::Types::IntPtr&gt;(from));
}

}  // close enterprise namespace
#endif

// ----------------------------------------------------------------------------
// Copyright 2016 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
