<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslstl_sharedptrallocateoutofplacerep.h                            -*-C++-*-
#ifndef INCLUDED_BSLSTL_SHAREDPTRALLOCATEOUTOFPLACEREP
#define INCLUDED_BSLSTL_SHAREDPTRALLOCATEOUTOFPLACEREP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id$ $CSID$&quot;)

//@PURPOSE: Provide an out-of-place implementation of &#39;bslma::SharedPtrRep&#39;.
//
//@CLASSES:
//  bslstl::SharedPtrAllocateOutofplaceRep: out-of-place &#39;shared_ptr&#39; imp.
//
//@SEE_ALSO: bslma_sharedptrrep, bslma_sharedptroutofplacerep, bslstl_sharedptr
//
//@DESCRIPTION: This component provides a class template,
// &#39;bslstl::SharedPtrAllocateOutofplaceRep&#39; , which is a concrete
// implementation of &#39;bslma::SharedPtrRep&#39; for managing objects of the
// parameterized &#39;TYPE&#39; that are stored outside of the representation.  When
// all references to the out-of-place object are released using &#39;releaseRef&#39;,
// the deleter of the parameterized &#39;DELETER&#39; type is invoked to delete the
// shared object.  Memory is supplied and reclaimed by an allocator of the
// parameterized &#39;ALLOCATOR&#39; type.
//
///Thread Safety
///-------------
// &#39;bslstl::SharedPtrAllocateOutofplaceRep&#39; is thread-safe provided that
// &#39;disposeObject&#39; and &#39;disposeRep&#39; are not called explicitly, meaning that all
// non-creator operations other than &#39;disposeObject&#39; and &#39;disposeRep&#39; on a
// given instance can be safely invoked simultaneously from multiple threads
// (&#39;disposeObject&#39; and &#39;disposeRep&#39; are meant to be invoked only by
// &#39;releaseRef&#39; and &#39;releaseWeakRef&#39;).  Note that there is no thread safety
// guarantees for operations on the managed object.
//
///Deleters
///--------
// When the last shared reference to a shared object is released, the object is
// destroyed using the &quot;deleter&quot; provided when the associated shared pointer
// representation was created.  &#39;bslstl::SharedPtrAllocateOutofplaceRep&#39;
// supports two kinds of &quot;deleter&quot; objects, which vary in how they are invoked.
// A &quot;function-like&quot; deleter is any language entity that can be invoked such
// that the expression &#39;deleterInstance(objectPtr)&#39; is a valid expression, and
// a &quot;factory&quot; deleter is any language entity that can be invoked such that the
// expression &#39;deleterInstance.deleteObject(objectPtr)&#39; is a valid expression,
// where &#39;deleterInstance&#39; is an instance of the &quot;deleter&quot; object, and
// &#39;objectPtr&#39; is a pointer to the shared object.  In summary:
//..
//  Deleter                     Expression used to destroy &#39;objectPtr&#39;
//  - - - - - - - -             - - - - - - - - - - - - - - - - - - -
//  &quot;function-like&quot;             deleterInstance(objectPtr);
//  &quot;factory&quot;                   deleterInstance.deleteObject(objectPtr);
//..
// The following are examples of function-like deleters that delete an object
// of &#39;MyType&#39;:
//..
//  void deleteObject(MyType *object);
//      // Delete the specified &#39;object&#39;.
//
//  void releaseObject(MyType *object);
//      // Release the specified &#39;object&#39;.
//
//  struct FunctionLikeDeleterObject {
//      // This &#39;struct&#39; provides an &#39;operator()&#39; that can be used to delete a
//      // &#39;MyType&#39; object.
//
//      void operator()(MyType *object);
//          // Destroy the specified &#39;object&#39;.
//  };
//..
// The following on the other hand is an example of a factory deleter:
//..
//  class MyFactory {
//
//     // . . .
//
//     // MANIPULATORS
//     MyType *createObject(bslma::Allocator *basicAllocator = 0);
//         // Create a &#39;MyType&#39; object.  Optionally specify a &#39;basicAllocator&#39;
//         // used to supply memory.  If &#39;basicAllocator&#39; is 0, the currently
//         // installed default allocator is used.
//
//     void deleteObject(MyType *object);
//         // Delete the specified &#39;object&#39;.
//  };
//..
// Note that &#39;deleteObject&#39; is provided by all &#39;bslma&#39; allocators and by any
// object that implements the &#39;bcema_Deleter&#39; protocol.  Thus, any of these
// objects can be used as a factory deleter.  The purpose of this design is to
// allow &#39;bslma&#39; allocators and factories to be used seamlessly as deleters.
//
// The selection of which expression is used by
// &#39;bslstl::SharedPtrAllocateOutofplaceRep&#39; to destroy a shared object is based
// on how the deleter is passed to the shared pointer object: Deleters that are
// passed by *address* are assumed to be factory deleters, while those that are
// passed by *value* are assumed to be function-like.  Note that if the wrong
// interface is used for a deleter, i.e., if a function-like deleter is passed
// by pointer, or a factory deleter is passed by value, and the expression used
// to delete the object is invalid, a compiler diagnostic will be emitted
// indicating the error.
//
///Usage
///-----
// The following example demonstrates how to implement a shared &#39;bdet_Datetime&#39;
// object using &#39;bslstl::SharedPtrAllocateOutofplaceRep&#39;:
//..
//  class MySharedDatetimePtr {
//      // This class provide a reference counted smart pointer to support
//      // shared ownership of a &#39;bdet_Datetime&#39; object.
//
//    private:
//      bdet_Datetime      *d_ptr_p;  // pointer to the managed object
//      bslma::SharedPtrRep *d_rep_p;  // pointer to the representation object
//
//    private:
//      // NOT IMPLEMENTED
//      MySharedDatetimePtr&amp; operator=(const MySharedDatetimePtr&amp;);
//
//    public:
//      // CREATORS
//      MySharedDatetimePtr(bdet_Datetime    *ptr,
//                          bslma::Allocator *basicAllocator = 0);
//          // Create a &#39;MySharedDatetimePtr&#39; object to managed the specified
//          // &#39;ptr&#39;.  Optionally specify an &#39;basicAllocator&#39; to allocate and
//          // deallocate the internal representation and to destroy &#39;ptr&#39; when
//          // all references have been released.  The behavior is undefined
//          // unless &#39;ptr&#39; was allocated using memory supplied by
//          // &#39;basicAllocator&#39;.
//
//      MySharedDatetimePtr(const MySharedDatetimePtr&amp; original);
//          // Create a shared datetime that refers to the same object managed
//          // by the specified &#39;original&#39;
//
//      ~MySharedDatetimePtr();
//          // Destroy this shared datetime and release the reference to the
//          // &#39;bdet_Datetime&#39; object to which it might be referring.  If this
//          // is the last shared reference, deleted the managed object.
//
//      // MANIPULATORS
//      bdet_Datetime&amp; operator*() const;
//          // Return a reference offering modifiable access to the shared
//          // datetime.
//
//      bdet_Datetime *operator-&gt;() const;
//          // Return the address of the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//
//      bdet_Datetime *ptr() const;
//          // Return the address of the modifiable &#39;bdet_Datetime&#39; to which
//          // this object refers.
//  };
//..
// Finally, we define the implementation.
//..
//  MySharedDatetimePtr::MySharedDatetimePtr(bdet_Datetime    *ptr,
//                                           bslma::Allocator *basicAllocator)
//  {
//      d_ptr_p = ptr;
//      d_rep_p = bslstl::SharedPtrAllocateOutofplaceRep&lt;bdet_Datetime,
//                                                       bslma::Allocator *&gt;::
//                      makeOutofplaceRep(ptr, basicAllocator, basicAllocator);
//  }
//
//  MySharedDatetimePtr::MySharedDatetimePtr(
//                                         const MySharedDatetimePtr&amp; original)
//  : d_ptr_p(original.d_ptr_p)
//  , d_rep_p(original.d_rep_p)
//  {
//      if (d_ptr_p) {
//          d_rep_p-&gt;acquireRef();
//      } else {
//          d_rep_p = 0;
//      }
//  }
//
//  MySharedDatetimePtr::~MySharedDatetimePtr()
//  {
//      if (d_rep_p) {
//          d_rep_p-&gt;releaseRef();
//      }
//  }
//
//  bdet_Datetime&amp; MySharedDatetimePtr::operator*() const {
//      return *d_ptr_p;
//  }
//
//  bdet_Datetime *MySharedDatetimePtr::operator-&gt;() const {
//      return d_ptr_p;
//  }
//
//  bdet_Datetime *MySharedDatetimePtr::ptr() const {
//      return d_ptr_p;
//  }
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATORTRAITS
#include &lt;bslstl_allocatortraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_SHAREDPTRREP
#include &lt;bslma_sharedptrrep.h&gt;
#endif

#ifndef INCLUDED_BSLS_UTIL
#include &lt;bsls_util.h&gt;
#endif

#ifndef INCLUDED_TYPEINFO
#include &lt;typeinfo&gt;
#define INCLUDED_TYPEINFO
#endif

namespace BloombergLP {
namespace bslstl {

                 // ====================================
                 // class SharedPtrAllocateOutofplaceRep
                 // ====================================

template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
class SharedPtrAllocateOutofplaceRep : public BloombergLP::bslma::SharedPtrRep
                                                                              {
    // This class provides a concrete implementation of the &#39;SharedPtrRep&#39;
    // protocol for out-of-place instances of the parameterized &#39;TYPE&#39;.  Upon
    // destruction of this object, the parameterized &#39;DELETER&#39; type is invoked
    // on the pointer to the shared object.

    // PRIVATE TYPES
    typedef bsl::allocator_traits&lt;ALLOCATOR&gt; OriginalTraits;

    typedef typename
         OriginalTraits::template rebind_traits&lt;SharedPtrAllocateOutofplaceRep&gt;
                                                               AllocatorTraits;
    typedef typename AllocatorTraits::allocator_type Allocator;

    // DATA
    TYPE      *d_ptr_p;     // pointer to out-of-place object (held, not owned)
    DELETER    d_deleter;   // deleter for this out-of-place instance
    Allocator  d_allocator; // copy of the allocator for this instance

  private:
    // NOT IMPLEMENTED
    SharedPtrAllocateOutofplaceRep(const SharedPtrAllocateOutofplaceRep&amp;);
    SharedPtrAllocateOutofplaceRep&amp; operator=(
                                        const SharedPtrAllocateOutofplaceRep&amp;);

    // PRIVATE CREATORS
    SharedPtrAllocateOutofplaceRep(TYPE             *ptr,
                                   const DELETER&amp;    deleter,
                                   const ALLOCATOR&amp;  basicAllocator);
        // Create a &#39;SharedPtrAllocateOutofplaceRep&#39; that manages the lifetime
        // of the specified &#39;ptr&#39;, using the specified &#39;deleter&#39; to destroy
        // &#39;ptr&#39;, and using the specified &#39;basicAllocator&#39; to supply memory.
        // Note that &#39;basicAllocator&#39; will be used to destroy this
        // representation object, but not necessarily to destroy &#39;ptr&#39;.  Also
        // note that a &#39;SharedPtrAllocateOutofplaceRep&#39; must be created using
        // &#39;makeOutofplaceRep&#39;, which will call the private constructor.

    ~SharedPtrAllocateOutofplaceRep();
        // Destroy this representation object and if the shared object has not
        // been deleted, delete the shared object using the associated deleter.
        // Note that this destructor is never called explicitly.  Instead,
        // &#39;disposeObject&#39; destroys the shared object and &#39;disposeRep&#39;
        // deallocates this representation object.

  public:
    // CLASS METHODS
    static SharedPtrAllocateOutofplaceRep *makeOutofplaceRep(
                                             TYPE             *ptr,
                                             const DELETER&amp;    deleter,
                                             const ALLOCATOR&amp;  basicAllocator);
        // Return the address of a newly created
        // &#39;SharedPtrAllocateOutofplaceRep&#39; object that manages the lifetime of
        // the specified &#39;ptr&#39;, uses the specified &#39;deleter&#39; to destroy &#39;ptr&#39;,
        // and uses the specified &#39;basicAllocator&#39; to supply memory.  Note that
        // the parameterized &#39;DELETER&#39; type will be used to deallocate the
        // memory pointed to by &#39;ptr&#39;.

    // MANIPULATORS
    virtual void disposeObject();
        // Destroy the object referred to by this representation.  This method
        // is invoked by &#39;releaseRef&#39; when the number of shared references
        // reaches zero and should not be explicitly invoked otherwise.

    virtual void disposeRep();
        // Destroy this representation object and deallocate the associated
        // memory.  This method is invoked by &#39;releaseRef&#39; and &#39;releaseWeakRef&#39;
        // when the number of weak references and the number of shared
        // references both reach zero and should not be explicitly invoked
        // otherwise.  The behavior is undefined unless &#39;disposeObject&#39; has
        // already been called for this representation.  Note that this method
        // effectively serves as the representation object&#39;s destructor.

    virtual void *getDeleter(const std::type_info&amp; type);
        // Return a pointer to the deleter stored by the derived representation
        // if the deleter has the same type as that described by the specified
        // &#39;type&#39;, and a null pointer otherwise.

    // ACCESSORS
    virtual void *originalPtr() const;
        // Return the (untyped) address of the modifiable shared object to
        // which this object refers.

    TYPE *ptr() const;
        // Return the address of the modifiable shared object to which this
        // object refers.
};

               // =================================================
               // struct SharedPtrAllocateOutofplaceRep_InitProctor
               // =================================================

template &lt;class TYPE, class DELETER&gt;
class SharedPtrAllocateOutofplaceRep_InitProctor {
    // This proctor is used for out-of-place shared pointer instantiations.
    // Generally, a proctor is created prior to constructing a
    // &#39;SharedPtrAllocateOutofplaceRep&#39; and released after successful
    // construction.  In the event that an exception is thrown during
    // construction of the representation, the proctor will delete the provided
    // pointer using the provided deleter.  Note that the provided deleter is
    // held by reference and must remain valid for the lifetime of the proctor.
    // If the proctor is not released before it&#39;s destruction, a copy of the
    // deleter is instantiated to delete the pointer (in case &#39;operator()&#39; is
    // non-&#39;const&#39;).  Also note that if the deleter throws during
    // copy construction, the provided pointer will not be destroyed.

    // DATA
    TYPE           *d_ptr_p;    // address of the managed object (held, not
                                // owned)

    const DELETER&amp;  d_deleter;  // deleter used to destroy managed object

  private:
    // NOT IMPLEMENTED
    SharedPtrAllocateOutofplaceRep_InitProctor(
                const SharedPtrAllocateOutofplaceRep_InitProctor&amp;); // = delete
    SharedPtrAllocateOutofplaceRep_InitProctor&amp; operator=(
                const SharedPtrAllocateOutofplaceRep_InitProctor&amp;); // = delete

  public:
    // CREATORS
    SharedPtrAllocateOutofplaceRep_InitProctor(TYPE           *ptr,
                                               const DELETER&amp;  deleter);
        // Create a proctor managing the specified &#39;ptr&#39; and using the
        // specified &#39;deleter&#39; to destroy &#39;ptr&#39; when the proctor is destroyed,
        // unless it has been released from management by a call to &#39;release&#39;.

    ~SharedPtrAllocateOutofplaceRep_InitProctor();
        // Destroy this proctor and the object (if any) managed by this
        // proctor.

    // MANIPULATORS
    void release();
        // Release from management the object referred to by this proctor.
};

// ============================================================================
//                           INLINE DEFINITIONS
// ============================================================================

                  // ------------------------------------
                  // class SharedPtrAllocateOutofplaceRep
                  // ------------------------------------

// PRIVATE CREATORS
template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
inline
SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt;::
SharedPtrAllocateOutofplaceRep(TYPE             *ptr,
                               const DELETER&amp;    deleter,
                               const ALLOCATOR&amp;  basicAllocator)
: d_ptr_p(ptr)
, d_deleter(deleter)
, d_allocator(basicAllocator)
{
}

template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
inline
SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt;::
~SharedPtrAllocateOutofplaceRep()
{
}

// CLASS METHODS
template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt; *
SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt;::makeOutofplaceRep(
                                              TYPE             *ptr,
                                              const DELETER&amp;    deleter,
                                              const ALLOCATOR&amp;  basicAllocator)
{
    SharedPtrAllocateOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt; proctor(ptr,
                                                                      deleter);

    Allocator alloc(basicAllocator);

    SharedPtrAllocateOutofplaceRep *rep = AllocatorTraits::allocate(alloc, 1);
    new (rep) SharedPtrAllocateOutofplaceRep(ptr, deleter, alloc);

    proctor.release();

    return rep;
}

// MANIPULATORS
template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
inline
void SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt;::disposeObject()
{
    d_deleter(d_ptr_p);
    d_ptr_p = 0;
}

template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
inline
void SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt;::disposeRep()
{
    Allocator alloc(d_allocator);
    this-&gt;~SharedPtrAllocateOutofplaceRep();
    AllocatorTraits::deallocate(alloc, this, 1);
}

template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
inline
void *
SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt;::getDeleter(
                                                    const std::type_info&amp; type)
{
    return typeid(d_deleter) == type
         ? bsls::Util::addressOf(d_deleter)
         : 0;
}

// ACCESSORS
template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
inline
void *
SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt;::originalPtr() const
{
    return const_cast&lt;void *&gt;(static_cast&lt;const void *&gt;(d_ptr_p));
}

template &lt;class TYPE, class DELETER, class ALLOCATOR&gt;
inline
TYPE *SharedPtrAllocateOutofplaceRep&lt;TYPE, DELETER, ALLOCATOR&gt;::ptr() const
{
    return d_ptr_p;
}

               // ------------------------------------------
               // SharedPtrAllocateOutofplaceRep_InitProctor
               // ------------------------------------------

// CREATORS
template &lt;class TYPE, class DELETER&gt;
inline
SharedPtrAllocateOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt;::
SharedPtrAllocateOutofplaceRep_InitProctor(TYPE           *ptr,
                                           const DELETER&amp;  deleter)
: d_ptr_p(ptr)
, d_deleter(deleter)
{
}

template &lt;class TYPE, class DELETER&gt;
inline
SharedPtrAllocateOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt;::
~SharedPtrAllocateOutofplaceRep_InitProctor()
{
    // The proctor must destroy &#39;d_ptr_p&#39; to avoid a leak, but is not subject
    // to the reference-counting of null pointers principle, where the deleter
    // is called on destroying the last reference, even if &#39;d_ptr_p&#39; is null.

    if (d_ptr_p) {
        d_deleter(d_ptr_p);
    }
}

// MANIPULATORS
template &lt;class TYPE, class DELETER&gt;
inline
void SharedPtrAllocateOutofplaceRep_InitProctor&lt;TYPE, DELETER&gt;::release()
{
    d_ptr_p = 0;
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
