<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bdlc_hashtable Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bdlc_hashtable<br/>
<small>
[<a class="el" href="group__bdlc.html">Package bdlc</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a double-hashed table with utility.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebdlc.html">bdlc</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Traditional Hash Algorithm</a> </li>
<li>
<a href="#3.2">Double-Hash Algorithm</a> </li>
<li>
<a href="#3.3">Bucket Type</a> </li>
<li>
<a href="#3.4">Traits</a> <ul>
<li>
<a href="#3.4.1">Default Traits</a> </li>
</ul>
</li>
<li>
<a href="#3.5">Hash Functors</a> <ul>
<li>
<a href="#3.5.1">Default Hash Functors</a> </li>
</ul>
</li>
<li>
<a href="#3.6">Disabling Support for <code>remove</code></a> </li>
<li>
<a href="#3.7">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a double-hashed table with utility. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a>  </td><td>double-hashed table  </td></tr>
<tr>
<td><a class="el" href="structbdlc_1_1HashTableDefaultTraits.html">bdlc::HashTableDefaultTraits</a>  </td><td>default traits  </td></tr>
<tr>
<td><a class="el" href="structbdlc_1_1HashTableDefaultHash1.html">bdlc::HashTableDefaultHash1</a>  </td><td>default hash functor 1  </td></tr>
<tr>
<td><a class="el" href="structbdlc_1_1HashTableDefaultHash2.html">bdlc::HashTableDefaultHash2</a>  </td><td>default hash functor 2  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bdlb__hashutil.html" title="Provide a utility of hash functions.">Component bdlb_hashutil</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a mechanism, <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code>, for efficiently finding elements identified by a parameterized <code>KEY</code>. Elements can also have an associated value by specifying an optional <code>VALUE</code> template parameter. Also, an optional <code>TRAITS</code> parameter can be supplied so that clients can override the default traits of the hash table, <code><a class="el" href="structbdlc_1_1HashTableDefaultTraits.html">bdlc::HashTableDefaultTraits</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> class achieves efficient lookup by using a double-hash algorithm, which will be explained later. Optional <code>HASH1</code> and <code>HASH2</code> parameters can be supplied so that clients can override the default hash functions used by the hash table, <code><a class="el" href="structbdlc_1_1HashTableDefaultHash1.html">bdlc::HashTableDefaultHash1</a></code> and <code><a class="el" href="structbdlc_1_1HashTableDefaultHash2.html">bdlc::HashTableDefaultHash2</a></code>. Hash functors may also optionally be specified at construction time, in case the functors contain state (e.g., if <code>bsl::function</code> is used). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The constructor for <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> takes a <code>capacityHint</code> argument. This <code>capacityHint</code> is used to calculate the capacity of the hash table (i.e., the maximum number of elements that can be stored at any one time). Once constructed, the capacity cannot be changed. The capacity hint can be either a positive integer or a negative integer. If the capacity hint is positive, then the capacity of the hash table will be the first available prime number larger than, or equal to, the capacity hint. Otherwise, the capacity of the hash table will be the first available prime number smaller than, or equal to, the capacity hint. The list of available prime numbers is obtained from an array in the <code>bdlc_hashtable.cpp</code> file. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="traditional_hash_algorithm"></a> <a class="anchor" id="description.traditional_hash_algorithm"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Traditional Hash Algorithm: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>A typical hash table implementation uses only a single hash function to determine the index in the hash table to store a given element. This approach results in constant time access if there are no collisions. To handle cases where there are hash collisions, the hash table needs to maintain a linked list or tree of elements for each index in the table. This data structure is illustrated in the diagram below: <br/>
<br/>
<div class="fragment"><pre class="fragment">               <a class="code" href="classBloombergLP_1_1bslh_1_1Hash.html">Hash</a> Table
               ----------

                :      :
                :      :
                :......:
                :      :
     index - 2  :      :
                :______:
                |      |
     index - 1  |      |
                |______|     ______      ______      ______
                |      |    |      |    |      |    |      |
      index     |      | -&gt; |      | -&gt; |      | -&gt; |      | -&gt; NULL
                |______|    |______|    |______|    |______|
                |      |
     index + 1  |      |    element1    element2    element3
                |______|
                |      |
     index + 2  |      |
                |______|
                :      :
                :      :
                :......:
                :      :
                :      :
</pre></div><br/>
<br/>
 In the diagram above, <code>element1</code>, <code>element2</code>, and <code>element3</code> hash to the <code>index</code>th bucket in the hash table. Because of this collision, they are maintained in a linked list, which results in linear time complexity. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="double-hash_algorithm"></a> <a class="anchor" id="description.double-hash_algorithm"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Double-Hash Algorithm: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The double-hash algorithm improves on the traditional algorithm by using a second hash function to compute an increment value. The index is incremented by the increment value until an available bucket is found. This augmented algorithm is illustrated in the following diagrams. Suppose we have a hash table that is initially empty: <br/>
<br/>
<div class="fragment"><pre class="fragment">                            <a class="code" href="classBloombergLP_1_1bslh_1_1Hash.html">Hash</a> Table
                            ----------

                             :      :
                             :      :
                             :......:
                             :      :
                  index - 2  :      :
                             :______:
                             |      |
                  index - 1  |      |
                             |______|
                             |      |
                   index     |      |
                             |______|
                             |      |
                  index + 1  |      |
                             |______|
                             |      |
                  index + 2  |      |
                             |______|
                             |      |
                  index + 3  |      |
                             |______|
                             :      :
                             :      :
                             :......:
                             :      :
                             :      :
</pre></div><br/>
<br/>
 Now suppose we insert <code>element1</code>. The first hash function evaluates to the <code>index</code>th bucket in the hash table: <br/>
<br/>
<div class="fragment"><pre class="fragment">                            <a class="code" href="classBloombergLP_1_1bslh_1_1Hash.html">Hash</a> Table
                            ----------

                             :      :
                             :      :
                             :......:
                             :      :
                  index - 2  :      :
                             :______:
                             |      |
                  index - 1  |      |
                             |______|     ______
                             |      |    |      |
                   index     |      | -&gt; |      |   element1
                             |______|    |______|
                             |      |
                  index + 1  |      |
                             |______|
                             |      |
                  index + 2  |      |
                             |______|
                             |      |
                  index + 3  |      |
                             |______|
                             :      :
                             :      :
                             :......:
                             :      :
                             :      :
</pre></div><br/>
<br/>
 Now suppose we want to insert <code>element2</code>, for which the first hash function also evaluates to the <code>index</code>th bucket in the hash table; however, there is a collision. So, we will calculate an increment using the second hash function. Suppose the increment value is 3, we will insert <code>element2</code> at <code>index + 3</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">                            <a class="code" href="classBloombergLP_1_1bslh_1_1Hash.html">Hash</a> Table
                            ----------

                             :      :
                             :      :
                             :......:
                             :      :
                  index - 2  :      :
                             :______:
                             |      |
                  index - 1  |      |
                             |______|     ______
                             |      |    |      |
            .----  index     |      | -&gt; |      |   element1
            |                |______|    |______|
            |                |      |
            |     index + 1  |      |
            |                |______|
            |                |      |
            |     index + 2  |      |
            |                |______|     ______
            |                |      |    |      |
            `---&gt; index + 3  |      | -&gt; |      |   element2
                             |______|    |______|
                             |      |
                  index + 4  |      |
                             |______|
                             |      |
                  index + 5  |      |
                             |______|
                             |      |
                  index + 6  |      |
                             |______|
                             |      |
                  index + 7  |      |
                             |______|
                             :      :
                             :      :
                             :......:
                             :      :
                             :      :
</pre></div><br/>
<br/>
 The entry for <code>element2</code> is said to be "chained" through node <code>index</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Now suppose we want to insert <code>element3</code>, for which the first hash function also evaluates to the <code>index</code>th bucket in the hash table. Again, there is a collision. So, we will calculate an increment using the second hash function. Suppose the increment value is 5, we will insert <code>element3</code> at <code>index + 5</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">                            <a class="code" href="classBloombergLP_1_1bslh_1_1Hash.html">Hash</a> Table
                            ----------

                             :      :
                             :      :
                             :......:
                             :      :
                  index - 2  :      :
                             :______:
                             |      |
                  index - 1  |      |
                             |______|     ______
                             |      |    |      |
      .-----.----  index     |      | -&gt; |      |   element1
      |     |                |______|    |______|
      |     |                |      |
      |     |     index + 1  |      |
      |     |                |______|
      |     |                |      |
      |     |     index + 2  |      |
      |     |                |______|     ______
      |     |                |      |    |      |
      |     `---&gt; index + 3  |      | -&gt; |      |   element2
      |                      |______|    |______|
      |                      |      |
      |           index + 4  |      |
      |                      |______|     ______
      |                      |      |    |      |
      `---------&gt; index + 5  |      | -&gt; |      |   element3
                             |______|    |______|
                             |      |
                  index + 6  |      |
                             |______|
                             |      |
                  index + 7  |      |
                             |______|
                             :      :
                             :      :
                             :......:
                             :      :
                             :      :
</pre></div><br/>
<br/>
 The entry for <code>element3</code> is also "chained" through node <code>index</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If there is a collision even after applying the increment, then the increment can be applied again to form a longer chain, until an available bucket is found. For example, suppose we want to insert <code>element4</code>, for which the first hash function evaluates to the <code>index</code>th bucket. Since there is a collision, we calculate an increment using the second hash function. Suppose the increment value is 3, we will get another collision because <code>element2</code> occupies the bucket at <code>index + 3</code>. Therefore, we apply the increment again and we get <code>index + 3 + 3</code>, i.e., <code>index + 6</code>. This bucket is empty, so we can store <code>element4</code> here: <br/>
<br/>
<div class="fragment"><pre class="fragment">                            <a class="code" href="classBloombergLP_1_1bslh_1_1Hash.html">Hash</a> Table
                            ----------

                             :      :
                             :      :
                             :......:
                             :      :
                  index - 2  :      :
                             :______:
                             |      |
                  index - 1  |      |
                             |______|     ______
                             |      |    |      |
      .-----.----  index     |      | -&gt; |      |   element1
      |     |                |______|    |______|
      |     |                |      |
      |     |     index + 1  |      |
      |     |                |______|
      |     |                |      |
      |     |     index + 2  |      |
      |     |                |______|     ______
      |     |                |      |    |      |
      |     `---&gt; index + 3  |      | -&gt; |      |   element2
      |     .----            |______|    |______|
      |     |                |      |
      |     |     index + 4  |      |
      |     |                |______|     ______
      |     |                |      |    |      |
      `-----+---&gt; index + 5  |      | -&gt; |      |   element3
            |                |______|    |______|
            |                |      |    |      |
            `---&gt; index + 6  |      | -&gt; |      |   element4
                             |______|    |______|
                             |      |
                  index + 7  |      |
                             |______|
                             :      :
                             :      :
                             :......:
                             :      :
                             :      :
</pre></div><br/>
<br/>
 The entry for <code>element4</code> is chained through nodes <code>index</code> and <code>index + 3</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>If the total number of buckets in the hash table and the increment value are relatively prime (i.e., their greatest common divisor is 1), then it is guaranteed that every bucket will be visited before looping back to <code>index</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> container makes sure that the number of buckets in the hash table and the increment values are relatively prime. The <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> container also keeps track of the maximum chain length, number of collisions, and the total chain length, which can be used for statistical purposes when evaluating different hash functions. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="bucket_type"></a> <a class="anchor" id="description.bucket_type"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Bucket Type: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> class treats individual buckets as value-semantic types. The type of the buckets depends on the <code>KEY</code> and <code>VALUE</code> parameters used to instantiate the <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> template. If the <code>VALUE</code> parameter is <code><a class="el" href="structbslmf_1_1Nil.html">bslmf::Nil</a></code>, then the type of the buckets is <code>KEY</code>. Otherwise, the type of the buckets is <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;KEY, VALUE&gt;</code>. For convenience, we will refer to the bucket type as <code>Bucket</code> throughout this documentation. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> class reserves two distinct values from <code>Bucket</code>s value-space to represent a "null" bucket and a "removed" bucket. These values are determined by the <code>TRAITS</code> parameter, which is described in the next section. Since these two values are reserved for the internal use of the <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> class, the behavior is undefined if one of these values is inserted into the hash table. Taking these values from the value-space of <code>Bucket</code> allows the storage space required for each bucket to be as compact as possible. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="traits"></a> <a class="anchor" id="description.traits"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Traits: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>An optional <code>TRAITS</code> parameter can be specified when instantiating the <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> template. This component provides a default traits implementation, <code><a class="el" href="structbdlc_1_1HashTableDefaultTraits.html">bdlc::HashTableDefaultTraits</a></code>, which will be described later. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>TRAITS</code> parameter allows clients to specify how to load a bucket and how to compare keys. It also allows clients to classify two distinct values to represent "null" and "removed" buckets (see "Bucket Type" for more information about these reserved values). </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following description, <code>key1</code> and <code>key2</code> refer to objects of type <code>KEY</code>. <code>bucket</code>, <code>dstBucket</code>, and <code>srcBucket</code> refer to objects of type <code>Bucket</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following expressions must be supported by the <code>TRAITS</code> parameter: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Expression                            Semantics
  ----------                            ---------
  TRAITS::load(&amp;dstBucket, srcBucket)   Load the value of the specified
                                        &#39;srcBucket&#39; into the specified
                                        &#39;dstBucket&#39;.

  TRAITS::areEqual(key1, key2)          Return true if the specified &#39;key1&#39;
                                        matches the specified &#39;key2&#39;, and
                                        false otherwise.

  TRAITS::<a class="code" href="namespacebdlat__NullableValueFunctions.html#aef3bd184c8665becb25bcfefe9c6d1cd">isNull</a>(bucket)                Return true if the specified &#39;bucket&#39;
                                        has the reserved &quot;null&quot; value, and
                                        false otherwise.

  TRAITS::setToNull(&amp;bucket)            Load the reserved &quot;null&quot; value into
                                        the specified &#39;bucket&#39;.

  TRAITS::isRemoved(bucket)             Return true if the specified &#39;bucket&#39;
                                        has the reserved &quot;removed&quot; value, and
                                        false otherwise.

  TRAITS::setToRemoved(&amp;bucket)         Load the reserved &quot;removed&quot; value
                                        into the specified &#39;bucket&#39;.
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="default_traits"></a> <a class="anchor" id="traits.default_traits"></a> <a class="anchor" id="description.traits.default_traits"></a> <a class="anchor" id="3.4.1"></a> </dd></dl>
<dl class="user"><dt><b>Default Traits: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default traits, identified by <code><a class="el" href="structbdlc_1_1HashTableDefaultTraits.html">bdlc::HashTableDefaultTraits</a></code>, can be used when <code>KEY</code> and <code>VALUE</code> are either: o <code>const char *</code> o <code>bsl::string</code> o POD types </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following expressions are implemented as: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Expression                                Implementation
  ----------                                --------------
  TRAITS::load(&amp;dstBucket, srcBucket)       This function is implemented as
                                            &#39;*dstBucket = srcBucket&#39;.

  TRAITS::areEqual(key1, key2)              If &#39;KEY&#39; is &#39;const <span class="keywordtype">char</span>*&#39;, this
                                            function is implemented as
                                            &#39;bsl::strcmp(key1, key2)&#39;.
                                            Otherwise, this function is
                                            implemented as &#39;key1 == key2&#39;.
</pre></div><br/>
<br/>
 The <code>isNull</code>, <code>setToNull</code>, <code>isRemoved</code>, and <code>setToRemoved</code> functions are implemented by checking for and assigning the appropriate "null" or "removed" values, respectively. These values are defined in the following table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Bucket <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a>        Null Value                    Removed Value
  -----------        ----------                    -------------
  <span class="keyword">const</span> <span class="keywordtype">char</span>*        0x00000000 address            0xFFFFFFFF address

  <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>        <span class="stringliteral">&quot;&quot;</span>                            <span class="stringliteral">&quot;(* REMOVED *)&quot;</span>

  All other types    All bytes in the footprint    All bytes in the footprint
                     are 0x00                      are 0xFF
</pre></div><br/>
<br/>
 If <code>Bucket</code> is of type <code><a class="el" href="classbsl_1_1pair.html">bsl::pair</a>&lt;KEY, VALUE&gt;</code>, then the "null" and "removed" values are applied to both the <code>KEY</code> and the <code>VALUE</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Since the default traits may write directly into the footprint of the bucket (except for <code>bsl::string</code>), it is important to note that the <code>KEY</code> and <code>VALUE</code> types should be POD types if the default traits are used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hash_functors"></a> <a class="anchor" id="description.hash_functors"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Hash Functors: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Optional <code>HASH1</code> and <code>HASH2</code> parameters can be specified when instantiating the <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> template. This component provides a default hash functors, <code><a class="el" href="structbdlc_1_1HashTableDefaultHash1.html">bdlc::HashTableDefaultHash1</a></code> and <code><a class="el" href="structbdlc_1_1HashTableDefaultHash2.html">bdlc::HashTableDefaultHash2</a></code>, which will be described later. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The <code>HASH1</code> and <code>HASH2</code> parameters allow clients to specify hash functor policies for the first and second hash functions, respectively. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following description, <code>key</code> refers to an object of type <code>KEY</code>, and <code>functor</code> refers to an immutable object of type <code>HASH1</code> or <code>HASH2</code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following expression must be supported by the supplied <code>HASH1</code> and <code>HASH2</code> parameters: <br/>
<br/>
<div class="fragment"><pre class="fragment">  Expression      Semantics                                      Return <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a>
  ----------      ---------                                      -----------
  functor(&amp;key)   Return a hash value for the specified &#39;key&#39;    <span class="keywordtype">unsigned</span> int
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="default_hash_functors"></a> <a class="anchor" id="hash_functors.default_hash_functors"></a> <a class="anchor" id="description.hash_functors.default_hash_functors"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Default Hash Functors: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The default hash functors, identified by <code><a class="el" href="structbdlc_1_1HashTableDefaultHash1.html">bdlc::HashTableDefaultHash1</a></code> and <code><a class="el" href="structbdlc_1_1HashTableDefaultHash2.html">bdlc::HashTableDefaultHash2</a></code>, can be used when <code>KEY</code> is either: <br/>
<br/>
<div class="fragment"><pre class="fragment">    o <span class="keyword">const</span> <span class="keywordtype">char</span>*
    o <a class="code" href="classbsl_1_1basic__string.html">bsl::string</a>
    o a POD type
</pre></div><br/>
<br/>
 The <code><a class="el" href="structbdlc_1_1HashTableDefaultHash1.html">bdlc::HashTableDefaultHash1</a></code> functor is implemented using <code><a class="el" href="structbdlb_1_1HashUtil.html#ae59c3a17456539f6423aa4552e39ee23">bdlb::HashUtil::hash1</a></code> and the <code><a class="el" href="structbdlc_1_1HashTableDefaultHash2.html">bdlc::HashTableDefaultHash2</a></code> functor is implemented using <code><a class="el" href="structbdlb_1_1HashUtil.html#ad9c25d1494d9bbb92059ef8b2a7b1cbb">bdlb::HashUtil::hash2</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Note that <code><a class="el" href="structbdlb_1_1HashUtil.html#ae59c3a17456539f6423aa4552e39ee23">bdlb::HashUtil::hash1</a></code> and <code><a class="el" href="structbdlb_1_1HashUtil.html#ad9c25d1494d9bbb92059ef8b2a7b1cbb">bdlb::HashUtil::hash2</a></code> calculate hash value from a fixed length block of memory. This block of memory is obtained based on the following table: <br/>
<br/>
<div class="fragment"><pre class="fragment">  KEY <a class="code" href="classBind__ImplSelector_1_1Type.html">Type</a>            Block Data                             Block Length
  --------            ----------                             ------------
  <span class="keyword">const</span> <span class="keywordtype">char</span>*         key                                    bsl::strlen(key)

  bsl::<span class="keywordtype">string</span>         key.data()                             key.length()

  All other types     reinterpret_cast&lt;const <span class="keywordtype">char</span> *&gt;(&amp;key)   sizeof(key)
</pre></div><br/>
<br/>
 Since the default hash functors use the footprint of the key (except for <code>const char*</code> and <code>bsl::string</code>) to compute hash values, it is important to note that the <code>KEY</code> type should be a POD type if the default hash functors are used. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="disabling_support_for_remove"></a> <a class="anchor" id="description.disabling_support_for_remove"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Disabling Support for remove: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>By default (i.e., when using the default traits), the <code>remove</code> method can be used to remove an element from the hash table. However, there are cases when it is desirable not to allow elements to be removed. This can be achieved by supplying the <code><a class="el" href="classbdlc_1_1HashTable.html">bdlc::HashTable</a></code> template with a <code>TRAITS</code> parameter that: <br/>
<br/>
<div class="fragment"><pre class="fragment">    o always returns <span class="keyword">false</span> <span class="keywordflow">for</span> the <span class="stringliteral">&#39;TRAITS::isRemoved(bucket)&#39;</span> expression
    o AND does not implemented the <span class="stringliteral">&#39;TRAITS::setToRemoved(&amp;bucket)&#39;</span> expression
</pre></div><br/>
<br/>
 This effectively describes a trait that does not define a special "removed" bucket value. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The following snippets of code illustrate the usage of this component. Suppose we wanted to store a table of <code>int</code> keys with <code>double</code> values. We will use a capacity hint of 10, default traits, and default hash functors for demonstration purposes: <br/>
<br/>
<div class="fragment"><pre class="fragment"><span class="preprocessor">  #include &lt;<a class="code" href="bdlc__hashtable_8h.html" title="Provide a double-hashed table with utility.">bdlc_hashtable.h</a>&gt;</span>

  <span class="keyword">using namespace </span>BloombergLP;

  <span class="keywordtype">void</span> usageExample()
  {
      <span class="keyword">typedef</span> <a class="code" href="classbdlc_1_1HashTable.html">bdlc::HashTable&lt;int, double&gt;</a> TableType;

      TableType table(10);
</pre></div><br/>
<br/>
 Now we can insert elements into this object: <br/>
<br/>
<div class="fragment"><pre class="fragment">      TableType::Handle handles[3];

      <span class="keyword">struct </span>{
          <span class="keywordtype">int</span>    d_key;
          <span class="keywordtype">double</span> d_value;
      } DATA[] = {
          {  10,   2.34   },
          {  92,   94.2   },
          { 236,   9.1    },
      };

      table.insert(&amp;handles[0], DATA[0].d_key, DATA[0].d_value);
      assert(DATA[0].d_key   == table.key(handles[0]));
      assert(DATA[0].d_value == table.value(handles[0]));

      table.insert(&amp;handles[1], DATA[1].d_key, DATA[1].d_value);
      assert(DATA[1].d_key   == table.key(handles[1]));
      assert(DATA[1].d_value == table.value(handles[1]));

      table.insert(&amp;handles[2], DATA[2].d_key, DATA[2].d_value);
      assert(DATA[2].d_key   == table.key(handles[2]));
      assert(DATA[2].d_value == table.value(handles[2]));
</pre></div><br/>
<br/>
 Now we can find elements in this object using the key: <br/>
<br/>
<div class="fragment"><pre class="fragment">      TableType::Handle otherHandles[3];

      table.find(&amp;otherHandles[0], DATA[0].d_key);
      assert(DATA[0].d_key   == table.key(otherHandles[0]));
      assert(DATA[0].d_value == table.value(otherHandles[0]));

      table.find(&amp;otherHandles[1], DATA[1].d_key);
      assert(DATA[1].d_key   == table.key(otherHandles[1]));
      assert(DATA[1].d_value == table.value(otherHandles[1]));

      table.find(&amp;otherHandles[2], DATA[2].d_key);
      assert(DATA[2].d_key   == table.key(otherHandles[2]));
      assert(DATA[2].d_value == table.value(otherHandles[2]));
  }
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:48:35 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
