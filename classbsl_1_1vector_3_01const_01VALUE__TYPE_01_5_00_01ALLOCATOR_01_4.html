<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class bsl::vector_3_01const_01VALUE_TYPE_01_5_00_01ALLOCATOR_01_4</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebsl.html">bsl</a>      </li>
      <li><a class="el" href="classbsl_1_1vector_3_01const_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.html">bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<h1>bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt; Class Template Reference<br/>
<small>
[<a class="el" href="group__bslstl__vector.html">Component bslstl_vector</a>]</small>
</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;" --><!-- doxytag: inherits="Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;" -->
<p><code>#include &lt;<a class="el" href="bslstl__vector_8h_source.html">bslstl_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classbsl_1_1vector_3_01const_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4.png" usemap="#bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;_map" alt=""/>
  <map id="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;_map" name="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;_map">
<area href="classbsl_1_1Vector__Imp.html" alt="bsl::Vector_Imp&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt;" shape="rect" coords="255,56,756,80"/>
<area href="classbsl_1_1Vector__ImpBase.html" alt="bsl::Vector_ImpBase&lt; const void * &gt;" shape="rect" coords="0,0,501,24"/>
<area href="classBloombergLP_1_1bslalg_1_1ContainerBase.html" alt="ContainerBase" shape="rect" coords="511,0,1012,24"/>
</map>
</div>

<p><a href="classbsl_1_1vector_3_01const_01VALUE__TYPE_01_5_00_01ALLOCATOR_01_4-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_reference&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE_TYPE **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE_TYPE *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5308963c5edb86c346bc1f14576a71ad">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const VALUE_TYPE *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3385240d8b8b8b1241daea914944818b">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga55b2f2ba3be58a312c86e829bea00079">allocator_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa982216c00abe2084c2c863dc0254511">pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ALLOCATOR::const_pointer&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga724824e0e6971c79b509b5a8151a9b36">const_pointer</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const void *&amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac6e8391c59e60b5a4dfd48e956f3b1c9">reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const void *const &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadb78a996fed8af2d5899cca9dd1a9bc9">const_reference</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga24d7c145ce94bf2f3ae8068569c143b8">iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const void *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga18f44f5ce10b93d15ea3def898eab913">const_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef std::ptrdiff_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga354535932a26dcc4a3021a0db40529ff">difference_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef const void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa738a4a015b0459014a402a11f434fa4">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga37a11cdffcc2935872a29b90a5b90f4b">reverse_iterator</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga973722bc781447a95bbe3bad22bee7cd">const_reverse_iterator</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga885f0a024872596f0edc7598433c9316">vector</a> (const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga75b47261356e66440a3f22326fca0c3c">vector</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> n, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga518a0bb8a9d0f20b087368c0ea100810">vector</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> n, const VALUE_TYPE *value, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadcc082b76fa6e1053a2f24b95cbbdb09">vector</a> (INPUT_ITER first, INPUT_ITER last, const ALLOCATOR &amp;alloc=ALLOCATOR())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5cc6a14692647bbb83dd82a866e33556">vector</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a> &amp;original)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf9cd6c1e661a3297a387f9dfc145e467">vector</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a> &amp;original, const ALLOCATOR &amp;alloc)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadd98de3e2f67da150e94b98fc065a179">~vector</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1vector.html">vector</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae93ec72d9ac8c3353f89b037de80eebf">operator=</a> (const <a class="el" href="classbsl_1_1vector.html">vector</a> &amp;rhs)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga80beed773775ff491a560d9827470983">assign</a> (INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga63ea4226486bf51bd44bc1c84ed81b60">assign</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> numElements, const VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1e9dc42f3178d710fe2c66a192508db1">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga3e6518351f9405fee2207027515573ab">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1d2c5620294830f3bd6f8481074424f3">rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2a3153ef2b2ca91c59a6fd0a90035e56">rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6f481f36ad2cc5f154ce79371f926511">operator[]</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf4a44098a0f50e69fad7cc01c408ba5e">at</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaae5378ea8aa29d554ed2dbc57854762b">front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga255da60d771bc40adc9602c63107d50e">back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE_TYPE **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae14419f8bfc1c405679399b295275811">data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga22024042f45a5f1566f956156d9cecb3">resize</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> newLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga2507559e3c1ed336d4bc988aa880afe4">resize</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> newLength, const VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad4b087bd66d82c406c68ec31a054ee4c">push_back</a> (const VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf0e738c92639f1b6a84145727982eacf">insert</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position, const VALUE_TYPE *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8142025bc027624b76dc97505310175c">insert</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position, <a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> numElements, const VALUE_TYPE *value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class INPUT_ITER &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae1ce3952d041389078ec3ee8450e8a54">insert</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga92ced92b9688f17e37023f8e95bfe130">erase</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga23ce96df781efd19791d63f1a07d78f6">erase</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> first, <a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga55b2f2ba3be58a312c86e829bea00079">allocator_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8f61cc68c2ce841df5d6a084d750dae3">get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5ee3d15eea6c4801e247f53e7b5c4e4c">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1e62a537951df42db9a85e01b1c509d6">cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab7d6db73f2b12880a2a9987bb1095350">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7a9a945d04de22e3cd264290a6d6e647">cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac0b64df8420c75db7c2927a7f6afc670">rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac8fe319720a2ef4788a2feea029c56f4">crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5dd4cfaacb1291b7cbb7eb05f82340d5">rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae1d17dce2e3f11f2a410513266227dc7">crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa491c401d912f10e4161f06aaa116482">operator[]</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga015e3fd3a1291374dbb98b1fc59ee96d">at</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> position) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4deef186a0f457ca404b26cc3b7cebb3">front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0630475bf0de545f5053bc23661a1b89">back</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const VALUE_TYPE *const *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac6feec182b2932d2c3d242eb16655bb7">data</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga142315e14e55d68bb9edf0c9c227feb0">assign</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> numElements, const const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac5203d4410a4c7c3d1d2014d5542e0d9">resize</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> newSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4fedf6842b169a88be67a5758b3aa229">resize</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> newSize, const const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac931be06971aedc190c1191a00ee251a">reserve</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> newCapacity)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf5dd77d0be1e77193b7289fc08e828ec">shrink_to_fit</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga332db0292e3c1107be19e02fd9f22299">emplace_back</a> (Args &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa1d6a35af66d87307ee9a48be96644a5">push_back</a> (const const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8fbe1d9aac697597bce2b527b8208003">pop_back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadeebf7a713dc053843dee059e23e9375">emplace</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position, Args &amp;&amp;...args)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaa856a23873fe4d5354e0d8b63f0b0659">insert</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position, const const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf28f2fa76a6acfe212d1dee103c2dafe">insert</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position, <a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> numElements, const const void *&amp;value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gadc116debf5b1eb8a37aa4d0bd85213b2">insert</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position, INPUT_ITER first, INPUT_ITER last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga8398ddeb0509741ce8734bc4eb5d5654">erase</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga840ceb3ecb6c53492e8a5b73fbe7501d">erase</a> (<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> first, <a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gac169aabe4c02a46527a12822254293ea">swap</a> (<a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae9fa4fec3242df3b8c6a70118726304d">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga66cf2ced34b3c15613d0ba2acc86f5c1">max_size</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga5b7f9c7b9b0be302ee1b7533b9764ef1">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0eb1a2336108dd9a87ba8682fe199837">begin</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga7eb9edf13eb71d39489477702fa09671">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4f6ee393ad3b6d9a72f13b15a95ea32a">end</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6080200616b755699e352155c7572d98">rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0dd4792a346dae5157c7f4a4f7ee25f9">rbegin</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gafe52ce718a880c32d4bd69ed3bc65d3b">rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga1f35ca07ac717fbc40e7cf3d755cc61f">rend</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaed1d2854dd5aaf5c0734202f5f43d42d">operator[]</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf92663fe0dfe8dd17097054a4c115626">operator[]</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> position) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gacd7de02bfa273ac7643909b55502e462">at</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> position)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf7db0521ebb67c49b5625972ebb0d944">at</a> (<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> position) const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga547e809dc68789a250cd367760601d78">front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gab884eb9fa93b6f6fb1e748978b6b7136">front</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad737a7196152ddb07b059506a070d149">back</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga813678ea2bee5b416ffaae85b1005dd2">back</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad98d192f5ea0af3ec3c6b5dabca1faa3">data</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const const void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gae6c1ea9e07542194c9bd652087e49974">data</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga0a53fc2c03dcc45dcba8fe6bf7298259">cbegin</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4a98f38e4458d7323fb526adf8c87da5">cend</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga259f561373a610c2accfdf2961596c7d">crbegin</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gaf7cd9b62a54f46268ef4d55c8358abbb">crend</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga6b5f3f3e0564b62536fd52679d99bdbd">size</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga22982ebdac58b9b9a89e339feeeb8eb6">capacity</a> () const</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gad77dd3f93b278367659e8d1489df4a86">empty</a> () const</td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbsl_1_1Vector__ImpBase.html#a6b6236ac7aa426aef856d09fe4aa30e2">d_dataBegin</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const void **&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#ga4270c95067ff340ec7469d1411e252ac">d_dataEnd</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::size_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__bslstl__vector.html#gabb717a1693d469a315711bddc394a404">d_capacity</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class VALUE_TYPE, class ALLOCATOR&gt;<br/>
 class bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;</h3>

<p>This partial specialization of <code>vector</code> for pointer types to a parameterized <code>const VALUE_TYPE</code> is implemented in terms of the <code><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt;const void *&gt;</code> to reduce the amount of code generated. Note that this specialization rebinds the parameterized <code>ALLOCATOR</code> type to an allocator of <code>const void *</code> so as to satisfy the invariant in <code><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a></code>. Also note that members which do not need to be redefined are inherited straightforwardly from the <code>Base</code>, although if an overloaded method needs to be redefined, then all its overloads need to be redefined. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="gac6e8391c59e60b5a4dfd48e956f3b1c9"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reference" ref="gac6e8391c59e60b5a4dfd48e956f3b1c9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const void * &amp; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gadb78a996fed8af2d5899cca9dd1a9bc9"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_reference" ref="gadb78a996fed8af2d5899cca9dd1a9bc9" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const void *  const&amp; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga24d7c145ce94bf2f3ae8068569c143b8"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::iterator" ref="ga24d7c145ce94bf2f3ae8068569c143b8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga18f44f5ce10b93d15ea3def898eab913"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_iterator" ref="ga18f44f5ce10b93d15ea3def898eab913" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const void *  const* <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gae247ca9f6b273a302bd925b3f0449c0d"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::size_type" ref="gae247ca9f6b273a302bd925b3f0449c0d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::size_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga354535932a26dcc4a3021a0db40529ff"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::difference_type" ref="ga354535932a26dcc4a3021a0db40529ff" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::ptrdiff_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga5308963c5edb86c346bc1f14576a71ad">difference_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa738a4a015b0459014a402a11f434fa4"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::value_type" ref="gaa738a4a015b0459014a402a11f434fa4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const void *  <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga3385240d8b8b8b1241daea914944818b">value_type</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga37a11cdffcc2935872a29b90a5b90f4b"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reverse_iterator" ref="ga37a11cdffcc2935872a29b90a5b90f4b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;<a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a>&gt; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">reverse_iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga973722bc781447a95bbe3bad22bee7cd"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::const_reverse_iterator" ref="ga973722bc781447a95bbe3bad22bee7cd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::reverse_iterator&lt;<a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a>&gt; <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ga142315e14e55d68bb9edf0c9c227feb0"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::assign" ref="ga142315e14e55d68bb9edf0c9c227feb0" args="(size_type numElements, const const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign to this vector the value of the vector of the specified <code>numElements</code> size whose every elements equal the specified <code>value</code>. This vector is left in an empty state in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. Note that this method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac5203d4410a4c7c3d1d2014d5542e0d9"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::resize" ref="gac5203d4410a4c7c3d1d2014d5542e0d9" args="(size_type newSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newSize</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ga4fedf6842b169a88be67a5758b3aa229"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::resize" ref="ga4fedf6842b169a88be67a5758b3aa229" args="(size_type newSize, const const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the size of this vector to the specified <code>newSize</code>, erasing elements at the end if <code>newSize &lt; <a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a></code> or appending the appropriate number of copies of the optionally specified <code>value</code> at the end if <code><a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a> &lt; newSize</code>. If <code>value</code> is not specified, a default-constructed value is used. Throw <code>std::length_error</code> if <code>newSize &gt; max_size()</code>. Note that this method requires that the (template parameter) type <code>VALUE_TYPE</code> be "copy-constructible" if <code>value</code> is specified and "default-constructible" otherwise (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gac931be06971aedc190c1191a00ee251a"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::reserve" ref="gac931be06971aedc190c1191a00ee251a" args="(size_type newCapacity)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::reserve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>newCapacity</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Change the capacity of this vector to the specified <code>newCapacity</code>. Note that the capacity of a vector is the maximum number of elements it can accommodate without reallocation. The actual storage allocated may be higher. </p>

</div>
</div>
<a class="anchor" id="gaf5dd77d0be1e77193b7289fc08e828ec"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::shrink_to_fit" ref="gaf5dd77d0be1e77193b7289fc08e828ec" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::shrink_to_fit </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reduce the capacity of this vector to its size. The method has no effect if the capacity is equivalent to the size. </p>

</div>
</div>
<a class="anchor" id="ga332db0292e3c1107be19e02fd9f22299"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::emplace_back" ref="ga332db0292e3c1107be19e02fd9f22299" args="(Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::emplace_back </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a new element to the end of this vector, constructed directly in place from the specified <code>args</code>. The <code>args</code> are passed to the constructor using "perfect forwarding", meaning move semantics will be utilized for rvalued elements that implement them. The combination of constructing in place and "perfect forwarding" means that when move semantics are available, elements in <code>args</code> will not be copied at all. When move semantics are not available, elements in <code>args</code> will be copied only once. This method provides the strong exception safety guarantee, so the state of this object will not be changed if an exception is thrown (such as when allocating memory, or from operations of <code>VALUE_TYPE</code>). </p>

</div>
</div>
<a class="anchor" id="gaa1d6a35af66d87307ee9a48be96644a5"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::push_back" ref="gaa1d6a35af66d87307ee9a48be96644a5" args="(const const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append a copy of the specified <code>value</code> at the end of this vector. This method provides the strong exception safety guarantee, so the state of this object will not be changed if an exception is thrown (such as when allocating memory, or from operations of <code>VALUE_TYPE</code>). Note that this method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8fbe1d9aac697597bce2b527b8208003"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::pop_back" ref="ga8fbe1d9aac697597bce2b527b8208003" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::pop_back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Erase the last element from this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gadeebf7a713dc053843dee059e23e9375"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::emplace" ref="gadeebf7a713dc053843dee059e23e9375" args="(const_iterator position, Args &amp;&amp;...args)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * * <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&nbsp;</td>
          <td class="paramname"> <em>args</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="gaa856a23873fe4d5354e0d8b63f0b0659"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gaa856a23873fe4d5354e0d8b63f0b0659" args="(const_iterator position, const const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a> <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector a copy of the specified <code>value</code>, and return an iterator pointing to the newly inserted element. If <code>value</code> has move semantics, then its value is valid but unspecified upon returning from this function. This method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[begin() .. end()]</code> (both endpoints included). Note that this method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gaf28f2fa76a6acfe212d1dee103c2dafe"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gaf28f2fa76a6acfe212d1dee103c2dafe" args="(const_iterator position, size_type numElements, const const void *&amp;value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga2954bfae57cec2922d80838c055258cc">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>numElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const const void *  &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector a number equal to the specified <code>numElements</code> of copies of the specified <code>value</code>. This method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[begin() .. end()]</code> (both endpoints included). Note that this method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="gadc116debf5b1eb8a37aa4d0bd85213b2"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::insert" ref="gadc116debf5b1eb8a37aa4d0bd85213b2" args="(const_iterator position, INPUT_ITER first, INPUT_ITER last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITER&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Insert at the specified <code>position</code> in this vector the values in the range starting at the specified <code>first</code> and ending immediately before the specified <code>last</code> iterators of the parameterized <code>INPUT_ITER</code> type. This method offers full guarantee of rollback in case an exception is thrown other than by the <code>VALUE_TYPE</code> copy constructor or assignment operator. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[begin() .. end()]</code> (both endpoints included), and <code>first</code> and <code>last</code> refer to a sequence of valid values where <code>first</code> is at a position at or before <code>last</code>. Note that this method requires that the (template parameter) type <code>VALUE_TYPE</code> be <a href="group__bslstl__vector.html#requirements_on_value_type.copy-constructible" class="glossary">copy-constructible</a> (see <a href="group__bslstl__vector.html#requirements_on_value_type" class="el">Requirements on <code>VALUE_TYPE</code></a>). </p>

</div>
</div>
<a class="anchor" id="ga8398ddeb0509741ce8734bc4eb5d5654"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::erase" ref="ga8398ddeb0509741ce8734bc4eb5d5654" args="(const_iterator position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a> <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this vector the element at the specified <code>position</code>, and return an iterator pointing to the element immediately following the removed element, or to the position returned by the <code>end</code> method if the removed element was the last in the sequence. The behavior is undefined unless <code>position</code> is an iterator in the range <code>[begin() .. end())</code>. </p>

</div>
</div>
<a class="anchor" id="ga840ceb3ecb6c53492e8a5b73fbe7501d"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::erase" ref="ga840ceb3ecb6c53492e8a5b73fbe7501d" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a> <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#ga0cd0846f3e77c27d31e494f6983c6d2a">const_iterator</a>&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove from this vector the elements starting at the specified <code>first</code> position that are before the specified <code>last</code> position, and return an iterator pointing to the element immediately following the last removed element, or the position returned by the method <code>end</code> if the removed elements were last in the sequence. The behavior is undefined unless <code>first</code> is an iterator in the range <code>[begin() .. end()]</code> and <code>last</code> is an iterator in the range <code>[first .. end()]</code> (both endpoints included). </p>

</div>
</div>
<a class="anchor" id="gac169aabe4c02a46527a12822254293ea"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::swap" ref="gac169aabe4c02a46527a12822254293ea" args="(Vector_Imp &amp;other)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1Vector__Imp.html">Vector_Imp</a>&lt; const void *, ALLOCATOR::template rebind&lt; const void * &gt;::other &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Exchange the value of this vector with that of the specified <code>other</code> vector, such that each vector has, upon return, the value of the other vector prior to this call. This method does not throw or invalidate iterators if <code>get_allocator</code>, invoked on this vector and <code>other</code>, returns the same value. </p>

</div>
</div>
<a class="anchor" id="gae9fa4fec3242df3b8c6a70118726304d"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::clear" ref="gae9fa4fec3242df3b8c6a70118726304d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove all the elements from this vector. Note that this vector is empty after this call, but preserves the same capacity. </p>

</div>
</div>
<a class="anchor" id="ga66cf2ced34b3c15613d0ba2acc86f5c1"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::max_size" ref="ga66cf2ced34b3c15613d0ba2acc86f5c1" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> <a class="el" href="classbsl_1_1Vector__Imp.html">bsl::Vector_Imp</a>&lt; const void * , ALLOCATOR &gt;::max_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the maximum possible size for this vector. Note that requests to create a vector longer than this number of elements are guaranteed to raise a <code>std::length_error</code> exception. </p>

</div>
</div>
<a class="anchor" id="ga5b7f9c7b9b0be302ee1b7533b9764ef1"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::begin" ref="ga5b7f9c7b9b0be302ee1b7533b9764ef1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga0eb1a2336108dd9a87ba8682fe199837"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::begin" ref="ga0eb1a2336108dd9a87ba8682fe199837" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this non-modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga7eb9edf13eb71d39489477702fa09671"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::end" ref="ga7eb9edf13eb71d39489477702fa09671" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga4291d2e6fef9b494c54cc6083d659ca0">iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga4f6ee393ad3b6d9a72f13b15a95ea32a"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::end" ref="ga4f6ee393ad3b6d9a72f13b15a95ea32a" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga6080200616b755699e352155c7572d98"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rbegin" ref="ga6080200616b755699e352155c7572d98" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga0dd4792a346dae5157c7f4a4f7ee25f9"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rbegin" ref="ga0dd4792a346dae5157c7f4a4f7ee25f9" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this non-modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="gafe52ce718a880c32d4bd69ed3bc65d3b"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rend" ref="gafe52ce718a880c32d4bd69ed3bc65d3b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga2d96c143e028e4314212bdba9ef9ef8a">reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga1f35ca07ac717fbc40e7cf3d755cc61f"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::rend" ref="ga1f35ca07ac717fbc40e7cf3d755cc61f" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="gaed1d2854dd5aaf5c0734202f5f43d42d"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator[]" ref="gaed1d2854dd5aaf5c0734202f5f43d42d" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>position</code> in this vector. The behavior is undefined unless <code>0 &lt;= position &lt; <a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gaf92663fe0dfe8dd17097054a4c115626"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::operator[]" ref="gaf92663fe0dfe8dd17097054a4c115626" args="(size_type position) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>position</code> in this vector. The behavior is undefined unless <code>0 &lt;= position &lt; <a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gacd7de02bfa273ac7643909b55502e462"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::at" ref="gacd7de02bfa273ac7643909b55502e462" args="(size_type position)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the specified <code>position</code> in this vector. Throws <code>std::out_of_range</code> if <code>position &gt;= <a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="gaf7db0521ebb67c49b5625972ebb0d944"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::at" ref="gaf7db0521ebb67c49b5625972ebb0d944" args="(size_type position) const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__bslstl__vector.html#gae247ca9f6b273a302bd925b3f0449c0d">size_type</a>&nbsp;</td>
          <td class="paramname"> <em>position</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the specified <code>position</code>. Throws <code>std::out_of_range</code> if <code>position &gt;= <a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a></code>. </p>

</div>
</div>
<a class="anchor" id="ga547e809dc68789a250cd367760601d78"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::front" ref="ga547e809dc68789a250cd367760601d78" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the first position in this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gab884eb9fa93b6f6fb1e748978b6b7136"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::front" ref="gab884eb9fa93b6f6fb1e748978b6b7136" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the first position in this vector. The behavior is undefined if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gad737a7196152ddb07b059506a070d149"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::back" ref="gad737a7196152ddb07b059506a070d149" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga49f23f56e64250ad863d15193ada7d3e">reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the modifiable element at the last position in this vector. The behavior is undefined if this vector is empty. Note that the last position is <code><a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a> - 1</code>. </p>

</div>
</div>
<a class="anchor" id="ga813678ea2bee5b416ffaae85b1005dd2"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::back" ref="ga813678ea2bee5b416ffaae85b1005dd2" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga74c04a33092057079255ade18163ded6">const_reference</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reference to the non-modifiable element at the last position in this vector. The behavior is undefined if this vector is empty. Note that the last position is <code><a class="el" href="namespacebdlat__ArrayFunctions.html#a65e1cfba76b2d13054b61159488b0da8">size()</a> - 1</code>. </p>

</div>
</div>
<a class="anchor" id="gad98d192f5ea0af3ec3c6b5dabca1faa3"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::data" ref="gad98d192f5ea0af3ec3c6b5dabca1faa3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the modifiable first element in this vector, or a valid, but non-dereferenceable pointer value if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="gae6c1ea9e07542194c9bd652087e49974"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::data" ref="gae6c1ea9e07542194c9bd652087e49974" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const const void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the non-modifiable first element in this vector, or a valid, but non-dereferenceable pointer value if this vector is empty. </p>

</div>
</div>
<a class="anchor" id="ga0a53fc2c03dcc45dcba8fe6bf7298259"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::cbegin" ref="ga0a53fc2c03dcc45dcba8fe6bf7298259" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return an iterator pointing the first element in this non-modifiable vector (or the past-the-end iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="ga4a98f38e4458d7323fb526adf8c87da5"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::cend" ref="ga4a98f38e4458d7323fb526adf8c87da5" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#ga67e0e0b7f2336c267c4884e8c340c156">const_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::cend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga259f561373a610c2accfdf2961596c7d"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::crbegin" ref="ga259f561373a610c2accfdf2961596c7d" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a reverse iterator pointing the last element in this non-modifiable vector (or the past-the-end reverse iterator if this vector is empty). </p>

</div>
</div>
<a class="anchor" id="gaf7cd9b62a54f46268ef4d55c8358abbb"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::crend" ref="gaf7cd9b62a54f46268ef4d55c8358abbb" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gaa1210066404446c90e43dc1b7ca1a94d">const_reverse_iterator</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::crend </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the past-the-end reverse iterator for this non-modifiable vector. </p>

</div>
</div>
<a class="anchor" id="ga6b5f3f3e0564b62536fd52679d99bdbd"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::size" ref="ga6b5f3f3e0564b62536fd52679d99bdbd" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of elements in this vector. </p>

</div>
</div>
<a class="anchor" id="ga22982ebdac58b9b9a89e339feeeb8eb6"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::capacity" ref="ga22982ebdac58b9b9a89e339feeeb8eb6" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__bslstl__vector.html#gae4813c4ee19eb083b1a358ea9238fe54">size_type</a> <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::capacity </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the capacity of this vector, i.e., the maximum number of elements for which resizing is guaranteed not to trigger a reallocation. </p>

</div>
</div>
<a class="anchor" id="gad77dd3f93b278367659e8d1489df4a86"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::empty" ref="gad77dd3f93b278367659e8d1489df4a86" args="() const" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return <code>true</code> if this vector has size 0, and <code>false</code> otherwise. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a6b6236ac7aa426aef856d09fe4aa30e2"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::d_dataBegin" ref="a6b6236ac7aa426aef856d09fe4aa30e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="classbsl_1_1Vector__ImpBase.html#a6b6236ac7aa426aef856d09fe4aa30e2">d_dataBegin</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>beginning of data storage (owned) </p>

</div>
</div>
<a class="anchor" id="ga4270c95067ff340ec7469d1411e252ac"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::d_dataEnd" ref="ga4270c95067ff340ec7469d1411e252ac" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * * <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#ga4270c95067ff340ec7469d1411e252ac">d_dataEnd</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>end of data storage (owned) </p>

</div>
</div>
<a class="anchor" id="gabb717a1693d469a315711bddc394a404"></a><!-- doxytag: member="bsl::vector&lt; const VALUE_TYPE *, ALLOCATOR &gt;::d_capacity" ref="gabb717a1693d469a315711bddc394a404" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classbsl_1_1Vector__ImpBase.html">bsl::Vector_ImpBase</a>&lt; const void *  &gt;::<a class="el" href="group__bslstl__vector.html#gabb717a1693d469a315711bddc394a404">d_capacity</a><code> [protected, inherited]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>length of storage </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="bslstl__vector_8h_source.html">bslstl_vector.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:50:48 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
