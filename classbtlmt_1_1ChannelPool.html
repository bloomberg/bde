<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: Class btlmt::ChannelPool</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><a class="el" href="namespacebtlmt.html">btlmt</a>      </li>
      <li><a class="el" href="classbtlmt_1_1ChannelPool.html">btlmt::ChannelPool</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>btlmt::ChannelPool Class Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="btlmt::ChannelPool" -->
<p><code>#include &lt;<a class="el" href="btlmt__channelpool_8h_source.html">btlmt_channelpool.h</a>&gt;</code></p>

<p><a href="classbtlmt_1_1ChannelPool-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbtlmt_1_1ChannelPool_1_1HandleInfo.html">HandleInfo</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535">ChannelEvents</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535aeebb10f21cc65b2e7c390ca18b31f9e5">e_CHANNEL_DOWN</a> =  0, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535a9460b8d5bd520645793671563f8d25be">e_CHANNEL_UP</a> =  1, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535a77f9fc7960966f305b45851bfdbf3641">e_READ_TIMEOUT</a> =  2, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535a9f8facfd241223128925d07712ed0fac">e_WRITE_BUFFER_FULL</a> =  3, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535a2d9cd75dfdec0db70424245fadfc077c">e_MESSAGE_DISCARDED</a> =  4, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535af82082154c0d2b27ee63095ec65d5f86">e_AUTO_READ_ENABLED</a> =  5, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535ad84ad4636d10c47e596dcc338a96487a">e_AUTO_READ_DISABLED</a> =  6, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535a183534129dcca5f18aa2f8034ea9c757">e_WRITE_QUEUE_LOWWATER</a> =  7, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535ac7da0cd3550293ee96eeae5247adcc60">e_WRITE_QUEUE_HIGHWATER</a> =  e_WRITE_BUFFER_FULL, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535ab0e630dca3239de13535216041709412">e_CHANNEL_DOWN_READ</a> =  8, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535ac2afdf1b80d09419b8abb7667bd37566">e_CHANNEL_DOWN_WRITE</a> =  9
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31e">PoolEvents</a> { <br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31eaa9e820743133a0f1dd1f13fe941b2876">e_ACCEPT_TIMEOUT</a> =  0, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31eaddf1065fd39f19a27e1bc852b709063b">e_ERROR_ACCEPTING</a>, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31ea65f110cedc2dd7b5a7c0dd731f4d0acc">e_ERROR_CONNECTING</a>, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31ea878ea29a7b248b6fd25c26e6479e0f4c">e_CHANNEL_LIMIT</a>, 
<br/>
&nbsp;&nbsp;<a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31ea2bf15bca6c3a5d3c71dd211a56167fb1">e_CAPACITY_LIMIT</a>, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31ea644a10c2703de1835d223b2f2b21b1e1">e_ERROR_BINDING_CLIENT_ADDR</a>, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31eaf6568d93983548363d70d2bba4a1bccf">e_ERROR_SETTING_OPTIONS</a>, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31ea80b9783734fa1f37397e9ee59dd9da67">e_EVENT_MANAGER_LIMIT</a>
<br/>
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aa41bfed959e462a98e0fea16d78278cc">ConnectResolutionMode</a> { <a class="el" href="classbtlmt_1_1ChannelPool.html#aa41bfed959e462a98e0fea16d78278cca72260ef4034cc8919f54e3261f7ba99d">e_RESOLVE_ONCE</a> =  0, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#aa41bfed959e462a98e0fea16d78278ccadf93bd65fba9b9abaa6c74b5ece79f13">e_RESOLVE_AT_EACH_ATTEMPT</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a> { <a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4a161648c9d2d2f4350a3d73b85f0a41b8">e_CLOSE_BOTH</a> =  0, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4affac1e0b0ea63a9b9f9e9a0a3034b99f">e_KEEP_HALF_OPEN</a> =  1
 }</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7">ShutdownMode</a> { <a class="el" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7a5ff8d9de035666225fde25a0ff36c97d">e_IMMEDIATE</a> =  0
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>Mode affecting how channel is terminated, passed to <code>shutdown</code>. </p>
 <a href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aa67470585402993b7e6ef5b407b1fe27">Severity</a> { <a class="el" href="classbtlmt_1_1ChannelPool.html#aa67470585402993b7e6ef5b407b1fe27a67a9bc0318d9053059c8e2e4a308f2d2">e_CRITICAL</a> =  0, 
<a class="el" href="classbtlmt_1_1ChannelPool.html#aa67470585402993b7e6ef5b407b1fe27a6c1c5328d9f508f842b10a2a80e5ceda">e_ALERT</a> =  1
 }</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight"><p>This enumeration provides names for different levels of severity. </p>
 <a href="classbtlmt_1_1ChannelPool.html#aa67470585402993b7e6ef5b407b1fe27">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int, <br class="typebreak"/>
int, int, void *)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a8007511e7782b66c18acf73c835e9ec4">ChannelStateChangeCallback</a> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int <br class="typebreak"/>
*, <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> *, int, void *)&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a530247348e3453328b7ee5d1a4971472">BlobBasedReadCallback</a> )</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef bsl::function&lt; void(int, <br class="typebreak"/>
int, int)&gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a6af6150b550904dd0b5601241796814e">PoolStateChangeCallback</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a84755eeb37002defe30d08c4e9043d56">ChannelPool</a> (<a class="el" href="classbtlmt_1_1ChannelPool.html#a8007511e7782b66c18acf73c835e9ec4">ChannelStateChangeCallback</a> channelStateCb, <a class="el" href="classbtlmt_1_1ChannelPool.html#a530247348e3453328b7ee5d1a4971472">BlobBasedReadCallback</a> blobBasedReadCb, <a class="el" href="classbtlmt_1_1ChannelPool.html#a6af6150b550904dd0b5601241796814e">PoolStateChangeCallback</a> poolStateCb, const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;parameters, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a64242764af079c6e98772eebfafeda51">ChannelPool</a> (<a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> *blobBufferFactory, <a class="el" href="classbtlmt_1_1ChannelPool.html#a8007511e7782b66c18acf73c835e9ec4">ChannelStateChangeCallback</a> channelStateCb, <a class="el" href="classbtlmt_1_1ChannelPool.html#a530247348e3453328b7ee5d1a4971472">BlobBasedReadCallback</a> blobBasedReadCb, <a class="el" href="classbtlmt_1_1ChannelPool.html#a6af6150b550904dd0b5601241796814e">PoolStateChangeCallback</a> poolStateCb, const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;parameters, <a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *basicAllocator=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ad5ca20be55e579eaf3013f0cfea578ce">~ChannelPool</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a0ed269ffcb4b9b67aadb0f8e5f92db6d">close</a> (int serverId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a44970e8107c1822208af590197b6f7b2">listen</a> (int portNumber, int backlog, int serverId, int reuseAddress=1, bool readEnabledFlag=true, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#adf2e646a1d32343b7a5ae91da4924ed2">listen</a> (int portNumber, int backlog, int serverId, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int reuseAddress=1, bool readEnabledFlag=true, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a7d00c38828f14287509f354cb19bd39b">listen</a> (const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;endpoint, int backlog, int serverId, int reuseAddress=1, bool readEnabledFlag=true, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aa4e5c7815ad108b554b24b4805252536">listen</a> (const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;endpoint, int backlog, int serverId, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;timeout, int reuseAddress=1, bool readEnabledFlag=true, <a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a> mode=e_CLOSE_BOTH, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aa17434163d2e35820d4ea7bb1d253e8a">connect</a> (const char *hostname, int portNumber, int numAttempts, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, int sourceId, <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *socket, <a class="el" href="classbtlmt_1_1ChannelPool.html#aa41bfed959e462a98e0fea16d78278cc">ConnectResolutionMode</a> resolutionMode=e_RESOLVE_ONCE, bool readEnabledFlag=true, <a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a> halfCloseMode=e_CLOSE_BOTH)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a07d4acf688d6899ca85a314be2b77655">connect</a> (const char *hostname, int portNumber, int numAttempts, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, int sourceId, <a class="el" href="classbtlmt_1_1ChannelPool.html#aa41bfed959e462a98e0fea16d78278cc">ConnectResolutionMode</a> resolutionMode=e_RESOLVE_ONCE, bool readEnabledFlag=true, <a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a> halfCloseMode=e_CLOSE_BOTH, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0, const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *localAddress=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a982df83f9ee81bbe77c694f2f44eb77b">connect</a> (const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;serverAddress, int numAttempts, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, int sourceId, <a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *socket, bool readEnabledFlag=true, <a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a> mode=e_CLOSE_BOTH)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a3592723feee45fbb878a5c861e69e6bb">connect</a> (const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;serverAddress, int numAttempts, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;interval, int sourceId, bool readEnabledFlag=true, <a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a> mode=e_CLOSE_BOTH, const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *socketOptions=0, const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *localAddress=0)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a8ce1a07fe5bed4300fed8eea21374946">disableRead</a> (int channelId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a89d0aea2bf5a3716201454258afd919f">enableRead</a> (int channelId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ab77cb79a157718d38ae5c809f7e8f52e">import</a> (<a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *streamSocket, int sourceId, bool readEnabledFlag=true, <a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a> mode=e_CLOSE_BOTH)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a4dc0844f034eae1548b2c1c05db8397d">setChannelContext</a> (int channelId, void *context)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a5052ef88897c4e40b912d4615ca0e018">shutdown</a> (int channelId, <a class="el" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7">ShutdownMode</a> mode=e_IMMEDIATE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ac0c54fb7829e4366e0bcd98db81d3132">shutdown</a> (int channelId, <a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2c">btlso::Flag::ShutdownType</a> type, <a class="el" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7">ShutdownMode</a> mode=e_IMMEDIATE)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a71778afeba4b6bb23b6437ec5c19c873">stopAndRemoveAllChannels</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aca17646aa57b4d5888e5768928b158ca">setWriteQueueHighWatermark</a> (int channelId, int numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a389eac2eac57881bda807f69ab872010">setWriteQueueLowWatermark</a> (int channelId, int numBytes)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ac8bdc156831a2e330ab3006972a09fad">setWriteQueueWatermarks</a> (int channelId, int lowWatermark, int highWatermark)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#af0740e0b2089cec1617b86c94a972c1a">resetRecordedMaxWriteQueueSize</a> (int channelId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a80cfe6abadc91ea84e9c7758f74f466c">start</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ab07ccf514dbcca6830fbc041e80547ad">stop</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#abbcc745eaa2f191205c34d48db809de7">incomingBlobBufferFactory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#af57160101bced246dbd07356d3bc8368">outboundBlobBufferFactory</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ab7df0ac56a8bda1281a1b2623528178b">write</a> (int channelId, const <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> &amp;message)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a1fb0a98067622a0f17d06d303d368593">write</a> (int channelId, const <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> &amp;message, int enqueueWatermark)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a12d08d6debfaa671868a28f24b80a1d9">write</a> (int channelId, const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a> vecs[], int numVecs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ac59308ac395400704f30a41a73b7d26a">write</a> (int channelId, const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a> vecs[], int numVecs)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#abe6e9d234c869d358fa4d4b27eefa680">registerClock</a> (const bsl::function&lt; void()&gt; &amp;command, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;startTime, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;period, int clockId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a018896a235aa2c3b0885cb56a5d0f9b0">registerClock</a> (const bsl::function&lt; void()&gt; &amp;command, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;startTime, const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;period, int clockId, int channelId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aa826022df4f88f6f379e9d653816c38f">deregisterClock</a> (int clockId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a3f9df8c2b519ddd50f5f3fbdad82d49b">getLingerOption</a> (btlso::SocketOptUtil::LingerData *result, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ad7640576cb50c195c9eb63ac7da4a191">getServerSocketOption</a> (int *result, int option, int level, int serverId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aef093c300ce7e3c0dac25a6cc37dbbee">getSocketOption</a> (int *result, int option, int level, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ae31534e6fc3cc182cd9080fb18d4c66b">setLingerOption</a> (const btlso::SocketOptUtil::LingerData &amp;value, int channelId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a709b48e531908bb177f628c2d9f15e25">setServerSocketOption</a> (int option, int level, int value, int serverId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aee4651e44e45d98cb2e5287b680b028c">setSocketOption</a> (int option, int level, int value, int channelId)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aff75406feb0a0c61810910b2f6572f79">reportWeightedAverageReset</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a70034197bc350050cf1adb38598a7dad">totalBytesReadReset</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a9645d5b71ad58578bc6aa885d5e346ef">totalBytesWrittenReset</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ad08c54c59a94d8d97df5a3345c7f3bb8">totalBytesRequestedToBeWrittenReset</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a06966c1669bd289e6e2773090d421523">busyMetrics</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#af9a07d7b2587d0e7d7095f74aa4e6df9">channelContext</a> (int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a5932e38ce2eac477b70a68253b17f643">getChannelStatistics</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *numRead, <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *numRequestedToBeWritten, <a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *numWritten, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a8357fc0afeaefa31bb4a94e2f53972cb">getChannelWriteQueueStatistics</a> (int *recordedMaxWriteQueueSize, int *currentWriteQueueSize, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a0e7d14a2feab639f3c48775859816a98">getHandleStatistics</a> (<a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="structbtlmt_1_1ChannelPool_1_1HandleInfo.html">HandleInfo</a> &gt; *handleInfo) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a8396fbe29ba0a3991785561b2fb6d144">getServerAddress</a> (<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *result, int serverId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a8826b9c5b495596fa1ff4e00194eb61e">getLocalAddress</a> (<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *result, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a5f7c3df656838e55d799eb56e1bf59d9">getPeerAddress</a> (<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *result, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ab14d12826959c644b2f443d383b46f18">numBytesRead</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a33b8fab61338282aa5d77d84c0a592a2">numBytesWritten</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#af9ec12dde1917cd418426e7d444ebf2f">numBytesRequestedToBeWritten</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result, int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ac1fc615b49f8225adca933939a0d9c86">numChannels</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ab0274bc2f9557f99dfc036c428b53898">numEvents</a> (int index) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#aadfd61a0a4b47f4d370ad72a902d1a2a">numThreads</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt; const <br class="typebreak"/>
<a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a><br class="typebreak"/>
&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a53d4c9f64dd9cde4050c29c65b57f08a">streamSocket</a> (int channelId) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a8c8f9816c654d3322d3c1e1d31ec6a0d">totalBytesRead</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ae35ba536be3e983f67fa90cba4537c0d">totalBytesRequestedToBeWritten</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#a7cf70cf524621d33e60decdda28851cf">totalBytesWritten</a> (<a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *result) const </td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbtlmt_1_1ChannelPool.html#ac47342240f21ce36f47485e4ab41a10d">Channel</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This class provides a channel pool, i.e., a mechanism by which connections can be established and managed. This channel pool allows the establishment of both server channels (see section "Server part" of the manipulators section) via the <code>listen</code> and <code>close</code> methods, and client channels (see section "Client part") via the <code>connect</code> method, and provide the <code>disableRead</code>, <code>enableRead</code>, and <code>shutdown</code> methods for managing the channels once they have been created (see the section "Channel management"). In addition, it allows the communication of messages through any of the channels (see the section "Outgoing
     Messages") via the <code>write</code> methods; the processing of incoming data to any of the channels is done asynchronously through a data callback passed at construction of this pool. An existing socket can be imported and this will create a channel enabled both for read and for write. This channel pool can dispatch events to be executed at different times at recurring intervals (see the section "Clock management"). All this processing will be performed in a number of threads. The channel pool can be started or stopped (see the section "Threads management"). Once started and until stopped, the channel pool dispatches incoming and outgoing connections, messages, and other channel functions to the processing threads. Once stopped, the channel pool can be started again and the channels will resume their operations. This channel pool keeps a set of metrics (see the "Metrics" section). It can be configured at construction by passing a <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a></code> object. </p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a8007511e7782b66c18acf73c835e9ec4"></a><!-- doxytag: member="btlmt::ChannelPool::ChannelStateChangeCallback" ref="a8007511e7782b66c18acf73c835e9ec4" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int, int, int, void*) <a class="el" href="classbtlmt_1_1ChannelPool.html#a8007511e7782b66c18acf73c835e9ec4">btlmt::ChannelPool::ChannelStateChangeCallback</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The callback of this type is invoked whenever a channel's state changes. The first argument is the (unique) channel ID, chosen by the channel pool, that identifies the connection channel that changed state. The second argument is the source ID, i.e., the client-provided identifier passed to the channel pool, identifying the operation responsible for creating the channel (e.g., the <code>serverId</code> parameter of <code>listen()</code> or the <code>sourceId</code> parameter of <code><a class="el" href="classbtlmt_1_1ChannelPool.html#aa17434163d2e35820d4ea7bb1d253e8a">connect()</a></code>). The third argument is the new state of this channel (can be any one of the <code>ChannelEvents</code> enumerations). The fourth and last parameter is passed the user-specified (via <code>setChannelContext</code>) channel context or <code>(void*)0</code> if no context was specified. Users MUST handle the <code>e_CHANNEL_DOWN</code> event, minimally by calling <code>shutdown</code> on the channel ID. The prototype for a channel state callback might look like: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">void</span> channelStateCallback(<span class="keywordtype">int</span>   channelId,
                                    <span class="keywordtype">int</span>   sourceId,
                                    <span class="keywordtype">int</span>   state,
                                    <span class="keywordtype">void</span> *context);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a530247348e3453328b7ee5d1a4971472"></a><!-- doxytag: member="btlmt::ChannelPool::BlobBasedReadCallback" ref="a530247348e3453328b7ee5d1a4971472" args=")" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int *, <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> *, int, void *) <a class="el" href="classbtlmt_1_1ChannelPool.html#a530247348e3453328b7ee5d1a4971472">btlmt::ChannelPool::BlobBasedReadCallback</a>)</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The callback of this type is invoked every time there is a sufficiently large amount of data read from a channel. The second argument to this callback is passed the data read from the channel in the form of a modifiable <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code>. The channel pool expects that clients take ownership of some of the data in the passed <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> and readjust the <code><a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a></code> accordingly. The third argument specifies the channel ID. The fourth and last parameter is passed the user-specified channel context (set using <code><a class="el" href="classbtlmt_1_1ChannelPool.html#a4dc0844f034eae1548b2c1c05db8397d">setChannelContext()</a></code>) or <code>(void *)0</code> if no context was specified. The callback, when invoked, must store into the first argument the minimum length of additional data that is needed to complete a message. If there is not enough data for a single message of a particular protocol, 0 must be stored into the first argument. The prototype for a data callback might look like: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">void</span> blobDataCallback(<span class="keywordtype">int</span>          *numNeeded,
                                <a class="code" href="classbtlb_1_1Blob.html">btlb::Blob</a> *message,
                                <span class="keywordtype">int</span>           channelId,
                                <span class="keywordtype">void</span>         *context);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<a class="anchor" id="a6af6150b550904dd0b5601241796814e"></a><!-- doxytag: member="btlmt::ChannelPool::PoolStateChangeCallback" ref="a6af6150b550904dd0b5601241796814e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bsl::function&lt;void(int, int, int)&gt; <a class="el" href="classbtlmt_1_1ChannelPool.html#a6af6150b550904dd0b5601241796814e">btlmt::ChannelPool::PoolStateChangeCallback</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The callback of this type is invoked whenever a change affecting the pool occurs. The first parameter indicates the type of event which triggered the callback (i.e., one of the <code>PoolEvents</code> enumerations). The second parameter indicates the source of the event (e.g., the <code>serverId</code> passed to <code>listen()</code> or the <code>sourceId</code> passed to <code><a class="el" href="classbtlmt_1_1ChannelPool.html#aa17434163d2e35820d4ea7bb1d253e8a">connect()</a></code>), or is 0 if there is no associated source (e.g. a <code>e_CHANNEL_LIMIT</code> alert). The third parameter indicates the severity of the event (must be one of the <code>Severity</code> enumerations). The prototype of a pool state callback might look like: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          <span class="keywordtype">void</span> poolStateCallback(<span class="keywordtype">int</span> eventType, <span class="keywordtype">int</span> sourceId, <span class="keywordtype">int</span> severity);
</pre></div><p><br/>
<br/>
 </p>

</div>
</div>
<hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535"></a><!-- doxytag: member="btlmt::ChannelPool::ChannelEvents" ref="ae1c721f4901568d3a6c77fe6b8700535" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1ChannelPool.html#ae1c721f4901568d3a6c77fe6b8700535">btlmt::ChannelPool::ChannelEvents</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This enumeration provides names for the different values passed into the third argument to <code>ChannelCallback</code> to discriminate between various changes in the state of a channel. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535aeebb10f21cc65b2e7c390ca18b31f9e5"></a><!-- doxytag: member="e_CHANNEL_DOWN" ref="ae1c721f4901568d3a6c77fe6b8700535aeebb10f21cc65b2e7c390ca18b31f9e5" args="" -->e_CHANNEL_DOWN</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535a9460b8d5bd520645793671563f8d25be"></a><!-- doxytag: member="e_CHANNEL_UP" ref="ae1c721f4901568d3a6c77fe6b8700535a9460b8d5bd520645793671563f8d25be" args="" -->e_CHANNEL_UP</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535a77f9fc7960966f305b45851bfdbf3641"></a><!-- doxytag: member="e_READ_TIMEOUT" ref="ae1c721f4901568d3a6c77fe6b8700535a77f9fc7960966f305b45851bfdbf3641" args="" -->e_READ_TIMEOUT</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535a9f8facfd241223128925d07712ed0fac"></a><!-- doxytag: member="e_WRITE_BUFFER_FULL" ref="ae1c721f4901568d3a6c77fe6b8700535a9f8facfd241223128925d07712ed0fac" args="" -->e_WRITE_BUFFER_FULL</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535a2d9cd75dfdec0db70424245fadfc077c"></a><!-- doxytag: member="e_MESSAGE_DISCARDED" ref="ae1c721f4901568d3a6c77fe6b8700535a2d9cd75dfdec0db70424245fadfc077c" args="" -->e_MESSAGE_DISCARDED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535af82082154c0d2b27ee63095ec65d5f86"></a><!-- doxytag: member="e_AUTO_READ_ENABLED" ref="ae1c721f4901568d3a6c77fe6b8700535af82082154c0d2b27ee63095ec65d5f86" args="" -->e_AUTO_READ_ENABLED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535ad84ad4636d10c47e596dcc338a96487a"></a><!-- doxytag: member="e_AUTO_READ_DISABLED" ref="ae1c721f4901568d3a6c77fe6b8700535ad84ad4636d10c47e596dcc338a96487a" args="" -->e_AUTO_READ_DISABLED</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535a183534129dcca5f18aa2f8034ea9c757"></a><!-- doxytag: member="e_WRITE_QUEUE_LOWWATER" ref="ae1c721f4901568d3a6c77fe6b8700535a183534129dcca5f18aa2f8034ea9c757" args="" -->e_WRITE_QUEUE_LOWWATER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535ac7da0cd3550293ee96eeae5247adcc60"></a><!-- doxytag: member="e_WRITE_QUEUE_HIGHWATER" ref="ae1c721f4901568d3a6c77fe6b8700535ac7da0cd3550293ee96eeae5247adcc60" args="" -->e_WRITE_QUEUE_HIGHWATER</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535ab0e630dca3239de13535216041709412"></a><!-- doxytag: member="e_CHANNEL_DOWN_READ" ref="ae1c721f4901568d3a6c77fe6b8700535ab0e630dca3239de13535216041709412" args="" -->e_CHANNEL_DOWN_READ</em>&nbsp;</td><td>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="ae1c721f4901568d3a6c77fe6b8700535ac2afdf1b80d09419b8abb7667bd37566"></a><!-- doxytag: member="e_CHANNEL_DOWN_WRITE" ref="ae1c721f4901568d3a6c77fe6b8700535ac2afdf1b80d09419b8abb7667bd37566" args="" -->e_CHANNEL_DOWN_WRITE</em>&nbsp;</td><td>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31e"></a><!-- doxytag: member="btlmt::ChannelPool::PoolEvents" ref="a4dbbfc4c3176cc23717fdf39b163d31e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1ChannelPool.html#a4dbbfc4c3176cc23717fdf39b163d31e">btlmt::ChannelPool::PoolEvents</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31eaa9e820743133a0f1dd1f13fe941b2876"></a><!-- doxytag: member="e_ACCEPT_TIMEOUT" ref="a4dbbfc4c3176cc23717fdf39b163d31eaa9e820743133a0f1dd1f13fe941b2876" args="" -->e_ACCEPT_TIMEOUT</em>&nbsp;</td><td>
<p>timed out accepting a connection </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31eaddf1065fd39f19a27e1bc852b709063b"></a><!-- doxytag: member="e_ERROR_ACCEPTING" ref="a4dbbfc4c3176cc23717fdf39b163d31eaddf1065fd39f19a27e1bc852b709063b" args="" -->e_ERROR_ACCEPTING</em>&nbsp;</td><td>
<p>error accepting a connection </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31ea65f110cedc2dd7b5a7c0dd731f4d0acc"></a><!-- doxytag: member="e_ERROR_CONNECTING" ref="a4dbbfc4c3176cc23717fdf39b163d31ea65f110cedc2dd7b5a7c0dd731f4d0acc" args="" -->e_ERROR_CONNECTING</em>&nbsp;</td><td>
<p>error connecting to the peer </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31ea878ea29a7b248b6fd25c26e6479e0f4c"></a><!-- doxytag: member="e_CHANNEL_LIMIT" ref="a4dbbfc4c3176cc23717fdf39b163d31ea878ea29a7b248b6fd25c26e6479e0f4c" args="" -->e_CHANNEL_LIMIT</em>&nbsp;</td><td>
<p>channel limit reached </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31ea2bf15bca6c3a5d3c71dd211a56167fb1"></a><!-- doxytag: member="e_CAPACITY_LIMIT" ref="a4dbbfc4c3176cc23717fdf39b163d31ea2bf15bca6c3a5d3c71dd211a56167fb1" args="" -->e_CAPACITY_LIMIT</em>&nbsp;</td><td>
<p>capacity limit reached </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31ea644a10c2703de1835d223b2f2b21b1e1"></a><!-- doxytag: member="e_ERROR_BINDING_CLIENT_ADDR" ref="a4dbbfc4c3176cc23717fdf39b163d31ea644a10c2703de1835d223b2f2b21b1e1" args="" -->e_ERROR_BINDING_CLIENT_ADDR</em>&nbsp;</td><td>
<p>error binding client address </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31eaf6568d93983548363d70d2bba4a1bccf"></a><!-- doxytag: member="e_ERROR_SETTING_OPTIONS" ref="a4dbbfc4c3176cc23717fdf39b163d31eaf6568d93983548363d70d2bba4a1bccf" args="" -->e_ERROR_SETTING_OPTIONS</em>&nbsp;</td><td>
<p>error setting socket options </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a4dbbfc4c3176cc23717fdf39b163d31ea80b9783734fa1f37397e9ee59dd9da67"></a><!-- doxytag: member="e_EVENT_MANAGER_LIMIT" ref="a4dbbfc4c3176cc23717fdf39b163d31ea80b9783734fa1f37397e9ee59dd9da67" args="" -->e_EVENT_MANAGER_LIMIT</em>&nbsp;</td><td>
<p>event manager limit reached </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa41bfed959e462a98e0fea16d78278cc"></a><!-- doxytag: member="btlmt::ChannelPool::ConnectResolutionMode" ref="aa41bfed959e462a98e0fea16d78278cc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1ChannelPool.html#aa41bfed959e462a98e0fea16d78278cc">btlmt::ChannelPool::ConnectResolutionMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mode indicating whether to perform name resolution at each connect attempt in <code>connect</code>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa41bfed959e462a98e0fea16d78278cca72260ef4034cc8919f54e3261f7ba99d"></a><!-- doxytag: member="e_RESOLVE_ONCE" ref="aa41bfed959e462a98e0fea16d78278cca72260ef4034cc8919f54e3261f7ba99d" args="" -->e_RESOLVE_ONCE</em>&nbsp;</td><td>
<p>perform resolution once prior to the first connect attempt </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa41bfed959e462a98e0fea16d78278ccadf93bd65fba9b9abaa6c74b5ece79f13"></a><!-- doxytag: member="e_RESOLVE_AT_EACH_ATTEMPT" ref="aa41bfed959e462a98e0fea16d78278ccadf93bd65fba9b9abaa6c74b5ece79f13" args="" -->e_RESOLVE_AT_EACH_ATTEMPT</em>&nbsp;</td><td>
<p>perform resolution prior to each connect attempt </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="abafe1b4119190bb0db35d432bbad4ef4"></a><!-- doxytag: member="btlmt::ChannelPool::KeepHalfOpenMode" ref="abafe1b4119190bb0db35d432bbad4ef4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">btlmt::ChannelPool::KeepHalfOpenMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Mode affecting how half-open connections are handled by a server or a client channel, passed to <code>connect</code>, <code>import</code> or <code>listen</code>. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="abafe1b4119190bb0db35d432bbad4ef4a161648c9d2d2f4350a3d73b85f0a41b8"></a><!-- doxytag: member="e_CLOSE_BOTH" ref="abafe1b4119190bb0db35d432bbad4ef4a161648c9d2d2f4350a3d73b85f0a41b8" args="" -->e_CLOSE_BOTH</em>&nbsp;</td><td>
<p>close whole channel if half-open connection </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="abafe1b4119190bb0db35d432bbad4ef4affac1e0b0ea63a9b9f9e9a0a3034b99f"></a><!-- doxytag: member="e_KEEP_HALF_OPEN" ref="abafe1b4119190bb0db35d432bbad4ef4affac1e0b0ea63a9b9f9e9a0a3034b99f" args="" -->e_KEEP_HALF_OPEN</em>&nbsp;</td><td>
<p>keep either part alive, if the other half senses a closed connection by the peer </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1d8daee01e011918e8d2c51580fbff7"></a><!-- doxytag: member="btlmt::ChannelPool::ShutdownMode" ref="ad1d8daee01e011918e8d2c51580fbff7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7">btlmt::ChannelPool::ShutdownMode</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="ad1d8daee01e011918e8d2c51580fbff7a5ff8d9de035666225fde25a0ff36c97d"></a><!-- doxytag: member="e_IMMEDIATE" ref="ad1d8daee01e011918e8d2c51580fbff7a5ff8d9de035666225fde25a0ff36c97d" args="" -->e_IMMEDIATE</em>&nbsp;</td><td>
<p>The channel is terminated immediately, all pending messages are discarded. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="aa67470585402993b7e6ef5b407b1fe27"></a><!-- doxytag: member="btlmt::ChannelPool::Severity" ref="aa67470585402993b7e6ef5b407b1fe27" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classbtlmt_1_1ChannelPool.html#aa67470585402993b7e6ef5b407b1fe27">btlmt::ChannelPool::Severity</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="aa67470585402993b7e6ef5b407b1fe27a67a9bc0318d9053059c8e2e4a308f2d2"></a><!-- doxytag: member="e_CRITICAL" ref="aa67470585402993b7e6ef5b407b1fe27a67a9bc0318d9053059c8e2e4a308f2d2" args="" -->e_CRITICAL</em>&nbsp;</td><td>
<p>A critical condition occurred and the channel pool is unable to operate normally. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="aa67470585402993b7e6ef5b407b1fe27a6c1c5328d9f508f842b10a2a80e5ceda"></a><!-- doxytag: member="e_ALERT" ref="aa67470585402993b7e6ef5b407b1fe27a6c1c5328d9f508f842b10a2a80e5ceda" args="" -->e_ALERT</em>&nbsp;</td><td>
<p>An alerting condition occurred and the channel pool can operate normally. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a84755eeb37002defe30d08c4e9043d56"></a><!-- doxytag: member="btlmt::ChannelPool::ChannelPool" ref="a84755eeb37002defe30d08c4e9043d56" args="(ChannelStateChangeCallback channelStateCb, BlobBasedReadCallback blobBasedReadCb, PoolStateChangeCallback poolStateCb, const ChannelPoolConfiguration &amp;parameters, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::ChannelPool::ChannelPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#a8007511e7782b66c18acf73c835e9ec4">ChannelStateChangeCallback</a>&nbsp;</td>
          <td class="paramname"> <em>channelStateCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#a530247348e3453328b7ee5d1a4971472">BlobBasedReadCallback</a>&nbsp;</td>
          <td class="paramname"> <em>blobBasedReadCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#a6af6150b550904dd0b5601241796814e">PoolStateChangeCallback</a>&nbsp;</td>
          <td class="paramname"> <em>poolStateCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a channel pool with the specified <code>channelStateCb</code>, <code>blobBasedReadCb</code> and <code>poolStateCb</code> callbacks to be invoked, correspondingly, when a channel state changes, data arrives, or pool state changes. The channel pool is configured using the specified configuration <code>parameters</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used.</p>
<p>The exact description of the argument to the callbacks are given in the type definitions of the <code>ChannelStateChangeCallback</code>, <code>BlobBasedReadCallback</code>, and <code>PoolStateChangeCallback</code>. </p>

</div>
</div>
<a class="anchor" id="a64242764af079c6e98772eebfafeda51"></a><!-- doxytag: member="btlmt::ChannelPool::ChannelPool" ref="a64242764af079c6e98772eebfafeda51" args="(btlb::BlobBufferFactory *blobBufferFactory, ChannelStateChangeCallback channelStateCb, BlobBasedReadCallback blobBasedReadCb, PoolStateChangeCallback poolStateCb, const ChannelPoolConfiguration &amp;parameters, bslma::Allocator *basicAllocator=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::ChannelPool::ChannelPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a> *&nbsp;</td>
          <td class="paramname"> <em>blobBufferFactory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#a8007511e7782b66c18acf73c835e9ec4">ChannelStateChangeCallback</a>&nbsp;</td>
          <td class="paramname"> <em>channelStateCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#a530247348e3453328b7ee5d1a4971472">BlobBasedReadCallback</a>&nbsp;</td>
          <td class="paramname"> <em>blobBasedReadCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#a6af6150b550904dd0b5601241796814e">PoolStateChangeCallback</a>&nbsp;</td>
          <td class="paramname"> <em>poolStateCb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1Allocator.html">bslma::Allocator</a> *&nbsp;</td>
          <td class="paramname"> <em>basicAllocator</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a channel pool having the specified <code>channelStateCb</code>, <code>blobBasedReadCb</code> and <code>poolStateCb</code> callbacks to be invoked, when a channel state changes, data arrives, or pool state changes (respectively), and using the specified <code>blobBufferFactory</code> to supply buffers for all internal read and write blobs including those passed to <code>blobBasedReadCb</code>. The channel pool is configured using the specified configuration <code>parameters</code>. Optionally specify a <code>basicAllocator</code> used to supply memory. If <code>basicAllocator</code> is 0, the currently installed default allocator is used.</p>
<p>The exact description of the argument to the callbacks are given in the type definitions of the <code>ChannelStateChangeCallback</code>, <code>BlobBasedReadCallback</code>, and <code>PoolStateChangeCallback</code>. </p>

</div>
</div>
<a class="anchor" id="ad5ca20be55e579eaf3013f0cfea578ce"></a><!-- doxytag: member="btlmt::ChannelPool::~ChannelPool" ref="ad5ca20be55e579eaf3013f0cfea578ce" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">btlmt::ChannelPool::~ChannelPool </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroy this channel pool. The behavior is undefined if the channel pool was not shut down properly. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a0ed269ffcb4b9b67aadb0f8e5f92db6d"></a><!-- doxytag: member="btlmt::ChannelPool::close" ref="a0ed269ffcb4b9b67aadb0f8e5f92db6d" args="(int serverId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::close </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serverId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Close the listening socket corresponding to the specified <code>serverId</code>. Return 0 on success, and a non-zero value otherwise. Note that closing a listening socket has no effect on any channels managed by this pool. </p>

</div>
</div>
<a class="anchor" id="a44970e8107c1822208af590197b6f7b2"></a><!-- doxytag: member="btlmt::ChannelPool::listen" ref="a44970e8107c1822208af590197b6f7b2" args="(int portNumber, int backlog, int serverId, int reuseAddress=1, bool readEnabledFlag=true, const btlso::SocketOptions *socketOptions=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::listen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>portNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serverId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reuseAddress</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="adf2e646a1d32343b7a5ae91da4924ed2"></a><!-- doxytag: member="btlmt::ChannelPool::listen" ref="adf2e646a1d32343b7a5ae91da4924ed2" args="(int portNumber, int backlog, int serverId, const bsls::TimeInterval &amp;timeout, int reuseAddress=1, bool readEnabledFlag=true, const btlso::SocketOptions *socketOptions=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::listen </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>portNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serverId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reuseAddress</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a7d00c38828f14287509f354cb19bd39b"></a><!-- doxytag: member="btlmt::ChannelPool::listen" ref="a7d00c38828f14287509f354cb19bd39b" args="(const btlso::IPv4Address &amp;endpoint, int backlog, int serverId, int reuseAddress=1, bool readEnabledFlag=true, const btlso::SocketOptions *socketOptions=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::listen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serverId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reuseAddress</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4e5c7815ad108b554b24b4805252536"></a><!-- doxytag: member="btlmt::ChannelPool::listen" ref="aa4e5c7815ad108b554b24b4805252536" args="(const btlso::IPv4Address &amp;endpoint, int backlog, int serverId, const bsls::TimeInterval &amp;timeout, int reuseAddress=1, bool readEnabledFlag=true, KeepHalfOpenMode mode=e_CLOSE_BOTH, const btlso::SocketOptions *socketOptions=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::listen </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>endpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>backlog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serverId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>reuseAddress</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>e_CLOSE_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Establish a listening socket having the specified <code>backlog</code> maximum number of pending connections on the specified <code>portNumber</code> on all local interfaces or the specified <code>endpoint</code>, depending on which overload of <code>listen</code> is used, and associate this newly established socket with the specified <code>serverId</code>. Optionally, specify a <code>timeout</code> <em>duration</em> for accepting a connection. If no connection attempt is received for a period of <code>timeout</code> since the last connection or the last timeout, a pool state callback is invoked with event equal to <code>e_ACCEPT_TIMEOUT</code>. Optionally specify a <code>reuseAddress</code> value to be used in setting <code>e_REUSEADDRESS</code> socket option; if <code>reuseAddress</code> is not specified, 1 is used (i.e., <code>e_REUSEADDRESS</code> is enabled). Optionally specify via a <code>readEnabledFlag</code> whether automatic reading should be enabled on this channel immediately after creation; if <code>readEnabledFlag</code> is not specified, then <code>true</code> is used (i.e., reading on new channels is automatically enabled). If <code>endpoint</code>, <code>timeout</code>, <code>reuseAddress</code> and <code>readEnabledFlag</code> are all specified, also optionally specify a <code>mode</code> to keep channel half-open in case a channel established by the server with this <code>serverId</code> is half-closed; if <code>mode</code> is not specified, then <code>e_CLOSE_BOTH</code> is used (i.e., half-open connections lead to closing the channel completely). Optionally specify <code>socketOptions</code> that will be used to indicate what options should be set on the listening socket. Return 0 on success, a positive value if there is a listening socket associated with <code>serverId</code> (i.e., <code>serverId</code> is not unique) and a negative value if an error occurred. Every time a connection is accepted by this pool on this (newly established) listening socket, <code>serverId</code> is passed to the callback provided in the configuration at construction. The behavior is undefined unless <code>0 &lt; backlog</code>. </p>

</div>
</div>
<a class="anchor" id="aa17434163d2e35820d4ea7bb1d253e8a"></a><!-- doxytag: member="btlmt::ChannelPool::connect" ref="aa17434163d2e35820d4ea7bb1d253e8a" args="(const char *hostname, int portNumber, int numAttempts, const bsls::TimeInterval &amp;interval, int sourceId, bslma::ManagedPtr&lt; btlso::StreamSocket&lt; btlso::IPv4Address &gt; &gt; *socket, ConnectResolutionMode resolutionMode=e_RESOLVE_ONCE, bool readEnabledFlag=true, KeepHalfOpenMode halfCloseMode=e_CLOSE_BOTH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::connect </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>portNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sourceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#aa41bfed959e462a98e0fea16d78278cc">ConnectResolutionMode</a>&nbsp;</td>
          <td class="paramname"> <em>resolutionMode</em> = <code>e_RESOLVE_ONCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a>&nbsp;</td>
          <td class="paramname"> <em>halfCloseMode</em> = <code>e_CLOSE_BOTH</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a07d4acf688d6899ca85a314be2b77655"></a><!-- doxytag: member="btlmt::ChannelPool::connect" ref="a07d4acf688d6899ca85a314be2b77655" args="(const char *hostname, int portNumber, int numAttempts, const bsls::TimeInterval &amp;interval, int sourceId, ConnectResolutionMode resolutionMode=e_RESOLVE_ONCE, bool readEnabledFlag=true, KeepHalfOpenMode halfCloseMode=e_CLOSE_BOTH, const btlso::SocketOptions *socketOptions=0, const btlso::IPv4Address *localAddress=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::connect </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>hostname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>portNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sourceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#aa41bfed959e462a98e0fea16d78278cc">ConnectResolutionMode</a>&nbsp;</td>
          <td class="paramname"> <em>resolutionMode</em> = <code>e_RESOLVE_ONCE</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a>&nbsp;</td>
          <td class="paramname"> <em>halfCloseMode</em> = <code>e_CLOSE_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>localAddress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously issue up to the specified <code>numAttempts</code> connection requests to a server at the address resolved from the specified <code>hostname</code> on the specified <code>portNumber</code>, with at least the specified (relative) time <code>interval</code> after each attempt before either a new connection is retried (if <code>numAttempts</code> is not reached) or the connection attempts are abandoned (if <code>numAttempts</code> is reached). When the connection is established, an internal channel is created and a channel state callback, with the event <code>e_CHANNEL_UP</code>, the newly created channel ID, and the specified <code>sourceId</code> is invoked in an internal thread. If the <code>interval</code> is reached, or in case other events occur (e.g., <code>e_ERROR_CONNECTING</code>, <code>e_CHANNEL_LIMIT</code>, or <code>e_CAPACITY_LIMIT</code>), a pool state callback is invoked with the event type, <code>sourceId</code> and a severity. Optionally specify a <code>resolutionMode</code> to indicate whether the name resolution is performed once (if <code>resolutionMode</code> is <code>e_RESOLVE_ONCE</code>), or performed anew prior to each attempt (if <code>resolutionMode</code> is <code>e_RESOLVE_AT_EACH_ATTEMPT</code>); if <code>resolutionMode</code> is not specified, <code>e_RESOLVE_ONCE</code> is used. Optionally specify via a <code>readEnabledFlag</code> whether automatic reading should be enabled on this channel immediately after creation; if <code>readEnabledFlag</code> is not specified, then <code>true</code> is used (i.e., reading on new channels is automatically enabled). Optionally specify a <code>halfCloseMode</code> in case the channel created for this connection is half-closed; if <code>mode</code> is not specified, then <code>e_CLOSE_BOTH</code> is used (i.e., so-called half-open connections, that is, anything less than full duplex, lead to close the channel). Optionally specify either <code>socketOptions</code> that will be used to specify what options should be set on the connecting socket and/or the specified <code>localAddress</code> to be used as the source address, or specify <code>socket</code> to use as the connecting socket (with any desired options and/or source address already set). If <code>socket</code> is specified, this pool will assume its ownership if this function returns successfully, and will be left unchanged if an error is returned. Return 0 on successful initiation, a positive value if there is an active connection attempt with the same <code>sourceId</code> (in which case this connection attempt may be retried after that other connection either succeeds, fails, or times out), or a negative value if an error occurred, with the value of -1 indicating that the channel pool is not running. The behavior is undefined unless <code>0 &lt; numAttempts</code>, and either <code>0 &lt; interval</code> or <code>1 == numAttempts</code> or both. Note that if the connection cannot be established, up to <code>numAttempts</code> pool state callbacks with <code>e_ERROR_CONNECTING</code> may be generated, one for each <code>interval</code>. Also note that this function will fail if this channel pool is not running, and that no callbacks will be invoked if the return value is non-zero. Also note that the same <code>sourceId</code> can be used in several calls to <code>connect</code> or <code>import</code> as long as two calls to connect with the same <code>sourceId</code> do not overlap. Finally, note that the lifetime of the <code>hostname</code> need not extend past the return of this function call, that is, <code>hostname</code> need not remain valid until the last connection attempt but can be deleted upon return. </p>

</div>
</div>
<a class="anchor" id="a982df83f9ee81bbe77c694f2f44eb77b"></a><!-- doxytag: member="btlmt::ChannelPool::connect" ref="a982df83f9ee81bbe77c694f2f44eb77b" args="(const btlso::IPv4Address &amp;serverAddress, int numAttempts, const bsls::TimeInterval &amp;interval, int sourceId, bslma::ManagedPtr&lt; btlso::StreamSocket&lt; btlso::IPv4Address &gt; &gt; *socket, bool readEnabledFlag=true, KeepHalfOpenMode mode=e_CLOSE_BOTH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>serverAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sourceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>e_CLOSE_BOTH</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a3592723feee45fbb878a5c861e69e6bb"></a><!-- doxytag: member="btlmt::ChannelPool::connect" ref="a3592723feee45fbb878a5c861e69e6bb" args="(const btlso::IPv4Address &amp;serverAddress, int numAttempts, const bsls::TimeInterval &amp;interval, int sourceId, bool readEnabledFlag=true, KeepHalfOpenMode mode=e_CLOSE_BOTH, const btlso::SocketOptions *socketOptions=0, const btlso::IPv4Address *localAddress=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::connect </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>serverAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numAttempts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sourceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>e_CLOSE_BOTH</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1SocketOptions.html">btlso::SocketOptions</a> *&nbsp;</td>
          <td class="paramname"> <em>socketOptions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>localAddress</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Asynchronously issue up to the specified <code>numAttempts</code> connection requests to a server at the specified <code>serverAddress</code>, with at least the specified (relative) time <code>interval</code> after each attempt before either a new connection is retried (if <code>numAttempts</code> is not reached) or the connection attempts are abandoned (if <code>numAttempts</code> is reached). When the connection is established, an internal channel is created and a channel state callback, with the event <code>e_CHANNEL_UP</code>, the newly created channel ID, and the specified <code>sourceId</code> is invoked in an internal thread. If the <code>interval</code> is reached, or in case other events occur (e.g., <code>e_ERROR_CONNECTING</code>, <code>e_CHANNEL_LIMIT</code>, or <code>e_CAPACITY_LIMIT</code>), a pool state callback is invoked with the event type, <code>sourceId</code> and a severity. Optionally specify via a <code>readEnabledFlag</code> whether automatic reading should be enabled on this channel immediately after creation; if <code>readEnabledFlag</code> is not specified, then <code>true</code> is used (i.e., reading on new channels is automatically enabled). Optionally specify a half-close <code>mode</code> in case the channel created for this connection is half-closed; if <code>mode</code> is not specified, then <code>e_CLOSE_BOTH</code> is used (i.e., half-open connections lead to close the channel). Optionally specify either <code>socketOptions</code> that will be used to specify what options should be set on the connecting socket and/or the specified <code>localAddress</code> to be used as the source address, or specify <code>socket</code> to use as the connecting socket (with any desired options and/or source address already set). If <code>socket</code> is specified, this pool will assume its ownership. Return 0 on successful initiation, a positive value if there is an active connection attempt with the same <code>sourceId</code> (in which case this connection attempt may be retried after that other connection either succeeds, fails, or times out), or a negative value if an error occurred, with the value of -1 indicating that the channel pool is not running. The behavior is undefined unless <code>0 &lt; numAttempts</code>, and either <code>0 &lt; interval</code> or <code>1 == numAttempts</code> or both. Note that if the connection cannot be established, up to <code>numAttempts</code> pool state callbacks with <code>e_ERROR_CONNECTING</code> may be generated, one for each <code>interval</code>. Also note that this function will fail if this channel pool is not running, and that no callbacks will be invoked if the return value is non-zero. Also note that the same <code>sourceId</code> can be used in several calls to <code>connect</code> or <code>import</code> as long as two calls to connect with the same <code>sourceId</code> do not overlap. </p>

</div>
</div>
<a class="anchor" id="a8ce1a07fe5bed4300fed8eea21374946"></a><!-- doxytag: member="btlmt::ChannelPool::disableRead" ref="a8ce1a07fe5bed4300fed8eea21374946" args="(int channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::disableRead </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue a request to disable automatic reading on the channel having the specified <code>channelId</code>. Return 0 on success and a non-zero value otherwise. Once automatic reading is disabled a channel state callback for this channel is invoked with <code>e_AUTO_READ_DISABLED</code> state.</p>
<p>This method offers the following specific guarantees:</p>
<ul>
<li>When shutting down a channel, <code>e_AUTO_READ_DISABLED</code> message is <em>not</em> generated.</li>
<li>A data callback will always happen in between <code>e_AUTO_READ_ENABLED</code> and <code>e_AUTO_READ_DISABLED</code> callbacks.</li>
<li>The data currently enqueued in the channel pool for this channel is <em>not</em> discarded. </li>
</ul>

</div>
</div>
<a class="anchor" id="a89d0aea2bf5a3716201454258afd919f"></a><!-- doxytag: member="btlmt::ChannelPool::enableRead" ref="a89d0aea2bf5a3716201454258afd919f" args="(int channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::enableRead </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue a request to enable automatic reading on the channel having the specified <code>channelId</code>. Return 0 on success and a non-zero value otherwise. Once automatic reading is enabled a channel state callback for this channel is invoked with <code>e_AUTO_READ_ENABLED</code> state.</p>
<p>This method offers the following specific guarantees:</p>
<ul>
<li>By default, a newly created channel is in <code>e_AUTO_READ_ENABLED</code> state (except imported channels with <code>readEnabledFlag</code> not set), unless the 'readEnabledFlag was set to <code>false</code>.</li>
<li>When a new channel is created and read is enabled, both <code>e_CHANNEL_UP</code> and e_AUTO_READ_ENABLED messages are generated, in this order. However, <code>e_CHANNEL_UP</code> and <code>e_AUTO_READ_ENABLED</code> may be generated from different threads.</li>
<li>A data callback will always happen in between <code>e_AUTO_READ_ENABLED</code> and <code>e_AUTO_READ_DISABLED</code> callbacks. </li>
</ul>

</div>
</div>
<a class="anchor" id="ab77cb79a157718d38ae5c809f7e8f52e"></a><!-- doxytag: member="btlmt::ChannelPool::import" ref="ab77cb79a157718d38ae5c809f7e8f52e" args="(bslma::ManagedPtr&lt; btlso::StreamSocket&lt; btlso::IPv4Address &gt; &gt; *streamSocket, int sourceId, bool readEnabledFlag=true, KeepHalfOpenMode mode=e_CLOSE_BOTH)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::import </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbslma_1_1ManagedPtr.html">bslma::ManagedPtr</a>&lt; <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt; <a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> &gt; &gt; *&nbsp;</td>
          <td class="paramname"> <em>streamSocket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sourceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>readEnabledFlag</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#abafe1b4119190bb0db35d432bbad4ef4">KeepHalfOpenMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>e_CLOSE_BOTH</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add the specified <code>streamSocket</code> to this channel pool. Assign a channel ID and invoke a channel state callback, passing <code>e_CHANNEL_UP</code> and the specified <code>sourceId</code>, in an internal thread. Assume ownership from <code>streamSocket</code>, leaving it null, if this function returns successfully, and leave it unchanged if an error is returned. Optionally specify via <code>readEnabledFlag</code> whether automatic reading should be enabled on this channel immediately after creation; if <code>readEnabledFlag</code> is not specified, then <code>true</code> is used (i.e., reading on new channels is automatically enabled). Optionally specify a half-close <code>mode</code> in case the channel created for this connection is half-closed; if <code>mode</code> is not specified, then <code>e_CLOSE_BOTH</code> is used (i.e., half-open connections lead to close the channel). Return 0 on success and a non-zero value, with no effect on the channel pool, otherwise. Note that the same <code>sourceId</code> can be used in several calls to <code>connect</code> or <code>import</code> as long as two calls to connect with the same <code>sourceId</code> do not overlap. Also note that a half-closed <code>streamSocket</code> can be imported into this channel pool, irrespective of <code>mode</code>. </p>

</div>
</div>
<a class="anchor" id="a4dc0844f034eae1548b2c1c05db8397d"></a><!-- doxytag: member="btlmt::ChannelPool::setChannelContext" ref="a4dc0844f034eae1548b2c1c05db8397d" args="(int channelId, void *context)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::setChannelContext </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>context</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Associate the specified (opaque) <code>context</code> with the channel having the specified <code>channelId</code>. The channel context will be reported on any invocation of a callback related to this channel. </p>

</div>
</div>
<a class="anchor" id="a5052ef88897c4e40b912d4615ca0e018"></a><!-- doxytag: member="btlmt::ChannelPool::shutdown" ref="a5052ef88897c4e40b912d4615ca0e018" args="(int channelId, ShutdownMode mode=e_IMMEDIATE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::shutdown </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7">ShutdownMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>e_IMMEDIATE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac0c54fb7829e4366e0bcd98db81d3132"></a><!-- doxytag: member="btlmt::ChannelPool::shutdown" ref="ac0c54fb7829e4366e0bcd98db81d3132" args="(int channelId, btlso::Flag::ShutdownType type, ShutdownMode mode=e_IMMEDIATE)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::shutdown </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbtlso_1_1Flag.html#ac6f8bfd3aebacd2f0c5cf4f8aacb7f2c">btlso::Flag::ShutdownType</a>&nbsp;</td>
          <td class="paramname"> <em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbtlmt_1_1ChannelPool.html#ad1d8daee01e011918e8d2c51580fbff7">ShutdownMode</a>&nbsp;</td>
          <td class="paramname"> <em>mode</em> = <code>e_IMMEDIATE</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Shut down the communication channel having the specified <code>channelId</code> in the optionally specified <code>mode</code> and return 0 on success, and a non-zero value otherwise. Optionally specify a shutdown <code>type</code> to close only the reading or the writing part; by default, <code>e_CLOSE_BOTH</code> is used (i.e., both halves of the channel are closed). Note that shutting down a channel will deallocate all system resources associated with <code>channel</code> and subsequent references to channel will result in undefined behavior. Also note that, if the channel does not support half-open connections (i.e., the <code>mode</code> passed to <code>connect</code>, <code>listen</code>, or <code>import</code> was set to <code>e_CLOSE_BOTH</code>), then shutting down the channel leads to a complete shutdown, irrespective of the shutdown <code>type</code>. If the channel does support half-open connections, but is already half-closed, and the <code>type</code> (set to <code>e_SHUTDOWN_BOTH</code>, <code>e_SHUTDOWN_RECEIVE</code> or <code>e_SHUTDOWN_SEND</code>) closes the other half, then the channel is shut down completely; otherwise, only one half of the channel is closed but the channel itself is not, and subsequent calls to write (if <code>type</code> is <code>e_SHUTDOWN_SEND</code>), or to <code>enableRead</code> (if <code>type</code> is <code>e_SHUTDOWN_RECEIVE</code>), will fail. </p>

</div>
</div>
<a class="anchor" id="a71778afeba4b6bb23b6437ec5c19c873"></a><!-- doxytag: member="btlmt::ChannelPool::stopAndRemoveAllChannels" ref="a71778afeba4b6bb23b6437ec5c19c873" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::stopAndRemoveAllChannels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Terminate all threads managed by this channel pool, close all listening sockets, close both the read and write parts of all communication channels under management, and remove all those communication channels from this channel pool. Return 0 on success, and a non-zero value otherwise. If any attempt to terminate a thread "gracefully" fails, previously terminated threads are restarted and a negative value is returned. The behavior is undefined if <code>start</code> is called concurrently or subsequent to the completion of this call. Note that shutting down a channel will deallocate all system resources associated with that channel. Also note that this function is intended to be called to release resources held by this channel pool just prior to its destruction. </p>

</div>
</div>
<a class="anchor" id="aca17646aa57b4d5888e5768928b158ca"></a><!-- doxytag: member="btlmt::ChannelPool::setWriteQueueHighWatermark" ref="aca17646aa57b4d5888e5768928b158ca" args="(int channelId, int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::setWriteQueueHighWatermark </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the write queue high-water mark for the specified <code>channelId</code> to the specified <code>numBytes</code>; return 0 on success, and a non-zero value if <code>channelId</code> does not exist. An <code>e_WRITE_QUEUE_HIGHWATER</code> alert is provided (via the channel state callback) if <code>numBytes</code> is less than or equal to the current size of the write queue. (See the "Invocation of High- and Low-Water Mark Callbacks" section under @DESCRIPTION in the component-level documentation for details on <code>e_WRITE_QUEUE_HIGHWATER</code> and <code>e_WRITE_QUEUE_LOWWATER</code> alerts.) The behavior is undefined unless <code>0 &lt;= numBytes</code>. Note that this method overrides the value configured (for all channels) by the <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a></code> supplied at construction. </p>

</div>
</div>
<a class="anchor" id="a389eac2eac57881bda807f69ab872010"></a><!-- doxytag: member="btlmt::ChannelPool::setWriteQueueLowWatermark" ref="a389eac2eac57881bda807f69ab872010" args="(int channelId, int numBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::setWriteQueueLowWatermark </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the write queue low-water mark for the specified <code>channelId</code> to the specified <code>numBytes</code>; return 0 on success, and a non-zero value if either <code>channelId</code> does not exist. An <code>e_WRITE_QUEUE_LOWWATER</code> alert is provided (via the channel state callback) if <code>numBytes</code> is greater than or equal to the current size state of the write queue. (See // the "Invocation of High- and Low-Water Mark Callbacks" section under @DESCRIPTION in the component-level documentation for details on <code>e_WRITE_QUEUE_HIGHWATER</code> and <code>e_WRITE_QUEUE_LOWWATER</code> alerts.) The behavior is undefined unless <code>0 &lt;= numBytes</code>. Note that this method overrides the value configured (for all channels) by the <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a></code> supplied at construction. </p>

</div>
</div>
<a class="anchor" id="ac8bdc156831a2e330ab3006972a09fad"></a><!-- doxytag: member="btlmt::ChannelPool::setWriteQueueWatermarks" ref="ac8bdc156831a2e330ab3006972a09fad" args="(int channelId, int lowWatermark, int highWatermark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::setWriteQueueWatermarks </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>lowWatermark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>highWatermark</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the write queue low- and high-water marks for the specified <code>channelId</code> to the specified <code>lowWatermark</code> and <code>highWatermark</code> values, respectively; return 0 on success, and a non-zero value if <code>channelId</code> does not exist. A <code>e_WRITE_QUEUE_LOWWATER</code> alert is provided (via the channel state callback) if <code>lowWatermark</code> is greater than or equal to the current size of the write queue, and a <code>e_WRITE_QUEUE_HIGHWATER</code> alert is provided if <code>highWatermark</code> is less than or equal to the current size of the write queue. (See the "Invocation of High- and Low-Water Mark Callbacks" section under @DESCRIPTION in the component-level documentation for details on <code>e_WRITE_QUEUE_HIGHWATER</code> and <code>e_WRITE_QUEUE_LOWWATER</code> alerts.) The behavior is undefined unless <code>0 &lt;= lowWatermark</code> and <code>0 &lt;= highWatermark</code>. Note that this method overrides the values configured (for all channels) by the <code><a class="el" href="classbtlmt_1_1ChannelPoolConfiguration.html">ChannelPoolConfiguration</a></code> supplied at construction. </p>

</div>
</div>
<a class="anchor" id="af0740e0b2089cec1617b86c94a972c1a"></a><!-- doxytag: member="btlmt::ChannelPool::resetRecordedMaxWriteQueueSize" ref="af0740e0b2089cec1617b86c94a972c1a" args="(int channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::resetRecordedMaxWriteQueueSize </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset the recorded max write queue size for the specified <code>channelId</code> to the current write queue size. Return 0 on success, or a non-zero value if <code>channelId</code> does not exist. Note that this function resets the recorded max write queue size and does not change the write queue high-water mark for <code>channelId</code>. </p>

</div>
</div>
<a class="anchor" id="a80cfe6abadc91ea84e9c7758f74f466c"></a><!-- doxytag: member="btlmt::ChannelPool::start" ref="a80cfe6abadc91ea84e9c7758f74f466c" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::start </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create internal threads that monitor network events and invoke corresponding callbacks supplied (in the configuration) at construction. Return 0 on success, and a non-zero value otherwise. The behavior is undefined if the internal threads are created (as reflected by the pool's state), see <code>state</code>. </p>

</div>
</div>
<a class="anchor" id="ab07ccf514dbcca6830fbc041e80547ad"></a><!-- doxytag: member="btlmt::ChannelPool::stop" ref="ab07ccf514dbcca6830fbc041e80547ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::stop </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Gracefully terminate the worker threads; return 0 on success and a non-zero value otherwise. If any attempt to terminate a thread "gracefully" fails, previously terminated threads are restarted and a negative value is returned. The behavior is undefined unless the threads exist (i.e., were created successfully). Note that this function has no effect on the state of any channel managed by this pool. </p>

</div>
</div>
<a class="anchor" id="abbcc745eaa2f191205c34d48db809de7"></a><!-- doxytag: member="btlmt::ChannelPool::incomingBlobBufferFactory" ref="abbcc745eaa2f191205c34d48db809de7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a>* btlmt::ChannelPool::incomingBlobBufferFactory </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the pooled blob buffer factory used by this channel pool to produce blobs for incoming messages. </p>

</div>
</div>
<a class="anchor" id="af57160101bced246dbd07356d3bc8368"></a><!-- doxytag: member="btlmt::ChannelPool::outboundBlobBufferFactory" ref="af57160101bced246dbd07356d3bc8368" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbtlb_1_1BlobBufferFactory.html">btlb::BlobBufferFactory</a>* btlmt::ChannelPool::outboundBlobBufferFactory </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the address of the blob buffer factory used by this channel pool to produce blobs for outbound messages.</p>
<p>Note that this version of channel pool now uses blob internally. It is more efficient to create blob messages, using the <code><a class="el" href="classbtlmt_1_1ChannelPool.html#af57160101bced246dbd07356d3bc8368">outboundBlobBufferFactory()</a></code>, than to create data messages using <code>outboundBufferFactory()</code>. </p>

</div>
</div>
<a class="anchor" id="ab7df0ac56a8bda1281a1b2623528178b"></a><!-- doxytag: member="btlmt::ChannelPool::write" ref="ab7df0ac56a8bda1281a1b2623528178b" args="(int channelId, const btlb::Blob &amp;message)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::write </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a1fb0a98067622a0f17d06d303d368593"></a><!-- doxytag: member="btlmt::ChannelPool::write" ref="a1fb0a98067622a0f17d06d303d368593" args="(int channelId, const btlb::Blob &amp;message, int enqueueWatermark)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::write </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtlb_1_1Blob.html">btlb::Blob</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>enqueueWatermark</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a12d08d6debfaa671868a28f24b80a1d9"></a><!-- doxytag: member="btlmt::ChannelPool::write" ref="a12d08d6debfaa671868a28f24b80a1d9" args="(int channelId, const btls::Iovec vecs[], int numVecs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::write </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Iovec.html">btls::Iovec</a>&nbsp;</td>
          <td class="paramname"> <em>vecs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVecs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="ac59308ac395400704f30a41a73b7d26a"></a><!-- doxytag: member="btlmt::ChannelPool::write" ref="ac59308ac395400704f30a41a73b7d26a" args="(int channelId, const btls::Ovec vecs[], int numVecs)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::write </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbtls_1_1Ovec.html">btls::Ovec</a>&nbsp;</td>
          <td class="paramname"> <em>vecs</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numVecs</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue a request to write the specified <code>message</code> or <code>vecs</code> into the channel having the specified <code>channelId</code>. Optionally specify an <code>enqueueWatermark</code> to fail if the write queue already has more than <code>enqueueWatermark</code> bytes. Return 0 on success, and a non-zero value otherwise. On error, the return value <em>may</em> equal to one of the enumerators in <code><a class="el" href="structbtlmt_1_1ChannelStatus.html#a4352e4c5f1558a16a42bff85712fe3dc">ChannelStatus::Enum</a></code>. If the error is a transient failure resulting from an overfull output queue, a high-water callback will be scheduled immediately, and a low-watermark callback will be scheduled to be called when the queue has drained enough to accept more data. These callbacks may be delivered to a different thread before this call returns. </p>

</div>
</div>
<a class="anchor" id="abe6e9d234c869d358fa4d4b27eefa680"></a><!-- doxytag: member="btlmt::ChannelPool::registerClock" ref="abe6e9d234c869d358fa4d4b27eefa680" args="(const bsl::function&lt; void()&gt; &amp;command, const bsls::TimeInterval &amp;startTime, const bsls::TimeInterval &amp;period, int clockId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::registerClock </td>
          <td>(</td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clockId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<a class="anchor" id="a018896a235aa2c3b0885cb56a5d0f9b0"></a><!-- doxytag: member="btlmt::ChannelPool::registerClock" ref="a018896a235aa2c3b0885cb56a5d0f9b0" args="(const bsl::function&lt; void()&gt; &amp;command, const bsls::TimeInterval &amp;startTime, const bsls::TimeInterval &amp;period, int clockId, int channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::registerClock </td>
          <td>(</td>
          <td class="paramtype">const bsl::function&lt; void()&gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>command</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>startTime</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbsls_1_1TimeInterval.html">bsls::TimeInterval</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>period</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clockId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Register the specified <code>command</code> to be invoked after the specified <code>startTime</code> absolute time and associate this registration with the specified <code>clockId</code>. If the specified <code>period</code> (relative time) is positive, repeat invoking <code>command</code> at <code>period</code> intervals until the clock is deregistered, otherwise a single <code>command</code> will be invoked. Optionally specify <code>channelId</code> to indicate that the clock must be executed in the same event manager as the <code>channelId</code> callbacks. Return 0 on success and a non-zero value otherwise; the return value of 1 is indicates that a clock with the specified <code>clockId</code> is already registered. Note that if <code>channelId</code> is provided and does not correspond to an active channel, a non-zero value not equal to 1 is returned, even if a clock with the specified <code>clockId</code> is already registered. </p>

</div>
</div>
<a class="anchor" id="aa826022df4f88f6f379e9d653816c38f"></a><!-- doxytag: member="btlmt::ChannelPool::deregisterClock" ref="aa826022df4f88f6f379e9d653816c38f" args="(int clockId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::deregisterClock </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>clockId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Deregister the clock having the specified <code>clockId</code>. </p>

</div>
</div>
<a class="anchor" id="a3f9df8c2b519ddd50f5f3fbdad82d49b"></a><!-- doxytag: member="btlmt::ChannelPool::getLingerOption" ref="a3f9df8c2b519ddd50f5f3fbdad82d49b" args="(btlso::SocketOptUtil::LingerData *result, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::getLingerOption </td>
          <td>(</td>
          <td class="paramtype">btlso::SocketOptUtil::LingerData *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code>, the value of the linger option for the channel having the specified <code>channelId</code>. Return 0 on success and a non-zero value otherwise. The behavior is undefined if <code>result</code> is 0. </p>

</div>
</div>
<a class="anchor" id="ad7640576cb50c195c9eb63ac7da4a191"></a><!-- doxytag: member="btlmt::ChannelPool::getServerSocketOption" ref="ad7640576cb50c195c9eb63ac7da4a191" args="(int *result, int option, int level, int serverId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::getServerSocketOption </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serverId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the value of the specified <code>option</code> of the specified <code>level</code> socket option on the server socket having the specified <code>serverId</code>. Return 0 on success and a non-zero value otherwise. (See <code><a class="el" href="structbtlso_1_1SocketOptUtil.html">btlso::SocketOptUtil</a></code> for the set of commonly-used options.) </p>

</div>
</div>
<a class="anchor" id="aef093c300ce7e3c0dac25a6cc37dbbee"></a><!-- doxytag: member="btlmt::ChannelPool::getSocketOption" ref="aef093c300ce7e3c0dac25a6cc37dbbee" args="(int *result, int option, int level, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::getSocketOption </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the value of the specified <code>option</code> of the specified <code>level</code> socket option on the channel having the specified <code>channelId</code>. Return 0 on success and a non-zero value otherwise. (See <code><a class="el" href="structbtlso_1_1SocketOptUtil.html">btlso::SocketOptUtil</a></code> for the set of commonly-used options.) </p>

</div>
</div>
<a class="anchor" id="ae31534e6fc3cc182cd9080fb18d4c66b"></a><!-- doxytag: member="btlmt::ChannelPool::setLingerOption" ref="ae31534e6fc3cc182cd9080fb18d4c66b" args="(const btlso::SocketOptUtil::LingerData &amp;value, int channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::setLingerOption </td>
          <td>(</td>
          <td class="paramtype">const btlso::SocketOptUtil::LingerData &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the linger option on the channel with the specified <code>channelId</code> to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. </p>

</div>
</div>
<a class="anchor" id="a709b48e531908bb177f628c2d9f15e25"></a><!-- doxytag: member="btlmt::ChannelPool::setServerSocketOption" ref="a709b48e531908bb177f628c2d9f15e25" args="(int option, int level, int value, int serverId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::setServerSocketOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serverId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>option</code> (of the specified <code>level</code>) socket option on the listening socket with the specified <code>serverId</code> to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. (See <code>btlso_socketoptutil</code> for the list of commonly supported options.) </p>

</div>
</div>
<a class="anchor" id="aee4651e44e45d98cb2e5287b680b028c"></a><!-- doxytag: member="btlmt::ChannelPool::setSocketOption" ref="aee4651e44e45d98cb2e5287b680b028c" args="(int option, int level, int value, int channelId)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::setSocketOption </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>option</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the specified <code>option</code> (of the specified <code>level</code>) socket option on the channel with the specified <code>channelId</code> to the specified <code>value</code>. Return 0 on success and a non-zero value otherwise. (See <code>btlso_socketoptutil</code> for the list of commonly supported options.) </p>

</div>
</div>
<a class="anchor" id="aff75406feb0a0c61810910b2f6572f79"></a><!-- doxytag: member="btlmt::ChannelPool::reportWeightedAverageReset" ref="aff75406feb0a0c61810910b2f6572f79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double btlmt::ChannelPool::reportWeightedAverageReset </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the weighted average of the connections lifetime since the previous call to this method or, for the first call, since this object construction, if at least one millisecond passed since then, otherwise return -1. If all the connections at the time of the call have been up during the considered period of time and were already up at the time of the previous reset, this method will return the same number as <code><a class="el" href="classbtlmt_1_1ChannelPool.html#ac1fc615b49f8225adca933939a0d9c86">numChannels()</a></code>. 0 means that they were all down. </p>

</div>
</div>
<a class="anchor" id="a70034197bc350050cf1adb38598a7dad"></a><!-- doxytag: member="btlmt::ChannelPool::totalBytesReadReset" ref="a70034197bc350050cf1adb38598a7dad" args="(bsls::Types::Int64 *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::totalBytesReadReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, and atomically reset the total number of bytes read by the pool. </p>

</div>
</div>
<a class="anchor" id="a9645d5b71ad58578bc6aa885d5e346ef"></a><!-- doxytag: member="btlmt::ChannelPool::totalBytesWrittenReset" ref="a9645d5b71ad58578bc6aa885d5e346ef" args="(bsls::Types::Int64 *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::totalBytesWrittenReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, and atomically reset the total number of bytes written by the pool. </p>

</div>
</div>
<a class="anchor" id="ad08c54c59a94d8d97df5a3345c7f3bb8"></a><!-- doxytag: member="btlmt::ChannelPool::totalBytesRequestedToBeWrittenReset" ref="ad08c54c59a94d8d97df5a3345c7f3bb8" args="(bsls::Types::Int64 *result)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::totalBytesRequestedToBeWrittenReset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, and atomically reset the total number of bytes requested to be written by the pool. </p>

</div>
</div>
<a class="anchor" id="a06966c1669bd289e6e2773090d421523"></a><!-- doxytag: member="btlmt::ChannelPool::busyMetrics" ref="a06966c1669bd289e6e2773090d421523" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::busyMetrics </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the (percent) value in the range [0..100] (inclusive) that reflects the workload of this channel pool (e.g., how busy it is for the last period). If the <code>collectTimeMetrics</code> property of the configuration supplied at construction is <code>false</code> (i.e., the collection of time metrics has been disable), then the returned value is unspecified. The value 0 indicates that the pool is idle and 100 indicates that pool operates at the configured capacity. </p>

</div>
</div>
<a class="anchor" id="af9a07d7b2587d0e7d7095f74aa4e6df9"></a><!-- doxytag: member="btlmt::ChannelPool::channelContext" ref="af9a07d7b2587d0e7d7095f74aa4e6df9" args="(int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* btlmt::ChannelPool::channelContext </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a user-defined channel context associated with the specified <code>channelId</code>, and <code>(void *)0</code> if no such channel exists or the user context for this channel was explicitly set to <code>(void *)0</code>. </p>

</div>
</div>
<a class="anchor" id="a5932e38ce2eac477b70a68253b17f643"></a><!-- doxytag: member="btlmt::ChannelPool::getChannelStatistics" ref="a5932e38ce2eac477b70a68253b17f643" args="(bsls::Types::Int64 *numRead, bsls::Types::Int64 *numRequestedToBeWritten, bsls::Types::Int64 *numWritten, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::getChannelStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>numRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>numRequestedToBeWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>numWritten</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>numRead</code>, <code>numRequestedToBeWritten</code> and <code>numWritten</code> respectively the number of bytes read, requested to be written and written by the channel identified by the specified <code>channelId</code> and return 0 if the specified <code>channelId</code> is a valid channel id. Otherwise, return a non-zero value. Note that for performance reasons this <em>sequence</em> is not captured atomically: by the time one of the values is captured, another may already have changed. </p>

</div>
</div>
<a class="anchor" id="a8357fc0afeaefa31bb4a94e2f53972cb"></a><!-- doxytag: member="btlmt::ChannelPool::getChannelWriteQueueStatistics" ref="a8357fc0afeaefa31bb4a94e2f53972cb" args="(int *recordedMaxWriteQueueSize, int *currentWriteQueueSize, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::getChannelWriteQueueStatistics </td>
          <td>(</td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>recordedMaxWriteQueueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>currentWriteQueueSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>recordedMaxWriteQueueSize</code> and <code>currentWriteQueueSize</code> the maximum and current size respectively of the write queue of the channel identified by the specified <code>channelId</code> and return 0 if the specified <code>channelId</code> is a valid channel id. Otherwise, return a non-zero value. Note that for performance reasons this <em>sequence</em> is not captured atomically: by the time one of the values is captured, another may already have changed. </p>

</div>
</div>
<a class="anchor" id="a0e7d14a2feab639f3c48775859816a98"></a><!-- doxytag: member="btlmt::ChannelPool::getHandleStatistics" ref="a0e7d14a2feab639f3c48775859816a98" args="(bsl::vector&lt; HandleInfo &gt; *handleInfo) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::getHandleStatistics </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbsl_1_1vector.html">bsl::vector</a>&lt; <a class="el" href="structbtlmt_1_1ChannelPool_1_1HandleInfo.html">HandleInfo</a> &gt; *&nbsp;</td>
          <td class="paramname"> <em>handleInfo</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Append to the specified <code>handleInfo</code> array a snapshot of the information per socket handle currently in use by this channel pool. Note that a socket handle <code>fd</code> is in use for one of five possible reasons: <br/>
<br/>
</p>
<div class="fragment"><pre class="fragment">          Reason                               d_channelType      d_userId
          ------                               -------------      --------
          1. This channel pool is listening    LISTENING_CHANNEL  serverId
             on <span class="stringliteral">&#39;fd&#39;</span>, with a given <span class="stringliteral">&#39;serverId&#39;</span>

          2. <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> channel was created as the      ACCEPTED_CHANNEL   serverId
             result of a connection to the
             server with the given <span class="stringliteral">&#39;serverId&#39;</span>

          3. This channel pool is connecting   CONNECTING_CHANNEL sourceId
             <span class="keyword">using</span> a connection socket with
             the socket handle <span class="stringliteral">&#39;fd&#39;</span>, with a
             a given <span class="stringliteral">&#39;sourceId&#39;</span>

          4. <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> channel was created as the      CONNECTED_CHANNEL  sourceId
             result of a call to <span class="stringliteral">&#39;connect&#39;</span>
             with the given <span class="stringliteral">&#39;sourceId&#39;</span>

          5. <a class="code" href="bdlf__bind__test_8h.html#a2487e64b489c5eaa866ce223b64a6713">A</a> channel was created as the      IMPORTED_CHANNEL   sourceId
             result of a call to <span class="stringliteral">&#39;import&#39;</span>
             with the given <span class="stringliteral">&#39;sourceId&#39;</span>
</pre></div><p><br/>
<br/>
 Also note that there is no specified order in which <code>handleInfo</code> is updated. Finally note that entries are appended to <code>handleInfo</code>; clear this vector prior to calling this function if desired. </p>

</div>
</div>
<a class="anchor" id="a8396fbe29ba0a3991785561b2fb6d144"></a><!-- doxytag: member="btlmt::ChannelPool::getServerAddress" ref="a8396fbe29ba0a3991785561b2fb6d144" args="(btlso::IPv4Address *result, int serverId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::getServerAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>serverId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the complete IP address associated with the server with the specified <code>serverId</code> that is managed by this channel pool if the server is established. Return 0 on success, and a non-zero value with no effect on <code>result</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a8826b9c5b495596fa1ff4e00194eb61e"></a><!-- doxytag: member="btlmt::ChannelPool::getLocalAddress" ref="a8826b9c5b495596fa1ff4e00194eb61e" args="(btlso::IPv4Address *result, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::getLocalAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the complete IP address associated with the local (i.e., this process) end-point of the communication channel having the specified <code>channelId</code>. Return 0 on success, and a non-zero value with no effect on <code>result</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="a5f7c3df656838e55d799eb56e1bf59d9"></a><!-- doxytag: member="btlmt::ChannelPool::getPeerAddress" ref="a5f7c3df656838e55d799eb56e1bf59d9" args="(btlso::IPv4Address *result, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::getPeerAddress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load into the specified <code>result</code> the complete IP address associated with the remote (i.e., peer process) end-point of the communication channel having the specified <code>channelId</code>. Return 0 on success, and a non-zero value with no effect on <code>result</code> otherwise. </p>

</div>
</div>
<a class="anchor" id="ab14d12826959c644b2f443d383b46f18"></a><!-- doxytag: member="btlmt::ChannelPool::numBytesRead" ref="ab14d12826959c644b2f443d383b46f18" args="(bsls::Types::Int64 *result, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::numBytesRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, the number of bytes read by the channel identified by the specified <code>channelId</code> and return 0 if the specified <code>channelId</code> is a valid channel id. Otherwise, return a non-zero value. </p>

</div>
</div>
<a class="anchor" id="a33b8fab61338282aa5d77d84c0a592a2"></a><!-- doxytag: member="btlmt::ChannelPool::numBytesWritten" ref="a33b8fab61338282aa5d77d84c0a592a2" args="(bsls::Types::Int64 *result, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::numBytesWritten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, the number of bytes written by the channel identified by the specified <code>channelId</code> and return 0 if the specified <code>channelId</code> is a valid channel id. Otherwise, return a non-zero value. </p>

</div>
</div>
<a class="anchor" id="af9ec12dde1917cd418426e7d444ebf2f"></a><!-- doxytag: member="btlmt::ChannelPool::numBytesRequestedToBeWritten" ref="af9ec12dde1917cd418426e7d444ebf2f" args="(bsls::Types::Int64 *result, int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::numBytesRequestedToBeWritten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, the number of bytes requested to be written by the channel identified by the specified <code>channelId</code> and return 0 if the specified <code>channelId</code> is a valid channel id. Otherwise, return a non-zero value. </p>

</div>
</div>
<a class="anchor" id="ac1fc615b49f8225adca933939a0d9c86"></a><!-- doxytag: member="btlmt::ChannelPool::numChannels" ref="ac1fc615b49f8225adca933939a0d9c86" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::numChannels </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of channels currently managed by this channel pool. </p>

</div>
</div>
<a class="anchor" id="ab0274bc2f9557f99dfc036c428b53898"></a><!-- doxytag: member="btlmt::ChannelPool::numEvents" ref="ab0274bc2f9557f99dfc036c428b53898" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::numEvents </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of events currently registered with an event manager corresponding to the specified <code>index</code>. The behavior is undefined unless <code>0 &lt;= index &lt; numThreads</code>. </p>

</div>
</div>
<a class="anchor" id="aadfd61a0a4b47f4d370ad72a902d1a2a"></a><!-- doxytag: member="btlmt::ChannelPool::numThreads" ref="aadfd61a0a4b47f4d370ad72a902d1a2a" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int btlmt::ChannelPool::numThreads </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of threads currently managed by this channel pool. Note that each thread corresponds to a single event manager, and, therefore, the number of threads is the number of active event managers. </p>

</div>
</div>
<a class="anchor" id="a53d4c9f64dd9cde4050c29c65b57f08a"></a><!-- doxytag: member="btlmt::ChannelPool::streamSocket" ref="a53d4c9f64dd9cde4050c29c65b57f08a" args="(int channelId) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbsl_1_1shared__ptr.html">bsl::shared_ptr</a>&lt;const <a class="el" href="classbtlso_1_1StreamSocket.html">btlso::StreamSocket</a>&lt;<a class="el" href="classbtlso_1_1IPv4Address.html">btlso::IPv4Address</a>&gt; &gt; btlmt::ChannelPool::streamSocket </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>channelId</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return a shared pointer to the non-modifiable stream socket associated with the specified <code>channelId</code>, and an empty shared pointer if a corresponding channel does not exist. The returned shared pointer is aliased to the underlying channel and the channel will not be closed until this shared pointer is destroyed. Therefore, it is important that clients carefully manage the lifetime of the returned shared pointer. The behavior of this channel pool is undefined if the underlying socket is manipulated while still under management by this channel pool. </p>

</div>
</div>
<a class="anchor" id="a8c8f9816c654d3322d3c1e1d31ec6a0d"></a><!-- doxytag: member="btlmt::ChannelPool::totalBytesRead" ref="a8c8f9816c654d3322d3c1e1d31ec6a0d" args="(bsls::Types::Int64 *result) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::totalBytesRead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, the total number of bytes read by the pool. </p>

</div>
</div>
<a class="anchor" id="ae35ba536be3e983f67fa90cba4537c0d"></a><!-- doxytag: member="btlmt::ChannelPool::totalBytesRequestedToBeWritten" ref="ae35ba536be3e983f67fa90cba4537c0d" args="(bsls::Types::Int64 *result) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::totalBytesRequestedToBeWritten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, the total number of bytes requested to be written by the pool. </p>

</div>
</div>
<a class="anchor" id="a7cf70cf524621d33e60decdda28851cf"></a><!-- doxytag: member="btlmt::ChannelPool::totalBytesWritten" ref="a7cf70cf524621d33e60decdda28851cf" args="(bsls::Types::Int64 *result) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void btlmt::ChannelPool::totalBytesWritten </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Load, into the specified <code>result</code>, the total number of bytes written by the pool. </p>

</div>
</div>
<hr/><h2>Friends And Related Function Documentation</h2>
<a class="anchor" id="ac47342240f21ce36f47485e4ab41a10d"></a><!-- doxytag: member="btlmt::ChannelPool::Channel" ref="ac47342240f21ce36f47485e4ab41a10d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">friend class Channel<code> [friend]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="btlmt__channelpool_8h_source.html">btlmt_channelpool.h</a></li>
</ul>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:51:13 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
