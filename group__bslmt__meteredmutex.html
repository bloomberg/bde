<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 3.0: bslmt_meteredmutex Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bal.html" target="_blank">bal</a> | <a class="qindex" href="group__bbl.html" target="_blank">bbl</a> | <a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a> | <a class="qindex" href="group__btl.html" target="_blank">btl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslmt_meteredmutex<br/>
<small>
[<a class="el" href="group__bslmt.html">Package bslmt</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide a mutex capable of keeping track of wait and hold time.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmt.html">bslmt</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Precise Definitions of Wait and Hold Time</a> </li>
<li>
<a href="#3.2">Performance</a> </li>
<li>
<a href="#3.3">Inaccuracy of <code>waitTime</code> and <code>holdTime</code></a> </li>
<li>
<a href="#3.4">Usage</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide a mutex capable of keeping track of wait and hold time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslmt_1_1MeteredMutex.html">bslmt::MeteredMutex</a> </td><td>mutex capable of keeping track of wait and hold time  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This component provides a class, <code><a class="el" href="classbslmt_1_1MeteredMutex.html">bslmt::MeteredMutex</a></code>, that functions as a mutex and has additional capability to keep track of wait time and hold time. This class can be used, for example, in evaluating the performance of an application, based on its lock contention behavior. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="precise_definitions_of_wait_and_hold_time"></a> <a class="anchor" id="description.precise_definitions_of_wait_and_hold_time"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Precise Definitions of Wait and Hold Time: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Wait time is defined as the sum of the time intervals between each call to <code>lock</code> (or <code>tryLock</code>) on the underlying mutex and the return of that call. Note that if one or more threads are waiting for the lock at the point when <code>waitTime</code> is called, those waiting time intervals are <em>not</em> included in the returned wait time. Hold time is defined as the sum of the time intervals between return from each call to <code>lock</code> (or a successful call to <code>tryLock</code>) on the underlying mutex and the subsequent call to <code>unlock</code>. Note that if a thread is holding the lock at the point when <code>holdTime</code> is called, then that holding time is <em>not</em> included in the returned hold time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="performance"></a> <a class="anchor" id="description.performance"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Performance: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>It should be noted that the overhead in keeping track of wait and hold time is very small. We do not use additional mutexes to manipulate these times, instead, we use atomic data types (which have very small overhead compared to a mutex) to update these times atomically. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="inaccuracy_of_waittime_and_holdtime"></a> <a class="anchor" id="description.inaccuracy_of_waittime_and_holdtime"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Inaccuracy of waitTime and holdTime: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Times reported by <code>waitTime</code> and <code>holdTime</code> are (close) approximate times and <em>not</em> 100% accurate. This inaccuracy can sometime cause surprising behavior. For example, one can incorrectly assume <code>lock()</code> and <code>while (tryLock() != 0);</code> to be effectively the same (both disallowing the thread to advance until the lock is acquired) but the wait time reported in the first case can be much more accurate than that of the second because the <code>lock</code> is called only once (and thus computation error is introduced only once) in the first case. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>In the following example, we have <code>NUM_THREADS</code> threads (that are sequentially numbered from <code>0</code> to <code>NUM_THREADS-1</code>) and two counters <code>evenCount</code> and <code>oddCount</code>. <code>evenCount</code> is incremented by the even numbered threads and <code>oddCount</code> is incremented by the odd ones. We considers two strategies to increment these counters. In the first strategy (strategy1), we use two mutexes (one for each counter) and in the second strategy (strategy2), we use a single mutex for both counters. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> oddCount = 0;
  <span class="keywordtype">int</span> evenCount = 0;

  <span class="keyword">typedef</span> <a class="code" href="classbslmt_1_1MeteredMutex.html">bslmt::MeteredMutex</a> Obj;
  Obj oddMutex;
  Obj evenMutex;
  Obj globalMutex;

  <span class="keyword">enum</span> { k_USAGE_NUM_THREADS = 4, k_USAGE_SLEEP_TIME = 100000 };
  <a class="code" href="classbslmt_1_1Barrier.html">bslmt::Barrier</a> usageBarrier(k_USAGE_NUM_THREADS);

  <span class="keywordtype">void</span> executeInParallel(<span class="keywordtype">int</span>                               numThreads,
                         <a class="code" href="structbslmt_1_1ThreadUtil.html#a01c7a6983e80799b2f5ed11471543dd1">bslmt::ThreadUtil::ThreadFunction</a> function)
      <span class="comment">// Create the specified &#39;numThreads&#39;, each executing the specified</span>
      <span class="comment">// &#39;function&#39;.  Number each thread (sequentially from 0 to</span>
      <span class="comment">// &#39;numThreads - 1&#39;) by passing i to i&#39;th thread.  Finally join all the</span>
      <span class="comment">// threads.</span>
  {
      <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a> *threads =
                                   <span class="keyword">new</span> <a class="code" href="structbslmt_1_1ThreadUtil.html#a3ed7de89fef3498278c0b4f8225217b9">bslmt::ThreadUtil::Handle</a>[numThreads];
      assert(threads);

      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numThreads; ++i) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a3948c1f54b2420a8e6b3d9a0821c8190">bslmt::ThreadUtil::create</a>(&amp;threads[i], function, (<span class="keywordtype">void</span>*)i);
      }
      <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; numThreads; ++i) {
          <a class="code" href="structbslmt_1_1ThreadUtil.html#a6080ed163948384d869f136bff12e248">bslmt::ThreadUtil::join</a>(threads[i]);
      }

      <span class="keyword">delete</span> [] threads;
  }

  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
      <span class="keywordtype">void</span> *strategy1(<span class="keywordtype">void</span> *arg)
      {
          usageBarrier.wait();
          <span class="keywordtype">int</span> remainder = (int)(<a class="code" href="structbsls_1_1Types.html#a8cfbbf00c2f5f99acc20d12b777326ce">bsls::Types::IntPtr</a>)arg % 2;
          <span class="keywordflow">if</span> (remainder == 1) {
              oddMutex.lock();
              ++oddCount;
              <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(k_USAGE_SLEEP_TIME);
              oddMutex.unlock();
          }
          <span class="keywordflow">else</span> {
              evenMutex.lock();
              ++evenCount;
              <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(k_USAGE_SLEEP_TIME);
              evenMutex.unlock();
          }
          <span class="keywordflow">return</span> NULL;
      }
  } <span class="comment">// extern &quot;C&quot;</span>

  <span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {
      <span class="keywordtype">void</span> *strategy2(<span class="keywordtype">void</span> *arg)
      {
          usageBarrier.wait();
          <span class="keywordtype">int</span> remainder = (int)(<a class="code" href="structbsls_1_1Types.html#a8cfbbf00c2f5f99acc20d12b777326ce">bsls::Types::IntPtr</a>)arg % 2;
          <span class="keywordflow">if</span> (remainder == 1) {
              globalMutex.lock();
              ++oddCount;
              <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(k_USAGE_SLEEP_TIME);
              globalMutex.unlock();
          }
          <span class="keywordflow">else</span> {
              globalMutex.lock();
              ++evenCount;
              <a class="code" href="structbslmt_1_1ThreadUtil.html#a4e6a840e495c3afa38474a2dcc073286">bslmt::ThreadUtil::microSleep</a>(k_USAGE_SLEEP_TIME);
              globalMutex.unlock();
          }
          <span class="keywordflow">return</span> NULL;
      }
  } <span class="comment">// extern &quot;C&quot;</span>
</pre></div><br/>
<br/>
 Then in the application <code>main</code>: <br/>
<br/>
<div class="fragment"><pre class="fragment">  executeInParallel(k_USAGE_NUM_THREADS, strategy1);
  <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> waitTimeForStrategy1 =
                                  oddMutex.waitTime() + evenMutex.waitTime();

  executeInParallel(k_USAGE_NUM_THREADS, strategy2);
  <a class="code" href="structbsls_1_1Types.html#aa382f43d8a0be6193c86ef5c82886c12">bsls::Types::Int64</a> waitTimeForStrategy2 = globalMutex.waitTime();

  assert(waitTimeForStrategy2 &gt; waitTimeForStrategy1);
  <span class="keywordflow">if</span> (veryVerbose) {
      <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a>(waitTimeForStrategy1);
      <a class="code" href="bdlf__bind__test_8h.html#a6dce1d51457f0415ec5302d3c05cded5">P</a>(waitTimeForStrategy2);
  }
</pre></div><br/>
<br/>
 We measured the wait times for each strategy. Intuitively, the wait time for the second strategy should be greater than that of the first. The output was consistent with our expectation. <br/>
<br/>
<div class="fragment"><pre class="fragment"> waitTimeForStrategy1 = 400787000
 waitTimeForStrategy2 = 880765000
</pre></div><br/>
<br/>
 </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Fri Apr 1 2016 16:49:00 for BDE Release 3.0 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
