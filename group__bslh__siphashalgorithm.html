<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>BDE 2.23.1 OSS: bslh_siphashalgorithm Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
    <style>
      div.hanging {
        padding-left: 0.75in;
        text-indent: -0.50in;
      }
      div.unhanging {
        text-indent:     0in;
      }
      a.glossary {
        font-weight: bold;
        font-style: italic;
      }
    </style>
</head>
<!--
<body onload='searchBox.OnSelectItem(0);'>
-->
<body>

<table border=2 cellspacing=0 cellpadding=0 align=center>
<tr>
 <td valign=top align=center>
 <p align=center><b><i>Quick Links:</i></b></p>
 </td>
 <td valign=top align=center>
 <p align=center>
<a class="qindex" href="group__bdl.html" target="_blank">bdl</a> | <a class="qindex" href="group__bsl.html" target="_blank">bsl</a>
 </td>
 </tr>
 </table>

  </div>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="components.html"><span>Components</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a>  </div>
  <div class="headertitle">
<h1>Component bslh_siphashalgorithm<br/>
<small>
[<a class="el" href="group__bslh.html">Package bslh</a>]</small>
</h1>  </div>
</div>
<div class="contents">

<p>Provide an implementation of the SipHash algorithm.  
<a href="#_details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslh.html">bslh</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebslmf.html">bslmf</a></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<dl class="user"><dt><b>Outline</b></dt><dd><ul>
<li>
<a href="#1">Purpose</a> </li>
<li>
<a href="#2">Classes</a> </li>
<li>
<a href="#3">Description</a> <ul>
<li>
<a href="#3.1">Security</a> <ul>
<li>
<a href="#3.1.1">Denial of Service (DoS) Protection</a> </li>
</ul>
</li>
<li>
<a href="#3.2">Speed</a> </li>
<li>
<a href="#3.3">Hash Distribution</a> </li>
<li>
<a href="#3.4">Hash Consistency</a> </li>
<li>
<a href="#3.5">Usage</a> <ul>
<li>
<a href="#3.5.1">Example: Creating and Using a Hash Table containing User Input</a> </li>
</ul>
</li>
<li>
<a href="#3.6">Changes</a> </li>
<li>
<a href="#3.7">Third Party Doc</a> </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="purpose"></a> <a class="anchor" id="1"></a> </dd></dl>
<dl class="user"><dt><b>Purpose: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Provide an implementation of the SipHash algorithm. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="classes"></a> <a class="anchor" id="2"></a> </dd></dl>
<dl class="user"><dt><b>Classes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><table class="doxtable">
<tr>
<td><a class="el" href="classbslh_1_1SipHashAlgorithm.html">bslh::SipHashAlgorithm</a> </td><td>functor implementing the SipHash algorithm  </td></tr>
</table>
</dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__bslh__hash.html" title="Provide a struct to run bslh hash algorithms on supported types.">Component bslh_hash</a> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="description"></a> <a class="anchor" id="3"></a> </dd></dl>
<dl class="user"><dt><b>Description: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><code><a class="el" href="classbslh_1_1SipHashAlgorithm.html">bslh::SipHashAlgorithm</a></code> implements the SipHash algorithm. SipHash is an algorithm designed for speed and security. A primary use case for this algorithm is to provide an extra line of defense in hash tables (such as the hash table that is used to implement <code>unordered_map</code>) against malicious input that could cause Denial of Service (DoS) attacks. It is based on one of the finalists for the SHA-3 cryptographic hash standard. Full details of the hash function can be found here: <a href="https://131002.net/siphash/siphash.pdf">https://131002.net/siphash/siphash.pdf</a> This particular implementation has been derived from Howard Hinnant's work here: <a href="https://github.com/HowardHinnant/hash_append/blob/master/siphash.h">https://github.com/HowardHinnant/hash_append/blob/master/siphash.h</a> and as much of the original code as possible, including comment headers, has been preserved. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This class satisfies the requirements for seeded <code>bslh</code> hashing algorithms, defined in <code><a class="el" href="bslh__seededhash_8h.html" title="Provide a struct to run seeded bslh hash algorithms on types.">bslh_seededhash.h</a></code>. More information can be found in the package level documentation for <code>bslh</code> (internal users can also find information here {TEAM BDE:USING MODULAR HASHING&lt;GO&gt;}) </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="security"></a> <a class="anchor" id="description.security"></a> <a class="anchor" id="3.1"></a> </dd></dl>
<dl class="user"><dt><b>Security: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>SipHash is <em>not</em> a cryptographically secure hash. In the paper linked above, the creators of this hash function describe it as "Cryptographically
 Strong", but explicitly avoid calling it cryptographically secure. In order to be cryptographically secure, and algorithm must, among other things, provide "collision resistance". "Collision resistance" means that it should be difficult to find two different messages m1 and m2 such that <code>hash(m1) == hash(m2)</code>. Because of the limited sized output (only 2^64 possibilities) and the fast execution time of the algorithm, it is feasible to find collisions by brute force, making the algorithm not cryptographically secure. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>SipHash <em>is</em>, however, a cryptographically strong PRF (pseudo-random function). This means, assuming a cryptographically secure random seed is given, the output of this algorithm will be indistinguishable from a uniform random distribution. This property is enough for the algorithm to be able to protect a hash table from malicious Denial of Service (DoS) attacks. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="denial_of_service_(dos)_protection"></a> <a class="anchor" id="security.denial_of_service_(dos)_protection"></a> <a class="anchor" id="description.security.denial_of_service_(dos)_protection"></a> <a class="anchor" id="3.1.1"></a> </dd></dl>
<dl class="user"><dt><b>Denial of Service (DoS) Protection: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Given a cryptographically secure seed, this algorithm will produce hashes with a distribution that is indistinguishable from random. This distribution means that there is no way for an attacker to predict which keys will cause collisions, meaning that this algorithm can help mitigate Denial of Service (DoS) attacks on a hash table. DoS attacks occur when an attacker deliberately degrades the performance of the hash table by inserting data that will collide to the same bucket, causing an average constant time lookup to become a linear search. This protection is only effective if the seed provided is a cryptographically secure random number that is not available to the attacker. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="speed"></a> <a class="anchor" id="description.speed"></a> <a class="anchor" id="3.2"></a> </dd></dl>
<dl class="user"><dt><b>Speed: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This algorithm is designed to be fast in comparison to other algorithms making similar guarantees. It is still slower than other commonly accepted and used hashes such as SpookyHash. This algorithm should only be used when protection from malicious input is required. Otherwise, an algorithm that documents better performance properties should be used, such as <code><a class="el" href="classbslh_1_1SpookyHashAlgorithm.html">bslh::SpookyHashAlgorithm</a></code>. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hash_distribution"></a> <a class="anchor" id="description.hash_distribution"></a> <a class="anchor" id="3.3"></a> </dd></dl>
<dl class="user"><dt><b>Hash Distribution: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Output hashes will be well distributed and will avalanche, which means changing one bit of the input will change approximately 50% of the output bits. This will prevent similar values from funneling to the same hash or bucket. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="hash_consistency"></a> <a class="anchor" id="description.hash_consistency"></a> <a class="anchor" id="3.4"></a> </dd></dl>
<dl class="user"><dt><b>Hash Consistency: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This hash algorithm is endian-specific. The algorithm will run on big- and little-endian machines and the above guarantees apply on both architectures, however, the hashes produced will be different. Therefor it is not recommended to send hashes from <code><a class="el" href="classbslh_1_1SipHashAlgorithm.html">bslh::SipHashAlgorithm</a></code> over a network. It is also not recommended to write hashes from <code><a class="el" href="classbslh_1_1SipHashAlgorithm.html">bslh::SipHashAlgorithm</a></code> to any memory accessible by multiple machines. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="usage"></a> <a class="anchor" id="description.usage"></a> <a class="anchor" id="3.5"></a> </dd></dl>
<dl class="user"><dt><b>Usage: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>This section illustrates intended usage of this component. </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="example~3A_creating_and_using_a_hash_table_containing_user_input"></a> <a class="anchor" id="usage.example~3A_creating_and_using_a_hash_table_containing_user_input"></a> <a class="anchor" id="description.usage.example~3A_creating_and_using_a_hash_table_containing_user_input"></a> <a class="anchor" id="example"></a> <a class="anchor" id="usage.example"></a> <a class="anchor" id="description.usage.example"></a> <a class="anchor" id="3.5.1"></a> </dd></dl>
<dl class="user"><dt><b>Example: Creating and Using a Hash Table containing User Input: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>Suppose we have any array of types that define <code>operator==</code>, and we want a fast way to find out if values are contained in the array. We can create a <code>HashTable</code> data structure that is capable of looking up values in O(1) time. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Further suppose that we will be storing arbitrary user input in our table. It is possible that an attacker with knowledge of the hashing algorithm we are using could specially craft input that will cause collisions in our hash table, degrading performance to O(n). To avoid this we will need to use a secure hash algorithm with a random seed. This algorithm will need to be in the form of a hash functor -- an object that will take objects stored in our array as input, and yield an integer value which is hard enough for an outside observer to predict that it appear random. The functor can pass the attributes of the <code>TYPE</code> that are salient to hashing into the hashing algorithm, and then return the hash that is produced. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>We can use the result of the hash function to index into our array of <code>buckets</code>. Each <code>bucket</code> is simply a pointer to a value in our original array of <code>TYPE</code> objects. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>First, we define our <code>HashTable</code> template class, with the two type parameters: <code>TYPE</code> (the type being referenced) and <code>HASHER</code> (a functor that produces the hash). <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">template</span> &lt;<span class="keyword">class</span> TYPE, <span class="keyword">class</span> HASHER&gt;
  <span class="keyword">class </span>HashTable {
      <span class="comment">// This class template implements a hash table providing fast lookup of</span>
      <span class="comment">// an external, non-owned, array of values of (template parameter)</span>
      <span class="comment">// &#39;TYPE&#39;.</span>
      <span class="comment">//</span>
      <span class="comment">// The (template parameter) &#39;TYPE&#39; shall have a transitive, symmetric</span>
      <span class="comment">// &#39;operator==&#39; function.  There is no requirement that it have any</span>
      <span class="comment">// kind of creator defined.</span>
      <span class="comment">//</span>
      <span class="comment">// The &#39;HASHER&#39; template parameter type must be a functor with a method</span>
      <span class="comment">// having the following signature:</span>
      <span class="comment">//..</span>
      <span class="comment">//  size_t operator()(TYPE)  const;</span>
      <span class="comment">//                   -OR-</span>
      <span class="comment">//  size_t operator()(const TYPE&amp;) const;</span>
      <span class="comment">//..</span>
      <span class="comment">// and &#39;HASHER&#39; shall have a publicly accessible default constructor</span>
      <span class="comment">// and destructor.</span>
      <span class="comment">//</span>
      <span class="comment">// Note that this hash table has numerous simplifications because we</span>
      <span class="comment">// know the size of the array and never have to resize the table.</span>

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> TYPE       *d_values;             <span class="comment">// Array of values table is to</span>
                                              <span class="comment">// hold</span>
      <span class="keywordtype">size_t</span>            d_numValues;          <span class="comment">// Length of &#39;d_values&#39;.</span>
      <span class="keyword">const</span> TYPE      **d_bucketArray;        <span class="comment">// Contains ptrs into</span>
                                              <span class="comment">// &#39;d_values&#39;</span>
      <span class="keywordtype">unsigned</span>          d_bucketArrayMask;    <span class="comment">// Will always be &#39;2^N - 1&#39;.</span>
      HASHER            d_hasher;

    <span class="keyword">private</span>:
      <span class="comment">// PRIVATE ACCESSORS</span>
      <span class="keywordtype">bool</span> lookup(<span class="keywordtype">size_t</span>      *idx,
                  <span class="keyword">const</span> TYPE&amp;  value,
                  <span class="keywordtype">size_t</span>       hashValue) <span class="keyword">const</span>;
          <span class="comment">// Look up the specified &#39;value&#39;, having the specified &#39;hashValue&#39;,</span>
          <span class="comment">// and load its index in &#39;d_bucketArray&#39; into the specified &#39;idx&#39;.</span>
          <span class="comment">// If not found, return the vacant entry in &#39;d_bucketArray&#39; where</span>
          <span class="comment">// it should be inserted.  Return &#39;true&#39; if &#39;value&#39; is found and</span>
          <span class="comment">// &#39;false&#39; otherwise.</span>

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      HashTable(<span class="keyword">const</span> TYPE *valuesArray,
                <span class="keywordtype">size_t</span>      numValues);
          <span class="comment">// Create a hash table referring to the specified &#39;valuesArray&#39;</span>
          <span class="comment">// having length of the specified &#39;numValues&#39;.  No value in</span>
          <span class="comment">// &#39;valuesArray&#39; shall have the same value as any of the other</span>
          <span class="comment">// values in &#39;valuesArray&#39;</span>

      ~HashTable();
          <span class="comment">// Free up memory used by this hash table.</span>

      <span class="comment">// ACCESSORS</span>
      <span class="keywordtype">bool</span> contains(<span class="keyword">const</span> TYPE&amp; value) <span class="keyword">const</span>;
          <span class="comment">// Return true if the specified &#39;value&#39; is found in the table and</span>
          <span class="comment">// false otherwise.</span>
  };
</pre></div><br/>
<br/>
 Then, we define a <code>Future</code> class, which holds a cstring <code>name</code>, char <code>callMonth</code>, and short <code>callYear</code>. This class can be used to store custom futures that the users have uploaded. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span>Future {
      <span class="comment">// This class identifies a future contract.  It tracks the name, call</span>
      <span class="comment">// month and year of the contract it represents, and allows equality</span>
      <span class="comment">// comparison.</span>

      <span class="comment">// DATA</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> *d_name;    <span class="comment">// held, not owned</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span>  d_callMonth;
      <span class="keyword">const</span> <span class="keywordtype">short</span> d_callYear;

    <span class="keyword">public</span>:
      <span class="comment">// CREATORS</span>
      Future(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keyword">const</span> <span class="keywordtype">char</span> callMonth, <span class="keyword">const</span> <span class="keywordtype">short</span> callYear)
      : d_name(name), d_callMonth(callMonth), d_callYear(callYear)
          <span class="comment">// Create a &#39;Future&#39; object out of the specified &#39;name&#39;,</span>
          <span class="comment">// &#39;callMonth&#39;, and &#39;callYear&#39;.</span>
      {}

      Future() : d_name(<span class="stringliteral">&quot;&quot;</span>), d_callMonth(<span class="stringliteral">&#39;\0&#39;</span>), d_callYear(0)
          <span class="comment">// Create a &#39;Future&#39; with default values.</span>
      {}

      <span class="comment">// ACCESSORS</span>
      <span class="keyword">const</span> <span class="keywordtype">char</span> * getMonth() const
          <span class="comment">// Return the month that this future expires.</span>
      {
          <span class="keywordflow">return</span> &amp;d_callMonth;
      }

      <span class="keyword">const</span> <span class="keywordtype">char</span> * getName() const
          <span class="comment">// Return the name of this future</span>
      {
          <span class="keywordflow">return</span> d_name;
      }

      <span class="keyword">const</span> <span class="keywordtype">short</span> * getYear() const
          <span class="comment">// Return the year that this future expires</span>
      {
          <span class="keywordflow">return</span> &amp;d_callYear;
      }

      <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aa87851224efdfae6f5f519901c970262">operator==</a>(<span class="keyword">const</span> Future&amp; other) <span class="keyword">const</span>
          <span class="comment">// Compare this to the specified &#39;other&#39; object and return true if</span>
          <span class="comment">// they are equal</span>
      {
          <span class="keywordflow">return</span> (!strcmp(d_name, other.d_name))  &amp;&amp;
             d_callMonth == other.d_callMonth &amp;&amp;
             d_callYear  == other.d_callYear;
      }
  };

  <span class="keywordtype">bool</span> <a class="code" href="namespacebdlb.html#aceb1a703f6f64327cd3cdcd03a557f4a">operator!=</a>(<span class="keyword">const</span> Future&amp; lhs, <span class="keyword">const</span> Future&amp; rhs)
      <span class="comment">// Compare compare the specified &#39;lhs&#39; and &#39;rhs&#39; objects and return</span>
      <span class="comment">// true if they are not equal</span>
  {
      <span class="keywordflow">return</span> !(lhs == rhs);
  }
</pre></div><br/>
<br/>
 Next, we need a hash functor for <code>Future</code>. We are going to use the <code>SipHashAlgorithm</code> because, it is a secure hash algorithm that will provide a way to securely combine the attributes of <code>Future</code> objects that are salient to hashing into one reasonable hash that an malicious user will not be able to predict. <br/>
<br/>
<div class="fragment"><pre class="fragment">  <span class="keyword">struct </span>HashFuture {
      <span class="comment">// This struct is a functor that will apply the SipHashAlgorithm to</span>
      <span class="comment">// objects of type &#39;Future&#39;.</span>

      <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> Future&amp; future) <span class="keyword">const</span>
          <span class="comment">// Return the hash of the of the specified &#39;future&#39;.  Note that</span>
          <span class="comment">// this uses the &#39;SipHashAlgorithm&#39; to safely combine the</span>
          <span class="comment">// attributes of &#39;Future&#39; objects that are salient to hashing into</span>
          <span class="comment">// a hash that is not predictable by an attacker.</span>
      {
          <span class="keywordtype">char</span> seed[SipHashAlgorithm::k_SEED_LENGTH];
          SeedGenerator&lt;CryptoSecureRNG&gt; seedGenerator;
          seedGenerator.generateSeed(seed, SipHashAlgorithm::k_SEED_LENGTH);

          SipHashAlgorithm hash(seed);

          hash(future.getName(),  strlen(future.getName()));
          hash(future.getMonth(), <span class="keyword">sizeof</span>(char));
          hash(future.getYear(),  <span class="keyword">sizeof</span>(short));

          <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">size_t</span><span class="keyword">&gt;</span>(hash.computeHash());
      }
  };
</pre></div><br/>
<br/>
 Then, we want to actually use our hash table on <code>Future</code> objects. We create an array of <code>Future</code>s based on data that was originally from some external source: <br/>
<br/>
<div class="fragment"><pre class="fragment">      Future futures[] = { Future(<span class="stringliteral">&quot;Swiss Franc&quot;</span>, <span class="charliteral">&#39;F&#39;</span>, 2014),
                           Future(<span class="stringliteral">&quot;US Dollar&quot;</span>, <span class="charliteral">&#39;G&#39;</span>, 2015),
                           Future(<span class="stringliteral">&quot;Canadian Dollar&quot;</span>, <span class="charliteral">&#39;Z&#39;</span>, 2014),
                           Future(<span class="stringliteral">&quot;British Pound&quot;</span>, <span class="charliteral">&#39;M&#39;</span>, 2015),
                           Future(<span class="stringliteral">&quot;Deutsche Mark&quot;</span>, <span class="charliteral">&#39;X&#39;</span>, 2016),
                           Future(<span class="stringliteral">&quot;Eurodollar&quot;</span>, <span class="charliteral">&#39;Q&#39;</span>, 2017)};
      <span class="keyword">enum</span> { NUM_FUTURES = <span class="keyword">sizeof</span> futures / <span class="keyword">sizeof</span> *futures };

 Next, we create our HashTable <span class="stringliteral">&#39;hashTable&#39;</span>.  We pass the functor that we
 defined above as the second argument:

      HashTable&lt;Future, HashFuture&gt; hashTable(futures, NUM_FUTURES);
</pre></div><br/>
<br/>
 Now, we verify that each element in our array registers with count: <br/>
<br/>
<div class="fragment"><pre class="fragment">      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; 6; ++i) {
          ASSERT(hashTable.contains(futures[i]));
      }
</pre></div><br/>
<br/>
 Finally, we verify that futures not in our original array are correctly identified as not being in the set: <br/>
<br/>
<div class="fragment"><pre class="fragment">      ASSERT(!hashTable.contains(Future(<span class="stringliteral">&quot;French Franc&quot;</span>, <span class="charliteral">&#39;N&#39;</span>, 2019)));
      ASSERT(!hashTable.contains(Future(<span class="stringliteral">&quot;Swiss Franc&quot;</span>, <span class="charliteral">&#39;X&#39;</span>, 2014)));
      ASSERT(!hashTable.contains(Future(<span class="stringliteral">&quot;US Dollar&quot;</span>, <span class="charliteral">&#39;F&#39;</span>, 2014)));
</pre></div><br/>
<br/>
 </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="changes"></a> <a class="anchor" id="description.changes"></a> <a class="anchor" id="3.6"></a> </dd></dl>
<dl class="user"><dt><b>Changes: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>The third party code begins with the <code>siphash.h</code> header below, and continues until the TYPE TRAITS banner below. Changes made to the original code include: </dd></dl>
<dl class="user"><dt><b></b></dt><dd><ol>
<li>
Adding <code><a class="el" href="namespaceBloombergLP.html">BloombergLP</a></code> and <code>bslh</code> namespaces  </li>
<li>
Renaming <code>siphash</code> to <code>SipHashAlgorithm</code>  </li>
<li>
Whitespace changes for formatting  </li>
<li>
Added comments  </li>
<li>
Removed C++11 features including class member initializer, <code>noexcept</code>, <code>std::Uint64_t</code>, explicit conversion operator, and an <code>= default</code> constructor.  </li>
<li>
Added <code>typedef</code> to replace removed <code>std::Uint64_t</code>  </li>
<li>
Added <code>computeHash()</code> to replace the removed explicit conversion  </li>
<li>
Added <code>k_SEED_LENGTH</code> and changed the constructor to accept a <code>const char *</code>  </li>
<li>
Included headers and added <code>include</code> guards  </li>
</ol>
<div class="hanging"> </div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> 10 Changed variables to use <code>size_t</code> rather than <code>unsigned int</code></div></dd></dl>
<dl class="user"><dt><b></b></dt><dd><div class="hanging"> </div> </dd></dl>
<dl class="user"><dt><b></b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd><a class="anchor" id="third_party_doc"></a> <a class="anchor" id="description.third_party_doc"></a> <a class="anchor" id="3.7"></a> </dd></dl>
<dl class="user"><dt><b>Third Party Doc: </b></dt><dd></dd></dl>
<dl class="user"><dt><b></b></dt><dd>------------------------------- siphash.h ----------------------------------- </dd></dl>
<dl class="user"><dt><b></b></dt><dd>This software is in the public domain. The only restriction on its use is that no one can remove it from the public domain by claiming ownership of it, including the original authors. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>There is no warranty of correctness on the software contained herein. Use at your own risk. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Derived from: </dd></dl>
<dl class="user"><dt><b></b></dt><dd>SipHash reference C implementation </dd></dl>
<dl class="user"><dt><b></b></dt><dd>Written in 2012 by Jean-Philippe Aumasson &lt;jeanphilippe.aumasson@gmail.com&gt; Daniel J. Bernstein &lt;djb@cr.yp.to&gt; </dd></dl>
<dl class="user"><dt><b></b></dt><dd>To the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>You should have received a copy of the CC0 Public Domain Dedication along with this software. If not, see &lt;<a href="http://creativecommons.org/publicdomain/zero/1.0/">http://creativecommons.org/publicdomain/zero/1.0/</a>&gt;. </dd></dl>
<dl class="user"><dt><b></b></dt><dd>----------------------------------------------------------------------------- </dd></dl>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Tue Jun 2 2015 13:40:20 for BDE Release 2.23.1 OSS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
