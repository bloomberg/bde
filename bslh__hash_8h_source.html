<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslh_hash.h                                                        -*-C++-*-
#ifndef INCLUDED_BSLH_HASH
#define INCLUDED_BSLH_HASH

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a struct to run &#39;bslh&#39; hash algorithms on supported types.
//
//@CLASSES:
//  bslh::Hash: functor that runs &#39;bslh&#39; hash algorithms on supported types
//
//@SEE_ALSO:
//
//@DESCRIPTION: This component provides a templated &#39;struct&#39;, &#39;bslh::Hash&#39;,
// that defines a hash-functor that can be used with standard containers (a
// drop in replacement for &#39;bsl::hash&#39;), and which applies the supplied
// (template parameter) &#39;HASH_ALGORITHM&#39; to the attributes of the (template
// parameter) &#39;TYPE&#39; which have been identified as salient to hashing.  The
// &#39;bslh::Hash&#39; template parameter &#39;HASH_ALGORITHM&#39; must be a hashing algorithm
// that conforms the the requirements outlined below (see {Requirements for
// Regular &#39;bslh&#39; Hashing Algorithms}).  Note that there are several hashing
// algorithms defined within the &#39;bslh&#39; package and some, such as those that
// require seeds, will not meet these requirements, meaning they cannot be used
// with &#39;bslh::Hash&#39;.  A call to &#39;bslh::Hash::operator()&#39; for a (template
// parameter) &#39;TYPE&#39; will call the &#39;hashAppend&#39; free function for &#39;TYPE&#39; and
// provide &#39;hashAppend&#39; an instance of the &#39;HASH_ALGORITHM&#39;.
//
// This component also contains &#39;hashAppend&#39; definitions for fundamental types,
// which are required by algorithms defined in &#39;bslh&#39;.  Clients are expected to
// define a free-function &#39;hashAppend&#39; for each of the types they wish to be
// hashable (see {&#39;hashAppend&#39;} below).  More information can be found in the
// package level documentation for &#39;bslh&#39; (internal users can also find
// information here {TEAM BDE:USING MODULAR HASHING&lt;GO&gt;})
//
///Modularity
///----------
// &#39;bslh::Hash&#39; provides a modular system for hashing.  This modularity refers
// to the decoupling of the various tasks associated with hashing.  Using this
// system, type implementers can identify attributes of their type that are
// salient to hashing, without having to write a hashing algorithm.
// Conversely, hashing algorithms can be written independent of types.
// Attributes that are salient to hashing are called out on a type using
// &#39;hashAppend&#39;.  Hashing algorithms are written to operate on the attributes
// called out by &#39;hashAppend&#39;.  Some default algorithms have been provided in
// the &#39;bslh&#39; package.  This modularity allows type creators to avoid writing
// hashing algorithms, which can save work and avoid bad hashing algorithm
// implementations.
//
///&#39;hashAppend&#39;
///------------
// &#39;hashAppend&#39; is the function that is used to pass attributes that are
// salient to hashing into a hashing algorithm.  A type must define a
// &#39;hashAppend&#39; overload that can be discovered through ADL in order to be
// hashed using this facility.  A simple implementation of an overload for
// &#39;hashAppend&#39; might call &#39;hashAppend&#39; on each of the type&#39;s attributes that
// are salient to hashing.  Note that when writing a &#39;hashAppend&#39; function,
// &#39;using bslh::hashAppend;&#39; must be included as the first line of code in the
// function.  The using statement ensures that ADL will always be able to find
// the fundamental type &#39;hashAppend&#39; functions, even when the (template
// parameter) type &#39;HASH_ALGORITHM&#39; is not implemented in &#39;bslh&#39;.
//
// Some types may require more subtle implementations for &#39;hashAppend&#39;, such as
// types containing C-strings which are salient to hashing.  These C-strings
// must be passed directly into the (template parameter) type &#39;HASH_ALGORITHM&#39;,
// rather than calling &#39;hashAppend&#39; with the pointer as an argument.  This
// special case exists because calling &#39;hashAppend&#39; with a pointer will hash
// the pointer rather than the data that is pointed to.
//
// Within this component, &#39;hashAppend&#39; has been implemented for all of the
// fundamental types.  When &#39;hashAppend is reached on a fundamental type, the
// hashing algorithm is no longer propagated, and instead a pointer to the
// beginning of the type in memory is passed to the algorithm, along with the
// length of the type.  There are special cases with floating point numbers and
// boolean values where the data is tweaked before hashing to ensure that
// values that compare equal will be hashed with the same bit-wise
// representation.  The algorithm will then incorporate the type into its
// internal state and return a finalized hash when requested.
//
///Hashing Algorithms
///------------------
// There are algorithms implemented in the &#39;bslh&#39; package that can be passed in
// and used as template parameters for &#39;bslh::Hash&#39; or other &#39;struct&#39;s like it.
// Some of these algorithms, such as &#39;bslh::SpookyHashAlgorithm&#39;, are named for
// the algorithm they implement.  These named algorithms are intended for use
// by those who want a specific algorithm.  There are other algorithms, such as
// &#39;bslh::DefaultHashAlgorithm&#39;, which wrap an unspecified algorithm and
// describe the properties of the wrapped algorithm.  The descriptive
// algorithms are intended for use by those who need specific properties and
// want to be updated to a new algorithm when one is published with
// improvements to the desired properties.  &#39;bslh::DefaultHashAlgorithm&#39; has
// the property of being a good default algorithm, specifically for use in a
// hash table.
//
///Requirements for Regular &#39;bslh&#39; Hashing Algorithms
///--------------------------------------------------
// Users of this modular hashing system are free to write their own hashing
// algorithms.  In order to plug into &#39;bslh::Hash&#39;, the user-implemented
// algorithms must implement the interface shown here:
//..
// class SomeHashAlgorithm
// {
//   public:
//     // TYPES
//     typedef Uint64 result_type;
//
//     // CREATORS
//     SomeHashAlgorithm();
//
//     // MANIPULATORS
//     void operator()(const void *data, size_t numBytes);
//
//     result_type computeHash();
// };
//..
// The &#39;result_type&#39; &#39;typedef&#39; must define the return type of this particular
// algorithm.  A default constructor (either implicit or explicit) must be
// supplied that creates an algorithm functor that is in a usable state.  An
// &#39;operator()&#39; must be supplied that takes a &#39;const void *&#39; to the data to be
// hashed and a &#39;size_t&#39; length of bytes to be hashed.  This operator must
// operate on all data uniformly, meaning that regardless of whether data is
// passed in all at once, or one byte at a time, the result returned by
// &#39;computeHash()&#39; will be the same.  &#39;computeHash()&#39; will return the final
// result of the hashing algorithm, as type &#39;result_type&#39;.  &#39;computeHash()&#39; is
// allowed to modify the internal state of the algorithm, meaning calling
// &#39;computeHash()&#39; more than once may not return the correct value.
//
///Usage
///-----
// This section illustrates intended usage of this component.
//
///Example 1: Keying a Hash Table with a User-Defined Type
///- - - - - - - - - - - - - - - - - - - - - - - - - - - -
// Suppose we have a value-semantic type, &#39;Box&#39;, that contains attributes that
// are salient to hashing as well as attributes that are not salient to
// hashing.  Some of these attributes are themselves user defined types.  We
// want to store objects of type &#39;Box&#39; in a hash table, so we need to be able
// to produce hash values that represent instances of &#39;Box&#39;.  We don&#39;t want to
// write our own hashing or hash combine algorithm, because we know it is very
// difficult and labor-intensive to write a proper hashing algorithm.  In
// order to hash this &#39;Box&#39;, we will use the modular hashing system supplied in
// &#39;bslh&#39;.
//
// First, we define &#39;Point&#39;, a class that allows us to identify a location on a
// two dimensional Cartesian plane.
//..
//  class Point {
//      // This class is a value-semantic type that represents a two
//      // dimensional location on a Cartesian plane.
//
//    private:
//      int    d_x;
//      int    d_y;
//      double d_distToOrigin; // This value will be accessed frequently, so we
//                             // cache it rather than recalculate it every
//                             // time.
//
//    public:
//      Point (int x, int y);
//          // Create a &#39;Point&#39; having the specified &#39;x&#39; and &#39;y&#39; coordinates.
//
//      double distanceToOrigin() const;
//          // Return the distance from the origin (0, 0) to this point.
//
//      int getX() const;
//          // Return the x coordinate of this point.
//
//      int getY() const;
//          // Return the y coordinate of this point.
//  };
//
//  inline
//  Point::Point(int x, int y)
//  : d_x(x)
//  , d_y(y)
//  {
//      d_distToOrigin = sqrt(static_cast&lt;double&gt;(d_x * d_x) +
//                            static_cast&lt;double&gt;(d_y * d_y));
//  }
//
//  inline
//  double Point::distanceToOrigin() const
//  {
//      return d_distToOrigin;
//  }
//
//  inline
//  int Point::getX() const
//  {
//      return d_x;
//  }
//
//  inline
//  int Point::getY() const
//  {
//      return d_y;
//  }
//..
// Then, we define &#39;operator==&#39;.  Notice how it checks only attributes that we
// would want to incorporate into the hashed value.  Note that attributes that
// are salient to hashing tend to be the same as or a subset of the attributes
// that are checked in &#39;operator==&#39;.
//..
//  bool operator==(const Point &amp;lhs, const Point &amp;rhs)
//      // Return true if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value.
//      // Two &#39;Point&#39; objects have the same value if they have the same x and
//      // y coordinates.
//  {
//      return (lhs.getX() == rhs.getX()) &amp;&amp; (lhs.getY() == rhs.getY());
//  }
//..
// Next, we define &#39;hashAppend&#39;.  This function will allow any hashing
// algorithm that meets the &#39;bslh&#39; hashing algorithm requirements to be applied
// to &#39;Point&#39;.  This is the full extent of the work that needs to be done by
// type creators.  They do not need to implement any algorithms, they just need
// to call out the attributes that are salient to hashing by calling
// &#39;hashAppend&#39; on them.
//..
//  template &lt;class HASH_ALGORITHM&gt;
//  void hashAppend(HASH_ALGORITHM &amp;hashAlg, const Point &amp;point)
//      // Apply the specified &#39;hashAlg&#39; to the specified &#39;point&#39;
//  {
//      using bslh::hashAppend;
//      hashAppend(hashAlg, point.getX());
//      hashAppend(hashAlg, point.getY());
//  }
//..
// Then, we declare another value-semantic type, &#39;Box&#39; that will have a &#39;Point&#39;
// as one of its attributes that are salient to hashing.
//..
//  class Box {
//      // This class is a value-semantic type that represents a box drawn on
//      // to a Cartesian plane.
//
//    private:
//      Point d_position;
//      int d_length;
//      int d_width;
//
//    public:
//      Box(Point position, int length, int width);
//          // Create a box having the specified &#39;length&#39; and &#39;width&#39;, with its
//          // upper left corner at the specified &#39;position&#39;
//
//      int getLength() const;
//          // Return the length of this box.
//
//      Point getPosition() const;
//          // Return a &#39;Point&#39; representing the upper left corner of this box
//          // on a Cartesian plane
//
//      int getWidth() const;
//          // Return the width of this box.
//  };
//
//  inline
//  Box::Box(Point position, int length, int width)
//  : d_position(position)
//  , d_length(length)
//  , d_width(width) { }
//
//  int Box::getLength() const
//  {
//      return d_length;
//  }
//
//  Point Box::getPosition() const
//  {
//      return d_position;
//  }
//
//  int Box::getWidth() const
//  {
//      return d_width;
//  }
//..
// Then, we define &#39;operator==&#39;.  This time all of the data members are salient
// to equality.
//..
//  bool operator==(const Box &amp;lhs, const Box &amp;rhs)
//      // Return true if the specified &#39;lhs&#39; and &#39;rhs&#39; have the same value.
//      // Two &#39;Box&#39; objects have the same value if they have the same length,
//      // width, and position.
//  {
//      return (lhs.getPosition() == rhs.getPosition()) &amp;&amp;
//             (lhs.getLength()   == rhs.getLength()) &amp;&amp;
//             (lhs.getWidth()    == rhs.getWidth());
//  }
//..
// Next, we define &#39;hashAppend&#39; for &#39;Box&#39;.  Notice how as well as calling
// &#39;hashAppend&#39; on fundamental types, we can also call it with our user defined
// type &#39;Point&#39;.  Calling &#39;hashAppend&#39; with &#39;Point&#39; will propogate a reference
// to the hashing algorithm functor &#39;hashAlg&#39; down to the fundamental types
// that make up &#39;Point&#39;, and those types will then be passed into the
// referenced algorithm functor.
//..
//  template &lt;class HASH_ALGORITHM&gt;
//  void hashAppend(HASH_ALGORITHM &amp;hashAlg, const Box &amp;box)
//      // Apply the specified &#39;hashAlg&#39; to the specified &#39;box&#39;
//  {
//      using bslh::hashAppend;
//      hashAppend(hashAlg, box.getPosition());
//      hashAppend(hashAlg, box.getLength());
//      hashAppend(hashAlg, box.getWidth());
//  }
//..
// Then, we declare our hash table (implementation elided).  We simplify the
// problem by requiring the caller to supply an array.  Our hash table takes
// two type parameters: &#39;TYPE&#39; (the type being referenced) and &#39;HASHER&#39; (a
// functor that produces the hash).  &#39;HASHER&#39; will default to &#39;bslh::Hash&lt;&gt;&#39;.
//..
//  template &lt;class TYPE, class HASHER = bslh::Hash&lt;&gt; &gt;
//  class HashTable {
//      // This class template implements a hash table providing fast lookup of
//      // an external, non-owned, array of values of (template parameter)
//      // &#39;TYPE&#39;.
//      //
//      // The (template parameter) &#39;TYPE&#39; shall have a transitive, symmetric
//      // &#39;operator==&#39; function and it will be hashable using &#39;bslh::Hash&#39;.
//      // Note that there is no requirement that it have any kind of creator
//      // defined.
//      //
//      // The &#39;HASHER&#39; template parameter type must be a functor with a method
//      // having the following signature:
//      //..
//      //  size_t operator()(TYPE)  const;
//      //                   -OR-
//      //  size_t operator()(const TYPE&amp;) const;
//      //..
//      // and &#39;HASHER&#39; shall have a publicly accessible default constructor
//      // and destructor.  Here we use &#39;bslh::Hash&#39; as our default template
//      // argument.  This allows us to hash any type for which &#39;hashAppend&#39;
//      // has been implemented.
//      //
//      // Note that this hash table has numerous simplifications because we
//      // know the size of the array and never have to resize the table.
//
//      // DATA
//      const TYPE       *d_values;             // Array of values table is to
//                                              // hold
//      size_t            d_numValues;          // Length of &#39;d_values&#39;.
//      const TYPE      **d_bucketArray;        // Contains ptrs into
//                                              // &#39;d_values&#39;
//      unsigned          d_bucketArrayMask;    // Will always be &#39;2^N - 1&#39;.
//      HASHER            d_hasher;
//
//    private:
//      // PRIVATE ACCESSORS
//      bool lookup(size_t      *idx,
//                  const TYPE&amp;  value,
//                  size_t       hashValue) const;
//          // Look up the specified &#39;value&#39;, having the specified &#39;hashValue&#39;,
//          // and load its index in &#39;d_bucketArray&#39; into the specified &#39;idx&#39;.
//          // If not found, return the vacant entry in &#39;d_bucketArray&#39; where
//          // it should be inserted.  Return &#39;true&#39; if &#39;value&#39; is found and
//          // &#39;false&#39; otherwise.
//
//    public:
//      // CREATORS
//      HashTable(const TYPE *valuesArray,
//                size_t      numValues);
//          // Create a hash table referring to the specified &#39;valuesArray&#39;
//          // having length of the specified &#39;numValues&#39;.  No value in
//          // &#39;valuesArray&#39; shall have the same value as any of the other
//          // values in &#39;valuesArray&#39;
//
//      ~HashTable();
//          // Free up memory used by this hash table.
//
//      // ACCESSORS
//      bool contains(const TYPE&amp; value) const;
//          // Return true if the specified &#39;value&#39; is found in the table and
//          // false otherwise.
//  };
//..
// Next, we will create an array of boxes that we want to store in our hash
// table.
//..
//
//        Box boxes[] = { Box(Point(1, 1), 3, 2),
//                        Box(Point(3, 1), 4, 2),
//                        Box(Point(1, 2), 3, 3),
//                        Box(Point(1, 1), 2, 2),
//                        Box(Point(1, 4), 4, 3),
//                        Box(Point(2, 1), 4, 2),
//                        Box(Point(1, 0), 3, 1)};
//        enum { NUM_BOXES = sizeof boxes / sizeof *boxes };
//
//..
// Then, we create our hash table &#39;hashTable&#39;.  We pass we use the default
// functor which will pick up the &#39;hashAppend&#39; function we created:
//..
//
//        HashTable&lt;Box&gt; hashTable(boxes, NUM_BOXES);
//..
// Now, we verify that each element in our array registers with count:
//..
// for ( int i = 0; i &lt; 6; ++i) { ASSERT(hashTable.contains(boxes[i])); }
//..
// Finally, we verify that futures not in our original array are correctly
// identified as not being in the set:
//..
// ASSERT(!hashTable.contains(Box(Point(1, 1), 1, 1)));
// ASSERT(!hashTable.contains(Box(Point(0, 0), 0, 0)));
// ASSERT(!hashTable.contains(Box(Point(3, 3), 3, 3)));
//..

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLH_DEFAULTHASHALGORITHM
#include &lt;bslh_defaulthashalgorithm.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ENABLEIF
#include &lt;bslmf_enableif.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISENUM
#include &lt;bslmf_isenum.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISFLOATINGPOINT
#include &lt;bslmf_isfloatingpoint.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISINTEGRAL
#include &lt;bslmf_isintegral.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISPOINTER
#include &lt;bslmf_ispointer.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISSAME
#include &lt;bslmf_issame.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYCOPYABLE
#include &lt;bslmf_istriviallycopyable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISTRIVIALLYDEFAULTCONSTRUCTIBLE
#include &lt;bslmf_istriviallydefaultconstructible.h&gt;
#endif

#ifndef INCLUDED_BSLS_COMPILERFEATURES
#include &lt;bsls_compilerfeatures.h&gt;
#endif

#ifndef INCLUDED_BSLS_PLATFORM
#include &lt;bsls_platform.h&gt;
#endif

#ifndef INCLUDED_STDDEF_H
#include &lt;stddef.h&gt;  // for &#39;size_t&#39;
#define INCLUDED_STDDEF_H
#endif

namespace BloombergLP {

namespace bslh {

                          // ================
                          // class bslh::Hash
                          // ================

template &lt;class HASH_ALGORITHM = bslh::DefaultHashAlgorithm&gt;
struct Hash {
    // This struct wraps the (template parameter) type &#39;HASH_ALGORITHM&#39; in an
    // interface that satisfies the &#39;hash&#39; requirements of the C++11 standard.

    // TYPES
    typedef size_t result_type;
        // The type of the hash value that will be returned by the
        // function-call operator.

    // CREATORS
    //! Hash() = default;
        // Create a &#39;bslh::Hash&#39; object.

    //! Hash(const Hash&amp; original) = default;
        // Create a &#39;bslh::Hash&#39; object.  Note that as &#39;bslh::Hash&#39; is an empty
        // (stateless) type, this operation will have no observable effect.

    //! ~Hash() = default;
        // Destroy this object.

    // MANIPULATORS
    //! Hash&amp; operator=(const Hash&amp; rhs) = default;
        // Assign to this object the value of the specified &#39;rhs&#39; object, and
        // return a reference providing modifiable access to this object.  Note
        // that as &#39;bslh::Hash&#39; is an empty (stateless) type, this operation
        // will have no observable effect.

    // ACCESSORS
    template &lt;class TYPE&gt;
    result_type operator()(const TYPE&amp; type) const;
        // Returns a hash value generated by the (template parameter) type
        // &#39;HASH_ALGORITHM&#39; for the specified &#39;type&#39;.  The value returned by
        // the &#39;HASH_ALGORITHM&#39; is cast to &#39;size_t&#39; before returning.

};

// FREE FUNCTIONS
template &lt;class HASH_ALGORITHM, class TYPE&gt;
inline
typename bsl::enable_if&lt;
    (bsl::is_integral&lt;TYPE&gt;::value ||
     bsl::is_pointer&lt;TYPE&gt;::value  ||
     bsl::is_enum&lt;TYPE&gt;::value)    &amp;&amp;
    !bsl::is_same&lt;TYPE, bool&gt;::value
&gt;::type
hashAppend(HASH_ALGORITHM&amp; hashAlg, TYPE input)
    // Passes the specified &#39;input&#39; into the specified &#39;hashAlg&#39; to be combined
    // into the internal state of the algorithm which is used to produce the
    // resulting hash value. Note that the &#39;enable_if&#39; meta-function is used to
    // enable this &#39;hashAppend&#39; function for only integral (excluding &#39;bool&#39;),
    // pointer, and enum types, because these types can all be hashed as a
    // continuous sequence of bytes. Also note that this function is defined
    // inline because MS Visual Studio compilers before 2013 require (some)
    // functions declared using enable_if be in-place inline.
{
    hashAlg(&amp;input, sizeof(input));
}

template &lt;class HASH_ALGORITHM, class TYPE&gt;
inline
typename bsl::enable_if&lt;
    bsl::is_floating_point&lt;TYPE&gt;::value &amp;&amp;
   !bsl::is_same&lt;TYPE, long double&gt;::value
&gt;::type
hashAppend(HASH_ALGORITHM&amp; hashAlg, TYPE input)
    // Passes the specified &#39;input&#39; into the specified &#39;hashAlg&#39; to be combined
    // into the internal state of the algorithm which is used to produce the
    // resulting hash value. Note that the &#39;enable_if&#39; meta-function is used to
    // enable this &#39;hashAppend&#39; function for only floating point (excluding
    // &#39;long double&#39;) types, because these types need to have +/-0.0 normalized
    // to 0.0 before they can be hashed as a continuous sequence of bytes. Also
    // note that this function is defined inline because MS Visual Studio
    // compilers before 2013 require (some) functions declared using enable_if
    // be in-place inline.
{
    if (input == 0)
        input = 0;
    hashAlg(&amp;input, sizeof(input));
}

template &lt;class HASH_ALGORITHM, class TYPE&gt;
typename bsl::enable_if&lt; bsl::is_same&lt;TYPE, bool&gt;::value &gt;::type
hashAppend(HASH_ALGORITHM&amp; hashAlg, TYPE input);
    // Passes the specified &#39;input&#39; into the specified &#39;hashAlg&#39; to be combined
    // into the internal state of the algorithm which is used to produce the
    // resulting hash value. Note that the &#39;enable_if&#39; meta-function is used to
    // enable this &#39;hashAppend&#39; function for only &#39;bool&#39;, because &#39;bool&#39;s can
    // have multiple &#39;true&#39; representations and need to be normalized before
    // they can be hashed as a continuous sequence of bytes.

template &lt;class HASH_ALGORITHM, class TYPE&gt;
typename bsl::enable_if&lt; bsl::is_same&lt;TYPE, long double&gt;::value &gt;::type
hashAppend(HASH_ALGORITHM&amp; hashAlg, TYPE input);
    // Passes the specified &#39;input&#39; into the specified &#39;hashAlg&#39; to be combined
    // into the internal state of the algorithm which is used to produce the
    // resulting hash value. Note that the &#39;enable_if&#39; meta-function is used to
    // enable this &#39;hashAppend&#39; function for only &#39;long double&#39;, because on
    // some compilers &#39;long double&#39;s contain garbage and can not be hashed as
    // a continuous sequence of bytes.

template &lt;class HASH_ALGORITHM, size_t N&gt;
void hashAppend(HASH_ALGORITHM&amp; hashAlg, char (&amp;input)[N]);
    // Passes the specified &#39;input&#39; into the specified &#39;hashAlg&#39; to be combined
    // into the internal state of the algorithm which is used to produce the
    // resulting hash value. Note that the entire &#39;char&#39; array will be hashed
    // in only one call to &#39;hashAlg&#39;. Also note that this &#39;hashAppend&#39; exists
    // because some platforms don&#39;t recognize that adding a const qualifier is
    // a better match for arrays than decaying to a pointer and using the
    // &#39;hashAppend&#39; function for pointers.

template &lt;class HASH_ALGORITHM, size_t N&gt;
void hashAppend(HASH_ALGORITHM&amp; hashAlg, const char (&amp;input)[N]);
    // Passes the specified &#39;input&#39; into the specified &#39;hashAlg&#39; to be combined
    // into the internal state of the algorithm which is used to produce the
    // resulting hash value. Note that the entire &#39;char&#39; array will be hashed
    // in only one call to &#39;hashAlg&#39;.

template &lt;class HASH_ALGORITHM, class TYPE, size_t N&gt;
void hashAppend(HASH_ALGORITHM&amp; hashAlg, TYPE (&amp;input)[N]);
    // Passes the specified &#39;input&#39; into the specified &#39;hashAlg&#39; to be combined
    // into the internal state of the algorithm which is used to produce the
    // resulting hash value. Note that the elements in &#39;input&#39; will be hashed
    // one at a time by calling &#39;hashAppend&#39; because the (template parameter)
    // &#39;TYPE&#39; might not be hashable as a contiguous sequence of bytes. Also
    // note that this &#39;hashAppend&#39; exists because some platforms don&#39;t
    // recognize that adding a const qualifier is a better match for arrays
    // than decaying to a pointer and using the &#39;hashAppend&#39; function for
    // pointers.

template &lt;class HASH_ALGORITHM, class TYPE, size_t N&gt;
void hashAppend(HASH_ALGORITHM&amp; hashAlg, const TYPE (&amp;input)[N]);
    // Passes the specified &#39;input&#39; into the specified &#39;hashAlg&#39; to be combined
    // into the internal state of the algorithm which is used to produce the
    // resulting hash value. Note that the elements in &#39;input&#39; will be hashed
    // one at a time by calling &#39;hashAppend&#39; because the (template parameter)
    // &#39;TYPE&#39; might not be hashable as a contiguous sequence of bytes.

}  // close package namespace

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

// ACCESSORS
template &lt;class HASH_ALGORITHM&gt;
template &lt;class TYPE&gt;
inline
typename bslh::Hash&lt;HASH_ALGORITHM&gt;::result_type
bslh::Hash&lt;HASH_ALGORITHM&gt;::operator()(TYPE const&amp; key) const
{
    HASH_ALGORITHM hashAlg;
    hashAppend(hashAlg, key);
    return static_cast&lt;result_type&gt;(hashAlg.computeHash());
}

// FREE FUNCTIONS
template &lt;class HASH_ALGORITHM, class TYPE&gt;
inline
typename bsl::enable_if&lt; bsl::is_same&lt;TYPE, bool&gt;::value &gt;::type
bslh::hashAppend(HASH_ALGORITHM&amp; hashAlg, TYPE input)
{
    // We need to ensure that any inputs that compare equal produce the same
    // hash.  Any non-zero binary representation of &#39;input&#39; can be &#39;true&#39;, so
    // we need to normalize &#39;input&#39; to ensure that we do not pass two different
    // binary representations of &#39;true&#39; true into our hashing algorithm.
    unsigned char normalizedData = input;

    hashAlg(&amp;normalizedData, sizeof(normalizedData));
}

template &lt;class HASH_ALGORITHM, class TYPE&gt;
inline
typename bsl::enable_if&lt; bsl::is_same&lt;TYPE, long double&gt;::value &gt;::type
bslh::hashAppend(HASH_ALGORITHM&amp; hashAlg, TYPE input)
{
    if (input == 0.0l){
        input = 0;
    }

#if (defined BSLS_PLATFORM_CPU_X86 || defined BSLS_PLATFORM_CPU_X86_64) &amp;&amp;    \
    (defined BSLS_PLATFORM_CMP_GNU || defined BSLS_PLATFORM_CMP_CLANG)
    // This needs to be done to work around issues when compiling with GCC and
    // Clang on 86 machines.  On 64-bit hardware, &#39;sizeof(long double)&#39; is
    // advertised as 16 bytes, but only 10 bytes of precision is used.  The
    // remaining 6 bytes are padding.
    //
    // For Clang, the final 2 bytes of the padding are zeroed, but the 4 bytes
    // that proceed the final two appear to be garbage.
    //
    //..
    //      Actual Data --+*****************************+
    //                    |                             |
    // Actual long double: 5d e9 79 a9 c2 82 bb ef 2b 40 87 d8 5c 2b  0  0
    //                                                   |          ||   |
    //      Garbage -------------------------------------+**********+|   |
    //      Zeroed --------------------------------------------------+***+
    //..
    //
    // For GCC, the first and last 2 bytes of the padding are zeroed, but the 2
    // bytes in the middle appear to be garbage.
    //
    //..
    //      Garbage -------------------------------------------+****+
    //      Actual Data --+*****************************+     |     |
    //                    |                             |     |     |
    // Actual long double: 5d e9 79 a9 c2 82 bb ef 2b 40  0  0 5c 2b  0  0
    //                                                   |    |      |    |
    //      Zeroed --------------------------------------+****+------+****+
    //..
    //
    // On 32-bit hardware, &#39;sizeof(long double)&#39; is advertised as 12 bytes, but
    // again, only 10 bytes of precision is used.  The remaining 2 bytes are
    // padding.
    //
    // For Clang, the 2 bytes of the padding appear to be garbage.
    //
    //..
    //      Actual Data --+*****************************+
    //                    |                             |
    // Actual long double: 5d e9 79 a9 c2 82 bb ef 2b 40 87 d8
    //                                                   |    |
    //      Garbage -------------------------------------+****+
    //..
    //
    // For GCC, the 2 bytes of the padding are zeroed.
    //
    //..
    //      Actual Data --+*****************************+
    //                    |                             |
    // Actual long double: 5d e9 79 a9 c2 82 bb ef 2b 40  0  0
    //                                                   |    |
    //      Zeroed --------------------------------------+****+
    //..
    //
    // To address all of these issues, we will pass in only 10 bytes for a
    // &#39;long double&#39; even if it is longer.
  #if !defined(BSLS_PLATFORM_CMP_CLANG) &amp;&amp; BSLS_PLATFORM_CPU_X86_64
    // We cant just check &#39;defined(BSLS_PLATFORM_CMP_GNU)&#39; because Clang
    // masquerades as GCC.  Since we know that to be in this block we must be
    // using GCC or Clang, we can just check
    // &#39;!defined(BSLS_PLATFORM_CMP_CLANG)&#39; to get the same result.

    if (bsl::is_same&lt;long double, __float128&gt;::value) {
        // We need to handle the posibility that somebody has set the GCC
        // compiler flag that makes &#39;long double&#39; actually be 128-bit.
        hashAlg(&amp;input, sizeof(input));
        return;                                                       // RETURN
    }
  #endif
    hashAlg(&amp;input, sizeof(input) &gt; 10 ? 10 : sizeof(input));
#else
    hashAlg(&amp;input, sizeof(input));
#endif
}

template &lt;class HASH_ALGORITHM, size_t N&gt;
inline
void bslh::hashAppend(HASH_ALGORITHM&amp; hashAlg, char (&amp;input)[N])
{
    hashAlg(&amp;input, sizeof(char)*N);
}

template &lt;class HASH_ALGORITHM, size_t N&gt;
inline
void bslh::hashAppend(HASH_ALGORITHM&amp; hashAlg, const char (&amp;input)[N])
{
    hashAlg(&amp;input, sizeof(char)*N);
}

template &lt;class HASH_ALGORITHM, class TYPE, size_t N&gt;
inline
void bslh::hashAppend(HASH_ALGORITHM&amp; hashAlg, TYPE (&amp;input)[N])
{

    for (size_t i = 0; i &lt; N; ++i) {
        hashAppend(hashAlg, input[i]);
    }
}


template &lt;class HASH_ALGORITHM, class TYPE, size_t N&gt;
inline
void bslh::hashAppend(HASH_ALGORITHM&amp; hashAlg, const TYPE (&amp;input)[N])
{
    for (size_t i = 0; i &lt; N; ++i) {
        hashAppend(hashAlg, input[i]);
    }
}

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for STL &#39;hash&#39;
//: o &#39;bsl::hash&lt;TYPE&gt;&#39; is trivially default constructible.
//: o &#39;bsl::hash&lt;TYPE&gt;&#39; is trivially copyable.
//: o &#39;bsl::hash&lt;TYPE&gt;&#39; is bitwise movable.

namespace bslmf {
template &lt;class TYPE&gt;
struct IsBitwiseMoveable&lt;bslh::Hash&lt;TYPE&gt; &gt;
    : bsl::true_type {};
}  // close namespace bslmf


}  // close enterprise namespace

namespace bsl {
template &lt;class TYPE&gt;
struct is_trivially_default_constructible&lt; ::BloombergLP::bslh::Hash&lt;TYPE&gt; &gt;
: bsl::true_type
{};

template &lt;class TYPE&gt;
struct is_trivially_copyable&lt; ::BloombergLP::bslh::Hash&lt;TYPE&gt; &gt;
: bsl::true_type
{};
}  // close namespace bsl



#endif

// ----------------------------------------------------------------------------
// Copyright 2014 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
