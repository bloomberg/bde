<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bdlmt_eventscheduler.h                                             -*-C++-*-

// ----------------------------------------------------------------------------
//                                   NOTICE
//
// This component is not up to date with current BDE coding standards, and
// should not be used as an example for new development.
// ----------------------------------------------------------------------------

#ifndef INCLUDED_BDLMT_EVENTSCHEDULER
#define INCLUDED_BDLMT_EVENTSCHEDULER

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide a thread-safe recurring and one-time event scheduler.
//
//@CLASSES:
//  bdlmt::EventScheduler: a thread-safe event scheduler
//  bdlmt::EventSchedulerEventHandle: handle to a single scheduled event
//  bdlmt::EventSchedulerRecurringEventHandle: handle to a recurring event
//
//@SEE_ALSO: bdlmt_timereventscheduler
//
//@DESCRIPTION: This component provides a thread-safe event scheduler.
// &#39;bdlmt::EventScheduler&#39;, that implements methods to schedule and cancel
// recurring and one-time events.  All of the callbacks for these events are
// processed by a separate thread (called the dispatcher thread).  By default
// the callbacks are also executed in the dispatcher thread, but that behavior
// can be altered by providing a dispatcher functor at creation time (see the
// section &quot;The Dispatcher Thread and the Dispatcher Functor&quot;).
//
// Events may be referred to by &#39;bdlmt::EventSchedulerEventHandle&#39; and
// &#39;bdlmt::EventSchedulerRecurringEventHandle&#39; objects, which clean up after
// themselves when they go out of scope, or by &#39;Event&#39; and &#39;RecurringEvent&#39;
// pointers, which must be released using &#39;releaseEventRaw&#39;.  Such pointers are
// used in the &quot;Raw&quot; API of this class and must be used carefully.
//
///Comparison to &#39;bdlmt::TimerEventScheduler&#39;
/// - - - - - - - - - - - - - - - - - - - - -
// This component was written after &#39;bdlmt_timereventscheduler&#39;, which suffered
// from a couple of short-comings: 1) there was a maximum number of events it
// could manage, and 2) it was inefficient at dealing with large numbers of
// events.  This component addresses both those problems -- there is no limit
// on the number of events it can , and it is more efficient at dealing with
// large numbers of events.  The disadvantage of this component relative to
// &#39;bdlmt_timereventscheduler&#39; is that handles referring to managed events in a
// &#39;bdlmt::EventScheduler&#39; are reference-counted and need to be released, while
// handles of events in a &#39;bdlmt::TimerEventScheduler&#39; are integral types that
// do not need to be released.
//
///Thread Safety and &quot;Raw&quot; Event Pointers
///--------------------------------------
// &#39;bdlmt::EventScheduler&#39; is thread-safe and thread-enabled, meaning that
// multiple threads may use their own instances of the class or use a shared
// instance without further synchronization.  The thread safety and correct
// behavior of the component depend on the correct usage of &#39;Event&#39; pointers,
// which refer to scheduled events in the &quot;Raw&quot; API of this class.  In
// particular:
//..
//   * Every &#39;Event*&#39;  and &#39;RecurringEvent*&#39; populated by &#39;scheduleEventRaw&#39;
// and &#39;scheduleRecurringEventRaw&#39; must be released using &#39;releaseEventRaw.&#39;
//       - Pointers are not released automatically when events are completed.
//       - Pointers are not released automatically when events are canceled.
//       - Events are not canceled when pointers to them are released.
//   * Pointers must not be used after being released.
//   * Pointers must never be shared or duplicated without using
//    &#39;addEventRefRaw&#39; and &#39;addRecurringEventRefRaw&#39; to get additional
//     references; *each* such added reference must be released separately.
//..
// &#39;bdlmt::EventSchedulerEventHandle&#39; and
// &#39;bdlmt::EventSchedulerRecurringEventHandle&#39; are *const* *thread-safe*.  It
// is not safe for multiple threads to invoke non-const methods on the same
// EventHandle or RecurringEventHandle object concurrently.
//
///The Dispatcher Thread and the Dispatcher Functor
///------------------------------------------------
// The scheduler creates a single separate thread (called the *dispatcher*
// *thread*) to process all the callbacks.  The dispatcher thread executes the
// callbacks by passing them to the dispatcher functor (optionally specified at
// creation time).  The default dispatcher functor simply invokes the passed
// callback, effectively executing it in the dispatcher thread.  Users can
// alter this behavior by defining their own dispatcher functor (for example in
// order to use a thread pool or a separate thread to run the callbacks).  Note
// that the user-supplied functor will still be run in the dispatcher thread.
//
// CAVEAT: Using a dispatcher functor such as the example above (to execute the
// callback in a separate thread) violates the guarantees of
// cancelEventAndWait().  Users who specify a dispatcher functor that transfers
// the event to another thread for execution should not use
// cancelEventAndWait(), and should instead ensure that the lifetime of any
// object bound to an event exceeds the lifetime of the mechanism used by the
// customized dispatcher functor.
//
///Timer Resolution and Order of Execution
///---------------------------------------
// It is intended that recurring and one-time events are processed as closely
// as possible to their respective time values, and that they are processed in
// the order scheduled.  However, this component *guarantees* only that events
// will not be executed before their scheduled time.  Generally, events that
// are scheduled more than 1 microsecond apart will be executed in the order
// scheduled; but different behavior may be observed when events are submitted
// after (or shortly before) their scheduled time.
//
// When events are executed in the dispatcher thread and take longer to
// complete than the time between events, the dispatcher can fall behind.  In
// this case, events will be executed in the correct order as soon as the
// dispatcher thread becomes available; once the backlog is worked off, events
// will be executed at or near their scheduled times.
//
///Supported Clock-Types
///---------------------
// The component &#39;bsls::SystemClockType&#39; supplies the enumeration indicating
// the system clock on which times supplied to other methods should be based.
// If the clock type indicated at construction is
// &#39;bsls::SystemClockType::e_REALTIME&#39;, time should be expressed as an absolute
// offset since 00:00:00 UTC, January 1, 1970 (which matches the epoch used in
// &#39;bdlt::CurrentTime::now(bsls::SystemClockType::e_REALTIME)&#39;.  If the clock
// type indicated at construction is &#39;bsls::SystemClockType::e_MONOTONIC&#39;, time
// should be expressed as an absolute offset since the epoch of this clock
// (which matches the epoch used in
// &#39;bdlt::CurrentTime::now(bsls::SystemClockType::e_MONOTONIC)&#39;.
//
///Usage
///-----
// This section illustrates intended use of this component.
//
///Example 1: Simple Clock
///- - - - - - - - - - - -
// In this example we wish to log some statistics periodically.  We define a
// method to store the value of a variable into an array, and set up a
// scheduler to call that as a recurring event.
//..
//   bsls::AtomicInt  g_data;  // Some global data we want to track
//   typedef pair&lt;bdlt::Datetime, int&gt; Value;
//
//   void saveData(vector&lt;Value&gt; *array)
//   {
//      array-&gt;push_back(Value(bdlt::CurrentTime::utc(), g_data));
//   }
//..
// We allow the scheduler to run for a short time while changing this value and
// observe that the callback is executed:
//..
//   bdlmt::EventScheduler scheduler;
//   vector&lt;Value&gt; values;
//
//   scheduler.scheduleRecurringEvent(bsls::TimeInterval(1.5),
//                                  bdlf::BindUtil::bind(&amp;saveData, &amp;values)));
//   scheduler.start();
//   bdlt::Datetime start = bdlt::CurrentTime::utc();
//   while ((bdlt::CurrentTime::utc() -
//                                          start).totalSeconds() &lt; 7) {
//     ++g_data;
//   }
//   scheduler.stop();
//   assert(values.size() &gt;= 4);
//   for (int i = 0; i &lt; values.size(); ++i) {
//     bsl::cout &lt;&lt; &quot;At &quot; &lt;&lt; values[i].first &lt;&lt; &quot; g_data was &quot;
//               &lt;&lt; values[i].second &lt;&lt; bsl::endl;
//   }
//..
// This will display, e.g.:
//..
//     At 06MAY2008_21:19:17.092 g_data was 816196
//     At 06MAY2008_21:19:18.592 g_data was 1620749
//     At 06MAY2008_21:19:20.092 g_data was 2443358
//     At 06MAY2008_21:19:21.592 g_data was 3267721
//..
//
///Example 2: Server Timeouts
/// - - - - - - - - - - - - -
// The following example shows how to use a &#39;bdlmt::EventScheduler&#39; to
// implement a timeout mechanism in a server.  &#39;my_Session&#39; maintains several
// connections.  It closes a connection if the data for it does not arrive
// before a timeout (specified at the server creation time).
//
//..
//    class my_Session{
//        // This class encapsulates the data and state associated with a
//        // connection and provides a method &#39;processData&#39; to process the
//        // incoming data for the connection.
//      public:
//        int processData(void *data, int length);
//            // Process the specified &#39;data&#39; of the specified &#39;length&#39;.  (TBD)
//    };
//
//    class my_Server {
//     // This class implements a server maintaining several connections.
//     // A connection is closed if the data for it does not arrive
//     // before a timeout (specified at the server creation time).
//
//     struct Connection {
//         bdlmt::EventSchedulerEventHandle d_timerId;   // handle for timeout
//                                                     // event
//
//         my_Session *d_session_p;                    // session for this
//                                                     // connection
//     };
//
//     bsl::vector&lt;Connection*&gt; d_connections; // maintained connections
//     bdlmt::EventScheduler      d_scheduler;   // timeout event scheduler
//     bsls::TimeInterval        d_ioTimeout;   // time out
//
//     void newConnection(Connection *connection);
//         // Add the specified &#39;connection&#39; to this server and schedule
//         // the timeout event that closes this connection if the data
//         // for this connection does not arrive before the timeout.
//
//     void closeConnection(Connection *connection);
//         // Close the specified &#39;connection&#39; and remove it from this server.
//
//     void dataAvailable(Connection *connection, void *data, int length);
//         // Return if the specified &#39;connection&#39; has already timed-out.
//         // If not, cancel the existing timeout event for the &#39;connection&#39;,
//         // process the specified &#39;data&#39; of the specified &#39;length&#39; and
//         // schedule a new timeout event that closes the &#39;connection&#39; if
//         // the data does not arrive before the timeout.
//
//   public:
//     my_Server(const bsls::TimeInterval&amp;  ioTimeout,
//               bslma::Allocator         *allocator = 0);
//         // Construct a &#39;my_Server&#39; object with a timeout value of
//         // &#39;ioTimeout&#39; seconds.  Optionally specify a &#39;allocator&#39; used to
//         // supply memory.  If &#39;allocator&#39; is 0, the currently installed
//         // default allocator is used.
//
//     ~my_Server();
//         // Perform the required clean-up and destroy this object.
// };
//
// my_Server::my_Server(const bsls::TimeInterval&amp;  ioTimeout,
//                      bslma::Allocator          *alloc)
// : d_connections(alloc)
// , d_scheduler(alloc)
// , d_ioTimeout(ioTimeout)
// {
//      // TBD: logic to start monitoring the arriving connections or data
//
//      d_scheduler.start();
// }
//
// my_Server::~my_Server()
// {
//     // TBD: logic to clean up
//
//     d_scheduler.stop();
// }
//
// void my_Server::newConnection(my_Server::Connection *connection)
// {
//     // TBD: logic to add &#39;connection&#39; to &#39;d_connections&#39;
//
//     // setup the timeout for data arrival
//     d_scheduler.scheduleEvent(
//        &amp;connection-&gt;d_timerId,
//        bdlt::CurrentTime::now() + d_ioTimeout,
//        bdlf::BindUtil::bind(&amp;my_Server::closeConnection, this, connection));
// }
//
// void my_Server::closeConnection(my_Server::Connection *connection)
// {
//     // TBD: logic to close the &#39;connection&#39; and remove it from &#39;d_ioTimeout&#39;
// }
//
// void my_Server::dataAvailable(my_Server::Connection *connection,
//                               void                  *data,
//                               int                    length)
// {
//     // If connection has already timed out and closed, simply return.
//     if (d_scheduler.cancelEvent(connection-&gt;d_timerId)) {
//         return;                                                    // RETURN
//     }
//
//     // process the data
//     connection-&gt;d_session_p-&gt;processData(data, length);
//
//     // setup the timeout for data arrival
//     d_scheduler.scheduleEvent(
//        &amp;connection-&gt;d_timerId,
//        bdlt::CurrentTime::now() + d_ioTimeout,
//        bdlf::BindUtil::bind(&amp;my_Server::closeConnection, this, connection));
// }
//..

#ifndef INCLUDED_BDLSCM_VERSION
#include &lt;bdlscm_version.h&gt;
#endif

#ifndef INCLUDED_BDLCC_SKIPLIST
#include &lt;bdlcc_skiplist.h&gt;
#endif

#ifndef INCLUDED_BSLMT_CONDITION
#include &lt;bslmt_condition.h&gt;
#endif

#ifndef INCLUDED_BSLMT_MUTEX
#include &lt;bslmt_mutex.h&gt;
#endif

#ifndef INCLUDED_BSLMT_THREADATTRIBUTES
#include &lt;bslmt_threadattributes.h&gt;
#endif

#ifndef INCLUDED_BSLMT_THREADUTIL
#include &lt;bslmt_threadutil.h&gt;
#endif

#ifndef INCLUDED_BSLS_SYSTEMCLOCKTYPE
#include &lt;bsls_systemclocktype.h&gt;
#endif

#ifndef INCLUDED_BSLS_TIMEINTERVAL
#include &lt;bsls_timeinterval.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITS
#include &lt;bslalg_typetraits.h&gt;
#endif

#ifndef INCLUDED_BSLMA_ALLOCATOR
#include &lt;bslma_allocator.h&gt;
#endif

#ifndef INCLUDED_BSLS_TYPES
#include &lt;bsls_types.h&gt;
#endif

#ifndef INCLUDED_BSL_FUNCTIONAL
#include &lt;bsl_functional.h&gt;
#endif

#ifndef INCLUDED_BSL_UTILITY
#include &lt;bsl_utility.h&gt;
#endif

namespace BloombergLP {


namespace bdlmt {

class EventSchedulerEventHandle;
class EventSchedulerRecurringEventHandle;

                            // ====================
                            // class EventScheduler
                            // ====================

class EventScheduler {
    // This class provides a thread-safe event scheduler that executes
    // callbacks in a separate &quot;dispatcher thread.&quot;  &#39;start&#39; must be invoked to
    // start dispatching the callbacks.  &#39;stop&#39; pauses the dispatching of the
    // callbacks without removing the pending events.

  private:
    // PRIVATE TYPES
    typedef bsl::pair&lt;bsl::function&lt;void()&gt;, bsls::TimeInterval&gt;
                                                           RecurringEventData;

    typedef bdlcc::SkipList&lt;bsls::Types::Int64,
                            RecurringEventData&gt;            RecurringEventQueue;

    typedef bdlcc::SkipList&lt;bsls::Types::Int64,
                            bsl::function&lt;void()&gt; &gt;        EventQueue;

    // FRIENDS
    friend class EventSchedulerEventHandle;
    friend class EventSchedulerRecurringEventHandle;

  public:
    // PUBLIC TYPES
    struct Event {};
    struct RecurringEvent {};
        // Pointers to the opaque structures &#39;Event&#39; and &#39;RecurringEvent&#39; are
        // populated by the &quot;Raw&quot; API of &#39;EventScheduler&#39;.

    typedef EventSchedulerEventHandle          EventHandle;

    typedef EventSchedulerRecurringEventHandle RecurringEventHandle;

    typedef bsl::function&lt;void(const bsl::function&lt;void()&gt;&amp;)&gt;
                                               Dispatcher;
        // Defines a type alias for the dispatcher functor type.

  private:
    // NOT IMPLEMENTED
    EventScheduler(const EventScheduler&amp;);
    EventScheduler&amp; operator=(const EventScheduler&amp;);

  private:
    // PRIVATE DATA
    bsls::SystemClockType::Enum
                          d_clockType;          // clock type used

    EventQueue            d_eventQueue;         // events

    RecurringEventQueue   d_recurringQueue;     // recurring events

    Dispatcher            d_dispatcherFunctor;  // dispatch events

    bslmt::ThreadUtil::Handle
                          d_dispatcherThread;   // dispatcher thread handle

    bslmt::Mutex          d_mutex;              // synchronizes access to
                                                // condition variables

    bslmt::Condition      d_queueCondition;     // condition variable used to
                                                // signal when the queues need
                                                // to be checked again (when
                                                // they become non-empty or get
                                                // a new front member)

    bslmt::Condition      d_iterationCondition; // condition variable used to
                                                // signal when the dispatcher
                                                // is ready to enter next
                                                // iteration (synchronizes
                                                // &#39;wait&#39; methods)

    volatile bool         d_running;            // controls the looping of the
                                                // dispatcher thread

    volatile bool         d_dispatcherAwaited;  // A thread is waiting for the
                                                // dispatcher to complete an
                                                // iteration

    RecurringEventQueue::Pair
                         *d_currentRecurringEvent;
                                                // Raw reference to the
                                                // scheduled event being
                                                // executed
    EventQueue::Pair     *d_currentEvent;
                                                // Raw reference to the
                                                // scheduled recurring event
                                                // being executed

    // PRIVATE MANIPULATORS
    bsls::Types::Int64 chooseNextEvent(bsls::Types::Int64 *now);
        // Pick either d_currentEvent or d_currentRecurringEvent as the next
        // event to be executed, given that the current time is the specified
        // (absolute) &#39;now&#39; interval, and return the (absolute) interval of the
        // chosen event.  If both &#39;d_currentEvent&#39; and
        // &#39;d_currentRecurringEvent&#39; are valid, release whichever one was not
        // chosen.  If both &#39;d_currentEvent&#39; and &#39;d_currentRecurringEvent&#39; are
        // scheduled before &#39;now&#39;, choose &#39;d_currentEvent&#39;.  The behavior is
        // undefined if neither d_currentEvent nor d_currentRecurringEvent is
        // valid.  Note that the argument and return value of this method are
        // expressed in terms of the number of microseconds elapsed since some
        // epoch, which is detemined by the clock indicated at construction
        // (see {&#39;Supported Clock-Types&#39;} in the component documentation).
        // Also note that this method may update the value of &#39;now&#39; with the
        // current system time if necessary.

    void dispatchEvents();
        // While d_running is true, execute events in the event and recurring
        // event queues at their scheduled times.  Note that this method
        // implements the dispatching thread.

    void releaseCurrentEvents();
        // Release &#39;d_currentRecurringEvent&#39; and &#39;d_currentEvent&#39;, if they
        // refer to valid events.

  public:
    // TRAITS
    BSLALG_DECLARE_NESTED_TRAITS(EventScheduler,
                                 bslalg::TypeTraitUsesBslmaAllocator);

    // CREATORS
    explicit EventScheduler(bslma::Allocator *basicAllocator = 0);
        // Construct an event scheduler using the default dispatcher functor
        // (see the &quot;The dispatcher thread and the dispatcher functor&quot; section
        // in component-level doc) and use the realtime clock epoch for all
        // time intervals (see {Supported Clock-Types} in the component
        // documentation).  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    explicit EventScheduler(bsls::SystemClockType::Enum  clockType,
                            bslma::Allocator            *basicAllocator = 0);
        // Construct an event scheduler using the default dispatcher functor
        // (see the &quot;The dispatcher thread and the dispatcher functor&quot; section
        // in component-level doc) and use the specified &#39;clockType&#39; to
        // indicate the epoch used for all time intervals (see {Supported
        // Clock-Types} in the component documentation).  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    explicit EventScheduler(const Dispatcher&amp;  dispatcherFunctor,
                            bslma::Allocator  *basicAllocator = 0);
        // Construct an event scheduler using the specified &#39;dispatcherFunctor&#39;
        // (see &quot;The dispatcher thread and the dispatcher functor&quot; section in
        // component-level doc) and use the realtime clock epoch for all time
        // intervals (see {Supported Clock-Types} in the component
        // documentation).  Optionally specify a &#39;basicAllocator&#39; used to
        // supply memory.  If &#39;basicAllocator&#39; is 0, the currently installed
        // default allocator is used.

    explicit EventScheduler(const Dispatcher&amp;            dispatcherFunctor,
                            bsls::SystemClockType::Enum  clockType,
                            bslma::Allocator            *basicAllocator = 0);
        // Construct an event scheduler using the specified &#39;dispatcherFunctor&#39;
        // (see &quot;The dispatcher thread and the dispatcher functor&quot; section in
        // component-level doc) and use the specified &#39;clockType&#39; to indicate
        // the epoch used for all time intervals (see {Supported Clock-Types}
        // in the component documentation).  Optionally specify a
        // &#39;basicAllocator&#39; used to supply memory.  If &#39;basicAllocator&#39; is 0,
        // the currently installed default allocator is used.

    ~EventScheduler();
        // Discard all unprocessed events and destroy this object.  The
        // behavior is undefined unless the scheduler is stopped.

    // MANIPULATORS
    void cancelAllEvents();
        // Cancel all recurring and one-time events scheduled in this
        // EventScheduler.

    void cancelAllEventsAndWait();
        // Cancel all recurring and one-time events scheduled in this
        // EventScheduler.  Block until all events have either been cancelled
        // or dispatched before this call returns.  The behavior is undefined
        // if this method is invoked from the dispatcher thread.

    int cancelEvent(const Event          *handle);
    int cancelEvent(const RecurringEvent *handle);
        // Cancel the event having the specified &#39;handle&#39;.  Return 0 on
        // successful cancellation, and a non-zero value if the &#39;handle&#39; is
        // invalid *or* if the event has already been dispatched or canceled.

    int cancelEvent(EventHandle          *handle);
    int cancelEvent(RecurringEventHandle *handle);
        // Cancel the event having the specified &#39;handle&#39; and release the
        // handle.  Return 0 on successful cancellation, and a non-zero value
        // if the &#39;handle&#39; is invalid *or* if the event has already been
        // dispatched or canceled.  Note that &#39;handle&#39; is released whether this
        // call is successful or not.

    int cancelEventAndWait(const Event          *handle);
    int cancelEventAndWait(const RecurringEvent *handle);
        // Cancel the event having the specified &#39;handle&#39;.  Block until the
        // event having &#39;handle&#39; (if it is valid) is either successfully
        // canceled or dispatched before the call returns.  Return 0 on
        // successful cancellation, and a non-zero value if &#39;handle&#39; is invalid
        // *or* if the event has already been dispatched or canceled.  The
        // behavior is undefined if this method is invoked from the dispatcher
        // thread.  Note that if the event is being executed when this method
        // is invoked, this method will block until it is completed and then
        // return a nonzero value.

    int cancelEventAndWait(EventHandle          *handle);
    int cancelEventAndWait(RecurringEventHandle *handle);
        // Cancel the event having the specified &#39;handle&#39; and release
        // &#39;*handle&#39;.  Block until the event having &#39;handle&#39; (if it is valid)
        // is either successfully canceled or dispatched before the call
        // returns.  Return 0 on successful cancellation, and a non-zero value
        // if &#39;handle&#39; is invalid *or* if the event has already been dispatched
        // or canceled.  The behavior is undefined if this method is invoked
        // from the dispatcher thread.  Note that if the event is being
        // executed when this method is invoked, this method will block until
        // it is completed and then return a nonzero value.  Also note that it
        // is guaranteed that &#39;*handle&#39; will be released whether this call is
        // successful or not.

    void releaseEventRaw(Event          *handle);
    void releaseEventRaw(RecurringEvent *handle);
        // Release the specified &#39;handle&#39;.  Every handle reference added by
        // &#39;scheduleEventRaw&#39;, &#39;addEventRefRaw&#39;, &#39;scheduleRecurringEventRaw&#39;,
        // or &#39;addRecurringEventRefRaw&#39; must be released using this method to
        // avoid leaking resources.  The behavior is undefined if the value of
        // &#39;handle&#39; is used for any purpose after being released.

    int rescheduleEvent(const Event               *handle,
                        const bsls::TimeInterval&amp;  newTime);
        // Reschedule the event referred to by the specified &#39;handle&#39; at the
        // specified &#39;newTime&#39;.  Return 0 on successful reschedule, and a
        // non-zero value if the &#39;handle&#39; is invalid *or* if the event has
        // already been dispatched.  The &#39;newTime&#39; is an absolute time
        // represented as an interval from some epoch, which is detemined by
        // the clock indicated at construction (see {&#39;Supported Clock-Types&#39;}
        // in the component documentation).

    int rescheduleEventAndWait(const Event               *handle,
                               const bsls::TimeInterval&amp;  newTime);
        // Reschedule the event referred to by the specified &#39;handle&#39; at the
        // specified &#39;newTime&#39;.  Block until the event having &#39;handle&#39; (if it
        // is valid) is either successfully rescheduled or dispatched before
        // the call returns.  Return 0 on successful reschedule, and a non-zero
        // value if &#39;handle&#39; is invalid *or* if the event has already been
        // dispatched.  The &#39;newTime&#39; is an absolute time represented as an
        // interval from some epoch, which is detemined by the clock indicated
        // at construction (see {Supported Clock-Types} in the component
        // documentation).  The behavior is undefined if this method is invoked
        // from the dispatcher thread.

    void scheduleEvent(const bsls::TimeInterval&amp;     time,
                       const bsl::function&lt;void()&gt;&amp;  callback);
    void scheduleEvent(EventHandle                  *event,
                       const bsls::TimeInterval&amp;     time,
                       const bsl::function&lt;void()&gt;&amp;  callback);
        // Schedule the specified &#39;callback&#39; to be dispatched at the specified
        // &#39;time&#39;.  Load into the optionally specified &#39;event&#39; a handle that
        // can be used to cancel the event (by invoking &#39;cancelEvent&#39;).  The
        // &#39;time&#39; is an absolute time represented as an interval from some
        // epoch, which is detemined by the clock indicated at construction
        // (see {&#39;Supported Clock-Types&#39;} in the component documentation).
        // Note that &#39;time&#39; may be in the past, in which case the event will be
        // executed as soon as possible.

    void scheduleEventRaw(Event                        **event,
                          const bsls::TimeInterval&amp;      time,
                          const bsl::function&lt;void()&gt;&amp;   callback);
        // Schedule the specified &#39;callback&#39; to be dispatched at the specified
        // &#39;time&#39;.  Load into the specified &#39;event&#39; pointer a handle that can
        // be used to cancel the event (by invoking &#39;cancelEvent&#39;).  The &#39;time&#39;
        // is an absolute time represented as an interval from some epoch,
        // which is detemined by the clock indicated at construction (see
        // {&#39;Supported Clock-Types&#39;} in the component documentation).  The
        // &#39;event&#39; pointer must be released by invoking &#39;releaseEventRaw&#39; when
        // it is no longer needed.

    void scheduleRecurringEvent(
               const bsls::TimeInterval&amp;    interval,
               const bsl::function&lt;void()&gt;&amp; callback,
               const bsls::TimeInterval&amp;    startTime = bsls::TimeInterval(0));
    void scheduleRecurringEvent(
              RecurringEventHandle         *event,
              const bsls::TimeInterval&amp;     interval,
              const bsl::function&lt;void()&gt;&amp;  callback,
              const bsls::TimeInterval&amp;     startTime = bsls::TimeInterval(0));
        // Schedule a recurring event that invokes the specified &#39;callback&#39; at
        // every specified &#39;interval&#39;, with the first event dispatched at the
        // optionally specified &#39;startTime&#39;.  If &#39;startTime&#39; is not specified,
        // the first event is dispatched at one &#39;interval&#39; from now.  Load into
        // the optionally specified &#39;event&#39; a handle that can be used to cancel
        // the event (by invoking &#39;cancelEvent&#39;).  The &#39;startTime&#39; is an
        // absolute time represented as an interval from some epoch, which is
        // detemined by the clock indicated at construction (see {Supported
        // Clock-Types} in the component documentation).  The behavior is
        // undefined if &#39;interval&#39; is exactly 0 seconds.

    void scheduleRecurringEventRaw(
             RecurringEvent               **event,
             const bsls::TimeInterval&amp;      interval,
             const bsl::function&lt;void()&gt;&amp;   callback,
             const bsls::TimeInterval&amp;      startTime = bsls::TimeInterval(0));
        // Schedule a recurring event that invokes the specified &#39;callback&#39; at
        // every specified &#39;interval&#39;, with the first event dispatched at the
        // optionally specified &#39;startTime&#39;.  If &#39;startTime&#39; is not specified,
        // the first event is dispatched at one &#39;interval&#39; from now.  Load into
        // the specified &#39;event&#39; pointer a handle that can be used to cancel
        // the event (by invoking &#39;cancelEvent&#39;).  The &#39;startTime&#39; is an
        // absolute time represented as an interval from some epoch, which is
        // detemined by the clock indicated at construction (see {Supported
        // Clock-Types} in the component documentation).  The &#39;event&#39; pointer
        // must be released by invoking &#39;releaseEventRaw&#39; when it is no longer
        // needed.  The behavior is undefined if &#39;interval&#39; is exactly 0
        // seconds.

    int start();
        // Begin dispatching events on this scheduler.  The dispatcher thread
        // will have default attributes.  Return 0 on success, and a non-zero
        // value otherwise.  If this scheduler is already started then return
        // 0 with no effect.  The scheduler must be stopped by invoking &#39;stop&#39;
        // before it is destroyed.  Note that any events scheduled in the past
        // will be dispatched immediately upon starting.

    int start(const bslmt::ThreadAttributes&amp; threadAttributes);
        // Begin dispatching events on this scheduler, using the specified
        // &#39;threadAttributes&#39; for the dispatcher thread, except the DETACHED
        // attribute will always be overridden to be joinable.  Return 0 on
        // success, and a non-zero value otherwise.  If this scheduler is
        // already started then return 0 with no effect.  The scheduler must be
        // stopped by invoking &#39;stop&#39; before it is destroyed.  Note that any
        // events scheduled in the past will be dispatched immediately upon
        // starting.

    void stop();
        // End the dispatching of events on this scheduler (but do not remove
        // any pending events), and wait for any (one) currently executing
        // event to complete.  If the scheduler is already stopped then this
        // method has no effect.  This scheduler can be restarted by invoking
        // &#39;start&#39;.  The behavior is undefined if this method is invoked from
        // the dispatcher thread.

    // ACCESSORS
    Event *addEventRefRaw(Event *handle) const;
        // Increment the reference count for the event referred to by the
        // specified &#39;handle&#39; and return &#39;handle&#39;.  There must be a
        // corresponding call to &#39;releaseEventRaw&#39; when the reference is no
        // longer needed.

    RecurringEvent *addRecurringEventRefRaw(RecurringEvent *handle) const;
        // Increment the reference count for the recurring event referred to by
        // the specified &#39;handle&#39; and return &#39;handle&#39;.  There must be a
        // corresponding call to &#39;releaseEventRaw&#39; when the reference is no
        // longer needed.

    bsls::SystemClockType::Enum clockType() const;
        // Return the value of the clock type that this object was created
        // with.

    int numEvents() const;
        // Return the number of pending and executing one-time events in this
        // scheduler.

    int numRecurringEvents() const;
        // Return the number of recurring events registered with this
        // scheduler.
};

                      // ===============================
                      // class EventSchedulerEventHandle
                      // ===============================

class EventSchedulerEventHandle
{
    // Objects of this type refer to events in the &#39;EventScheduler&#39;
    // API.  They are convertible to &#39;const Event*&#39; references and may be used
    // in any method which expects them.

    // PRIVATE TYPES
    typedef bdlcc::SkipList&lt;bsls::Types::Int64,
                            bsl::function&lt;void()&gt; &gt; EventQueue;

    // DATA
    EventQueue::PairHandle  d_handle;

    // FRIENDS
    friend class EventScheduler;

  public:
    // PUBLIC TYPES
    typedef EventScheduler::Event Event;

    // CREATORS
    EventSchedulerEventHandle();
        // Create a new handle object that does not refer to an event.

    EventSchedulerEventHandle(const EventSchedulerEventHandle&amp; original);
        // Create a new handle object referring to the same event as the
        // specified &#39;rhs&#39; handle.

    ~EventSchedulerEventHandle();
        // Destroy this object and release the managed reference, if any.

    // MANIPULATORS
    EventSchedulerEventHandle&amp; operator=(const EventSchedulerEventHandle&amp; rhs);
        // Release this handle&#39;s reference, if any; then make this handle refer
        // to the same event as the specified &#39;rhs&#39; handle.  Return a
        // modifiable reference to this handle.

    void release();
        // Release the reference (if any) held by this object.

    // ACCESSORS
    operator const Event*() const;
        // Return a &quot;raw&quot; pointer to the event managed by this handle, or 0 if
        // this handle does not manage a reference.
};

                  // ========================================
                  // class EventSchedulerRecurringEventHandle
                  // ========================================

class EventSchedulerRecurringEventHandle
{
    // Objects of this type refer to recurring events in the &#39;EventScheduler&#39;
    // API.  They are convertible to &#39;const RecurringEvent*&#39; references and may
    // be used in any method which expects these.

    // PRIVATE TYPES
    typedef bsl::pair&lt;bsl::function&lt;void()&gt;, bsls::TimeInterval&gt;
                                                     RecurringEventData;
    typedef bdlcc::SkipList&lt;bsls::Types::Int64,
                          RecurringEventData&gt;        RecurringEventQueue;

    // DATA
    RecurringEventQueue::PairHandle  d_handle;

    // FRIENDS
    friend class EventScheduler;

  public:
    // PUBLIC TYPES
    typedef EventScheduler::RecurringEvent RecurringEvent;

    // CREATORS
    EventSchedulerRecurringEventHandle();
        // Create a new handle object.

    EventSchedulerRecurringEventHandle(
                           const EventSchedulerRecurringEventHandle&amp; original);
        // Create a new handle object referring to the same recurring event as
        // the specified &#39;rhs&#39; handle.

    ~EventSchedulerRecurringEventHandle();
        // Destroy this object and release the managed reference, if any.

    // MANIPULATORS
    EventSchedulerRecurringEventHandle&amp; operator=(
                                const EventSchedulerRecurringEventHandle&amp; rhs);
        // Release the reference managed by this handle, if any; then make this
        // handle refer to the same recurring event as the specified &#39;rhs&#39;
        // handle.  Return a modifiable reference to this event handle.

    void release();
        // Release the reference managed by this handle, if any.

    // ACCESSORS
    operator const RecurringEvent*() const;
        // Return a &quot;raw&quot; pointer to the recurring event managed by this
        // handle, or 0 if this handle does not manage a reference.

};

// ============================================================================
//                            INLINE DEFINITIONS
// ============================================================================

                      // -------------------------------
                      // class EventSchedulerEventHandle
                      // -------------------------------

// CREATORS
inline
EventSchedulerEventHandle::EventSchedulerEventHandle()
{
}

inline
EventSchedulerEventHandle::EventSchedulerEventHandle(
                                     const EventSchedulerEventHandle&amp; original)
: d_handle(original.d_handle)
{
}

inline
EventSchedulerEventHandle::~EventSchedulerEventHandle()
{
}

// MANIPULATORS
inline
EventSchedulerEventHandle&amp;
EventSchedulerEventHandle::operator=(const EventSchedulerEventHandle&amp; rhs)
{
    d_handle = rhs.d_handle;
    return *this;
}

inline
void EventSchedulerEventHandle::release()
{
    d_handle.release();
}
}  // close package namespace

// ACCESSORS

// The scoping of &quot;Event&quot; below should not be necessary, but xlc (versions 8
// and 9) requires it
inline
bdlmt::EventSchedulerEventHandle::
operator const bdlmt::EventSchedulerEventHandle::Event*() const
{
    return (const Event*)((const EventQueue::Pair*)d_handle);
}

namespace bdlmt {
                  // ----------------------------------------
                  // class EventSchedulerRecurringEventHandle
                  // ----------------------------------------

// CREATORS
inline
EventSchedulerRecurringEventHandle::EventSchedulerRecurringEventHandle()
{
}

inline
EventSchedulerRecurringEventHandle::EventSchedulerRecurringEventHandle(
                            const EventSchedulerRecurringEventHandle&amp; original)
: d_handle(original.d_handle)
{
}

inline
EventSchedulerRecurringEventHandle::
                                     ~EventSchedulerRecurringEventHandle()
{
}

// MANIPULATORS
inline
void EventSchedulerRecurringEventHandle::release()
{
    d_handle.release();
}

inline
EventSchedulerRecurringEventHandle&amp;
EventSchedulerRecurringEventHandle::operator=(
                                 const EventSchedulerRecurringEventHandle&amp; rhs)
{
    d_handle = rhs.d_handle;
    return *this;
}
}  // close package namespace

// ACCESSORS

// The scoping of &quot;RecurringEvent&quot; below should not be necessary, but xlc
// (versions 8 and 9) requires it
inline
bdlmt::EventSchedulerRecurringEventHandle::operator
       const bdlmt::EventSchedulerRecurringEventHandle::RecurringEvent*() const
{
    return (const RecurringEvent*)((const RecurringEventQueue::Pair*)d_handle);
}

namespace bdlmt {
                            // --------------------
                            // class EventScheduler
                            // --------------------

// MANIPULATORS
inline
int EventScheduler::cancelEvent(const Event *handle)
{
    const EventQueue::Pair *itemPtr =
                        reinterpret_cast&lt;const EventQueue::Pair*&gt;(
                                        reinterpret_cast&lt;const void*&gt;(handle));

    return d_eventQueue.remove(itemPtr);
}

inline
int EventScheduler::cancelEvent(const RecurringEvent *handle)
{
    const RecurringEventQueue::Pair *itemPtr =
                reinterpret_cast&lt;const RecurringEventQueue::Pair*&gt;(
                                        reinterpret_cast&lt;const void*&gt;(handle));

    return d_recurringQueue.remove(itemPtr);
}

inline
void EventScheduler::scheduleEvent(const bsls::TimeInterval&amp;    time,
                                   const bsl::function&lt;void()&gt;&amp; callback)
{
    scheduleEventRaw(0, time, callback);
}

inline
void EventScheduler::releaseEventRaw(Event *handle)
{
    d_eventQueue.releaseReferenceRaw(reinterpret_cast&lt;EventQueue::Pair*&gt;(
                                             reinterpret_cast&lt;void*&gt;(handle)));
}

inline
void EventScheduler::releaseEventRaw(RecurringEvent *handle)
{
    d_recurringQueue.releaseReferenceRaw(
                         reinterpret_cast&lt;RecurringEventQueue::Pair*&gt;(
                                             reinterpret_cast&lt;void*&gt;(handle)));
}

inline
void EventScheduler::scheduleRecurringEvent(
                                        const bsls::TimeInterval&amp;    interval,
                                        const bsl::function&lt;void()&gt;&amp; callback,
                                        const bsls::TimeInterval&amp;    startTime)
{
    scheduleRecurringEventRaw(0, interval, callback, startTime);
}

// ACCESSORS
inline
EventScheduler::Event*
EventScheduler::addEventRefRaw(Event *handle) const
{
    EventQueue::Pair *h = reinterpret_cast&lt;EventQueue::Pair*&gt;(
                                              reinterpret_cast&lt;void*&gt;(handle));
    return reinterpret_cast&lt;Event*&gt;(d_eventQueue.addPairReferenceRaw(h));
}

inline
EventScheduler::RecurringEvent*
EventScheduler::addRecurringEventRefRaw(RecurringEvent *handle) const
{
    RecurringEventQueue::Pair *h =
                               reinterpret_cast&lt;RecurringEventQueue::Pair*&gt;(
                                              reinterpret_cast&lt;void*&gt;(handle));
    return reinterpret_cast&lt;RecurringEvent*&gt;(
                                     d_recurringQueue.addPairReferenceRaw(h));
}

inline
bsls::SystemClockType::Enum EventScheduler::clockType() const
{
    return d_clockType;
}

inline
int EventScheduler::numEvents() const
{
    return d_eventQueue.length();
}

inline
int EventScheduler::numRecurringEvents() const
{
    return d_recurringQueue.length();
}

}  // close package namespace
}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2015 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
