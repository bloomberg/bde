<!doctype HTML public "-//W3C//DTD HTML 4.0 Frameset//EN">
<html>
<title>BDE 3.0</title>
<html>
<pre>
// bslstl_unorderedmultimap.h                                         -*-C++-*-
#ifndef INCLUDED_BSLSTL_UNORDEREDMULTIMAP
#define INCLUDED_BSLSTL_UNORDEREDMULTIMAP

#ifndef INCLUDED_BSLS_IDENT
#include &lt;bsls_ident.h&gt;
#endif
BSLS_IDENT(&quot;$Id: $&quot;)

//@PURPOSE: Provide an STL-compliant &#39;unordered_multimap&#39; container.
//
//@CLASSES:
//   bsl::unordered_multimap : hashed-map container
//
//@SEE_ALSO: bsl+stdhdrs
//
//@DESCRIPTION: This component defines a single class template,
// &#39;bsl::unordered_multimap&#39;, implementing the standard container holding a
// collection of (possibly repeated) keys, each mapped to an associated value
// (with minimal guarantees on ordering).
//
// An instantiation of &#39;unordered_multimap&#39; is an allocator-aware,
// value-semantic type whose salient attributes are its size (number of keys)
// and the set of key-value pairs the &#39;unordered_multimap&#39; contains, without
// regard to their order.  If &#39;unordered_multimap&#39; is instantiated with a key
// type or mapped value-type that is not itself value-semantic, then it will
// not retain all of its value-semantic qualities.  In particular, if the key
// or value type cannot be tested for equality, then an &#39;unordered_multimap&#39;
// containing that type cannot be tested for equality.  It is even possible to
// instantiate &#39;unordered_multimap&#39; with type that do not have an accessible
// copy-constructor, in which case the &#39;unordered_multimap&#39; will not be
// copyable.  Note that the equality operator for each key-value pair is used
// to determine when two &#39;unordered_multimap&#39; objects have the same value, and
// not the instance of the &#39;EQUAL&#39; template parameter supplied at construction.
//
// An &#39;unordered_multimap&#39; meets the requirements of an unordered associative
// container with forward iterators in the C++11 standard [unord].  The
// &#39;unordered_multimap&#39; implemented here adheres to the C++11 standard, except
// that it may rehash when setting the &#39;max_load_factor&#39; in order to preserve
// the property that the value is always respected (which is a potentially
// throwing operation) and it does not have interfaces that take rvalue
// references, &#39;initializer_list&#39;, &#39;emplace&#39;, or operations taking a variadic
// number of template parameters.  Note that excluded C++11 features are those
// that require (or are greatly simplified by) C++11 compiler support.
//
///Requirements on &#39;KEY&#39; and &#39;VALUE&#39;
///---------------------------------
// An &#39;unordered_multimap&#39; instantiation is a fully &quot;Value-Semantic Type&quot; (see
// {&#39;bsldoc_glossary&#39;}) only if the supplied &#39;KEY&#39; and &#39;VALUE&#39; template
// parameters are fully value-semantic.  It is possible to instantiate an
// &#39;unordered_multimap&#39; with &#39;KEY&#39; and &#39;VALUE&#39; parameter arguments that do not
// provide a full set of value-semantic operations, but then some methods of
// the container may not be instantiable.  The following terminology, adopted
// from the C++11 standard, is used in the function documentation of
// &#39;unordered_multimap&#39; to describe a function&#39;s requirements for the &#39;KEY&#39; and
// &#39;VALUE&#39; template parameters.  These terms are also defined in section
// [utility.arg.requirements] of the C++11 standard.  Note that, in the context
// of an &#39;unordered_multimap&#39; instantiation, the requirements apply
// specifically to the &#39;unordered_multimap&#39;s element type, &#39;value_type&#39;, which
// is an alias for &#39;std::pair&lt;const KEY, VALUE&gt;&#39;.
//
//: &quot;default-constructible&quot;:
//:     The type provides an accessible default constructor.
//:
//: &quot;copy-constructible&quot;:
//:     The type provides an accessible copy constructor.
//:
//: &quot;equality-comparable&quot;:
//:     The type provides an equality-comparison operator that defines an
//:     equivalence relationship and is both reflexive and transitive.
//
///Requirements on &#39;HASH&#39; and &#39;EQUAL&#39;
///----------------------------------
// The (template parameter) types &#39;HASH&#39; and &#39;EQUAL&#39; must be copy-constructible
// function-objects.  Note that this requirement is somewhat stronger than the
// requirement currently in the standard; see the discussion for Issue 2215
// (http://cplusplus.github.com/LWG/lwg-active.html#2215);
//
// &#39;HASH&#39; shall support a function call operator compatible with the following
// statements:
//..
//  HASH        hash;
//  KEY         key;
//  std::size_t result = hash(key);
//..
// where the definition of the called function meets the requirements of a
// hash function, as specified in {&#39;bslstl_hash&#39;|Standard Hash Function}.
//
// &#39;EQUAL&#39; shall support the a function call operator compatible with the
//  following statements:
//..
//  EQUAL equal;
//  KEY   key1, key2;
//  bool  result = equal(key1, key2);
//..
// where the definition of the called function defines an equivalence
// relationship on keys that is both reflexive and transitive.
//
// &#39;HASH&#39; and &#39;EQUAL&#39; function-objects are further constrained, such for any
// two objects whose keys compare equal by the comparator, shall produce the
// same value from the hasher.
//
///Memory Allocation
///-----------------
// The type supplied as the &#39;ALLOCATOR&#39; template parameter determines how this
// container will allocate memory.  The &#39;unordered_multimap&#39; template supports
// allocators meeting the requirements of the C++11 standard
// [allocator.requirements], and in addition it supports scoped-allocators
// derived from the &#39;bslma::Allocator&#39; memory allocation protocol.  Clients
// intending to use &#39;bslma&#39; style allocators should use the template&#39;s default
// &#39;ALLOCATOR&#39; type: The default type for the &#39;ALLOCATOR&#39; template parameter,
// &#39;bsl::allocator&#39;, provides a C++11 standard-compatible adapter for a
// &#39;bslma::Allocator&#39; object.
//
///&#39;bslma&#39;-Style Allocators
/// - - - - - - - - - - - -
// If the parameterized &#39;ALLOCATOR&#39; type of an &#39;unordered_multimap&#39;
// instantiation is &#39;bsl::allocator&#39;, then objects of that set type will
// conform to the standard behavior of a &#39;bslma&#39;-allocator-enabled type.  Such
// a type accepts an optional &#39;bslma::Allocator&#39; argument at construction.  If
// the address of a &#39;bslma::Allocator&#39; object is explicitly supplied at
// construction, it is used to supply memory for the &#39;unordered_multimap&#39;
// throughout its lifetime; otherwise, the &#39;unordered_multimap&#39; will use the
// default allocator installed at the time of the &#39;unordered_multimap&#39;s
// construction (see &#39;bslma_default&#39;).  In addition to directly allocating
// memory from the indicated &#39;bslma::Allocator&#39;, an &#39;unordered_multimap&#39;
// supplies that allocator&#39;s address to the constructors of contained objects
// of the parameterized &#39;KEY&#39; types with the
// &#39;bslalg::TypeTraitUsesBslmaAllocator&#39; trait.
//
///Operations
///----------
// This section describes the run-time complexity of operations on instances
// of &#39;unsupported_multimap&#39;:
//..
//  Legend
//  ------
//  &#39;K&#39;             - parameterized &#39;KEY&#39; type of the unordered multi map
//  &#39;V&#39;             - parameterized &#39;VALUE&#39; type of the unordered multi map
//  &#39;a&#39;, &#39;b&#39;        - two distinct objects of type &#39;unordered_multimap&lt;K, V&gt;&#39;
//  &#39;n&#39;, &#39;m&#39;        - number of elements in &#39;a&#39; and &#39;b&#39; respectively
//  &#39;w&#39;             - number of buckets of &#39;a&#39;
//  &#39;value_type&#39;    - unordered_multimap&lt;K, V&gt;::value_type
//  &#39;c&#39;             - comparator providing an ordering for objects of type &#39;K&#39;
//  &#39;al             - an STL-style memory allocator
//  &#39;i1&#39;, &#39;i2&#39;      - two iterators defining a sequence of &#39;value_type&#39; objects
//  &#39;k&#39;             - an object of type &#39;K&#39;
//  &#39;v&#39;             - an object of type &#39;value_type&#39;
//  &#39;p1&#39;, &#39;p2&#39;      - two iterators belonging to &#39;a&#39;
//  distance(i1,i2) - the number of elements in the range [i1, i2)
//  distance(p1,p2) - the number of elements in the range [p1, p2)
//
//  +----------------------------------------------------+--------------------+
//  | Operation                                          | Complexity         |
//  +====================================================+====================+
//  | unordered_multimap&lt;K, V&gt; a;    (dflt construction) | O[1]               |
//  | unordered_multimap&lt;K, V&gt; a(al);                    |                    |
//  +----------------------------------------------------+--------------------+
//  | unordered_multimap&lt;K, V&gt; a(b); (copy construction) | Average: O[n]      |
//  | unordered_multimap&lt;K, V&gt; a(b, al);                 | Worst: O[n^2]      |
//  +----------------------------------------------------+--------------------+
//  | unordered_multimap&lt;K, V&gt; a(w);                     | O[n]               |
//  | unordered_multimap&lt;K, V&gt; a(w, hf);                 |                    |
//  | unordered_multimap&lt;K, V&gt; a(w, hf, eq);             |                    |
//  | unordered_multimap&lt;K, V&gt; a(w, hf, eq, al);         |                    |
//  +----------------------------------------------------+--------------------+
//  | unordered_multimap&lt;K, V&gt; a(i1, i2);                | Average: O[N]      |
//  | unordered_multimap&lt;K, V&gt; a(i1, i2, n)              | Worst:  O[N^2]     |
//  | unordered_multimap&lt;K, V&gt; a(i1, i2, n, hf);         | where N =          |
//  | unordered_multimap&lt;K, V&gt; a(i1, i2, n, hf, eq);     |  distance(i1, i2)] |
//  | unordered_multimap&lt;K, V&gt; a(i1, i2, n, hf, eq, al); |                    |
//  +----------------------------------------------------+--------------------+
//  | a.~unordered_multimap&lt;K, V&gt;(); (destruction)       | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a = b;          (assignment)                       | Average: O[n]      |
//  |                                                    | Worst:   O[n^2]    |
//  +----------------------------------------------------+--------------------+
//  | a.begin(), a.end(), a.cbegin(), a.cend(),          | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a == b, a != b                                     | Best:  O[n]        |
//  |                                                    | Worst: O[n^2]      |
//  +----------------------------------------------------+--------------------+
//  | a.swap(b), swap(a, b                               | O[1] if &#39;a&#39; and    |
//  |                                                    | &#39;b&#39; use the same   |
//  |                                                    | allocator,         |
//  |                                                    | O[n + m] otherwise |
//  +----------------------------------------------------+--------------------+
//  | a.key_eq()                                         | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.hash_function()                                  | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.size()                                           | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.max_size()                                       | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.empty()                                          | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.allocator()                                      | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.insert(v)                                        | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.insert(p1, v)                                    | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.insert(i1, i2)                                   | Average: O[        |
//  |                                                    |   distance(i1, i2)]|
//  |                                                    | Worst:   O[n *     |
//  |                                                    |   distance(i1, i2)]|
//  +----------------------------------------------------+--------------------+
//  | a.erase(p1)                                        | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.erase(k)                                         | Average:           |
//  |                                                    |       O[a.count(k)]|
//  |                                                    | Worst:             |
//  |                                                    |       O[n]         |
//  +----------------------------------------------------+--------------------+
//  | a.erase(p1, p2)                                    | Average: O[        |
//  |                                                    |   distance(p1, p2)]|
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.clear()                                          | O[n]               |
//  +----------------------------------------------------+--------------------+
//  | a.find(k)                                          | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.count(k)                                         | Average: O[1]      |
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.equal_range(k)                                   | Average: O[        |
//  |                                                    |         a.count(k)]|
//  |                                                    | Worst:   O[n]      |
//  +----------------------------------------------------+--------------------+
//  | a.bucket_count()                                   | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.max_bucket_count()                               | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.bucket(k)                                        | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.bucket_size(k)                                   | O[a.bucket_size(k)]|
//  +----------------------------------------------------+--------------------+
//  | a.load_factor()                                    | O[1]               |
//  +----------------------------------------------------+--------------------+
//  | a.max_load_factor()                                | O[1]               |
//  | a.max_load_factor(z)                               | Average: O[1]      |
//  +----------------------------------------------------+--------------------+
//  | a.rehash(k)                                        | Average: O[n]      |
//  |                                                    | Worst:   O[n^2]    |
//  +----------------------------------------------------+--------------------+
//  | a.reserve(k)                                       | Average: O[n]      |
//  |                                                    | Worst:   O[n^2]    |
//  +----------------------------------------------------+--------------------+
//..
//
///Iterator, Pointer, and Reference Invalidation
///---------------------------------------------
// No method of &#39;unordered_multimap&#39; invalidates a pointer or reference to an
// element in the set, unless it also erases that element, such as any &#39;erase&#39;
// overload, &#39;clear&#39;, or the destructor (that erases all elements).  Pointers
// and references are stable through a rehash.
//
// Iterators to elements in the container are invalidated by any rehash, so
// iterators may be invalidated by an &#39;insert&#39; or &#39;emplace&#39; call if it triggers
// a rehash (but not otherwise).  Iterators to specific elements are also
// invalidated when that element is erased.  Note that the &#39;end&#39; iterator is
// not an iterator referring to any element in the container, so may be
// invalidated by any non-&#39;const&#39; method.
//
///Unordered Multi-Map Configuration
///---------------------------------
// The unordered multi-map has interfaces that can provide insight into and
// control of its inner workings.  The syntax and semantics of these interfaces
// for &#39;bslstl_unorderedmultimap&#39; are identical to those of
// &#39;bslstl_unorderedmap&#39;.  See the discussion in
// {&#39;bslstl_unorderedmap&#39;|Unordered Map Configuration} and the illustrative
// material in {&#39;bslstl_unorderedmap&#39;|Example 2}.
//
///Practical Requirements on &#39;HASH&#39;
///--------------------------------
// An important factor in the performance an unordered multi-map (and any of
// the other unordered containers) is the choice of hash function.  Please see
// the discussion in {&#39;bslstl_unorderedmap&#39;|Practical Requirements on &#39;HASH&#39;}.
//
///Usage
///-----
// In this section we show intended use of this component.
//
///Example 1: Creating a Concordance
///- - - - - - - - - - - - - - - - -
// Unordered multimap are useful in situations when there is no meaningful way
// to compare key values, when the order of the keys is irrelevant to the
// problem domain, or (even if there is a meaningful ordering) the benefit of
// ordering the results is outweighed by the higher performance provided by
// unordered maps (compared to ordered maps).
//
// One uses a multi-map (ordered or unordered) when there may be more than one
// mapped value associated with a key value.  In this example we will use
// &#39;bslstl_unorderedmultimap&#39; to create a concordance (an index of where each
// unique word appears in the set of documents).
//
// Our source of documents is a set of statically initialized arrays:
//..
//  static char document0[] =
//  &quot; IN CONGRESS, July 4, 1776.\n&quot;
//  &quot;\n&quot;
//  &quot; The unanimous Declaration of the thirteen united States of America,\n&quot;
//  &quot;\n&quot;
//  &quot; When in the Course of human events, it becomes necessary for one\n&quot;
//  &quot; people to dissolve the political bands which have connected them with\n&quot;
//  &quot; another, and to assume among the powers of the earth, the separate\n&quot;
//  &quot; and equal station to which the Laws of Nature and of Nature&#39;s God\n&quot;
//  &quot; entitle them, a decent respect to the opinions of mankind requires\n&quot;
//  &quot; that they should declare the causes which impel them to the\n&quot;
//  &quot; separation.  We hold these truths to be self-evident, that all men\n&quot;
//  &quot; are created equal, that they are endowed by their Creator with\n&quot;
//  &quot; certain unalienable Rights, that among these are Life, Liberty and\n&quot;
//  &quot; the pursuit of Happiness.--That to secure these rights, Governments\n&quot;
//  &quot; are instituted among Men, deriving their just powers from the consent\n&quot;
//  &quot; of the governed, --That whenever any Form of Government becomes\n&quot;
//  ...
//  &quot; States may of right do.  And for the support of this Declaration,\n&quot;
//  &quot; with a firm reliance on the protection of divine Providence, we\n&quot;
//  &quot; mutually pledge to each other our Lives, our Fortunes and our sacred\n&quot;
//  &quot; Honor.\n&quot;;
//
//  static char document1[] =
//  &quot;/The Universal Declaration of Human Rights\n&quot;
//  &quot;/-----------------------------------------\n&quot;
//  &quot;/Preamble\n&quot;
//  &quot;/ - - - -\n&quot;
//  &quot; Whereas recognition of the inherent dignity and of the equal and\n&quot;
//  &quot; inalienable rights of all members of the human family is the\n&quot;
//  &quot; foundation of freedom, justice and peace in the world,\n&quot;
//  ...
//  &quot;/Article 30\n&quot;
//  &quot;/ - - - - -\n&quot;
//  &quot; Nothing in this Declaration may be interpreted as implying for any\n&quot;
//  &quot; State, group or person any right to engage in any activity or to\n&quot;
//  &quot; perform any act aimed at the destruction of any of the rights and\n&quot;
//  &quot; freedoms set forth herein.\n&quot;;
//
//  static char document2[] =
//  &quot;/CHARTER OF FUNDAMENTAL RIGHTS OF THE EUROPEAN UNION\n&quot;
//  &quot;/---------------------------------------------------\n&quot;
//  &quot; PREAMBLE\n&quot;
//  &quot;\n&quot;
//  &quot; The peoples of Europe, in creating an ever closer union among them,\n&quot;
//  &quot; are resolved to share a peaceful future based on common values.\n&quot;
//  ...
//  &quot;/Article 54\n&quot;
//  &quot;/-  -  -  -\n&quot;
//  &quot; Prohibition of abuse of rights\n&quot;
//  &quot;\n&quot;
//  &quot; Nothing in this Charter shall be interpreted as implying any right to\n&quot;
//  &quot; engage in any activity or to perform any act aimed at the destruction\n&quot;
//  &quot; of any of the rights and freedoms recognized in this Charter or at\n&quot;
//  &quot; their limitation to a greater extent than is provided for herein.\n&quot;;
//
//  static char * const documents[]  = { document0,
//                                       document1,
//                                       document2
//                                     };
//  const int           numDocuments = sizeof documents / sizeof *documents;
//..
// First, we define several aliases to make our code more comprehensible.
//..
//  typedef bsl::pair&lt;int, int&gt;                  WordLocation;
//      // Document code number (&#39;first&#39;) and word offset (&#39;second&#39;) in that
//      // document specify a word location.  The first word in the document
//      // is at word offset 0.
//
//  typedef bsl::unordered_multimap&lt;bsl::string, WordLocation&gt;
//                                               Concordance;
//  typedef Concordance::const_iterator          ConcordanceConstItr;
//..
// Next, we create an (empty) unordered map to hold our word tallies.
//..
//  Concordance concordance;
//..
// Then, we define the set of characters that define word boundaries:
//..
//  const char *delimiters = &quot; \n\t,:;.()[]?!/&quot;;
//..
// Next, we extract the words from our documents.  Note that &#39;strtok&#39; modifies
// the document arrays (which were not made &#39;const&#39;).
//
// As each word is located, we create a map value -- a pair of the word
// converted to a &#39;bsl::string&#39; and a &#39;WordLocation&#39; object (itself a pair of
// document code and (word) offset of that word in the document) -- and insert
// the map value into the map.  Note that (unlike maps and unordered maps)
// there is no status to check; the insertion succeeds even if the key is
// already present in the (multi) map.
//..
//  for (int idx = 0; idx &lt; numDocuments; ++idx) {
//      int wordOffset = 0;
//      for (char *cur = strtok(documents[idx], delimiters);
//                 cur;
//                 cur = strtok(NULL,           delimiters)) {
//          WordLocation            location(idx, wordOffset++);
//          Concordance::value_type value(bsl::string(cur), location);
//          concordance.insert(value);
//      }
//  }
//..
// Then, we can readily print a complete concordance by iterating through the
// map.
//..
//  for (ConcordanceConstItr itr  = concordance.begin(),
//                           end  = concordance.end();
//                           end != itr; ++itr) {
//      printf(&quot;\&quot;%s\&quot;, %2d, %4d\n&quot;,
//             itr-&gt;first.c_str(),
//             itr-&gt;second.first,
//             itr-&gt;second.second);
//  }
//..
// Standard output shows:
//..
//  &quot;extent&quot;,  2, 3837
//  &quot;greater&quot;,  2, 3836
//  &quot;abuse&quot;,  2, 3791
//  &quot;constitutions&quot;,  2, 3782
//  &quot;affecting&quot;,  2, 3727
//  ...
//  &quot;he&quot;,  1, 1746
//  &quot;he&quot;,  1,  714
//  &quot;he&quot;,  0,  401
//  &quot;include&quot;,  2,  847
//..
// Next, if there are some particular words of interest, we seek them out using
// the &#39;equal_range&#39; method of the &#39;concordance&#39; object:
//..
//  const bsl::string wordsOfInterest[] = { &quot;human&quot;,
//                                          &quot;rights&quot;,
//                                          &quot;unalienable&quot;,
//                                          &quot;inalienable&quot;
//                                        };
//  const int   numWordsOfInterest = sizeof  wordsOfInterest
//                                 / sizeof *wordsOfInterest;
//
//  for (int idx = 0; idx &lt; numWordsOfInterest; ++idx) {
//     bsl::pair&lt;ConcordanceConstItr,
//               ConcordanceConstItr&gt; found = concordance.equal_range(
//                                                       wordsOfInterest[idx]);
//     for (ConcordanceConstItr itr  = found.first,
//                              end  = found.second;
//                              end != itr; ++itr) {
//         printf(&quot;\&quot;%s\&quot;, %2d, %4d\n&quot;,
//                itr-&gt;first.c_str(),
//                itr-&gt;second.first,
//                itr-&gt;second.second);
//     }
//     printf(&quot;\n&quot;);
//  }
//..
// Finally, we see on standard output:
//..
//  &quot;human&quot;,  2, 3492
//  &quot;human&quot;,  2, 2192
//  &quot;human&quot;,  2,  534
//  ...
//  &quot;human&quot;,  1,   65
//  &quot;human&quot;,  1,   43
//  &quot;human&quot;,  1,   25
//  &quot;human&quot;,  0,   20
//
//  &quot;rights&quot;,  2, 3583
//  &quot;rights&quot;,  2, 3553
//  &quot;rights&quot;,  2, 3493
//  ...
//  &quot;rights&quot;,  1,   44
//  &quot;rights&quot;,  1,   19
//  &quot;rights&quot;,  0,  496
//  &quot;rights&quot;,  0,  126
//
//  &quot;unalienable&quot;,  0,  109
//
//  &quot;inalienable&quot;,  1,   18
//
//..
// {&#39;bslstl_unorderedmap&#39;|Example 3} shows how to use the concordance to create
// an inverse concordance, and how to use the inverse concordance to find the
// context (surrounding words) of a word of interest.

#if defined(BSL_OVERRIDES_STD) &amp;&amp; !defined(BSL_STDHDRS_PROLOGUE_IN_EFFECT)
// Prevent &#39;bslstl&#39; headers from being included directly in &#39;BSL_OVERRIDES_STD&#39;
// mode.  Doing so is unsupported, and is likely to cause compilation errors.
#error &quot;&lt;bslstl_unorderedmultimap.h&gt; header can&#39;t be included directly in \
BSL_OVERRIDES_STD mode&quot;
#endif

#ifndef INCLUDED_BSLSCM_VERSION
#include &lt;bslscm_version.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ALLOCATOR
#include &lt;bslstl_allocator.h&gt;  // Can probably escape with a fwd-decl, but not
#endif                         // very user friendly

#ifndef INCLUDED_BSLSTL_ALLOCATORTRAITS
#include &lt;bslstl_allocatortraits.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_EQUALTO
#include &lt;bslstl_equalto.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASH
#include &lt;bslstl_hash.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASHTABLE
#include &lt;bslstl_hashtable.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASHTABLEBUCKETITERATOR
#include &lt;bslstl_hashtablebucketiterator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_HASHTABLEITERATOR
#include &lt;bslstl_hashtableiterator.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_ITERATORUTIL
#include &lt;bslstl_iteratorutil.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_PAIR
#include &lt;bslstl_pair.h&gt;
#endif

#ifndef INCLUDED_BSLSTL_UNORDEREDMAPKEYCONFIGURATION
#include &lt;bslstl_unorderedmapkeyconfiguration.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALLINK
#include &lt;bslalg_bidirectionallink.h&gt;
#endif

#ifndef INCLUDED_BSLALG_BIDIRECTIONALNODE
#include &lt;bslalg_bidirectionalnode.h&gt;
#endif

#ifndef INCLUDED_BSLALG_TYPETRAITHASSTLITERATORS
#include &lt;bslalg_typetraithasstliterators.h&gt;
#endif

#ifndef INCLUDED_BSLMA_USESBSLMAALLOCATOR
#include &lt;bslma_usesbslmaallocator.h&gt;
#endif

#ifndef INCLUDED_BSLMF_ISBITWISEMOVEABLE
#include &lt;bslmf_isbitwisemoveable.h&gt;
#endif

#ifndef INCLUDED_BSLMF_NESTEDTRAITDECLARATION
#include &lt;bslmf_nestedtraitdeclaration.h&gt;
#endif

#ifndef INCLUDED_BSLS_ASSERT
#include &lt;bsls_assert.h&gt;
#endif

#ifndef INCLUDED_CSTDDEF
#include &lt;cstddef&gt;  // for &#39;std::size_t&#39;
#define INCLUDED_CSTDDEF
#endif

namespace bsl {

template &lt;class KEY,
          class VALUE,                  // Not to be confused with &#39;value_type&#39;
          class HASH  = bsl::hash&lt;KEY&gt;,
          class EQUAL = bsl::equal_to&lt;KEY&gt;,
          class ALLOCATOR = bsl::allocator&lt;bsl::pair&lt;const KEY, VALUE&gt; &gt; &gt;
class unordered_multimap
{
    // an unordered sequence of unique keys (of the parameterized type, &#39;KEY&#39;).
    //
    // This class:
    //: o supports a complete set of *value-semantic* operations
    //:   o except for &#39;bdex&#39; serialization
    //: o is *exception-neutral* (agnostic except for the &#39;at&#39; method)
    //: o is *alias-safe*
    //: o is &#39;const&#39; *thread-safe*
    // For terminology see {&#39;bsldoc_glossary&#39;}.

    typedef bsl::allocator_traits&lt;ALLOCATOR&gt;              AllocatorTraits;
        // This typedef is an alias for the allocator traits type associated
        // with this container.

  public:
    // PUBLIC TYPES
    typedef KEY                         key_type;
    typedef VALUE                       mapped_type;
    typedef bsl::pair&lt;const KEY, VALUE&gt; value_type;
    typedef HASH                        hasher;
    typedef EQUAL                       key_equal;
    typedef ALLOCATOR                   allocator_type;

    typedef typename allocator_type::reference         reference;
    typedef typename allocator_type::const_reference   const_reference;

    typedef typename AllocatorTraits::size_type        size_type;
    typedef typename AllocatorTraits::difference_type  difference_type;
    typedef typename AllocatorTraits::pointer          pointer;
    typedef typename AllocatorTraits::const_pointer    const_pointer;

  private:
    // PRIVATE TYPES
    typedef ::BloombergLP::bslalg::BidirectionalLink   HashTableLink;

    typedef ::BloombergLP::bslstl::UnorderedMapKeyConfiguration&lt;value_type&gt;
                                                                    ListPolicy;
    typedef ::BloombergLP::bslstl::HashTable&lt;ListPolicy,
                                             HASH,
                                             EQUAL,
                                             ALLOCATOR&gt; Impl;
  public:
    // PUBLIC TYPES
    typedef ::BloombergLP::bslstl::HashTableIterator&lt;value_type,
                                                     difference_type&gt; iterator;
    typedef ::BloombergLP::bslstl::HashTableIterator&lt;const value_type,
                                                     difference_type&gt;
                                                                const_iterator;
    typedef ::BloombergLP::bslstl::HashTableBucketIterator&lt;value_type,
                                                           difference_type&gt;
                                                                local_iterator;
    typedef ::BloombergLP::bslstl::HashTableBucketIterator&lt;const value_type,
                                                           difference_type&gt;
                                                          const_local_iterator;

    // TRAITS
    BSLMF_NESTED_TRAIT_DECLARATION_IF(
                         unordered_multimap,
                         ::BloombergLP::bslmf::IsBitwiseMoveable,
                         ::BloombergLP::bslmf::IsBitwiseMoveable&lt;Impl&gt;::value);

  private:
    // DATA
    Impl d_impl;

    // FRIEND
    template &lt;class KEY2,
              class VALUE2,
              class HASH2,
              class EQUAL2,
              class ALLOCATOR2&gt;
    friend
    bool operator==(const unordered_multimap&lt;KEY2,
                                             VALUE2,
                                             HASH2,
                                             EQUAL2,
                                             ALLOCATOR2&gt;&amp;,
                    const unordered_multimap&lt;KEY2,
                                             VALUE2,
                                             HASH2,
                                             EQUAL2,
                                             ALLOCATOR2&gt;&amp;);

  public:
    // CREATORS
    explicit unordered_multimap(
                      size_type             initialNumBuckets = 0,
                      const hasher&amp;         hashFunction = hasher(),
                      const key_equal&amp;      keyEqual = key_equal(),
                      const allocator_type&amp; basicAllocator = allocator_type());
        // Construct an empty unordered multi map.  Optionally specify an
        // &#39;initialNumBuckets&#39; indicating the initial size of the array of
        // buckets of this container.  If &#39;initialNumBuckets&#39; is not supplied,
        // an implementation defined value is used.  Optionally specify a
        // &#39;hashFunction&#39; used to generate the hash values associated to the
        // key-value pairs contained in this object.  If &#39;hashFunction&#39; is not
        // supplied, a default-constructed object of type &#39;hasher&#39; is used.
        // Optionally specify a key-equality functor &#39;keyEqual&#39; used to verify
        // that two key values are the same.  If &#39;keyEqual&#39; is not supplied, a
        // default-constructed object of type &#39;key_equal&#39; is used.  Optionally
        // specify the &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is not supplied, a default-constructed object of
        // the (template parameter) type &#39;allocator_type&#39; is used.  If the
        // &#39;allocator_type&#39; is &#39;bsl::allocator&#39; (the default), then
        // &#39;basicAllocator&#39; shall be convertible to &#39;bslma::Allocator *&#39;.  If
        // the &#39;ALLOCATOR&#39; is &#39;bsl::allocator&#39; and &#39;basicAllocator&#39; is not
        // supplied, the currently installed default allocator is used to
        // supply memory.

    explicit unordered_multimap(const allocator_type&amp; basicAllocator);
        // Construct an empty unordered multi map that uses the specified
        // &#39;basicAllocator&#39; to supply memory.  Use a default-constructed object
        // of type &#39;hasher&#39; to generate hash values for the key-value pairs
        // contained in this object.  Also, use a default-constructed object of
        // type &#39;key_equal&#39; to verify that two key values are the same.  If the
        // &#39;allocator_type&#39; is &#39;bsl::allocator&#39; (the default), then
        // &#39;basicAllocator&#39; shall be convertible to &#39;bslma::Allocator *&#39;.

    unordered_multimap(const unordered_multimap&amp; original);
    unordered_multimap(const unordered_multimap&amp; original,
                       const allocator_type&amp;     basicAllocator);
        // Construct an unordered multi map having the same value as that of
        // the specified &#39;original&#39;.  Use a default-constructed object of type
        // &#39;hasher&#39; to generate hash values for the key-value pairs contained
        // in this object.  Also, use a default-constructed object of type
        // &#39;key_equal&#39; to verify that two key values are the same.  Optionally
        // specify the &#39;basicAllocator&#39; used to supply memory.  If
        // &#39;basicAllocator&#39; is not supplied, a default-constructed object of
        // type &#39;allocator_type&#39; is used.  If the &#39;allocator_type&#39; is
        // &#39;bsl::allocator&#39; (the default), then &#39;basicAllocator&#39; shall be
        // convertible to &#39;bslma::Allocator *&#39;.

    template &lt;class INPUT_ITERATOR&gt;
    unordered_multimap(INPUT_ITERATOR        first,
                       INPUT_ITERATOR        last,
                       size_type             initialNumBuckets = 0,
                       const hasher&amp;         hashFunction = hasher(),
                       const key_equal&amp;      keyEqual = key_equal(),
                       const allocator_type&amp; basicAllocator =allocator_type());
        // Construct an empty unordered multi map and insert each &#39;value_type&#39;
        // object in the sequence starting at the specified &#39;first&#39; element,
        // and ending immediately before the specified &#39;last&#39; element.
        // Optionally specify an &#39;initialNumBuckets&#39; indicating the initial
        // size of the array of buckets of this container.  If
        // &#39;initialNumBuckets&#39; is not supplied, an implementation defined value
        // is used.  Optionally specify a &#39;hashFunction&#39; used to generate hash
        // values for the key-value pairs contained in this object.  If
        // &#39;hashFunction&#39; is not supplied, a default-constructed object of type
        // &#39;hasher&#39; is used.  Optionally specify a key-equality functor
        // &#39;keyEqual&#39; used to verify that two key values are the same.  If
        // &#39;keyEqual&#39; is not supplied, a default-constructed object of type
        // &#39;key_equal&#39; is used.  Optionally specify the &#39;basicAllocator&#39; used
        // to supply memory.  If &#39;basicAllocator&#39; is not supplied, a
        // default-constructed object of the (template parameter) type
        // &#39;allocator_type&#39; is used.  If the &#39;allocator_type&#39; is
        // &#39;bsl::allocator&#39; (the default), then &#39;basicAllocator&#39; shall be
        // convertible to &#39;bslma::Allocator *&#39;.  If the &#39;allocator_type&#39; is
        // &#39;bsl::allocator&#39; and &#39;basicAllocator&#39; is not supplied, the currently
        // installed default allocator is used to supply memory.  The (template
        // parameter) type &#39;INPUT_ITERATOR&#39; shall meet the requirements of an
        // input iterator defined in the C++11 standard [24.2.3] providing
        // access to values of a type convertible to &#39;value_type&#39;.  The
        // behavior is undefined unless &#39;first&#39; and &#39;last&#39; refer to a sequence
        // of valid values where &#39;first&#39; is at a position at or before &#39;last&#39;.
        // Note that this method requires that the (template parameter) types
        // &#39;KEY&#39; and &#39;VALUE&#39; both be &quot;copy-constructible&quot; (see {Requirements on
        // &#39;KEY&#39; and &#39;VALUE&#39;}).

    ~unordered_multimap();
        // Destroy this object.

    // MANIPULATORS
    unordered_multimap&amp; operator=(const unordered_multimap&amp; rhs);
        // Assign to this object the value, hasher, and key-equality functor of
        // the specified &#39;rhs&#39; object, propagate to this object the allocator
        // of &#39;rhs&#39; if the &#39;ALLOCATOR&#39; type has trait
        // &#39;propagate_on_container_copy_assignment&#39;, and return a reference
        // providing modifiable access to this object.  Note that this method
        // requires that the (template parameter types) &#39;KEY&#39; and &#39;VALUE&#39; both
        // be &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).

    iterator begin();
        // Return an iterator providing modifiable access to the first
        // &#39;value_type&#39; object (in the sequence of &#39;value_type&#39; objects)
        // maintained by this multi-map, or the &#39;end&#39; iterator if this
        // multi-map is empty.

    iterator end();
        // Return an iterator providing modifiable access to the past-the-end
        // element in the sequence of &#39;value_type&#39; objects maintained by this
        // unordered multi map.

    local_iterator begin(size_type index);
        // Return a local iterator providing modifiable access to the first
        // &#39;value_type&#39; object in the sequence of &#39;value_type&#39; objects of the
        // bucket having the specified &#39;index&#39;, in the array of buckets
        // maintained by this multi-map, or the &#39;end(index)&#39; otherwise.

    local_iterator end(size_type index);
        // Return a local iterator providing modifiable access to the
        // past-the-end element in the sequence of &#39;value_type&#39; objects of the
        // bucket having the specified &#39;index&#39;s, in the array of buckets
        // maintained by this multi-map.

    template &lt;class SOURCE_TYPE&gt;
    iterator insert(const SOURCE_TYPE&amp; value);
        // Insert the specified &#39;value&#39; into this multi-map, and return an
        // iterator to the newly inserted element.  Note that this method
        // requires that the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; types
        // both be &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and
        // &#39;VALUE&#39;}).  Also note that this one template stands in for two
        // &#39;insert&#39; functions in the C++11 standard.

    template &lt;class SOURCE_TYPE&gt;
    iterator insert(const_iterator hint, const SOURCE_TYPE&amp; value);
        // Insert the specified &#39;value&#39; into this multi-map (in constant time
        // if the specified &#39;hint&#39; is a valid element in the bucket to which
        // &#39;value&#39; belongs).  Return an iterator referring to the newly
        // inserted &#39;value_type&#39; object in this multi-map whose key is the same
        // as that of &#39;value&#39;.  If &#39;hint&#39; is not a position in the bucket of
        // the key of &#39;value&#39;, this operation has worst case &#39;O[N]&#39; and average
        // case constant-time complexity, where &#39;N&#39; is the size of this
        // multi-map.  The behavior is undefined unless &#39;hint&#39; is a valid
        // iterator into this unordered multi map.  Note that this method
        // requires that the (template parameter) types &#39;KEY&#39; and &#39;VALUE&#39; both
        // be &quot;copy-constructible&quot; (see {Requirements on &#39;KEY&#39; and &#39;VALUE&#39;}).
        // Also note that this one template stands in for two &#39;insert&#39;
        // functions in the C++11 standard.

    template &lt;class INPUT_ITERATOR&gt;
    void insert(INPUT_ITERATOR first, INPUT_ITERATOR last);
        // Insert into this multi-map the value of each &#39;value_type&#39; object in
        // the range starting at the specified &#39;first&#39; iterator and ending
        // immediately before the specified &#39;last&#39; iterator.  The (template
        // parameter) type &#39;INPUT_ITERATOR&#39; shall meet the requirements of an
        // input iterator defined in the C++11 standard [24.2.3] providing
        // access to values of a type convertible to &#39;value_type&#39;.  The
        // behavior is undefined unless &#39;first&#39; and &#39;last&#39; refer to a sequence
        // of valid values where &#39;first&#39; is at a position at or before &#39;last&#39;.
        // Note that this method requires that the (template parameter) types
        // &#39;KEY&#39; and &#39;VALUE&#39; both be &quot;copy-constructible&quot; (see {Requirements on
        // &#39;KEY&#39; and &#39;VALUE&#39;}).

    iterator erase(const_iterator position);
        // Remove from this multi-map the &#39;value_type&#39; object at the specified
        // &#39;position&#39;, and return an iterator referring to the element
        // immediately following the removed element, or to the past-the-end
        // position if the removed element was the last element in the sequence
        // of elements maintained by this container.  The behavior is undefined
        // unless &#39;position&#39; refers to a &#39;value_type&#39; object in this multi-map.

    size_type erase(const key_type&amp; key);
        // Remove from this container all objects whose keys match the
        // specified &#39;key&#39;, and return the number of objects deleted.  If there
        // is no object matching &#39;key&#39;, return 0 with no other effect.

    iterator erase(const_iterator first, const_iterator last);
        // Remove from this container the objects starting at the specified
        // &#39;first&#39; position up to, but not including the specified &#39;last&#39;
        // position, and return &#39;last&#39;.  The behavior is undefined unless
        // &#39;first&#39; and &#39;last&#39; either refer to elements in this container or are
        // the &#39;end&#39; iterator, and the &#39;first&#39; position is at or before the
        // &#39;last&#39; position in the ordered sequence provided by this container.

    void clear();
        // Remove all entries from this container.  Note that the container is
        // empty after this call, but allocated memory may be retained for
        // future use.

    iterator find(const key_type&amp; key);
        // Return an iterator providing modifiable access to the first
        // &#39;value_type&#39; object in the sequence of all the &#39;value_type&#39; objects
        // of this container matching the specified &#39;key&#39;, if they exist, and
        // the past-the-end (&#39;end&#39;) iterator otherwise.

    pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; key);
        // Return a pair of iterators providing modifiable access to the
        // sequence of &#39;value_type&#39; objects in this multi-map matching the
        // specified &#39;key&#39;, where the the first iterator is positioned at the
        // start of the sequence, and the second is positioned one past the end
        // of the sequence.  If this unordered multi map contains no
        // &#39;value_type&#39; objects matching &#39;key&#39;, then the two returned iterators
        // will have the same value.

    void max_load_factor(float newLoadFactor);
        // Set the maximum load factor of this container to the specified
        // &#39;newLoadFactor&#39;.  This operation will not do an immediate rehash of
        // the container, if that is wanted, it is recommended that this call
        // be followed by a call to &#39;reserve&#39;.

    void rehash(size_type numBuckets);
        // Change the size of the array of buckets maintained by this container
        // to the specified &#39;numBuckets&#39;, and redistribute all the contained
        // elements into the new sequence of buckets, according to their hash
        // values.  Note that this operation has no effect if rehashing the
        // elements into &#39;numBuckets&#39; would cause this multi-map to exceed its
        // &#39;max_load_factor&#39;.

    void reserve(size_type numElements);
        // Increase the number of buckets of this set to a quantity such that
        // the ratio between the specified &#39;numElements&#39; and this quantity does
        // not exceed &#39;max_load_factor&#39;.  Note that this guarantees that, after
        // the reserve, elements can be inserted to grow the container to
        // &#39;size() == numElements&#39; without rehashing.  Also note that memory
        // allocations may still occur when growing the container to
        // &#39;size() == numElements&#39;.  Also note that this operation has no
        // effect if &#39;numElements &lt;= size()&#39;.

    void swap(unordered_multimap&amp; other);
        // Exchange the value of this object as well as its hasher and
        // key-equality functor with those of the specified &#39;other&#39; object.
        // Additionally, if
        // &#39;bslstl::AllocatorTraits&lt;ALLOCATOR&gt;::propagate_on_container_swap&#39; is
        // &#39;true&#39;, then exchange the allocator of this object with that of the
        // &#39;other&#39; object, and do not modify either allocator otherwise.  This
        // method provides the no-throw exception-safety guarantee and
        // guarantees &#39;O[1]&#39; complexity.  The behavior is undefined unless
        // either this object was created with the same allocator as &#39;other&#39; or
        // &#39;propagate_on_container_swap&#39; is &#39;true&#39;.

    // ACCESSORS
    allocator_type get_allocator() const;
        // Return (a copy of) the allocator used for memory allocation by this
        // multi-map.

    const_iterator begin() const;
    const_iterator cbegin() const;
        // Return an iterator providing non-modifiable access to the first
        // &#39;value_type&#39; object (in the sequence of &#39;value_type&#39; objects)
        // maintained by this multi-map, or the &#39;end&#39; iterator if this
        // multi-map is empty.

    const_iterator end() const;
    const_iterator cend() const;
        // Return an iterator providing non-modifiable access to the
        // past-the-end element (in the sequence of &#39;value_type&#39; objects)
        // maintained by this multi-map.

    const_local_iterator begin(size_type index) const;
    const_local_iterator cbegin(size_type index) const;
        // Return a local iterator providing non-modifiable access to the first
        // &#39;value_type&#39; object (in the sequence of &#39;value_type&#39; objects) of the
        // bucket having the specified &#39;index&#39; in the array of buckets
        // maintained by this container, or the &#39;end(index)&#39; otherwise.

    const_local_iterator end(size_type index) const;
    const_local_iterator cend(size_type index) const;
        // Return a local iterator providing non-modifiable access to the
        // past-the-end element (in the sequence of &#39;value_type&#39; objects) of
        // the bucket having the specified &#39;index&#39; in the array of buckets
        // maintained by this container.

    size_type bucket(const key_type&amp; key) const;
        // Return the index of the bucket, in the array of buckets of this
        // container, where values matching the specified &#39;key&#39; would be
        // inserted.

    size_type bucket_count() const;
        // Return the number of buckets in the array of buckets maintained by
        // this container.

    size_type max_bucket_count() const;
        // Return a theoretical upper bound on the largest number of buckets
        // that this container could possibly manage.  Note that there is no
        // guarantee that the container can successfully grow to the returned
        // size, or even close to that size without running out of resources.

    size_type bucket_size(size_type index) const;
        // Return the number of elements contained in the bucket at the
        // specified &#39;index&#39; in the array of buckets maintained by this
        // container.

    size_type count(const key_type&amp; key) const;
        // Return the number of &#39;value_type&#39; objects within this container
        // matching the specified &#39;key&#39;.

    bool empty() const;
        // Return &#39;true&#39; if this container contains no elements, and &#39;false&#39;
        // otherwise.

    pair&lt;const_iterator, const_iterator&gt; equal_range(
                                                    const key_type&amp; key) const;
        // Return a pair of iterators providing non-modifiable access to the
        // sequence of &#39;value_type&#39; objects in this container matching the
        // specified &#39;key&#39;, where the the first iterator is positioned at the
        // start of the sequence and the second iterator is positioned one past
        // the end of the sequence.  If this container contains no &#39;value_type&#39;
        // objects matching &#39;key&#39;, then the two returned iterators will have
        // the same value.

    const_iterator find(const key_type&amp; key) const;
        // Return an iterator providing non-modifiable access to the first
        // &#39;value_type&#39; object in the sequence of all the &#39;value_type&#39; objects
        // of this container matching the specified &#39;key&#39;, if they exist, and
        // the past-the-end (&#39;end&#39;) iterator otherwise.  If multiple elements
        // match &#39;key&#39;, they are guaranteed to be adjacent to each other, and
        // this function will return the first in the sequence.

    hasher hash_function() const;
        // Return (a copy of) the hash unary functor used by this container to
        // generate a hash value (of type &#39;size_t&#39;) for a &#39;key_type&#39; object.

    key_equal key_eq() const;
        // Return (a copy of) the key-equality binary functor that returns
        // &#39;true&#39; if the value of two &#39;key_type&#39; objects is the same, and
        // &#39;false&#39; otherwise.

    float load_factor() const;
        // Return the current ratio between the &#39;size&#39; of this container and
        // the number of buckets.  The &#39;load_factor&#39; is a measure of how full
        // the container is, and a higher load factor leads to an increased
        // number of collisions, thus resulting in a loss performance.

    float max_load_factor() const;
        // Return the maximum load factor allowed for this container.  If an
        // insert operation would cause &#39;load_factor&#39; to exceed the
        // &#39;max_load_factor&#39;, that same insert operation will increase the
        // number of buckets and rehash the elements of the container into
        // those buckets the (see rehash).  Note that it is possible for the
        // load factor of this container to exceed &#39;max_load_factor&#39;,
        // especially after &#39;max_load_factor(newLoadFactor)&#39; is called.

    size_type max_size() const;
        // Return a theoretical upper bound on the largest number of elements
        // that this container could possibly hold.  Note that there is no
        // guarantee that the container can successfully grow to the returned
        // size, or even close to that size without running out of resources.

    size_type size() const;
        // Return the number of elements in this container.
};

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bool operator==(
            const unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; lhs,
            const unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects have the same
    // value, and &#39;false&#39; otherwise.  Two &#39;unordered_multimap&#39; objects have the
    // same value if they have the same number of key-value pairs, and for each
    // key-value pair that is contained in &#39;lhs&#39; there is a pair value-key
    // contained in &#39;rhs&#39; having the same value, and vice-versa.  Note that
    // this method requires that the (template parameter) types &#39;KEY&#39; and
    // &#39;VALUE&#39; both be &quot;equality-comparable&quot; (see {Requirements on &#39;KEY&#39; and
    // &#39;VALUE&#39;}).

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bool operator!=(
            const unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; lhs,
            const unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; rhs);
    // Return &#39;true&#39; if the specified &#39;lhs&#39; and &#39;rhs&#39; objects do not have the
    // same value, and &#39;false&#39; otherwise.  Two &#39;unordered_multimap&#39; objects do
    // not have the same value if they do not have the same number of key-value
    // pairs, or that for some key-value pair that is contained in &#39;lhs&#39; there
    // is not a key-value pair in &#39;rhs&#39; having the same value, and vice-versa.
    // Note that this method requires that the (template parameter) types &#39;KEY&#39;
    // and &#39;VALUE&#39; both be &quot;equality-comparable&quot; (see {Requirements on &#39;KEY&#39;
    // and &#39;VALUE&#39;}).

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
void swap(unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; a,
          unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; b);
    // Swap both the value and the comparator of the specified &#39;a&#39; object with
    // the value and comparator of the specified &#39;b&#39; object.  Additionally, if
    // &#39;bslstl::AllocatorTraits&lt;ALLOCATOR&gt;::propagate_on_container_swap&#39; is
    // &#39;true&#39;, then exchange the allocator of &#39;a&#39; with that of &#39;b&#39;, and do not
    // modify either allocator otherwise.  This method provides the no-throw
    // exception-safety guarantee and guarantees &#39;O[1]&#39; complexity.  The
    // behavior is undefined unless either this object was created with the
    // same allocator as &#39;other&#39; or &#39;propagate_on_container_swap&#39; is &#39;true&#39;.

// ============================================================================
//                  TEMPLATE AND INLINE FUNCTION DEFINITIONS
// ============================================================================

                        //-------------------------
                        // class unordered_multimap
                        //-------------------------

// CREATORS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::unordered_multimap(
                                       size_type             initialNumBuckets,
                                       const hasher&amp;         hashFunction,
                                       const key_equal&amp;      keyEqual,
                                       const allocator_type&amp; basicAllocator)
: d_impl(hashFunction, keyEqual, initialNumBuckets, 1.0f, basicAllocator)
{
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
template &lt;class INPUT_ITERATOR&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::
unordered_multimap(INPUT_ITERATOR        first,
                   INPUT_ITERATOR        last,
                   size_type             initialNumBuckets,
                   const hasher&amp;         hashFunction,
                   const key_equal&amp;      keyEqual,
                   const allocator_type&amp; basicAllocator)
: d_impl(hashFunction, keyEqual, initialNumBuckets, 1.0f, basicAllocator)
{
    this-&gt;insert(first, last);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL,
          class ALLOCATOR&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::unordered_multimap(
                                            const unordered_multimap&amp; original)
: d_impl(original.d_impl,
         AllocatorTraits::select_on_container_copy_construction(
                                                     original.get_allocator()))
{
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::unordered_multimap(
                                          const allocator_type&amp; basicAllocator)
: d_impl(basicAllocator)
{
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL,
          class ALLOCATOR&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::unordered_multimap(
                                      const unordered_multimap&amp; original,
                                      const allocator_type&amp;     basicAllocator)
: d_impl(original.d_impl, basicAllocator)
{
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::~unordered_multimap()
{
    // All memory management is handled by the base &#39;d_impl&#39; member.
}

// MANIPULATORS
template &lt;class KEY, class VALUE, class HASH, class EQUAL,
          class ALLOCATOR&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::operator=(
                                                 const unordered_multimap&amp; rhs)
{
    unordered_multimap(rhs, this-&gt;get_allocator()).swap(*this);
    return *this;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::local_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::begin(size_type index)
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return local_iterator(&amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::local_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::end(size_type index)
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return local_iterator(0, &amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
void unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::clear()
{
    d_impl.removeAll();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::find(
                                                           const key_type&amp; key)
{
    return iterator(d_impl.find(key));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::erase(
                                                       const_iterator position)
{
    BSLS_ASSERT(position != this-&gt;end());

    return iterator(d_impl.remove(position.node()));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::erase(
                                                           const key_type&amp; key)
{   // As an alternative implementation, the table could return an extracted
    // &quot;slice&quot; list from the underlying table, and now need merely:
    //   iterate each node, destroying the associated value
    //   reclaim each node (potentially returning to a node-pool)

    typedef ::BloombergLP::bslalg::BidirectionalNode&lt;value_type&gt; BNode;
    if (HashTableLink *target = d_impl.find(key)) {
        target = d_impl.remove(target);
        size_type result = 1;
        while (target &amp;&amp; this-&gt;key_eq()(
              key,
              ListPolicy::extractKey(
                                    static_cast&lt;BNode *&gt;(target)-&gt;value()))) {
            target = d_impl.remove(target);
            ++result;
        }
        return result;                                                // RETURN
    }
    else {
        return 0;                                                     // RETURN
    }
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::erase(
                                                          const_iterator first,
                                                          const_iterator last)
{
#if defined BDE_BUILD_TARGET_SAFE_2
    if (first != last) {
        iterator it        = this-&gt;begin();
        const iterator end = this-&gt;end();
        for (; it != first; ++it) {
            BSLS_ASSERT(last != it);
            BSLS_ASSERT(end  != it);
        }
        for (; it != last; ++it) {
            BSLS_ASSERT(end  != it);
        }
    }
#endif

    while (first != last) {
        first = this-&gt;erase(first);
    }

    return iterator(first.node());          // convert from const_iterator
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
template &lt;class SOURCE_TYPE&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::insert(
                                                      const SOURCE_TYPE&amp; value)
{
    return iterator(d_impl.insert(value));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
template &lt;class SOURCE_TYPE&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::insert(
                                                      const_iterator     hint,
                                                      const SOURCE_TYPE&amp; value)
{
    return iterator(d_impl.insert(value, hint.node()));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
template &lt;class INPUT_ITERATOR&gt;
void unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::insert(
                                                          INPUT_ITERATOR first,
                                                          INPUT_ITERATOR last)
{
    if (size_type maxInsertions =
            ::BloombergLP::bslstl::IteratorUtil::insertDistance(first, last)) {
        this-&gt;reserve(this-&gt;size() + maxInsertions);
    }

    while (first != last) {
        d_impl.insert(*first);
        ++first;
    }
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::max_load_factor(
                                                           float newLoadFactor)
{
    d_impl.setMaxLoadFactor(newLoadFactor);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::rehash(
                                                          size_type numBuckets)
{
    d_impl.rehashForNumBuckets(numBuckets);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::reserve(
                                                         size_type numElements)
{
    d_impl.reserveForNumElements(numElements);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
void unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::swap(
                                                     unordered_multimap&amp; other)
{
    d_impl.swap(other.d_impl);
}

// ACCESSORS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::begin()
{
    return iterator(d_impl.elementListRoot());
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::begin() const
{
    return const_iterator(d_impl.elementListRoot());
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::end()
{
    return iterator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::end() const
{
    return const_iterator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::cbegin() const
{
    return const_iterator(d_impl.elementListRoot());
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::cend() const
{
    return const_iterator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::
                                                           const_local_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::begin(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return const_local_iterator(&amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_local_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::end(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return const_local_iterator(0, &amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_local_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::cbegin(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return const_local_iterator(&amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::
                                                           const_local_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::cend(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return const_local_iterator(0, &amp;d_impl.bucketAtIndex(index));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::bucket(
                                                     const key_type&amp; key) const
{
    return d_impl.bucketIndexForKey(key);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::bucket_count() const
{
    return d_impl.numBuckets();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::bucket_size(
                                                         size_type index) const
{
    BSLS_ASSERT_SAFE(index &lt; this-&gt;bucket_count());

    return d_impl.countElementsInBucket(index);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;:: size_type
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::count(
                                                     const key_type&amp; key) const
{
    typedef ::BloombergLP::bslalg::BidirectionalNode&lt;value_type&gt; BNode;

    size_type result = 0;
    for (HashTableLink *cursor = d_impl.find(key);
         cursor;
         ++result, cursor = cursor-&gt;nextLink())
    {
        BNode *cursorNode = static_cast&lt;BNode *&gt;(cursor);
        if (!this-&gt;key_eq()(key,
                            ListPolicy::extractKey(cursorNode-&gt;value()))) {

            break;
        }
    }
    return  result;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bool unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::empty() const
{
    return 0 == d_impl.size();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
ALLOCATOR
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::get_allocator() const
{
    return d_impl.allocator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::max_size() const
{
    return d_impl.maxSize();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::hasher
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::hash_function() const
{
    return d_impl.hasher();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::key_equal
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::key_eq() const
{
    return d_impl.comparator();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::const_iterator
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::find(
                                                     const key_type&amp; key) const
{
    return const_iterator(d_impl.find(key));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bsl::pair&lt;
     typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator,
     typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::iterator&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::equal_range(
                                                           const key_type&amp; key)
{
    typedef bsl::pair&lt;iterator, iterator&gt; ResultType;

    HashTableLink *first;
    HashTableLink *last;
    d_impl.findRange(&amp;first, &amp;last, key);
    return ResultType(iterator(first), iterator(last));
}


template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size() const
{
    return d_impl.size();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
bsl::pair&lt;typename unordered_multimap&lt;KEY,
                                      VALUE,
                                      HASH,
                                      EQUAL,
                                      ALLOCATOR&gt;::const_iterator,
          typename unordered_multimap&lt;KEY,
                                      VALUE,
                                      HASH,
                                      EQUAL,
                                      ALLOCATOR&gt;::const_iterator&gt;
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::equal_range(
                                                     const key_type&amp; key) const
{
    typedef bsl::pair&lt;const_iterator, const_iterator&gt; ResultType;

    HashTableLink *first;
    HashTableLink *last;
    d_impl.findRange(&amp;first, &amp;last, key);
    return ResultType(const_iterator(first), const_iterator(last));
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
float unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::load_factor()
                                                                          const
{
    return d_impl.loadFactor();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
typename unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::size_type
unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;:: max_bucket_count()
                                                                          const
{
    return d_impl.maxNumBuckets();
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
float unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;::max_load_factor()
                                                                          const
{
    return d_impl.maxLoadFactor();
}

}  // close namespace bsl

// FREE FUNCTIONS
template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
bool bsl::operator==(
        const bsl::unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; lhs,
        const bsl::unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; rhs)
{
    return lhs.d_impl == rhs.d_impl;
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
bool bsl::operator!=(
        const bsl::unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; lhs,
        const bsl::unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; rhs)
{
    return !(lhs == rhs);
}

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
inline
void bsl::swap(bsl::unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; a,
               bsl::unordered_multimap&lt;KEY, VALUE, HASH, EQUAL, ALLOCATOR&gt;&amp; b)
{
    a.swap(b);
}

// ============================================================================
//                                TYPE TRAITS
// ============================================================================

// Type traits for STL *unordered* *associative* containers:
//: o An unordered associative container defines STL iterators.
//: o An unordered associative container is bitwise moveable if the both
//:      functors and the allocator are bitwise moveable.
//: o An unordered associative container uses &#39;bslma&#39; allocators if the
//:      parameterized &#39;ALLOCATOR&#39; is convertible from &#39;bslma::Allocator*&#39;.

namespace BloombergLP {

namespace bslalg {

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
struct HasStlIterators&lt;bsl::unordered_multimap&lt;KEY,
                                               VALUE,
                                               HASH,
                                               EQUAL,
                                               ALLOCATOR&gt; &gt;
: bsl::true_type
{};

}  // close namespace bslalg

namespace bslma {

template &lt;class KEY, class VALUE, class HASH, class EQUAL, class ALLOCATOR&gt;
struct UsesBslmaAllocator&lt;bsl::unordered_multimap&lt;KEY,
                                                  VALUE,
                                                  HASH,
                                                  EQUAL,
                                                  ALLOCATOR&gt; &gt;
: bsl::is_convertible&lt;Allocator*, ALLOCATOR&gt;::type
{};

}  // close namespace bslma

}  // close enterprise namespace

#endif

// ----------------------------------------------------------------------------
// Copyright 2013 Bloomberg Finance L.P.
//
// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ----------------------------- END-OF-FILE ----------------------------------
</pre>
</body>
</html>
